<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>工业相机常见参数</title>
      <link href="/2020/03/28/ISP_CameraPara/"/>
      <url>/2020/03/28/ISP_CameraPara/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>了解工业相机的相关参数能够帮助我们更好的理解相机功能，进而帮助我们完成对相机的选型工作。所谓外行看热闹，内行看门道，工业相机的门道就从其参数开始。<br><a id="more"></a></p><h2 id="1、分辨率"><a href="#1、分辨率" class="headerlink" title="1、分辨率"></a>1、分辨率</h2><p>相机的传感器sensor是有许多像素点按照矩阵的形式排列而成，分辨率就是以水平方向和垂直方向的像素来表示的。分辨率越高，成像后的图像像素数就越高，图像就越清晰。常用的工业面阵相机分辨率有130万、200万、500万等；对于线阵相机而言，分辨率就是传感器水平方向上的像素数，常见有1K、2K、6K等。</p><p>在相机分辨率的选型上，要根据我们的项目需求而定，并不一定是分辨率越高就越好，分辨率高带来的图像数据量就大，后期的算法处理复杂度就高，而且一般分辨率大的相机，帧率一般都不会太高。</p><h2 id="2、传感器尺寸"><a href="#2、传感器尺寸" class="headerlink" title="2、传感器尺寸"></a>2、传感器尺寸</h2><p>传感器尺寸是以有效面积（宽x高）或以对角线大小（英寸）来表示的，常见的传感器尺寸如下：</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_CaPara_1.png" alt></p><p>传感器尺寸越大，一定程度上表示相机可容纳像素个数越多，成像的画幅越大。</p><h2 id="3、像元尺寸"><a href="#3、像元尺寸" class="headerlink" title="3、像元尺寸"></a>3、像元尺寸</h2><p>像元尺寸就是每个像素的面积。单个像素面积小，单位面积内的像素数量多，相机的分辨率增加，利于对细小缺陷的检测和增大检测视场。随着像素面积的缩小，满阱能力（每个像素能够储存的电荷数量）也随之减小，造成相机动态范围的降低。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_CaPara_2.png" alt></p><h2 id="4、像素深度"><a href="#4、像素深度" class="headerlink" title="4、像素深度"></a>4、像素深度</h2><p>像素深度是指每个像素用多少比特位表示。通常，每个像素的比特位数多，表达图像细节的能力强，这个像素的颜色值更加丰富、分的更细，颜色深度就更深。一般像素深度有1位、8位、16位、24位和32位。</p><p>1位像素深度就是有二进制来表示，也叫单色显示。</p><p>8位像素深度是最常见的，用8个二进制位来表示颜色，能表示256种颜色，这种就是常说的灰度显示。</p><p>16位是用16个二进制位来表示，能表示65536种颜色，这时就可以彩色显示啦。</p><p>24位和31位则表达的颜色信息就会更加的丰富。</p><h2 id="5、动态范围"><a href="#5、动态范围" class="headerlink" title="5、动态范围"></a>5、动态范围</h2><p>动态范围是用来描述每个像素能够分辨出的灰度等级。它是饱和电压（最大的输出电平）相机输出的噪声之比。宽动态范围能够使场景中非常亮和非常昏暗部分的细节同时被清晰的显示。一般来说，低动态范围的相机噪声比较多，照片会缺失亮部细节和暗部细节。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_CaPara_3.png" alt><br><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_CaPara_4.png" alt></p><h2 id="6、最大帧率"><a href="#6、最大帧率" class="headerlink" title="6、最大帧率"></a>6、最大帧率</h2><p>最大帧率表示的是面阵工业相机每秒能够采集并输出的最大帧数，这往往和传感器芯片和数据输出接口带宽有关。根据项目需求，对于拍摄运动物体，建议选取高帧率相机，具体帧率数要根据拍摄精度来确定。</p><h2 id="7、曝光方式"><a href="#7、曝光方式" class="headerlink" title="7、曝光方式"></a>7、曝光方式</h2><p>工业相机常见的曝光方式有帧曝光（global shutter）和行曝光（rolling shutter）。</p><p>帧曝光是指传感器阵列中所有像素同时曝光，曝光周期由预先设定的快门时间确定。这种曝光方式的相机适合拍摄运动物体，图像不会偏移，不会失真。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_CaPara_5.png" alt></p><p>行曝光是指同一行上的像素同时曝光，不同行的曝光起始时间不同，每行的曝光时间是相同的，行间的延迟不变。这种曝光方式的相机适用于拍摄静止的物体，拍摄运动物体，图像会偏移。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_CaPara_6.png" alt></p><h2 id="8、曝光时间"><a href="#8、曝光时间" class="headerlink" title="8、曝光时间"></a>8、曝光时间</h2><p>传感器将光信号转换为电信号形成一帧图像，每个像元接受光信号的过程叫曝光，所花费的时间叫曝光时间，也叫快门速度。</p><h2 id="9、采集模式"><a href="#9、采集模式" class="headerlink" title="9、采集模式"></a>9、采集模式</h2><p>采集模式分为了连续采集、外触发采集和软触发采集三种。</p><p>连续采集指相机进行连续曝光，输出实时图像。</p><p>外触发采集是指当相机处于外触发模式后，相机处于待机模式，不曝光，只有当相机通过I/O口接收到相机规定的单个脉冲（方波）信号后，传感器曝光一次，部分相机支持信号的上升沿、下降沿和高低电平的触发。</p><p>软触发是指当相机处于外触发模式后，相机处于待机模式，不曝光，只有当相机软件发出指令后，传感器曝光一次。</p><h2 id="10、增益"><a href="#10、增益" class="headerlink" title="10、增益"></a>10、增益</h2><p>工业相机通常具有一个对传感器的信号进行放大的视频放大器，其放大倍数称为增益。增益越大，噪声就会变大，一般情况不建议增大增益值。</p><h2 id="11、光谱响应特性"><a href="#11、光谱响应特性" class="headerlink" title="11、光谱响应特性"></a>11、光谱响应特性</h2><p>光谱响应特性是指图像传感器对不同光波的敏感特性，变现了传感器的量子效率QE。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_CaPara_7.png" alt></p><h2 id="12、模拟相机与数字相机"><a href="#12、模拟相机与数字相机" class="headerlink" title="12、模拟相机与数字相机"></a>12、模拟相机与数字相机</h2><p>工业相机按输出图像信号格式划分为模拟相机与数字相机。早期的工业相机多采用PAL/ NTSC/ CCIR/ EIA-170等标准模拟输出，也有采用非标准模拟输出的产品，随着GigE/IEEE 1394/USB 2.0/  USB 3.0/ Camera Link/ CameraLink HS/ CoaXPress等数字接口技术的发展和普及，越来越多的工业数字相机取代传统的模拟相机出现在各种机器视觉系统中。</p><p>数字相机的信号受噪声干扰较少，因此数字相机的动态范围很高，图像质量更好；而模拟相机采集到的是模拟信号，要经过数字采集卡转换为数字信号，受噪声影响较大，分辨率低，且帧率一般固定。</p><p>模拟相机工作流程图如下：<br><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_CaPara_8.jpg" alt></p><p>数字相机工作流程图如下：<br><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_CaPara_8.jpg" alt></p><p>转自公众号《AI图像》</p><h1 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h1><h1 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h1><h1 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> ISP </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISP-YUV格式</title>
      <link href="/2020/03/28/ISP_YUV/"/>
      <url>/2020/03/28/ISP_YUV/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>ISP-YUV格式<br><a id="more"></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>数字图像处理的过程中，YUV文件是比较常见的视频源数据。YUV不像RGB那样要求三个独立的视频信号同时传输，所以用YUV方式传送占用极少的频宽。</p><h2 id="YUV采样格式"><a href="#YUV采样格式" class="headerlink" title="YUV采样格式"></a>YUV采样格式</h2><p>和RGB颜色空间相比，YUV颜色空间充分利用了人眼的特性，人的眼睛对亮度的敏感度远大于色度。在保证基本画质的前提下，可以对一幅画面的色度分量进行删减。下面三张图片是常见的三种YUV采样方式，YUV4：4：4、YUV4：2：2、YUV4：2：0。其中，YUV4：4：4是一种无压缩的采样方式，每一个Y分量对应一组UV分量；YUV4：2：2的采样方式丢弃了一半的色度分量，每两个Y分量对应一组UV分量；YUV4：2：0的采样方式对齐了四分之三的色度分量，每四个Y分量对应一组UV分量。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_yuv_1.bmp" alt><br><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_yuv_2.bmp" alt><br><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_yuv_3.bmp" alt></p><h2 id="YUV文件格式之UYVY和I420"><a href="#YUV文件格式之UYVY和I420" class="headerlink" title="YUV文件格式之UYVY和I420"></a>YUV文件格式之UYVY和I420</h2><p>下面说明UYVY和I420的文件存储格式。</p><h3 id="UYVY文件"><a href="#UYVY文件" class="headerlink" title=" UYVY文件"></a><1> UYVY文件</1></h3><p>UYVY文件是YUV4：2：2采样格式的一种存储格式，具体的地址对应关系如下图所示，U、Y、V、Y依次按顺序存储在文件中。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_yuv_4.bmp" alt></p><h3 id="I420文件"><a href="#I420文件" class="headerlink" title=" I420文件"></a><2> I420文件</2></h3><p>I420文件是YUV4：2：0采样格式的一种存储格式，具体的地址对应关系如下图所示，和UYVY文件稍有不同。I420文件先存储Y块、然后是U块和V块。每个Y/U/V块块内的的像素依次存储在文件中。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_yuv_5.bmp" alt></p><h2 id><a href="#" class="headerlink" title=" "></a> </h2><p>以YUV4：2：2 和YUV4：2：0转换为例，如下：</p><p>　　最简单的方式：</p><p>　　YUV4:2:2 —-&gt; YUV4:2:0  Y不变，将U和V信号值在行(垂直方向)在进行一次隔行抽样。 YUV4:2:0 —-&gt; YUV4:2:2  Y不变，将U和V信号值的每一行分别拷贝一份形成连续两行数据。</p><p>　　在YUV420中，一个像素点对应一个Y，一个4X4的小方块对应一个U和V。对于所有YUV420图像，它们的Y值排列是完全相同的，因为只有Y的图像就是灰度图像。YUV420sp与YUV420p的数据格式它们的UV排列在原理上是完全不同的。420p它是先把U存放完后，再存放V，也就是说UV它们是连续的。而420sp它是UV、UV这样交替存放的。(见下图) 有了上面的理论，我就可以准确的计算出一个YUV420在内存中存放的大小。width <em> hight =Y（总和） U = Y / 4   V = Y / 4 ，所以YUV420 数据在内存中的长度是 width </em> hight * 3 / 2。</p><h2 id="色域转换"><a href="#色域转换" class="headerlink" title="色域转换"></a>色域转换</h2><p>本文采用的转换公式如下：<br>R =1.164<em>(Y-16) + 1.596</em>(V-128)<br>G =1.164<em>(Y-16) - 0.813</em>(V-128) - 0.392<em>(U-128)<br>B =1.164</em>(Y-16) + 2.017<em>(U-128)<br>具体实践的时候，我又将这些浮点数扩大1024倍变为定点数，然后再做处理，经过处理后的公式如下：<br>R =(1192</em>(Y-16) + 1634<em>(V-128))/1024<br>G =(1192</em>(Y-16) -  833<em>(V-128) -401</em>(U-128))/1024<br>B =(1192<em>(Y-16) + 2065</em>(U-128))/1024</p><p><a href="https://blog.csdn.net/jiandan524/article/details/57452211" target="_blank" rel="noopener">参考YUV播放器设计</a></p><h1 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h1><h1 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h1><h1 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> ISP </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客Next主题留言板</title>
      <link href="/2020/03/25/hexo_gusetbook/"/>
      <url>/2020/03/25/hexo_gusetbook/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>hexo博客Next主题留言板</p><a id="more"></a><p>留言让博客看起来更加的人性化<br>NexT 主题官网有给出添加标签页、分类页的方法，其实添加留言本的方式异曲同工。方式稍微会有一点不同。</p><h3 id="一、添加留言本-page"><a href="#一、添加留言本-page" class="headerlink" title="一、添加留言本 page"></a>一、添加留言本 page</h3><p>进入到博客的根目录，运行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page guestbook</span><br></pre></td></tr></table></figure></p><p>生成<code>index.md</code>，在里面可以写一些留言板介绍内容等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">博客根目录\source\guestbook\index.md</span><br></pre></td></tr></table></figure></p><h3 id="二、修改菜单目录"><a href="#二、修改菜单目录" class="headerlink" title="二、修改菜单目录"></a>二、修改菜单目录</h3><p>Next主题默认只有主页和和关于，如果要增加菜单，在themes/next/_config.yml中修改配置，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># ---------------------------------------------------------------</span><br><span class="line"># Menu Settings</span><br><span class="line"># ---------------------------------------------------------------</span><br><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags #标签</span><br><span class="line">  categories: /categories/ || th #分类</span><br><span class="line">  archives: /archives/ || archive #归档</span><br><span class="line">  guestbook: /guestbook/ || comment #留言</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure></p><p>其中留言页需要自己增加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">guestbook: /guestbook/ || comment #留言</span><br></pre></td></tr></table></figure></p><h3 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h3><p>本地预览<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure></p><h3 id="博客部署"><a href="#博客部署" class="headerlink" title="博客部署"></a>博客部署</h3><p>博客部署<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></p><p>推荐使用 <code>&amp;&amp;</code> 作为组合命令的串联符号</p><p>注：一定要严格清理缓存，这样不容易出现问题，即需要执行<code>hexo clean</code></p><hr><h3 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h3><h3 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h3><h3 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo，Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;转&gt;--ISP（图像信号处理）算法概述、工作原理、架构、处理流程</title>
      <link href="/2020/03/22/ISP%E5%A4%84%E7%90%86/"/>
      <url>/2020/03/22/ISP%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>&lt;转&gt;—ISP（图像信号处理）算法概述、工作原理、架构、处理流程</p><a id="more"></a><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="ISP的主要内部构成："><a href="#ISP的主要内部构成：" class="headerlink" title="ISP的主要内部构成："></a>ISP的主要内部构成：</h3><p>ISP内部包含 CPU、SUP IP（各种功能模块的通称）、IF 等设备</p><h3 id="ISP的控制结构："><a href="#ISP的控制结构：" class="headerlink" title="ISP的控制结构："></a>ISP的控制结构：</h3><p>1、ISP逻辑    2、运行在其上的firmware</p><h3 id="ISP上的Firmware包含三部分："><a href="#ISP上的Firmware包含三部分：" class="headerlink" title="ISP上的Firmware包含三部分："></a>ISP上的Firmware包含三部分：</h3><p>AP对ISP的操控方式：外置：I2C/SPI。 内置：MEM MAP、MEM SHARE</p><h3 id="ISP架构方案："><a href="#ISP架构方案：" class="headerlink" title="ISP架构方案："></a>ISP架构方案：</h3><p>内置、外置</p><h3 id="ISP-处理流程："><a href="#ISP-处理流程：" class="headerlink" title="ISP 处理流程："></a>ISP 处理流程：</h3><p>Bayer、黑电平补偿 （black level compensation）、镜头矫正（lens shading correction）、坏像素矫正（bad pixel correction）、颜色插值 （demosaic）、Bayer 噪声去除、 白平衡（AWB） 矫正、 色彩矫正（color correction）、gamma 矫正、色彩空间转换（RGB 转换为 YUV）、在YUV 色彩空间上彩噪去除与边缘加强、色彩与对比度加强，中间还要进行自动曝光控制等， 然后输出 YUV（或者RGB） 格式的数据， 再通过 I/O 接口传输到 CPU 中处理。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>ISP是Image Signal Processor 的简称，也就是图像信号处理器。</p><p>DSP是Digital Signal Processor 的缩写，也就是数字信号处理器。</p><p>ISP一般用来处理Image Sensor（图像传感器）的输出数据，如做AEC（自动曝光控制）、AGC（自动增益控制）、AWB（自动白平衡）、色彩校正、Lens Shading、Gamma 校正、祛除坏点、Auto Black Level、Auto White Level等等功能的处理。</p><p>而DSP功能就比较多了，它可以做些拍照以及回显（JPEG的编解码）、录像以及回放（Video 的编解码）、H.264的编解码、还有很多其他方面的处理，总之是处理数字信号了。ISP是一类特殊的处理图像信号的DSP。</p><p>ISP架构方案：分为独立（外置）与集成（内置）两种形式。</p><p>CPU处理器包括：AP、BP、CP。 其中BP：基带处理器、AP：应用处理器、CP：多媒体加速器。</p><h2 id="ISP的主要内部构成"><a href="#ISP的主要内部构成" class="headerlink" title="ISP的主要内部构成"></a>ISP的主要内部构成</h2><p>如下图所示，ISP内部包含 CPU、SUP IP、IF 等设备，事实上，可以认为 ISP 是一个 SOC（system of chip），可以运行各种算法程序，实时处理图像信号。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_isp_1.png" alt></p><p>CPU：CPU 即中央处理器，可以运行 AF、LSC 等各种图像处理算法，控制外围设备。现代的 ISP 内部的 CPU 一般都是 ARM Cortex-A 系列的，例如 Cortex-A5、Cortex-A7。</p><p>SUB IP：SUB IP 是各种功能模块的通称，对图像进行各自专业的处理。常见的 SUB IP 如 DIS、CSC、VRA 等。<br>图像传输接口：图像传输接口主要分两种，并口 ITU 和串口 CSI。CSI 是 MIPI CSI 的简称，鉴于 MIPI CSI 的诸多优点，在手机相机领域，已经广泛使用 MIPI-CSI 接口传输图像数据和各种自定义数据。外置 ISP 一般包含 MIPI-CSIS 和 MIPI-CSIM 两个接口。内置 ISP 一般只需要 MIPI-CSIS 接口。<br>通用外围设备：通用外围设备指 I2C、SPI、PWM、UART、WATCHDOG 等。ISP 中包含 I2C 控制器，用于读取 OTP 信息，控制 VCM 等。对于外置 ISP，ISP 本身还是 I2C 从设备。AP 可以通过 I2C 控制 ISP 的工作模式，获取其工作状态等。</p><h2 id="ISP的控制结构"><a href="#ISP的控制结构" class="headerlink" title="ISP的控制结构"></a>ISP的控制结构</h2><p>ISP包括： 1、ISP逻辑    2、运行在其上的firmware<br>如图所示，lens 将光信号投射到sensor 的感光区域后，sensor 经过光电转换，将Bayer 格式的原始图像送给ISP，ISP 经过算法处理，输出RGB空间域的图像给后端的视频采集单元。在这个过程中，ISP通过运行在其上的firmware（固件）对ISP逻辑，从而对lens 和sensor 进行相应控制，进而完成自动光圈、自动曝光、自动白平衡等功能。其中，firmware的运转靠视频采集单元的中断驱动。PQ Tools 工具通过网口或者串口完成对ISP 的在线图像质量调节。<br>ISP 由ISP逻辑及运行在其上的Firmware组成，逻辑单元除了完成一部分算法处理外，还可以统计出当前图像的实时信息。Firmware 通过获取ISP 逻辑的图像统计信息，重新计算，反馈控制lens、sensor 和ISP 逻辑，以达到自动调节图像质量的目的。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_isp_2.png" alt></p><p>ISP上的Firmware包含三部分<br>ISP 的Firmware包含三部分，一部分是ISP 控制单元和基础算法库，一部分是AE/AWB/AF 算法库，一部分是sensor 库。Firmware 设计的基本思想是单独提供3A算法库，由ISP控制单元调度基础算法库和3A 算法库，同时sensor 库分别向ISP 基础算法库和3A 算法库注册函数回调，以实现差异化的sensor 适配。ISP firmware 架构如图所示。<br>不同的sensor 都以回调函数的形式，向ISP 算法库注册控制函数。ISP 控制单元调度基础算法库和3A 算法库时，将通过这些回调函数获取初始化参数，并控制sensor，如调节曝光时间、模拟增益、数字增益，控制lens 步进聚焦或旋转光圈等。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_isp_3.png" alt></p><h2 id="AP对ISP的操控方式"><a href="#AP对ISP的操控方式" class="headerlink" title="AP对ISP的操控方式"></a>AP对ISP的操控方式</h2><p>CPU处理器包括：AP、BP、CP。 BP：基带处理器、AP：应用处理器、CP：多媒体加速器<br>这里所说的控制方式是AP 对 ISP 的操控方式 。<br>I2C/SPI：这一般是外置 ISP 的做法。SPI 一般用于下载固件、I2C 一般用于寄存器控制。在内核的 ISP 驱动中，外置 ISP 一般是实现为 I2C 设备，然后封装成 V4L2-SUBDEV。<br>MEM MAP：这一般是内置 ISP 的做法。将 ISP 内部的寄存器地址空间映射到内核地址空间，<br>MEM SHARE：这也是内置 ISP 的做法。AP 这边分配内存，然后将内存地址传给 ISP，二者实际上共享同一块内存。因此 AP 对这段共享内存的操作会实时反馈到 ISP 端。</p><h2 id="ISP架构方案"><a href="#ISP架构方案" class="headerlink" title="ISP架构方案"></a>ISP架构方案</h2><p>上文多次提到外置 ISP 和内置 ISP，这实际上是 ISP的架构方案。</p><h3 id="外置-ISP-架构"><a href="#外置-ISP-架构" class="headerlink" title="外置 ISP 架构"></a>外置 ISP 架构</h3><p>外置 ISP 架构是指在 AP 外部单独布置 ISP 芯片用于图像信号处理。外置 ISP 的架构图一般如下所示：</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_isp_4.png" alt></p><p>外置 ISP 架构的优点主要有：<br>能够提供更优秀的图像质量：在激烈的市场竞争下，能够存活到现在的外置 ISP 生产厂商在此领域一般都有很深的造诣，积累了丰富的影像质量调试经验，能够提供比内置 ISP 更优秀的性能和效果。因此，选用优质的外置 ISP 能提供专业而且优秀的图像质量。<br>能够支援更丰富的设计规划：外置 ISP 的选型基本不受 AP 的影响，因此魅族可以从各个优秀 ISP 芯片供应商的众多产品中甄选最合适的器件，从而设计出更多优秀的产品。<br>能够实现产品的差异化：内置 ISP 是封装在 AP 内部的，是和 AP 紧密的联系在一起，如果 AP 相同，那么 ISP 也就是一样的。因此基于同样 AP 生产出来的手机，其 ISP 的性能也是一样的，可供调教的条件也是固定的，这样就不利于实现产品的差异化。而如果选择外置 ISP，那么同一颗 AP，可以搭配不同型号的 ISP，这样可以实现产品的差异化，为给用户提供更丰富和优质的产品。<br>外置 ISP 架构的缺点主要有：<br>成本价格高：外置 ISP 需要单独购买，其售价往往不菲，而且某些特殊功能还需要额外支付费用。使用外置 ISP，需要进行额外的原理图设计和 LAYOUT，需要使用额外的元器件。<br>开发周期长：外置 ISP 驱动的设计需要多费精力和时间。使用外置 ISP 时，AP 供应商提供的 ISP 驱动就无法使用，需要额外设计编写外置 ISP 驱动。另外，为了和 AP 进行完美的搭配，将效果最大化，也往往需要付出更多的调试精力。上文也提到，使用外置 ISP，需要进行额外的原理图设计和 LAYOUT，需要使用额外的元器件，这也是需要花费时间进行处理的。</p><h3 id="内置-ISP-架构："><a href="#内置-ISP-架构：" class="headerlink" title="内置 ISP 架构："></a>内置 ISP 架构：</h3><p>内置 ISP 架构是指在 AP 内部嵌入了 ISP IP，直接使用 AP 内部的 ISP 进行图像信号处理。 内置 ISP 的架构图一般如下所示：</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_isp_5.png" alt></p><p>内置 ISP 架构的优点主要有：<br>能降低成本价格：内置 ISP 内嵌在 AP 内部，因此无需像外置 ISP 一样需要额外购买，且不占 PCB 空间，无需单独为其设计外围电路，这样就能节省 BOM，降低成本。鉴于大多数用户在选购手机时会将价格因素放在重要的位置，因此降低成本能有效的降低终端成品价格，有利于占领市场。<br>能提高产品的上市速度：内置 ISP 和 AP 紧密结合，无需进行原理图设计和 LAYOUT 设计，因此可以减小开发周期，加快产品上市的速度。<br>能降低开发难度：如果使用内置 ISP，那么 AP 供应商能在前期提供相关资料，驱动开发人员可以有充足的时间熟悉相关资料，而且不会存在软件版本适配问题，也不存在平台架构兼容性问题。但是，如果使用外置 ISP，那么 ISP 供应商往往都不能提供针对某个平台的代码/资料，而且一般都存在软件版本兼容问题，这就需要驱动开发人员付出额的经历和时间。<br>使用内置 ISP 当然也有相应的不足之处，具体见上文的分析，这里就不赘述了。<br>事实上，鉴于 ISP 的重要性，为了推广其 AP，提高其 AP 竞争力，现在 AP 内置的 ISP 也越来越强大，其性能足以满足手机市场的需求。再加上其一系列优点，现在使用内置 ISP 方案的手机越来越多。</p><h2 id="ISP-处理流程"><a href="#ISP-处理流程" class="headerlink" title="ISP 处理流程"></a>ISP 处理流程</h2><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_isp_6.png" alt></p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_isp_7.png" alt><br>图像产生过程：景物通过 Lens 生成的光学图像投射到 sensor 表面上， 经过光电转换为模拟电信号， 消噪声后经过 A/D 转换后变为数字图像信号， 再送到数字信号处理芯片（ DSP） 中加工处理。<br>所以，从 sensor 端过来的图像是 Bayer 图像，经过黑电平补偿 （black level compensation）、镜头矫正（lens shading correction）、坏像素矫正（bad pixel correction）、颜色插值 （demosaic）、Bayer 噪声去除、 白平衡（awb） 矫正、 色彩矫正（color correction）、gamma 矫正、色彩空间转换（RGB 转换为 YUV）、在YUV 色彩空间上彩噪去除与边缘加强、色彩与对比度加强，中间还要进行自动曝光控制等， 然后输出 YUV（或者RGB） 格式的数据， 再通过 I/O 接口传输到 CPU 中处理。</p><h3 id="1-Bayer（拜耳滤波器得到彩色）"><a href="#1-Bayer（拜耳滤波器得到彩色）" class="headerlink" title="1.Bayer（拜耳滤波器得到彩色）"></a>1.Bayer（拜耳滤波器得到彩色）</h3><p>图像在将实际的景物转换为图像数据时， 通常是将传感器分别接收红、 绿、 蓝三个分量的信息， 然后将红、 绿、 蓝三个分量的信息合成彩色图像。 该方案需要三块滤镜， 这样价格昂贵，且不好制造， 因为三块滤镜都必须保证每一个像素点都对齐。<br>通过在黑白 cmos 图像传感器的基础上， 增加彩色滤波结构和彩色信息处理模块就可以获得图像的彩色信息， 再对该彩色信息进行处理， 就可以获得色彩逼真的彩色图像。通常把彩色图像传感器表面覆盖的滤波称为彩色滤波阵列（Color Filter Arrays，CFA）。<br>目前最常用的滤镜阵列是棋盘格式的， 已经有很多种类的， 其中绝大多数的摄像产品采用的是原色贝尔模板彩色滤波阵列（Bayer Pattern CFA）。R、G、B 分别表示透红色、透绿色和透蓝色的滤镜阵列单元。由于人的视觉对绿色最为敏感，所以在 Bayer CFA 中G分量是 R和B 的二倍，在每个像素点上只能获取一种色彩分量的信息，然后根据该色彩分量的信息通过插值算法得到全色彩图像。</p><h3 id="2-BLC-Black-level-Correction-（黑电平补偿）"><a href="#2-BLC-Black-level-Correction-（黑电平补偿）" class="headerlink" title="2.BLC(Black level Correction)（黑电平补偿）"></a>2.BLC(Black level Correction)（黑电平补偿）</h3><h4 id="a-暗电流"><a href="#a-暗电流" class="headerlink" title="a.暗电流"></a>a.暗电流</h4><p>物理器件不可能是理想的， 由于杂质、 受热等其他原因的影响， 即使没有光照射到象素，象素单元也会产生电荷， 这些电荷产生了暗电流。 而且， 暗电流与光照产生的电荷很难进行区分。</p><h4 id="b-Black-Level"><a href="#b-Black-Level" class="headerlink" title="b.Black Level"></a>b.Black Level</h4><p>Black Level 是用来定义图像数据为0时对应的信号电平。由于暗电流的影响， 传感器出来的实际原始数据并不是我们需要的黑平衡（数据不为0）。所以，为减少暗电流对图像信号的影响，可以采用的有效的方法是从已获得的图像信号中减去参考暗电流信号。一般情况下， 在传感器中，实际像素要比有效像素多， 如下图所示， 像素区头几行作为不感光区（ 实际上，这部分区域也做了RGB 的 color filter），用于自动黑电平校正，其平均值作为校正值， 然后在下面区域的像素都减去此矫正值，那么就可以将黑电平矫正过来了。<br>做了black level 矫正与没做black level 矫正的对比，没做black level矫正的图片会比较亮，影响图像的对比度。</p><h3 id="3-LSC-Lens-Shading-Correction-（镜头矫正）"><a href="#3-LSC-Lens-Shading-Correction-（镜头矫正）" class="headerlink" title="3.LSC(Lens Shading Correction)（镜头矫正）"></a>3.LSC(Lens Shading Correction)（镜头矫正）</h3><p>由于镜头本身的物理性质， 造成图像四周亮度相对中心亮度逐渐降低，以及，由于图像光照在透过镜头照射到 pixel 上时，边角处的焦点夹角大于中心焦点夹角，造成边角失光。表现在图像上的效果就是亮度从图像中心到四周逐渐衰减， 且离图像中心越远亮度越暗。 为了补偿四周的亮度， 需要进行 Lens Shading 的矫正。<br>Lens Shading 的矫正的方法是根据一定的算法计算每个像素对应的亮度矫正值，从而补偿周边衰减的亮度。<br>矫正方法有二次项矫正、 四次项矫正。</p><h3 id="4-BPC-Bad-Pixel-Correction-（坏点矫正）"><a href="#4-BPC-Bad-Pixel-Correction-（坏点矫正）" class="headerlink" title="4.BPC(Bad Pixel Correction)（坏点矫正）"></a>4.BPC(Bad Pixel Correction)（坏点矫正）</h3><h4 id="a-坏点"><a href="#a-坏点" class="headerlink" title="a.坏点"></a>a.坏点</h4><p>坏点为全黑环境下输出图像中的白点，高亮环境下输出图像中的黑点。</p><h4 id="b-坏点修复方法"><a href="#b-坏点修复方法" class="headerlink" title="b.坏点修复方法"></a>b.坏点修复方法</h4><p>一般情况下， RGB 信号应与景物亮度呈线性响应关系， 但由于 Senor 部分 pixel 不良导致输出的信号不正常， 出现白点或黑点。</p><p>坏点修复方法通常有两种：<br>一种是自动检测坏点并自动修复， 另一种是建立坏点像素链表进行固定位置的坏像素点修复， 这种方式是 OTP 的方式。</p><h3 id="5-Demosaic颜色插值-（抵马赛克）"><a href="#5-Demosaic颜色插值-（抵马赛克）" class="headerlink" title="5.Demosaic颜色插值 （抵马赛克）"></a>5.Demosaic颜色插值 （抵马赛克）</h3><p>当光线通过 Bayer型 CFA（Color Filter Arrays） 阵列之后， 单色光线打在传感器上，每个像素都为单色光，从而理想的Bayer 图是一个较为昏暗的马赛克图。<br>首先需要说明的就是demosaiced并不是和字面的意思一样是为了去除电影中的一些打马赛克的图像，而是数字图像处理中用来从不完整的color samples插值生成完整的color samples的方法(因为bayer pattern看起来像一个个马赛克，因此称为去马赛克)。在sensor端通常需要使用CFA滤镜来得到Bayer pattern，而在后面的处理中需要把bayer pattern变成完整的RGB444(真彩色)图像。在ISP中需要有这么一个模块来做。</p><p>在传统的ISP中有很多算法可以来做这个插值，包括最近邻域法，bilinear 插值，cubic 插值等。</p><h3 id="6-Bayer-Denoise（去噪声）"><a href="#6-Bayer-Denoise（去噪声）" class="headerlink" title="6.Bayer Denoise（去噪声）"></a>6.Bayer Denoise（去噪声）</h3><p>使用 cmos sensor获取图像，光照程度和传感器问题是生成图像中大量噪声的主要因素。同时， 当信号经过ADC 时， 又会引入其他一些噪声。 这些噪声会使图像整体变得模糊， 而且丢失很多细节， 所以需要对图像进行去噪处理空间去噪传统的方法有均值滤波、 高斯滤波等。</p><p>但是， 一般的高斯滤波在进行采样时主要考虑了像素间的空间距离关系， 并没有考虑像素值之间的相似程度， 因此这样得到的模糊结果通常是整张图片一团模糊。 所以， 一般采用非线性去噪算法， 例如双边滤波器， 在采样时不仅考虑像素在空间距离上的关系， 同时加入了像素间的相似程度考虑， 因而可以保持原始图像的大体分块， 进而保持边缘。</p><h3 id="7-AWB-Automatic-White-Balance-（自动白平衡）"><a href="#7-AWB-Automatic-White-Balance-（自动白平衡）" class="headerlink" title="7.AWB(Automatic White Balance)（自动白平衡）"></a>7.AWB(Automatic White Balance)（自动白平衡）</h3><p>白平衡的基本原理是在任意环境下， 把白色物体还原成白色物体， 也就是通过找到图像中的白块， 然后调整R/G/B 的比例， 如下关系：</p><script type="math/tex; mode=display">R’= R * R_Gain</script><script type="math/tex; mode=display">G’ = G * G_Gain</script><script type="math/tex; mode=display">B’ = B * B_Gain</script><script type="math/tex; mode=display">R’ = G’= B’</script><p>AWB 算法通常包括的步骤如下：<br>(1)色温统计： 根据图像统计出色温；</p><p>(2)计算通道增益： 计算出R 和B 通道的增益；</p><p>(3)进行偏色的矫正： 根据给出的增益， 算出偏色图像的矫正。</p><h3 id="8-Color-Correction（颜色矫正）"><a href="#8-Color-Correction（颜色矫正）" class="headerlink" title="8.Color Correction（颜色矫正）"></a>8.Color Correction（颜色矫正）</h3><p>由于人类眼睛可见光的频谱响应度和半导体传感器频谱响应度之间存在差别，还有透镜等的影响， 得到的RGB 值颜色会存在偏差， 因此必须对颜色进行校正， 通常的做法是通过一个3x3 的颜色变化矩阵来进行颜色矫正。 </p><h3 id="9-Gamma-Correction（伽马矫正）"><a href="#9-Gamma-Correction（伽马矫正）" class="headerlink" title="9.Gamma Correction（伽马矫正）"></a>9.Gamma Correction（伽马矫正）</h3><p>人眼对外界光源的感光值与输入光强不是呈线性关系的， 而是呈指数型关系的。 在低照度下，人眼更容易分辨出亮度的变化， 随着照度的增加，人眼不易分辨出亮度的变化。而摄像机感光与输入光强呈线性关系， 为方便人眼辨识图像， 需要将摄像机采集的图像进行gamma 矫正。<br>Gamma 矫正是对输入图像灰度值进行的非线性操作， 使输出图像灰度值与输入图像灰度值呈指数关系：<br>out = Vin ^ gamma<br><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_isp_8.png" alt><br>这个指数就是 gamma， 横坐标是输入灰度值， 纵坐标是输出灰度值， 蓝色曲线是 gamma 值小于 1 时的输入输出关系， 红色曲线是 gamma 值大于 1 时的输入输出关系。 可以观察到， 当 gamma 值小于 1 时(蓝色曲线)， 图像的整体亮度值得到提升， 同时低灰度处的对比度得到增加， 更利于分辩低灰度值时的图像细节。</p><h3 id="10-色彩空间转换"><a href="#10-色彩空间转换" class="headerlink" title="10.色彩空间转换"></a>10.色彩空间转换</h3><p>YUV 是一种基本色彩空间， 人眼对亮度改变的敏感性远比对色彩变化大很多， 因此， 对于人眼而言， 亮度分量Y 要比色度分量U、V 重要得多。 所以， 可以适当地抛弃部分U、V分量， 达到压缩数据的目的。<br>YCbCr 其实是YUV 经过缩放和偏移的改动版，Y 表示亮度，Cr、Cb 表示色彩的色差，RGB信号亮度值之间的差异，分别是红色和蓝色的分量。 在YUV 家族中，YCbCr 是在计算机系统中应用最多的成员， 其应用领域很广泛，JPEG、MPEG 均采用此格式。 一般人们所讲的YUV 大多是指YCbCr。YCbCr有许多取样格式，如 4∶4∶4，4∶2∶2， 4∶1∶1和 4∶2∶0。<br>Cb：反映的是RGB输入信号蓝色部分与RGB信号亮度值之间的差异。<br>Cr：反映了RGB输入信号红色部分与RGB信号亮度值之间的差异。<br>在以下两个公式中RGB和YCbCr各分量的值的范围均为0-255。<br>RGB转换为Ycbcr公式：</p><script type="math/tex; mode=display">Y = 0.257*R+0.564*G+0.098*B+16</script><script type="math/tex; mode=display">Cb = -0.148*R-0.291*G+0.439*B+128</script><script type="math/tex; mode=display">Cr = 0.439*R-0.368*G-0.071*B+128</script><p>YCbCr转换为RGB公式：</p><script type="math/tex; mode=display">R = 1.164*(Y-16)+1.596*(Cr-128)</script><script type="math/tex; mode=display">G = 1.164*(Y-16)-0.392*(Cb-128)-0.813*(Cr-128)</script><script type="math/tex; mode=display">B =1.164*(Y-16)+2.017*(Cb-128)</script><p>色彩空间转换这个模块， 是将RGB 转换为 YUV444， 然后在YUV 色彩空间上进行后续的彩色噪声去除、 边缘增强等， 也为后续输出转换为jpeg 图片提供方便。</p><h3 id="11-Color-Denoise"><a href="#11-Color-Denoise" class="headerlink" title="11.Color Denoise"></a>11.Color Denoise</h3><p>为了抑制图像的彩色噪声， 一般采用低通滤波器进行处理。 例如使用M×N的高斯低通滤波器在色度通道上进行处理。</p><p>参考：<br><a href="https://blog.csdn.net/weijory/article/details/70225392" target="_blank" rel="noopener">高通camera结构（摄像头基础介绍）</a><br><a href="https://blog.csdn.net/weijory/article/details/53306545" target="_blank" rel="noopener">ISP算法概述</a><br><a href="https://blog.csdn.net/l18318931829/article/details/78274790" target="_blank" rel="noopener">ISP概述、工作原理及架构</a><br><a href="https://blog.csdn.net/hunanchenxingyu/article/details/49750177" target="_blank" rel="noopener">ISP  DSP的区别</a><br><a href="https://blog.csdn.net/aoshilang2249/article/details/38070663" target="_blank" rel="noopener">数字图像处理 颜色空间RGB、HSI、CMYK、YUV的相互转换</a><br><a href="https://blog.csdn.net/a1809032425/article/details/81272965" target="_blank" rel="noopener">ISP基本框架及算法介绍</a><br><a href="https://blog.csdn.net/lyfwill/article/details/81220380" target="_blank" rel="noopener">ISP（图像信号处理）之——图像处理概述</a><br><a href="http://kernel.meizu.com/camera-isp-intro.html" target="_blank" rel="noopener">相机系统综述 —— ISP</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理之下采样</title>
      <link href="/2020/03/20/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B9%8B%E4%B8%8B%E9%87%87%E6%A0%B7/"/>
      <url>/2020/03/20/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B9%8B%E4%B8%8B%E9%87%87%E6%A0%B7/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>图像处理之下采样<br><a id="more"></a></p><h2 id="下采样"><a href="#下采样" class="headerlink" title="下采样"></a>下采样</h2><p> 下采样（subsampled）或降采样（downsampled））的目的有：</p><p>1、使得图像符合显示区域的大小；<br>2、生成对应图像的缩略图；<br>3、处理大型图像减少运算量。</p><h3 id="下采样实现"><a href="#下采样实现" class="headerlink" title="下采样实现"></a>下采样实现</h3><p>两种方式：<br>方法一，for循环隔行隔列循环遍历每一个像素点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">%读入图像进行下采样</span><br><span class="line">%两种方法用时只需将对应方法注释掉其中一个即可</span><br><span class="line">clear all;</span><br><span class="line">close all;</span><br><span class="line">clc;</span><br><span class="line">img = imread(&apos;F:\MATLAB2017b\AMOutputResults\lena.jpg&apos;);</span><br><span class="line">% n为下采样倍数</span><br><span class="line">n = 2;</span><br><span class="line">img = rgb2gray(img);</span><br><span class="line">[h w] = size(img);</span><br><span class="line">L =1;</span><br><span class="line">R = 1;</span><br><span class="line">%对图像进行下采样</span><br><span class="line">tic;</span><br><span class="line">img_down = zeros(256,256);</span><br><span class="line"></span><br><span class="line">% %方法一循环遍历每一个像素点，j为行，i表示列</span><br><span class="line">% for j = 1:n:h</span><br><span class="line">%     for i = 1:n:w</span><br><span class="line">%         img_down(L, R) = img(j,i);</span><br><span class="line">%         R = R+1;</span><br><span class="line">%     end</span><br><span class="line">%     L = L+1;</span><br><span class="line">%     R = 1;</span><br><span class="line">% end</span><br><span class="line">toc;</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%</span><br><span class="line">%tic;</span><br></pre></td></tr></table></figure></p><p>方法二，矩阵隔行隔列复制<br>其实道理也是一样的不过代码更短一些，在程序中间加了tic,toc来计时间，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%方法二矩阵隔行隔列赋值</span><br><span class="line">%img_down = img(1:n:512,1:n:512);</span><br><span class="line">%toc;</span><br><span class="line">imshowpair(img,(uint8(img_down)),&apos;montage&apos;);</span><br></pre></td></tr></table></figure></p><p>发现方法一：时间已过 0.002278 秒。方法二大概：时间已过 0.000293 秒。。。<br>第二种方法比第一种for循环快了将近10倍。可见在大型图片下采样时还是尽量避免for嵌套循环，转而用矩阵向量的计算方式，这样会省不少时间 。</p><h2 id="DCT域下采样算法"><a href="#DCT域下采样算法" class="headerlink" title="DCT域下采样算法"></a>DCT域下采样算法</h2><p>在传统的图像，视频的后处理阶段，一般会涉及到图像大小的缩放问题。这样的操作是为了适配不同屏幕分辨率的大小。例如，对于高档相机拍摄的照片，一般都很大，而要在普通显示器上显示，则要在解码图像数据之后再做缩小操作才能显示到屏幕上。对于手机屏幕，更是如此。那么，能否在图像解码的过程中实现图片的缩小？</p><p>通过在视频解码中使用频域下采样技术，我们在400M主频的手机上实现了720p的流畅解码，在400M主频的CPU上实现了1080p的视频解码，但不是很流畅。</p><h3 id="1、DCT频率域下采样算法"><a href="#1、DCT频率域下采样算法" class="headerlink" title="1、DCT频率域下采样算法"></a>1、DCT频率域下采样算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">% 根据Dugad方法实现</span><br><span class="line">%程序作者： celery.chen@yahoo.com.cn</span><br><span class="line">%2010-10-12</span><br><span class="line"></span><br><span class="line">I=imread(&apos;456.png&apos;);</span><br><span class="line">I=rgb2gray(I);</span><br><span class="line">figure(1);</span><br><span class="line">imshow(I);</span><br><span class="line">[width,height] = size(I);</span><br><span class="line">block_size_x = 8;</span><br><span class="line">block_size_y = 8;</span><br><span class="line">x_block_num = width/block_size_x;</span><br><span class="line">y_block_num = height/block_size_y;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">z_dst = zeros(width/2,height/2);</span><br><span class="line"></span><br><span class="line">pfun1 = @dct2;</span><br><span class="line"></span><br><span class="line">I_freq = blkproc(I,[8 8],pfun1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i = 1: x_block_num</span><br><span class="line">    for j = 1 : y_block_num</span><br><span class="line">        </span><br><span class="line">        P = I_freq((i-1)*8+1:(i-1)*8+4,(j-1)*8+1:(j-1)*8+4);</span><br><span class="line">        P = P/2.0;</span><br><span class="line">        z_dst( (i-1)*4 +1 : (i-1)*4 +4, (j-1)*4 +1 : (j-1)*4 +4) = P;  </span><br><span class="line">     </span><br><span class="line">    end</span><br><span class="line"> end</span><br><span class="line"></span><br><span class="line">pfun2 = @idct2;</span><br><span class="line"></span><br><span class="line">J = blkproc(z_dst,[4 4],pfun2);</span><br><span class="line">J = uint8(round(J));</span><br><span class="line">figure(2);</span><br><span class="line">imshow(J);</span><br></pre></td></tr></table></figure><h3 id="2、DCT频域下采样算法"><a href="#2、DCT频域下采样算法" class="headerlink" title="2、DCT频域下采样算法"></a>2、DCT频域下采样算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">% dct频率域下采样算法，根据下面论文提到的算法实现</span><br><span class="line">% 一种高效的DCT域图像下采样方法 中国图像图形学报 2005年4月</span><br><span class="line">%程序作者： celery.chen@yahoo.com.cn ，2010-10</span><br><span class="line">clc;</span><br><span class="line">clear;</span><br><span class="line">I=imread(&apos;456.png&apos;);</span><br><span class="line">I=rgb2gray(I);</span><br><span class="line">figure(1);</span><br><span class="line">imshow(I);</span><br><span class="line">[width,height] = size(I);</span><br><span class="line">block_size_x = 8*2;</span><br><span class="line">block_size_y = 8*2;</span><br><span class="line">x_block_num = width/block_size_x;</span><br><span class="line">y_block_num = height/block_size_y;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C16 = dctmtx(16);</span><br><span class="line"></span><br><span class="line"> C16LL = C16(1:8,1:8);</span><br><span class="line"> C16LH = C16(1:8,9:16);</span><br><span class="line"> C16HL = C16(9:16,1:8);</span><br><span class="line"> C16HH = C16(9:16,9:16);</span><br><span class="line"> </span><br><span class="line"> C8 = dctmtx(8);</span><br><span class="line"> </span><br><span class="line"> P = C16LL*C8&apos;;</span><br><span class="line"> P = P/sqrt(2);</span><br><span class="line">  </span><br><span class="line"> Q = C16LH*C8&apos;;</span><br><span class="line"> Q = Q/sqrt(2);</span><br><span class="line"> </span><br><span class="line">  E = (P + Q)/2;</span><br><span class="line">  F = (P - Q)/2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">z_dst = zeros(width/2,height/2);</span><br><span class="line"></span><br><span class="line">pfun1 = @dct2;</span><br><span class="line"></span><br><span class="line">I_freq = blkproc(I,[8 8],pfun1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i = 1: x_block_num</span><br><span class="line">    for j = 1 : y_block_num</span><br><span class="line">        </span><br><span class="line">        X1 = I_freq((i-1)*16+1:(i-1)*16+8,(j-1)*16+1:(j-1)*16+8);</span><br><span class="line">X2 = I_freq((i-1)*16+1:(i-1)*16+8,(j-1)*16+9:(j-1)*16+16);</span><br><span class="line"></span><br><span class="line">X3 = I_freq((i-1)*16+9:(i-1)*16+16,(j-1)*16+1:(j-1)*16+8);</span><br><span class="line">X4 = I_freq((i-1)*16+9:(i-1)*16+16,(j-1)*16+9:(j-1)*16+16);        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A  = E*(X1+X3)+F*(X1-X3);</span><br><span class="line">B  = E*(X2+X4)+F*(X2-X4);</span><br><span class="line"></span><br><span class="line">XLL = (A + B) * E&apos; + (A - B) * F&apos;;</span><br><span class="line"></span><br><span class="line">        z_dst( (i-1)*8 +1 : (i-1)*8 +8, (j-1)*8 +1 : (j-1)*8 +8) = XLL;  </span><br><span class="line">     </span><br><span class="line">    end</span><br><span class="line"> end</span><br><span class="line"></span><br><span class="line">pfun2 = @idct2;</span><br><span class="line"></span><br><span class="line">J = blkproc(z_dst,[8 8],pfun2);</span><br><span class="line">J = uint8(round(J));</span><br><span class="line">figure(2);</span><br><span class="line">imshow(J);</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/celerychen/archive/2013/06/05/3588198.html" target="_blank" rel="noopener">参考文章-视频图像处理中的频域下采样技术</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理之天空区域识别</title>
      <link href="/2020/02/23/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B9%8B%E5%A4%A9%E7%A9%BA%E5%8C%BA%E5%9F%9F%E8%AF%86%E5%88%AB/"/>
      <url>/2020/02/23/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B9%8B%E5%A4%A9%E7%A9%BA%E5%8C%BA%E5%9F%9F%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>图像处理之天空区域识别<br><a id="more"></a></p><p>近几年来，去雾方法得到广泛的研究，汤晓鸥等人发现无雾图像相对于雾化图像具有较高的对比度，通过最大化恢复图像的对比度来实现图像去雾，但由于该方法没有从物理模型上恢复真实的场景反射率，图像去雾后有可能出现颜色过饱和失真。 Kaiming He提出了一种基于暗通道先验的方法，即在有雾图像的特定窗中至少有一个颜色分量的值是零，该算法利用最小值滤波估算出介质传播函数，然后利用软抠图原理对估算的介质传播函数进行优化估计，达到了较好的去雾效果。软抠图需要较高计算量，很难得到实际应用。所以后来Kaiming He又提出了引导滤波法，来精细化透射率。</p><p>通过对比实验发现，场景中如果存在较大的天空区域的话，Kaiming He提出的暗通道先验的理论在天空区域将不成立，图像去雾后天空区域存在失真，特別是在天空区域不明显的浓雾环境下。</p><h2 id="一-为什么天空区域识别很重要？"><a href="#一-为什么天空区域识别很重要？" class="headerlink" title="一  为什么天空区域识别很重要？"></a>一  为什么天空区域识别很重要？</h2><p>人们常用传感器进行测距，在自主导航领域常见测距传感器有两类：第一类是主动式传感器，比如雷达，激光传感器，这类传感器比较精确，但缺点是比较贵；第二类是被动式传感器，比如视觉传感器。这类传感器成本较低，主要依赖于算法，但有些场景精度不好。但随着技术的发展，这些精度问题都可以得到解决。</p><h2 id="处理不同透射率区域"><a href="#处理不同透射率区域" class="headerlink" title="处理不同透射率区域"></a>处理不同透射率区域</h2><p>改进的基于暗原色先验的图像去雾算法<br>作者: 蒋建国</p><p>对一些含雾图像，基于暗原色先验的去雾结果出现色彩失真，因为含天空、水面等大面积明亮区域的图像，他们的像素值很大，在此区域找不到像素值接近于0的暗原色。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_天空K参数，纠正偏色.png" alt></p><p>一般情况下大气光A的取值和天空部分应该是非常接近的，而那些符合暗通道的地方则远离天空。</p><h2 id="识别出天空区域单独处理"><a href="#识别出天空区域单独处理" class="headerlink" title="识别出天空区域单独处理"></a>识别出天空区域单独处理</h2><p>专利《一种基于天空识别与分割的暗通道先验去雾方法》<br><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_专利天空识别.png" alt></p><h3 id="重点："><a href="#重点：" class="headerlink" title="重点："></a>重点：</h3><p>1、进行天空识别与分割，确定天空区域与非天空区域不同透射率。<br>2、引导滤波优化透射率，输出头屋图像</p><h3 id="相似操作识别天空区域"><a href="#相似操作识别天空区域" class="headerlink" title="相似操作识别天空区域"></a>相似操作识别天空区域</h3><p>1、天空部分平坦区域多，处理成梯度图表示图像的像素落差，梯度值越小的区域表示为平坦区域。</p><p>2、设定一个阈值来初步划分天空区域与非天空。</p><p>3、对第二步的结果进行扩展处理。</p><p>4、对第三步的图的像素平均亮度进行判断，如果大于阈值T则认为是真天空区域。（阈值可以设置为0.8，灰度值为204左右均可），自我构思</p><p>该方案可以消除去雾图像边缘处的光晕现象，提高处理效率。</p><h2 id="分割天空区域"><a href="#分割天空区域" class="headerlink" title="分割天空区域"></a>分割天空区域</h2><p>专利《一种含天空区域雾天图像的去雾方法、服务器及系统 》</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1、利用预设的亮度阈值 + 图像梯度信息，分割天空区域和非天空区域，梯度阈值选择概率最大的梯度，避免误分割；<br>2、利用四分法或者天空区域大气光值；<br>3、非天空区域加权图像融合的方法细化透射率；<br>4、图像去雾</p><hr><p>我们希望分为天空、似天空和非天空区域，三个区域采用不同的光透射率。<br>注：如果其他区域的像素满足以下两个条件认为是似天空区域：<br>   <1> 弱纹理区域<br>   <2> 像素值和Strue区域的平均像素值 相差很小。</2></1></p><p>其他相关算法程序可以看看<a href="https://github.com/AomanHao/Matlab-Image-Dehazing-Enhazing" target="_blank" rel="noopener">我的github</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>亮度估计相关</title>
      <link href="/2019/12/31/%E4%BA%AE%E5%BA%A6%E4%BC%B0%E8%AE%A1/"/>
      <url>/2019/12/31/%E4%BA%AE%E5%BA%A6%E4%BC%B0%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>亮度估计相关<br><a id="more"></a></p><p>相机照拍夜视图像曝光亮度估计原理水平集是跟踪界面变化的数值计算方法［7］ ， 其把平面闭合取消描述成三维连续曲面 $φ( x，y)$ 的等值曲线， $φ( x，y)$ 表示水平集函数， 一般令 $φ( x，y) = 0$。在相机照拍夜视图像曝光亮度估计原理中， 通过水平集函数对相机照拍夜视图像曝光亮度进行描述， 为后续曝光亮度估计提供依据。曝光亮度估计公式如下:</p><script type="math/tex; mode=display">Hv = Ev * t</script><p>式( 1) 中，$Ev$ 表示光照度，$t$ 表示时间。</p><p>水平集边缘描述方法优势为: 对于水平集函数中夜视图像目标出现的拓扑变化， 水平集函数不会失效， 再拓扑出现变化时依然能够轻松处理。图 1( a) 为夜视图像原图， 图像曲线的水平集函数描述分别如图 1( b) 与图 1( c) 所示， 当图像曲线分裂时， 即进行二次分裂， 三次分裂时， 它的水平集函数没有分裂， 此时函数依然保持有效。</p><p>另外， 图像的一些数学特征也可通过水平集函数描述。水平集方法同样适用于处理高维问题， 如采用水平集方法对多传感器融合图像进行光值估计时， 利用水平集方法描述闭合曲面的演化过程等</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像融合简介</title>
      <link href="/2019/12/31/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E8%9E%8D%E5%90%88/"/>
      <url>/2019/12/31/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E8%9E%8D%E5%90%88/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>图像融合<br><a id="more"></a></p><p>图像融合（Image fusion）的整体重心是对于目标源信息的信息细节的提取和整合。一般情况下，我们先会对不同传感器取得的各自信息及信号进行一个整合加强过程，例如图像间的配准，图像边缘增强，图像纹理平滑，抑制背景杂波等；然后我们要做的是对于融合层和融合算法的选取，不同的算法处理方式和提取特征信息的方法不同，结果也不尽相同，我们仍需要根据我们需要的要求进行选取。最后是对融合效果的评价，看所得结果是否满足我们的预期要求，如不满足我们应当从新讨论融合层次和算法的选取优化等等，具体划分步骤如下：</p><p>1、对于目标探测器的选取。不同的探测器有着各自不同的探测性能，我们需要选取合适的探测器来获取我们想要的信号种类。</p><p>2、对于同一目标的多源图像信号的采集。通过传感器进行目标信号采集，采集过程虽然简单，却可也不能轻视，好的采集方法可以获得更优质的信号信息，为后续的信号处理过程打下基础。</p><p>3、对于采集信号的预处理。收集到的信号不一定直接就能用，在进行图像融合之前，对采集到的信号进行去噪、增强、配准等预处理，可以大大提高图像的对比度以及分辨率，有助于图像融合效果的进一步提高。</p><p>4、图像融合过程。这是整个图像融合最为关键和重要的部分，不同的融合级别有着不同的融合算法以及不同层次的变换域，需要具体情况具体分析对待，以选最合适的融合规则和算法，因为该过程的处理是最为重要的一环。</p><p>5、。根据视觉效果以及各项指标进行判断和分析融合结果。</p><p>图像融合处理过程的流程框图如下：<br><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_imageFusion1.png" alt></p><p>不同的层次所进行数据处理的要求和融合算法是不一样的，需要具体问题具体分析，通常我们将图像数据分为三层，融合过程流程图如下：<br><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_imageFusion2.png" alt></p><p>图像融合层简介：</p><p>1、基于像素级的图像融合属于最基本的图像融合技术。这一层主要是直接处理图像的单像素，因为像素级是由源场景的图像最大化描述的。像素级图像融合需要对图像进行预处理，包括图像配准、滤波和增强。像素级图像融合的主要优点是从这一层获得的图像比其他两种图像更快、更快，显示出源和场景信息，大大提高了源图像中包含的有用和详细信息。</p><p>2、基于特征层的图像融合是基于不同传感器的图像分析，将有用的信息融合成能展现人们需要的特征，特征层的融合对于多元传感器的选择十分重要，因为需要获取的图像必须有人们需要的特征在里面，再进行算法的图像融合使得特征更加明显，特征的数据更加全面和丰富。如果是实时性的特征融合对于传感器的数据处理能力和数据压缩能力都有很大的要求。</p><p>3、对于决策层图像融合所需要做的工作量和工作种类是最大最多的，先是需要对多元传感器所获得的图像进行预处理，再进行特征提取，最后还能做出相应的评判和决策，是图像融合功能最极致却又很难实现的层次。</p><p>其他相关算法程序可以看看<a href="https://github.com/AomanHao/Matlab-Image-Dehazing-Enhazing" target="_blank" rel="noopener">我的github</a></p><hr><h3 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h3><h3 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h3><h3 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> 图像融合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客Next主题友链页面</title>
      <link href="/2019/12/29/hexo_links/"/>
      <url>/2019/12/29/hexo_links/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Hexo博客Next主题友链页面<br><a id="more"></a></p><p>博客友链太多，需要自定义一个友情链接页面</p><h3 id="link渲染文件"><a href="#link渲染文件" class="headerlink" title="link渲染文件"></a>link渲染文件</h3><p>在 <code>hexo/themes/next/layout</code> 目录下建一个 <code>link.swig</code>文件，写入以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">  &#123;######################&#125;</span><br><span class="line">  &#123;### LINKS BLOCK ###&#125;</span><br><span class="line">  &#123;######################&#125;</span><br><span class="line"></span><br><span class="line">    &lt;div id=&quot;links&quot;&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line"></span><br><span class="line">            #links&#123;</span><br><span class="line">               margin-top: 5rem;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            .links-content&#123;</span><br><span class="line">                margin-top:1rem;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            .link-navigation::after &#123;</span><br><span class="line">                content: &quot; &quot;;</span><br><span class="line">                display: block;</span><br><span class="line">                clear: both;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            .card &#123;</span><br><span class="line">                width: 300px;</span><br><span class="line">                font-size: 1rem;</span><br><span class="line">                padding: 10px 20px;</span><br><span class="line">                border-radius: 4px;</span><br><span class="line">                transition-duration: 0.15s;</span><br><span class="line">                margin-bottom: 1rem;</span><br><span class="line">                display:flex;</span><br><span class="line">            &#125;</span><br><span class="line">            .card:nth-child(odd) &#123;</span><br><span class="line">                float: left;</span><br><span class="line">            &#125;</span><br><span class="line">            .card:nth-child(even) &#123;</span><br><span class="line">                float: right;</span><br><span class="line">            &#125;</span><br><span class="line">            .card:hover &#123;</span><br><span class="line">                transform: scale(1.1);</span><br><span class="line">                box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04);</span><br><span class="line">            &#125;</span><br><span class="line">            .card a &#123;</span><br><span class="line">                border:none;</span><br><span class="line">            &#125;</span><br><span class="line">            .card .ava &#123;</span><br><span class="line">                width: 3rem!important;</span><br><span class="line">                height: 3rem!important;</span><br><span class="line">                margin:0!important;</span><br><span class="line">                margin-right: 1em!important;</span><br><span class="line">                border-radius:4px;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            .card .card-header &#123;</span><br><span class="line">                font-style: italic;</span><br><span class="line">                overflow: hidden;</span><br><span class="line">                width: 236px;</span><br><span class="line">            &#125;</span><br><span class="line">            .card .card-header a &#123;</span><br><span class="line">                font-style: normal;</span><br><span class="line">                color: #2bbc8a;</span><br><span class="line">                font-weight: bold;</span><br><span class="line">                text-decoration: none;</span><br><span class="line">            &#125;</span><br><span class="line">            .card .card-header a:hover &#123;</span><br><span class="line">                color: #d480aa;</span><br><span class="line">                text-decoration: none;</span><br><span class="line">            &#125;</span><br><span class="line">            .card .card-header .info &#123;</span><br><span class="line">                font-style:normal;</span><br><span class="line">                color:#a3a3a3;</span><br><span class="line">                font-size:14px;</span><br><span class="line">                min-width: 0;</span><br><span class="line">                text-overflow: ellipsis;</span><br><span class="line">                overflow: hidden;</span><br><span class="line">                white-space: nowrap;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">        &lt;div class=&quot;links-content&quot;&gt;</span><br><span class="line"></span><br><span class="line">             &lt;div class=&quot;no-icon note warning&quot;&gt;&lt;div class=&quot;link-info&quot;&gt;👨‍🎓 跟着大佬走，成为小大佬&lt;/div&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;link-navigation&quot;&gt;</span><br><span class="line">                    &#123;% for link in theme.defaultlinks %&#125;</span><br><span class="line"></span><br><span class="line">                    &lt;div class=&quot;card&quot;&gt;</span><br><span class="line">                        &lt;img class=&quot;ava nofancybox&quot; src=&quot;&#123;&#123; link.avatar &#125;&#125;&quot;/&gt;</span><br><span class="line">                        &lt;div class=&quot;card-header&quot;&gt;</span><br><span class="line">                        &lt;div&gt;&lt;a href=&quot;&#123;&#123; link.site &#125;&#125;&quot; target=&quot;_blank&quot;&gt; &#123;&#123; link.nickname &#125;&#125;&lt;/a&gt; &lt;a href=&quot;&#123;&#123; link.site &#125;&#125;&quot;&gt;&lt;span class=&quot;focus-links&quot;&gt;&lt;i class=&quot;fa fa-plus&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&amp;nbsp;关注&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">                        &lt;div class=&quot;info&quot;&gt;&#123;&#123; link.info &#125;&#125;&lt;/div&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">                &#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">            &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">            &lt;div class=&quot;no-icon note primary&quot;&gt;&lt;div class=&quot;link-info&quot;&gt;🍭 五湖四海的朋友们&lt;/div&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">             &lt;div class=&quot;link-navigation&quot;&gt;</span><br><span class="line">                    &#123;% for link in theme.friendslinks %&#125;</span><br><span class="line"></span><br><span class="line">                    &lt;div class=&quot;card&quot;&gt;</span><br><span class="line">                        &lt;img class=&quot;ava nofancybox&quot; src=&quot;&#123;&#123; link.avatar &#125;&#125;&quot;/&gt;</span><br><span class="line">                        &lt;div class=&quot;card-header&quot;&gt;</span><br><span class="line">                        &lt;div&gt;&lt;a href=&quot;&#123;&#123; link.site &#125;&#125;&quot; target=&quot;_blank&quot;&gt; &#123;&#123; link.nickname &#125;&#125;&lt;/a&gt; &lt;a href=&quot;&#123;&#123; link.site &#125;&#125;&quot;&gt;&lt;span class=&quot;focus-links&quot;&gt;&lt;i class=&quot;fa fa-plus&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&amp;nbsp;关注&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;</span><br><span class="line">                        &lt;div class=&quot;info&quot;&gt;&#123;&#123; link.info &#125;&#125;&lt;/div&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">                &#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">            &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">            &#123;&#123; page.content &#125;&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &#123;##########################&#125;</span><br><span class="line">  &#123;### END LINKS BLOCK ###&#125;</span><br><span class="line">  &#123;##########################&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><h3 id="page渲染文件"><a href="#page渲染文件" class="headerlink" title="page渲染文件"></a>page渲染文件</h3><p>然后修改 <code>hexo/themems/next/layout/page.swig</code> 文件，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#&#125;&#123;% elif page.type === &quot;tags&quot; and not page.title %&#125;&#123;#</span><br><span class="line">    #&#125;&#123;&#123; __(&apos;title.tag&apos;) + page_title_suffix &#125;&#125;&#123;#</span><br></pre></td></tr></table></figure></p><p>位置添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 友情链接--&gt;</span><br><span class="line">#&#125;&#123;% elif page.type === &apos;links&apos; and not page.title %&#125;&#123;#</span><br><span class="line">  #&#125;&#123;&#123; __(&apos;title.links&apos;) + page_title_suffix &#125;&#125;&#123;#</span><br></pre></td></tr></table></figure></p><p>如图所示：</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/hexo_links1.png" alt></p><p>然后还是在这个 page.swig 文件中，引入刚才新建的 swig 页面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 友情链接--&gt;</span><br><span class="line">&#123;% elif page.type === &apos;links&apos; %&#125;</span><br><span class="line">    &#123;% include &apos;links.swig&apos; %&#125;</span><br></pre></td></tr></table></figure></p><p>这个代码位置可以放到下面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  &#123;% elif page.type === &apos;categories&apos; %&#125;</span><br><span class="line">    &lt;div class=&quot;category-all-page&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;category-all-title&quot;&gt;</span><br><span class="line">          &#123;&#123; _p(&apos;counter.categories&apos;, site.categories.length) &#125;&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div class=&quot;category-all&quot;&gt;</span><br><span class="line">        &#123;&#123; list_categories() &#125;&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#123;% elif page.type === &apos;links&apos; %&#125;</span><br><span class="line">   &#123;% include &apos;links.swig&apos; %&#125;</span><br><span class="line">  &#123;% else %&#125;</span><br><span class="line">    &#123;&#123; page.content &#125;&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/hexo_links2.png" alt></p><h3 id="index文件"><a href="#index文件" class="headerlink" title="index文件"></a>index文件</h3><p>然后在 <code>hexo/source</code> 下创建 <code>links</code> 文件夹，创建 <code>index.md</code> 文件，写入以下内容，如下，这个是友链页面的申请信息，可以按照自己想法修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">----</span><br><span class="line">title: 友情链接</span><br><span class="line">date: 2019-12-08 03:21:39</span><br><span class="line">type: &quot;links&quot;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 申请要求：</span><br><span class="line"></span><br><span class="line">1、内容持续更新且可以稳定访问</span><br><span class="line">2、网页整洁无繁杂广告推广</span><br><span class="line">3、博客主页被百度或谷歌等搜索引擎收录</span><br><span class="line">4、头像能够快速加载</span><br><span class="line">5、拥有独立域名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 友链声明：</span><br><span class="line"></span><br><span class="line">1、本站会主动保存您的 HTTPS 形式的头像图片链接</span><br><span class="line">2、本站会定期清理无法访问的友链，如果更换了链接信息请至评论区留言，谢谢合作！</span><br><span class="line">3、本站会定期查看双方是否互为友链，如果取消本站友链，本站也会将您的友链移除</span><br><span class="line"></span><br><span class="line">### 申请方式：</span><br><span class="line"></span><br><span class="line">先将本站的友链添加到您的友链，相关信息如下</span><br><span class="line">然后按照以下格式在本站留言区留言，待博主为您添上友链</span><br><span class="line"></span><br><span class="line">&gt;名称：AomanHao </span><br><span class="line">头像链接：http://www.aomanhao.top/images/Avatar.jpg</span><br><span class="line">主页链接：http://www.aomanhao.top/ </span><br><span class="line">说明信息：图像处理，优化世界</span><br></pre></td></tr></table></figure></p><h3 id="config配置文件"><a href="#config配置文件" class="headerlink" title="config配置文件"></a>config配置文件</h3><p>最后，我们添加友链的话，需要在主题配置文件 <code>hexo/themes/next/_config.xml</code> 文件末尾添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 友情链接</span><br><span class="line">defaultlinks:</span><br><span class="line">  - nickname: AomanHao     # 昵称</span><br><span class="line">    avatar: http://www.aomanhao.top/images/Avatar.jpg    # 头像地址</span><br><span class="line">    site: http://www.aomanhao.top #友链地址</span><br><span class="line">    info: 图像处理，优化世界</span><br><span class="line"></span><br><span class="line">friendslinks:</span><br><span class="line">  - nickname: AomanHao     # 昵称</span><br><span class="line">    avatar: http://www.aomanhao.top/images/Avatar.jpg    # 头像地址</span><br><span class="line">    site: http://www.aomanhao.top #友链地址</span><br><span class="line">    info: 图像处理，优化世界</span><br></pre></td></tr></table></figure></p><p><code>defaultlinks:</code>呼应的是<code>link.swig</code>文件中 <code>👨‍🎓 跟着大佬走，成为小大佬</code>段落，此处链接写大佬的博客；<br><code>friendslinks:</code>呼应的是<code>link.swig</code>文件中 <code>🍭 五湖四海的朋友们</code>段落，此处链接写朋友的博客。<br>此处内容可以根据自己需要自行修改</p><p>菜单栏汉化需要在 <code>hexo/themes/next/languages/zh-CN.yml</code>文件中，新增 links ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line"></span><br><span class="line">  links: 友链</span><br></pre></td></tr></table></figure><hr><p><a href="https://bestzuo.cn/posts/2016690040.html" target="_blank" rel="noopener">参考文章，sanarous</a></p><h3 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h3><h3 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h3><h3 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客Next主题相册搭建</title>
      <link href="/2019/12/22/hexo_photos/"/>
      <url>/2019/12/22/hexo_photos/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Hexo博客Next主题相册搭建<br><a id="more"></a><br>在<code>blog文件夹/source</code>下创建<code>photos</code>文件夹，在<code>photos</code>文件夹创建<code>index.md</code>文件，编辑<code>index.md</code>文件，写入以下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    .header-inner&#123;</span><br><span class="line">         display: none;</span><br><span class="line">    &#125;</span><br><span class="line">    .sidebar&#123;</span><br><span class="line">        display: none;</span><br><span class="line">    &#125;</span><br><span class="line">    .content&#123;</span><br><span class="line">        margin-bottom: 360px;</span><br><span class="line">    &#125;</span><br><span class="line">    .content-wrap&#123;</span><br><span class="line">       width: 100%;</span><br><span class="line">       // box-sizing: content-box;</span><br><span class="line">       padding: initial !important;</span><br><span class="line">       background:url(&apos;https://s2.ax1x.com/2019/09/07/nlL4pR.jpg&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">.main-inner&#123;</span><br><span class="line">width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.main &#123;</span><br><span class="line">        padding-bottom: 150px;</span><br><span class="line">        margin-top: 0px;</span><br><span class="line">        background:url(&apos;https://s2.ax1x.com/2019/09/07/nlL4pR.jpg&apos;);</span><br><span class="line">&#125;</span><br><span class="line">.main-inner&#123;</span><br><span class="line">margin-top: unset;</span><br><span class="line">&#125;</span><br><span class="line">.page-post-detail .post-meta&#123;</span><br><span class="line">display: none;</span><br><span class="line">&#125;</span><br><span class="line">body &#123;</span><br><span class="line">background-image: unset;</span><br><span class="line">background-attachment: unset;</span><br><span class="line">background-size: 100%;</span><br><span class="line">/*background-position: top left;*/</span><br><span class="line">&#125;</span><br><span class="line">.header&#123;</span><br><span class="line">background: rgba(28, 25, 25, 0.6);</span><br><span class="line">border-bottom: unset;</span><br><span class="line">&#125;</span><br><span class="line">.menu .menu-item a&#123;</span><br><span class="line">    font-weight: 300;</span><br><span class="line">    color: #e6eaed;</span><br><span class="line">&#125;</span><br><span class="line">.footer-inner &#123;</span><br><span class="line">     padding-left: 0px;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    img:hover &#123;</span><br><span class="line">        //opacity:0.8; /*透明度*/</span><br><span class="line">        //filter:alpha(opacity=100); /* For IE8 and earlier */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">.imgbox&#123;</span><br><span class="line">    margin-top: 20px;</span><br><span class="line">    padding: 1px 10px;</span><br><span class="line">        width: 100%;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        height: 250px;</span><br><span class="line">    border-right: 1px solid #bcbcbc;</span><br><span class="line">    background:url(&apos;https://s2.ax1x.com/2019/09/07/nlL4pR.jpg&apos;);</span><br><span class="line">&#125;</span><br><span class="line">.box&#123;</span><br><span class="line">visibility: visible;</span><br><span class="line">overflow: auto; </span><br><span class="line">zoom: 1;</span><br><span class="line">&#125;</span><br><span class="line">.box li&#123;</span><br><span class="line">        float: left;</span><br><span class="line">        width: 25%;</span><br><span class="line">        position: relative;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">        text-align: center;</span><br><span class="line">        list-style: none;</span><br><span class="line">        margin: 0;</span><br><span class="line">        /*display: inline;*/</span><br><span class="line">        padding: 0;</span><br><span class="line">        height: 360px;</span><br><span class="line">&#125;</span><br><span class="line">.box li span&#123;</span><br><span class="line">        display: block;</span><br><span class="line">        padding: 12% 7% 10% 7%;</span><br><span class="line">        min-height: 80px;</span><br><span class="line">        //background: #fff;</span><br><span class="line">        color: #fff;</span><br><span class="line">        font-size: 16px;</span><br><span class="line">        font-weight: 600;</span><br><span class="line">        line-height: 26px;</span><br><span class="line">        -webkit-box-sizing: border-box;</span><br><span class="line">        box-sizing: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">img.imgitem&#123;</span><br><span class="line">padding: unset;</span><br><span class="line">padding: unset;</span><br><span class="line">border: unset;</span><br><span class="line">position: relative;</span><br><span class="line">padding: 0px;</span><br><span class="line">height: auto;</span><br><span class="line">width: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    div#posts.posts-expand &#123;</span><br><span class="line">        border: unset;</span><br><span class="line">        padding: unset;</span><br><span class="line">        margin-bottom: 10px;</span><br><span class="line">    &#125;</span><br><span class="line">    .posts-expand .post-body img&#123;</span><br><span class="line">        padding: 0px !important;</span><br><span class="line">    &#125;</span><br><span class="line">    .box p&#123;</span><br><span class="line">        margin-top: -25px;</span><br><span class="line">        display: block;</span><br><span class="line">        background: #121212;</span><br><span class="line">        color: #fff;</span><br><span class="line">        font-size: 14px;</span><br><span class="line">        -webkit-box-sizing: border-box;</span><br><span class="line">        box-sizing: border-box;</span><br><span class="line">        text-align: center;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .box span strong&#123;</span><br><span class="line">        background: rgba(0,0,0,0.4);</span><br><span class="line">        padding: 20px;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .posts-expand .post-title &#123;</span><br><span class="line">        display: none;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .title&#123;</span><br><span class="line">        margin: 10px auto;</span><br><span class="line">        display: inline-block;</span><br><span class="line">        vertical-align: middle;</span><br><span class="line">        //background: url(/images/beichen.jpg);</span><br><span class="line">        font: 85px/250px &apos;ChaletComprimeMilanSixty&apos;;</span><br><span class="line">        //background-position: left bottom !important;</span><br><span class="line">        background-position: center center !important;</span><br><span class="line">        color: #fff;</span><br><span class="line">        background-size: 100% auto !important; </span><br><span class="line">        -webkit-background-size: cover; </span><br><span class="line">        -moz-background-size: cover;</span><br><span class="line">        -o-background-size: cover;</span><br><span class="line">        width: 100%;</span><br><span class="line">        text-align: center;</span><br><span class="line">        border: unset;</span><br><span class="line">        height: 560px;</span><br><span class="line">        cursor: unset !important;</span><br><span class="line">        -webkit-box-sizing: border-box;</span><br><span class="line">        box-sizing: border-box;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @media (max-width: 767px)&#123;</span><br><span class="line">        .box li &#123;</span><br><span class="line">            width: 98%;</span><br><span class="line">        &#125;</span><br><span class="line">        .title &#123;</span><br><span class="line">            height: 200px;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .box span &#123;</span><br><span class="line">            min-height: 80px;</span><br><span class="line">            border-right: unset;</span><br><span class="line">            font-size: 17px;</span><br><span class="line">        &#125;</span><br><span class="line">        .box p&#123;</span><br><span class="line">            border-right: unset;</span><br><span class="line">            font-size: 12px;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">        .posts-expand &#123;</span><br><span class="line">            margin: unset;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @media (min-width: 1600px)&#123;</span><br><span class="line">    </span><br><span class="line">        .container .main-inner&#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;box&quot; class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">   </span><br><span class="line">   // 相册json</span><br><span class="line">   var json = </span><br><span class="line">    [</span><br><span class="line">    [</span><br><span class="line">            &#123;</span><br><span class="line">                &apos;title&apos;: &apos;七彩丹霞&apos;,</span><br><span class="line">                &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlRzZt.jpg&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &apos;title&apos;: &apos;9月雨后&apos;,</span><br><span class="line">                &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlRvqI.jpg&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &apos;title&apos;: &apos;五花肉&apos;,</span><br><span class="line">                &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlRbGD.jpg&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &apos;title&apos;: &apos;五花肉+1&apos;,</span><br><span class="line">                &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlRHPO.jpg&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &apos;title&apos;: &apos;别样的艳&apos;,</span><br><span class="line">                &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlRTIK.jpg&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &apos;title&apos;: &apos;远处的城堡&apos;,</span><br><span class="line">                &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlRXMd.md.jpg&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &apos;title&apos;: &apos;夕阳红&apos;,</span><br><span class="line">                &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlRqRe.md.jpg&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &apos;title&apos;: &apos;卢浮宫&apos;,</span><br><span class="line">                &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlRIVx.md.jpg&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &apos;title&apos;: &apos;景区一角&apos;,</span><br><span class="line">                &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlRhrR.md.jpg&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &apos;title&apos;: &apos;夕阳🌇&apos;,</span><br><span class="line">                &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlRbGD.md.jpg&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &apos;title&apos;: &apos;冰沟丹霞&apos;,</span><br><span class="line">                &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlRLxH.md.jpg&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &apos;title&apos;: &apos;别样的雨后&apos;,</span><br><span class="line">                &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlRRxJ.md.jpg&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &apos;title&apos;: &apos;卢浮宫&apos;,</span><br><span class="line">                &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlR4q1.md.jpg&apos;</span><br><span class="line">            &#125;</span><br><span class="line">    ],</span><br><span class="line">    </span><br><span class="line">    [</span><br><span class="line">            &#123;</span><br><span class="line">                &apos;title&apos;: &apos;世界之巅&apos;,</span><br><span class="line">                &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nl5540.md.jpg&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &apos;title&apos;: &apos;一天的行程&apos;,</span><br><span class="line">                &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nl56gS.md.jpg&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &apos;title&apos;: &apos;珠峰国家公园&apos;,</span><br><span class="line">                &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nl5RBj.md.jpg&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &apos;title&apos;: &apos;盘山公路&apos;,</span><br><span class="line">                &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nl54Nq.md.jpg&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &apos;title&apos;: &apos;保护区&apos;,</span><br><span class="line">                &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nl5LDJ.md.png&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &apos;title&apos;: &apos;珠峰大本营&apos;,</span><br><span class="line">                &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlINGV.md.png&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &apos;title&apos;: &apos;氧气瓶&apos;,</span><br><span class="line">                &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nl5jER.md.jpg&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &apos;title&apos;: &apos;珠峰日出&apos;,</span><br><span class="line">                &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nl5cjg.md.jpg&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &apos;title&apos;: &apos;海拔最高的寺庙—绒布寺&apos;,</span><br><span class="line">                &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nl5hEn.md.jpg&apos;</span><br><span class="line">            &#125;</span><br><span class="line">    ]</span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    var content = json2Array(json);</span><br><span class="line">        </span><br><span class="line">    var wid = 250;</span><br><span class="line">    if ((window.innerWidth) &gt; 1200) &#123;</span><br><span class="line">        wid = (window.innerWidth*3)/18;</span><br><span class="line">    &#125;</span><br><span class="line">    var box = document.getElementById(&apos;box&apos;);</span><br><span class="line">    </span><br><span class="line">    var i=0;</span><br><span class="line">    for (var i = 0; i &lt; content.length; i++) &#123;</span><br><span class="line">    var conBox = document.createElement(&quot;div&quot;);</span><br><span class="line">    conBox.id = &apos;conBox&apos;+i;</span><br><span class="line">    box.appendChild(conBox);</span><br><span class="line">    var item = document.createElement(&quot;div&quot;);</span><br><span class="line">    var title = content[i][0].title;</span><br><span class="line">    var url = content[i][0].url;</span><br><span class="line">    item.innerHTML = &quot;&lt;button class = &apos;title&apos; style = &apos;background: url(&quot; + url + &quot;);&apos;&gt;&lt;span style = &apos;display: inline;&apos;&gt;&lt;strong style = &apos;color:#f0f3f6;&apos; &gt;&quot; + title + &quot;&lt;/strong&gt;&lt;/span&gt;&lt;/button&gt;&quot;;</span><br><span class="line">    conBox.appendChild(item);</span><br><span class="line">    </span><br><span class="line">    for (var j = 1; j &lt; content[i].length ; j++) &#123;</span><br><span class="line">    var _title = content[i][j].title;</span><br><span class="line">    var _url = content[i][j].url;</span><br><span class="line">    var item = document.createElement(&quot;li&quot;);</span><br><span class="line">    item.innerHTML=&quot;&lt;div class = &apos;imgbox&apos; id = &apos;imgbox&apos; style = &apos;height: &quot; + wid + &quot;px;&apos;&gt;&lt;img class = &apos;imgitem&apos; src=&apos;&quot; + _url + &quot;&apos; alt=&apos;&quot; + _url + &quot;&apos;&gt;&lt;/div&gt;&lt;span&gt;&quot; + _title +&quot;&lt;/span&gt;&quot;;</span><br><span class="line">    conBox.appendChild(item);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //json转二维数组</span><br><span class="line">    function json2Array(arr) &#123;</span><br><span class="line">        for (var i=0; i&lt;arr.length; i++) &#123;</span><br><span class="line">            var tmpArr = []</span><br><span class="line">            for (var attr in arr[i]) &#123;</span><br><span class="line">                tmpArr.push(arr[i][attr])</span><br><span class="line">            &#125;</span><br><span class="line">            arr[i] = tmpArr</span><br><span class="line">        &#125;</span><br><span class="line">        return arr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>图像修改的地方为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;title&apos;: &apos;世界之巅&apos;,</span><br><span class="line">&apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nl5540.md.jpg&apos;</span><br></pre></td></tr></table></figure></p><p>图片链接和图像注释</p><p>背景图片修改地方为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background:url(&apos;https://s2.ax1x.com/2019/09/07/nlL4pR.jpg&apos;);</span><br></pre></td></tr></table></figure></p><hr><p><a href="https://me.idealli.com/post/73ad4183.html" target="_blank" rel="noopener">参考文章，小红鸡</a><br><a href="https://www.liaofuzhan.com/posts/2114475547.html" target="_blank" rel="noopener">参考文章，主题美化</a></p><h3 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h3><h3 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h3><h3 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
            <tag> 相册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索生活-消费性快乐与创造性快乐</title>
      <link href="/2019/12/07/%E6%8E%A2%E7%B4%A2%E7%94%9F%E6%B4%BB/"/>
      <url>/2019/12/07/%E6%8E%A2%E7%B4%A2%E7%94%9F%E6%B4%BB/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>探索生活-消费性快乐与创造性快乐<br><a id="more"></a></p><p><a href="https://www.zhihu.com/people/dong-ji-zai-hang-zhou/activities" target="_blank" rel="noopener">作者“动机在杭州”知乎主页</a></p><p>生活的乐趣分两种：消费型快乐和创造型快乐。</p><h2 id="消费型快乐"><a href="#消费型快乐" class="headerlink" title="消费型快乐"></a>消费型快乐</h2><p>消费型快乐中，我们通过占有和消耗资源来获得快乐。这种快乐依赖于外在的物质化的东西。酒色就是典型的消费型快乐。这种快乐有三个特点：</p><p>（1）以满足感官等生物性需要为主。我们所做的，是消费。</p><p>（2）消耗有限资源。为了满足消费型快乐，我们不得不和别人竞争这些资源。要不然权势王位老有这么多人眼红呢？这造成了人际紧张和冲突。</p><p>（3）容易厌倦，尤其是在无限供给的情况下。因为我们的感官系统具有很强的适应性，它只对变化敏感。酒色已经算是不那么容易适应的快乐了，但你觉得后宫佳丽这么多，他整天种猪似的，真有多快乐么？（好吧，有点酸了）</p><p>即使对消费型快乐，也有两种态度：粗放型和精致型。对酒，粗放型是豪饮，精致型是慢品。对色，粗放型是交配，细致型是恋爱。同样的资源，不同的态度创造的乐趣也会很不同。所以没有美酒美人，细细品味，粗茶淡饭未必不能有滋有味。</p><h2 id="创造型快乐"><a href="#创造型快乐" class="headerlink" title="创造型快乐"></a>创造型快乐</h2><p>创造型快乐中，我们不是占有者和消耗者，而是分享者和贡献者。在这种创造型快乐中，我们在创造中充分发挥着自己的优势和美德，努力工作和生活，带给社会和他人美好东西的时候，也体会着一种深刻的成就感：那种我正变得更好的感觉。</p><h3 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h3><h3 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h3><h3 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模糊特征隶属度及图像增强相关</title>
      <link href="/2019/12/07/%E6%A8%A1%E7%B3%8A%E5%A2%9E%E5%BC%BA/"/>
      <url>/2019/12/07/%E6%A8%A1%E7%B3%8A%E5%A2%9E%E5%BC%BA/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>模糊特征隶属度及图像增强相关<br><a id="more"></a></p><h2 id="模糊特征隶属度函数"><a href="#模糊特征隶属度函数" class="headerlink" title="模糊特征隶属度函数"></a>模糊特征隶属度函数</h2><p>若以像素的相对灰度等级作为感兴趣的模糊特征，模糊隶属度函数的定义方式多，在实际问题中，最常用的隶属度函数形式是标准的$S$型函数和$pai$型函数。其中，$S$型函数是一种从0到1的单调增长喊数；$pai$型函数是指“中间高两边低”的函数。从图像处理的角度看，转化为模糊域的灰度值是从低到高的连续过程，$S$型函数符合边缘的过渡变化过程，所以以$S$型函数作为模糊函数的基本变换形式比较合理。</p><p>$S$型函数公式如下：</p><script type="math/tex; mode=display">f(x,a,x) = \frac{1}{1+e^{-a(x-c)}}</script><p>根据参数$a$为正，$S$型隶属度函数的开口朝左<br><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_mohu_haze_1.png" alt></p><h2 id="图像模糊增强边缘提取"><a href="#图像模糊增强边缘提取" class="headerlink" title="图像模糊增强边缘提取"></a>图像模糊增强边缘提取</h2><p>根据灰度级阈值参数$X<em>T$，定义新的隶属函数，式如：<br><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_mohu_haze_2.png" alt><br>当$X</em>{ij}$减小，$\mu_{ij}$减小。</p><p>参数$F_d$为倒数型模糊因子，$F_e$为指数型模糊因子，均为正数，其值影响模糊性，影响曲线形状。</p><h2 id="图像增强"><a href="#图像增强" class="headerlink" title="图像增强"></a>图像增强</h2><h3 id="基于模糊集的图像增强"><a href="#基于模糊集的图像增强" class="headerlink" title="基于模糊集的图像增强"></a>基于模糊集的图像增强</h3><p>基于模糊集的图像增强算法框架如下:<br><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_mohu_haze_3.png" alt><br>模糊域内图像增强实在图像的模糊特征平面上对$\mu<em>{ij}$进行非线性变换，当$\mu</em>{ij}&gt;0.5$时，增大$\mu<em>{ij}$数值，当$\mu</em>{ij}&lt;0.5$时，增大$\mu_{ij}$数值</p><p>如下增强因子<br><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_mohu_haze_7.png" alt></p><p>$T_r$是$T_1$的多次递归调用，有限次递归调用可以增强图像，地带次数够多，会产生二值图像。</p><p>$T$变换图像如下：<br><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_mohu_haze_4.png" alt></p><h3 id="空域图像增强"><a href="#空域图像增强" class="headerlink" title="空域图像增强"></a>空域图像增强</h3><p>模糊域增强图像进行$G^{-1}$逆变换，得到空域增强图像，逆变换公式如下：<br><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_mohu_haze_5.png" alt></p><h2 id="模糊边缘提取效果"><a href="#模糊边缘提取效果" class="headerlink" title="模糊边缘提取效果"></a>模糊边缘提取效果</h2><p>调节模糊参数减少噪声对图像边缘提取的影响，具有一定的抗噪声干扰能力</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_mohu_haze_6.png" alt></p><p>其他相关算法程序可以看看<a href="https://github.com/AomanHao/Matlab-Image-Dehazing-Enhazing" target="_blank" rel="noopener">我的github</a></p><h3 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h3><h3 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h3><h3 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> 图像增强 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>社会心理学效应</title>
      <link href="/2019/12/07/%E7%A4%BE%E4%BC%9A%E5%BF%83%E7%90%86%E5%AD%A6/"/>
      <url>/2019/12/07/%E7%A4%BE%E4%BC%9A%E5%BF%83%E7%90%86%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>社会心理学效应<br><a id="more"></a></p><h2 id="焦点效应与透明度错觉"><a href="#焦点效应与透明度错觉" class="headerlink" title="焦点效应与透明度错觉"></a>焦点效应与透明度错觉</h2><blockquote><p>我们往往把自己看做一切的中心，并且直觉地高估别人对我们的关注程度。</p></blockquote><p>这可能造成对于他人行为的过分解读，而理解这一点可以帮助自己缓解不利情绪，要清楚你所表现出来的尴尬或紧张别人很可能并未察觉。</p><h2 id="预测误差"><a href="#预测误差" class="headerlink" title="预测误差"></a>预测误差</h2><blockquote><p>我们常常低估我们完成一项任务的时间%3B也常常高估情绪事件的持续性影响。</p></blockquote><p>这意味着我们对自我的认识是有局限性的，想要准确预测行为最好参考过去在相似情境下的行为，不能仅凭臆想。我们有较完善的心理免疫机制，使得重大事件带给我们情绪的影响很可能比我们曾以为的要轻微得多。</p><h2 id="自我服务归因"><a href="#自我服务归因" class="headerlink" title="自我服务归因"></a>自我服务归因</h2><blockquote><p>把好的结果归因于自己，而把坏的结果归因于其他。+就像当我们获得成功的时候，我们常会将原因归于我们超乎寻常的才智和品德。但当我们失败时，我们会觉得自己的失误是普遍发生在其他人身上的。</p></blockquote><p>这能够保护人们免受抑郁，帮助缓解压力，并让我们认为自己比真实的更优秀，激发我们努力去自我实现。但过分地高看自己就显得狂妄和傲慢了，而与之所对应的谦卑，并不是看轻自己，而更像是不太在意自己，一方面让人们为自己的专长而欣喜，另一方面也真诚地认可他人的专长。</p><h2 id="自我妨碍"><a href="#自我妨碍" class="headerlink" title="自我妨碍"></a>自我妨碍</h2><p>我们会通过设置障碍来阻挠自己获得成功。这个行为看上去是自己拆自己的台，但其实自我妨碍并不是为了破坏自我而是保护自我。</p><p>因为害怕失败，我们可能在任务刚开始时不好好干，以此不让自己产生过高的期望。因为害怕失败，我们在关系到自己形象的困难任务中不尽全力。尽全力失败了比因耽搁而失败更令人泄气，如果在重重阻碍下我们竟然成功了，那对自己的信任会更加坚固。而如果失败了也不会因此怀疑自己的天赋和能力，自己的自尊也不会受到损害。</p><h2 id="错觉思维"><a href="#错觉思维" class="headerlink" title="错觉思维"></a>错觉思维</h2><blockquote><p>我们常常在随机事件中找规律，当我们期待发现某种重要联系时，我们很容易将随机事件联系起来，以此来支持自己的信念。</p></blockquote><p>假如我们相信事件相互关联，我们更可能会更注意某些支持性的证据。就像答主高中时每当体育课因为下雨取消就会记忆深刻，那时候我甚至总结出了体育课那天多半会下雨的经验，现在想想体育课和下雨之间当然没什么联系。</p><p>而这种将随机事件建立联系的行为往往容易让我们产生一种控制错觉，认为各种随机事件受我们的影响。这种控制感会让人很爽，但它也能让你沉迷在小概率事件的谜之自信中，比如赌博。</p><h2 id="重构记忆"><a href="#重构记忆" class="headerlink" title="重构记忆"></a>重构记忆</h2><blockquote><p>我们可以轻易地无意识地修正自己的记忆，以使它更适合我们当前的认识。</p></blockquote><p>记忆很多时候不是连续的，为了去填补空白所形成的记忆，很多受到当前感受的影响，已经失去了真实性。积极记忆的建构会美化我们的回忆，就像旅行只有在回味时才是迷人的，过去的幸福时光显得无比纯粹。而消极记忆的构建会导致恶性的循环，对于婚姻已经变质的人来说，他们记忆中的婚姻从一开始就很糟糕，即使事实其实并非如此。</p><h2 id="安全型自尊"><a href="#安全型自尊" class="headerlink" title="安全型自尊"></a>安全型自尊</h2><blockquote><p>是指不因为外在(例如成绩、长相、金钱和其他的赞美），而是因为自己的内在特质（如个人美德）而感觉良好。</p></blockquote><p>验表明，安全型自尊的人更容易处于健康的状态，而与安全型自尊的人相比，将自尊主要依赖在外部的人的自我价值感更脆弱，他们会经历更多的压力、愤怒、人际关系问题、酗酒以及饮食障碍。</p><p>把自我感觉良好做作为自己的目标，便不能敞开心扉接受批评，试图通过漂亮、富有或受人欢迎来寻求自尊的人，更可能对真正提升生活质量的东西视而不见。</p><p>所以自我关注少一点，生活愉悦多一些。</p><hr><h3 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h3><h3 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h3><h3 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客Next主题文章置顶相关</title>
      <link href="/2019/11/23/hexo_ArticleTop/"/>
      <url>/2019/11/23/hexo_ArticleTop/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Hexo博客Next主题文章置顶相关<br><a id="more"></a><br>我需要写一些文章做推荐相关，需要文章置顶功能<br><a href="http://www.aomanhao.top/">博客效果</a></p><h2 id="置顶方法配置"><a href="#置顶方法配置" class="headerlink" title="置顶方法配置"></a>置顶方法配置</h2><h3 id="一、修改库文件"><a href="#一、修改库文件" class="headerlink" title="一、修改库文件"></a>一、修改库文件</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在Hexo生成首页HTML时，将top值高的文章排在前面，达到置顶功能。</p><h4 id="修改方法"><a href="#修改方法" class="headerlink" title="修改方法"></a>修改方法</h4><p>修改<code>Hexo</code>文件夹下的<code>node_modules/hexo-generator-index/lib/generator.js</code>，在生成文章之前进行文章top值排序。</p><p>需添加的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">posts.data = posts.data.sort(function(a, b) &#123;</span><br><span class="line">    if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义</span><br><span class="line">        if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排</span><br><span class="line">        else return b.top - a.top; // 否则按照top值降序排</span><br><span class="line">    &#125;</span><br><span class="line">    else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else return b.date - a.date; // 都没定义按照文章日期降序排</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>其中涉及Javascript的比较函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmp(var a, var b) &#123;</span><br><span class="line">    return  a - b; // 升序，降序的话就 b - a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改完成后，只需要在front-matter中设置需要置顶文章的top值，将会根据top值大小来选择置顶顺序top值越大越靠前。需要注意的是，这个文件不是主题的一部分，也不是Git管理的，备份的时候比较容易忽略。</p><h4 id="修改内容"><a href="#修改内容" class="headerlink" title="修改内容"></a>修改内容</h4><p>以下是最终的<code>generator.js</code>内容，可以直接复制替换<code>node_modules/hexo-generator-index/lib/generator.js</code>的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">var pagination = require(&apos;hexo-pagination&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = function(locals) &#123;</span><br><span class="line">  var config = this.config;</span><br><span class="line">  var posts = locals.posts.sort(config.index_generator.order_by);</span><br><span class="line"></span><br><span class="line">  posts.data = posts.data.sort(function(a, b) &#123;</span><br><span class="line">      if(a.top &amp;&amp; b.top) &#123;</span><br><span class="line">          if(a.top == b.top) return b.date - a.date;</span><br><span class="line">          else return b.top - a.top;</span><br><span class="line">      &#125;</span><br><span class="line">      else if(a.top &amp;&amp; !b.top) &#123;</span><br><span class="line">          return -1;</span><br><span class="line">      &#125;</span><br><span class="line">      else if(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">          return 1;</span><br><span class="line">      &#125;</span><br><span class="line">      else return b.date - a.date;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  var paginationDir = config.pagination_dir || &apos;page&apos;;</span><br><span class="line"></span><br><span class="line">  return pagination(&apos;&apos;, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [&apos;index&apos;, &apos;archive&apos;],</span><br><span class="line">    format: paginationDir + &apos;/%d/&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="二、插件配置"><a href="#二、插件配置" class="headerlink" title="二、插件配置"></a>二、插件配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm uninstall hexo-generator-index --save</span><br><span class="line">$ npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure><h2 id="置顶文章配置"><a href="#置顶文章配置" class="headerlink" title="置顶文章配置"></a>置顶文章配置</h2><p>然后在需要置顶的文章的Front-matter中加上<code>top: true</code>或者top数字<code>top: 1</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 置顶</span><br><span class="line">date: 2019-09-09 09:09:09</span><br><span class="line">top: true</span><br><span class="line">top: 1</span><br></pre></td></tr></table></figure><p>按照数字大小依次往下置顶排序</p><h2 id="置顶标志"><a href="#置顶标志" class="headerlink" title="置顶标志"></a>置顶标志</h2><p>置顶的文章会显示在主页最上面，没有明确的置顶标志，我们需要键入置顶标志。</p><h3 id="设置置顶标志"><a href="#设置置顶标志" class="headerlink" title="设置置顶标志"></a>设置置顶标志</h3><p>打开：<code>/blog/themes/next/layout/_macro</code>目录下的<code>post.swig</code>文件，定位到<code>&lt;div class=&quot;post-meta&quot;&gt;</code>标签下，插入如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt;</span><br><span class="line">  &lt;font color=7D26CD&gt;置顶&lt;/font&gt;</span><br><span class="line">  &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>效果展示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        &lt;div class=&quot;post-meta&quot;&gt;</span><br><span class="line">          &lt;span class=&quot;post-time&quot;&gt;</span><br><span class="line">在此之下插入代码，包含在 span块内        </span><br><span class="line">          &#123;% if post.top %&#125;</span><br><span class="line">            &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt;</span><br><span class="line">            &lt;font color=7D26CD&gt;置顶&lt;/font&gt;</span><br><span class="line">            &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">          &#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><hr><p><a href="https://www.jianshu.com/p/42a4efcdf8d7" target="_blank" rel="noopener">参考文章1</a><br><a href="https://blog.csdn.net/qq_30930805/article/details/88890124" target="_blank" rel="noopener">参考文章2</a></p><h3 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h3><h3 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h3><h3 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git插件报错，Appears to be a git repo or submodule</title>
      <link href="/2019/11/21/git_error_part/"/>
      <url>/2019/11/21/git_error_part/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Git插件报错，Appears to be a git repo or submodule<br><a id="more"></a></p><p>Hexo博客需要引入第三方插件，不少包作者误把包项目得<code>.git</code>文件上传到<code>github</code>，或者在插件的<code>github</code>路径下直接下载插件文件夹，结果是插件内含有<code>.git</code>文件，导致下载别的<code>npm</code>包时报错<code>npm err:</code></p><h3 id="报错信息如下："><a href="#报错信息如下：" class="headerlink" title="报错信息如下："></a>报错信息如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-index-pin-top --save                                            npm ERR! path D:\GitHub\AomanHao.github.io\node_modules\hexo-symbols-count-time</span><br><span class="line">npm ERR! code EISGIT</span><br><span class="line">npm ERR! git D:\GitHub\AomanHao.github.io\node_modules\hexo-symbols-count-time: Appears to be a git repo or submodule.</span><br><span class="line">npm ERR! git     D:\GitHub\AomanHao.github.io\node_modules\hexo-symbols-count-time</span><br><span class="line">npm ERR! git Refusing to remove it. Update manually,</span><br><span class="line">npm ERR! git or move it out of the way first.</span><br><span class="line"></span><br><span class="line">npm ERR! A complete log of this run can be found in:</span><br><span class="line">npm ERR!     C:\Users\10143\AppData\Roaming\npm-cache\_logs\2019-11-22T12_30_49_238Z-debug.log</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.nos-eastchina1.126.net/blog/git_error_repo.png" alt></p><h3 id="解决方式："><a href="#解决方式：" class="headerlink" title="解决方式："></a>解决方式：</h3><p>进入到报错的<code>node_modules\hexo-symbols-count-time</code>目录去把.git目录删除就可以了</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/git_error_repo1.png" alt></p><hr><h3 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h3><h3 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h3><h3 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>野居青年-三个男人的诗和远方</title>
      <link href="/2019/11/21/Wild_Youth/"/>
      <url>/2019/11/21/Wild_Youth/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>野居青年-三个男人的诗和远方<br><a id="more"></a><br>简介： 远离城市，隐居深山，三个男人的诗和远方。<br>野居青年主要由 钟洋、马培源、王淦这三人组成，三人都是毕业于西安建筑科技大学美术系的高材生，希望同龄人能见证他们实实在在的乡野生活。</p><p><a href="https://space.bilibili.com/176756724?from=search&amp;seid=2689578322465416287" target="_blank" rel="noopener">野居青年的B站主页</a></p><h3 id="喜欢的一集"><a href="#喜欢的一集" class="headerlink" title="喜欢的一集"></a>喜欢的一集</h3><p><a href="https://www.bilibili.com/video/av14875394" target="_blank" rel="noopener">秋名山一集</a></p><iframe src="//player.bilibili.com/player.html?aid=14875394&cid=24237231&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>想来都已经是2年前的作品了，时光过得真快啊</p><h3 id="喜欢的理由"><a href="#喜欢的理由" class="headerlink" title="喜欢的理由"></a>喜欢的理由</h3><p>有人说：他们的视频内容很简单，一狗两鸡三餐四季，还有画画写生，很日常的生活。</p><p>有人说：拍的视频不像同类型博主那样精细，但是，会让你觉得很真实。没有夸张的滤镜，简简单单的配乐，不过剪辑是真的好。<br>反正视频我看着是很舒服，对他们这种生活方式也很是向往，也很佩服。</p><p>我喜欢他们拍摄视频的创意和编排，喜欢他们的动手能力，自己去完善和实现自己的想法与创意，剪辑的手法与风格也渐渐成熟，希望他们越来越好，越来越火，带来更多的创意视频。</p><hr><h3 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h3><h3 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h3><h3 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客Next主题添加粒子时钟特效</title>
      <link href="/2019/11/04/hexo_clock/"/>
      <url>/2019/11/04/hexo_clock/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Hexo博客添加粒子时钟特效<br><a id="more"></a><br>博客应用canvas粒子时钟的操作步骤：</p><p>在<code>\themes\next\layout\_custom\</code>目录下，新建<code>clock.swig</code>文件，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;&quot;&gt;</span><br><span class="line">  &lt;canvas id=&quot;canvas&quot; style=&quot;width:60%;&quot;&gt;当前浏览器不支持canvas，请更换浏览器后再试&lt;/canvas&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">(function()&#123;</span><br><span class="line"></span><br><span class="line">   var digit=</span><br><span class="line">    [</span><br><span class="line">        [</span><br><span class="line">            [0,0,1,1,1,0,0],</span><br><span class="line">            [0,1,1,0,1,1,0],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [0,1,1,0,1,1,0],</span><br><span class="line">            [0,0,1,1,1,0,0]</span><br><span class="line">        ],//0</span><br><span class="line">        [</span><br><span class="line">            [0,0,0,1,1,0,0],</span><br><span class="line">            [0,1,1,1,1,0,0],</span><br><span class="line">            [0,0,0,1,1,0,0],</span><br><span class="line">            [0,0,0,1,1,0,0],</span><br><span class="line">            [0,0,0,1,1,0,0],</span><br><span class="line">            [0,0,0,1,1,0,0],</span><br><span class="line">            [0,0,0,1,1,0,0],</span><br><span class="line">            [0,0,0,1,1,0,0],</span><br><span class="line">            [0,0,0,1,1,0,0],</span><br><span class="line">            [1,1,1,1,1,1,1]</span><br><span class="line">        ],//1</span><br><span class="line">        [</span><br><span class="line">            [0,1,1,1,1,1,0],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [0,0,0,0,0,1,1],</span><br><span class="line">            [0,0,0,0,1,1,0],</span><br><span class="line">            [0,0,0,1,1,0,0],</span><br><span class="line">            [0,0,1,1,0,0,0],</span><br><span class="line">            [0,1,1,0,0,0,0],</span><br><span class="line">            [1,1,0,0,0,0,0],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,1,1,1,1,1]</span><br><span class="line">        ],//2</span><br><span class="line">        [</span><br><span class="line">            [1,1,1,1,1,1,1],</span><br><span class="line">            [0,0,0,0,0,1,1],</span><br><span class="line">            [0,0,0,0,1,1,0],</span><br><span class="line">            [0,0,0,1,1,0,0],</span><br><span class="line">            [0,0,1,1,1,0,0],</span><br><span class="line">            [0,0,0,0,1,1,0],</span><br><span class="line">            [0,0,0,0,0,1,1],</span><br><span class="line">            [0,0,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [0,1,1,1,1,1,0]</span><br><span class="line">        ],//3</span><br><span class="line">        [</span><br><span class="line">            [0,0,0,0,1,1,0],</span><br><span class="line">            [0,0,0,1,1,1,0],</span><br><span class="line">            [0,0,1,1,1,1,0],</span><br><span class="line">            [0,1,1,0,1,1,0],</span><br><span class="line">            [1,1,0,0,1,1,0],</span><br><span class="line">            [1,1,1,1,1,1,1],</span><br><span class="line">            [0,0,0,0,1,1,0],</span><br><span class="line">            [0,0,0,0,1,1,0],</span><br><span class="line">            [0,0,0,0,1,1,0],</span><br><span class="line">            [0,0,0,1,1,1,1]</span><br><span class="line">        ],//4</span><br><span class="line">        [</span><br><span class="line">            [1,1,1,1,1,1,1],</span><br><span class="line">            [1,1,0,0,0,0,0],</span><br><span class="line">            [1,1,0,0,0,0,0],</span><br><span class="line">            [1,1,1,1,1,1,0],</span><br><span class="line">            [0,0,0,0,0,1,1],</span><br><span class="line">            [0,0,0,0,0,1,1],</span><br><span class="line">            [0,0,0,0,0,1,1],</span><br><span class="line">            [0,0,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [0,1,1,1,1,1,0]</span><br><span class="line">        ],//5</span><br><span class="line">        [</span><br><span class="line">            [0,0,0,0,1,1,0],</span><br><span class="line">            [0,0,1,1,0,0,0],</span><br><span class="line">            [0,1,1,0,0,0,0],</span><br><span class="line">            [1,1,0,0,0,0,0],</span><br><span class="line">            [1,1,0,1,1,1,0],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [0,1,1,1,1,1,0]</span><br><span class="line">        ],//6</span><br><span class="line">        [</span><br><span class="line">            [1,1,1,1,1,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [0,0,0,0,1,1,0],</span><br><span class="line">            [0,0,0,0,1,1,0],</span><br><span class="line">            [0,0,0,1,1,0,0],</span><br><span class="line">            [0,0,0,1,1,0,0],</span><br><span class="line">            [0,0,1,1,0,0,0],</span><br><span class="line">            [0,0,1,1,0,0,0],</span><br><span class="line">            [0,0,1,1,0,0,0],</span><br><span class="line">            [0,0,1,1,0,0,0]</span><br><span class="line">        ],//7</span><br><span class="line">        [</span><br><span class="line">            [0,1,1,1,1,1,0],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [0,1,1,1,1,1,0],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [0,1,1,1,1,1,0]</span><br><span class="line">        ],//8</span><br><span class="line">        [</span><br><span class="line">            [0,1,1,1,1,1,0],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [1,1,0,0,0,1,1],</span><br><span class="line">            [0,1,1,1,0,1,1],</span><br><span class="line">            [0,0,0,0,0,1,1],</span><br><span class="line">            [0,0,0,0,0,1,1],</span><br><span class="line">            [0,0,0,0,1,1,0],</span><br><span class="line">            [0,0,0,1,1,0,0],</span><br><span class="line">            [0,1,1,0,0,0,0]</span><br><span class="line">        ],//9</span><br><span class="line">        [</span><br><span class="line">            [0,0,0,0,0,0,0],</span><br><span class="line">            [0,0,1,1,1,0,0],</span><br><span class="line">            [0,0,1,1,1,0,0],</span><br><span class="line">            [0,0,1,1,1,0,0],</span><br><span class="line">            [0,0,0,0,0,0,0],</span><br><span class="line">            [0,0,0,0,0,0,0],</span><br><span class="line">            [0,0,1,1,1,0,0],</span><br><span class="line">            [0,0,1,1,1,0,0],</span><br><span class="line">            [0,0,1,1,1,0,0],</span><br><span class="line">            [0,0,0,0,0,0,0]</span><br><span class="line">        ]//:</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">var canvas = document.getElementById(&apos;canvas&apos;);</span><br><span class="line"></span><br><span class="line">if(canvas.getContext)&#123;</span><br><span class="line">    var cxt = canvas.getContext(&apos;2d&apos;);</span><br><span class="line">    //声明canvas的宽高</span><br><span class="line">    var H = 100,W = 700;</span><br><span class="line">    canvas.height = H;</span><br><span class="line">    canvas.width = W;</span><br><span class="line">    cxt.fillStyle = &apos;#f00&apos;;</span><br><span class="line">    cxt.fillRect(10,10,50,50);</span><br><span class="line"></span><br><span class="line">    //存储时间数据</span><br><span class="line">    var data = [];</span><br><span class="line">    //存储运动的小球</span><br><span class="line">    var balls = [];</span><br><span class="line">    //设置粒子半径</span><br><span class="line">    var R = canvas.height/20-1;</span><br><span class="line">    (function()&#123;</span><br><span class="line">        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());</span><br><span class="line">        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成</span><br><span class="line">        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);</span><br><span class="line">    &#125;)();</span><br><span class="line"></span><br><span class="line">    /*生成点阵数字*/</span><br><span class="line">    function renderDigit(index,num)&#123;</span><br><span class="line">        for(var i = 0; i &lt; digit[num].length; i++)&#123;</span><br><span class="line">            for(var j = 0; j &lt; digit[num][i].length; j++)&#123;</span><br><span class="line">                if(digit[num][i][j] == 1)&#123;</span><br><span class="line">                    cxt.beginPath();</span><br><span class="line">                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);</span><br><span class="line">                    cxt.closePath();</span><br><span class="line">                    cxt.fill();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*更新时钟*/</span><br><span class="line">    function updateDigitTime()&#123;</span><br><span class="line">        var changeNumArray = [];</span><br><span class="line">        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());</span><br><span class="line">        var NewData = [];</span><br><span class="line">        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);</span><br><span class="line">        for(var i = data.length-1; i &gt;=0 ; i--)&#123;</span><br><span class="line">            //时间发生变化</span><br><span class="line">            if(NewData[i] !== data[i])&#123;</span><br><span class="line">                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中</span><br><span class="line">                changeNumArray.push(i+&apos;_&apos;+(Number(data[i])+1)%10);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //增加小球</span><br><span class="line">        for(var i = 0; i&lt; changeNumArray.length; i++)&#123;</span><br><span class="line">            addBalls.apply(this,changeNumArray[i].split(&apos;_&apos;));</span><br><span class="line">        &#125;</span><br><span class="line">        data = NewData.concat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*更新小球状态*/</span><br><span class="line">    function updateBalls()&#123;</span><br><span class="line">        for(var i = 0; i &lt; balls.length; i++)&#123;</span><br><span class="line">            balls[i].stepY += balls[i].disY;</span><br><span class="line">            balls[i].x += balls[i].stepX;</span><br><span class="line">            balls[i].y += balls[i].stepY;</span><br><span class="line">            if(balls[i].x &gt; W + R || balls[i].y &gt; H + R)&#123;</span><br><span class="line">                balls.splice(i,1);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*增加要运动的小球*/</span><br><span class="line">    function addBalls(index,num)&#123;</span><br><span class="line">        var numArray = [1,2,3];</span><br><span class="line">        var colorArray =  [&quot;#3BE&quot;,&quot;#09C&quot;,&quot;#A6C&quot;,&quot;#93C&quot;,&quot;#9C0&quot;,&quot;#690&quot;,&quot;#FB3&quot;,&quot;#F80&quot;,&quot;#F44&quot;,&quot;#C00&quot;];</span><br><span class="line">        for(var i = 0; i &lt; digit[num].length; i++)&#123;</span><br><span class="line">            for(var j = 0; j &lt; digit[num][i].length; j++)&#123;</span><br><span class="line">                if(digit[num][i][j] == 1)&#123;</span><br><span class="line">                    var ball = &#123;</span><br><span class="line">                        x:14*(R+2)*index + j*2*(R+1)+(R+1),</span><br><span class="line">                        y:i*2*(R+1)+(R+1),</span><br><span class="line">                        stepX:Math.floor(Math.random() * 4 -2),</span><br><span class="line">                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],</span><br><span class="line">                        color:colorArray[Math.floor(Math.random()*colorArray.length)],</span><br><span class="line">                        disY:1</span><br><span class="line">                    &#125;;</span><br><span class="line">                    balls.push(ball);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*渲染*/</span><br><span class="line">    function render()&#123;</span><br><span class="line">        //重置画布宽度，达到清空画布的效果</span><br><span class="line">        canvas.height = 100;</span><br><span class="line">        //渲染时钟</span><br><span class="line">        for(var i = 0; i &lt; data.length; i++)&#123;</span><br><span class="line">            renderDigit(i,data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        //渲染小球</span><br><span class="line">        for(var i = 0; i &lt; balls.length; i++)&#123;</span><br><span class="line">            cxt.beginPath();</span><br><span class="line">            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);</span><br><span class="line">            cxt.fillStyle = balls[i].color;</span><br><span class="line">            cxt.closePath();</span><br><span class="line">            cxt.fill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clearInterval(oTimer);</span><br><span class="line">    var oTimer = setInterval(function()&#123;</span><br><span class="line">        //更新时钟</span><br><span class="line">        updateDigitTime();</span><br><span class="line">        //更新小球状态</span><br><span class="line">        updateBalls();</span><br><span class="line">        //渲染</span><br><span class="line">        render();</span><br><span class="line">    &#125;,50);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h3 id="引用代码"><a href="#引用代码" class="headerlink" title="引用代码"></a>引用代码</h3><p>直接引用或者通过配置文件配置，二选一</p><h4 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h4><p>在<code>博客目录\themes\next\layout\_macro\sidebar.swig</code>尾部中引入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include &apos;../_custom/clock.swig&apos; %&#125;</span><br></pre></td></tr></table></figure><p>示意图如下：<br><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_clock.png" alt></p><blockquote><p>注：代码块要放置在<code>sider-inner</code>的<code>div</code>块中，放在<code>div</code>块的位置决定时钟样式的展示位置。我选择放置在尾部，看着效果好点。</p></blockquote><h3 id="通过配置文件配置"><a href="#通过配置文件配置" class="headerlink" title="通过配置文件配置"></a>通过配置文件配置</h3><p>1、在<code>博客目录\themes\next\layout\_macro\sidebar.swig</code>尾部中引入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.diy_time.clock %&#125;</span><br><span class="line">  &lt;!-- canvas粒子时钟 --&gt;</span><br><span class="line">  &#123;% include &apos;../_custom/clock.swig&apos; %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>示意图如下：<br><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_clock_if.png" alt></p><blockquote><p>注：代码块要放置在<code>sider-inner</code>的<code>div</code>块中，放在<code>div</code>块的位置决定时钟样式的展示位置。</p></blockquote><p>2、在主题的配置文件中加入应用代码，配置文件位置是<code>博客目录\themes\next\_config.yml</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 侧栏粒子时钟</span><br><span class="line">diy_time:</span><br><span class="line">  runtime: true </span><br><span class="line">  clock: true # 粒子时钟</span><br></pre></td></tr></table></figure></p><h3 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h3><h3 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h3><h3 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像格式及Matlab的格式转换</title>
      <link href="/2019/10/21/img_%E6%A0%BC%E5%BC%8F_matlab/"/>
      <url>/2019/10/21/img_%E6%A0%BC%E5%BC%8F_matlab/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>图像格式及Matlab的格式转换<br><a id="more"></a></p><h2 id="1-matlab图像保存说明"><a href="#1-matlab图像保存说明" class="headerlink" title="1. matlab图像保存说明"></a>1. matlab图像保存说明</h2><p>　　matlab中读取图片后保存的数据是uint8类型(8位无符号整数，即1个字节)，以此方式存储的图像称作8位图像，好处相比较默认matlab数据类型双精度浮点double（64位，8个字节），自然可以节省很大一部分存储空间。<br>　　详细来说imread把灰度图像存入一个8位矩阵，当为RGB图像时，就存入8位RGB矩阵中。例如，彩色图像像素大小是400<em>300( 高 </em> 宽 )，则保存的数据矩阵为400<em>300</em>3，其中每个颜色通道值是处于0~255之间。<br>但是虽然matlab中读入图像的数据类型是uint8，而在图像矩阵运算的时候，使用的数据类型却是double类型。一是为了保证精度，二是因为如果不转换，在对uint8进行加减时会产生溢出，可能提示的错误为：　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function ‘*’ is not defined for values of class ‘uint8’</span><br></pre></td></tr></table></figure></p><p>　　1个字节无符号整型最大只能存储数据为255，对图片的操作所以很容易溢出。</p><h2 id="2-matlab图像类型转换"><a href="#2-matlab图像类型转换" class="headerlink" title="2. matlab图像类型转换"></a>2. matlab图像类型转换</h2><p>　　matlab读入图像的数据是<code>uint8</code>，而matlab中数值一般采用double型（64位）存储和运算。所以要先将图像转为double格式的才能运算，区别如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = imread(&apos;./1.jpg&apos;); % 读入是unit8型(0~255)数据I1  = im2double(img);    % 把图像转换成double精度类型（0~1）I2  = double(img)/255;   % uint8转换成double,作用同im2double</span><br></pre></td></tr></table></figure></p><p>　　这里补充说明一下，im2double( )和double( )的区别。double( img)就是简单的数据类型转换，将无符号整型转换为双精度浮点型double，但是数据大小没有变化，原本数据是0~255之间，转化后还是0~255。例如原来是255，那么转换后为255.0，小数位0个数是由double数据长度决定，实际数据大小还是255，只不过这个255已经是double类型空间存储了，再增加不会发生溢出情况。而im2double(img)则不仅仅是将uint8转换到double类型，而且把数据大小从0~255映射到0~1区间。<br>　　另外需要补充说明下面这种情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = imread(&apos;./1.jpg&apos;);I1  = double(img);I2  = im2double(I2); % I2数据依然是0~255，并不是0~1，即I1=I2</span><br></pre></td></tr></table></figure></p><p>　　因为I1已经是double类型，imdouble不会对double类型数据0~255映射到区间0~1，所以上面im2double操作没有任何作用，I1和I2相等。<br>　　总结如下：函数im2double将输入转换成double类型。如果输入是uint8、unit16 或者是二值的logical类型，则函数im2double 将其值归一化到0～1之间，当然就是double类型的了。如果输入本身就是double类型，输出还是double类型，并不进行映射。<br>　　如果已经是double类型的数据需要映射，则进行下面操作即可：　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I2 = I1/255;</span><br></pre></td></tr></table></figure></p><h2 id="3-matlab图像显示imshow类型问题"><a href="#3-matlab图像显示imshow类型问题" class="headerlink" title="3. matlab图像显示imshow类型问题"></a>3. matlab图像显示imshow类型问题</h2><p>　　在matlab处理完数据好，我们希望显示或者imwrite写入图片时候，需要注意。如果直接对double之间的数据矩阵I运行imshow(I)，我们会发现有时候显示的是一个白色的图像。<br>　　这是因为imshow()显示图像时对double型是认为在0~1范围内，即大于1时都是显示为白色，而imshow显示uint8型时是0~255范围。所以对double类型的图像显示的时候，要么归一化到0~1之间，要么将double类型的0~255数据转为uint8类型。解决方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imshow(I/255);    % 将图像矩阵转化到0-1之间imshow(I,[]);     % 自动调整数据的范围以便于显示inshow(uint8(I)); % 转成uint8</span><br></pre></td></tr></table></figure></p><h2 id="4-uint和double数据转换的深入说明"><a href="#4-uint和double数据转换的深入说明" class="headerlink" title="4. uint和double数据转换的深入说明"></a>4. uint和double数据转换的深入说明</h2><p>　　double和uint8、uint16之间数据转换有下面的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">im2double(); % 将图像数组转换成double精度类型</span><br><span class="line">im2uint8();  % 将图像数组转换成unit8类型 </span><br><span class="line">im2uint16(); % 将图像数组转换成unit16类型</span><br></pre></td></tr></table></figure></p><p>　　当然，当图像数据是double类型的0~1之间，下面两者操作是等价的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I1=im2uint8(I);</span><br><span class="line">I2=uint8(round(I*255));</span><br></pre></td></tr></table></figure></p><p>　　但是matlab默认double类型图片数据是位于0~1之间的，而uint8是位于0~255。所以如果矩阵数据图像是double类型（0~1之间）可直接im2uint8，这样不仅完成数据类型转换，而且将0~1之间映射为了0~255之间的数据。<br>但是如果图像矩阵数据是double类型的0~255，直接im2uint8转换的话，matlab会将大于1的数据都转换为255，0~1之间的数据才会映射到0~255之间整型的数据。例如下面程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img64 = [1,2,3,4];I8    = im2uint8(img64); % I8结果为[255255255255]</span><br></pre></td></tr></table></figure></p><h2 id="5-mat2gray-和im2double-区别"><a href="#5-mat2gray-和im2double-区别" class="headerlink" title="5. mat2gray()和im2double()区别"></a>5. mat2gray()和im2double()区别</h2><p>　　这两个如果都是对uint8数据操作，区别就在于前者是归一化操作，归一化后也在0~1之间，自然结果也是double类型，后者是将数据从0~255映射到0~1。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I  = uint8([1,1,2,3]);</span><br><span class="line">I1 = mat2gray(I);  % 归一化，I1结果是double型[0,0,0.5,1]</span><br><span class="line">I2 = im2double(I); % 映射化，I2结果是double型[0.0039,0.0039,0.0078,0.0118]</span><br></pre></td></tr></table></figure><p>　　可以看出，虽然两者都是一种归一化，im2double只不过最大值永远是常数255，最小值永远是0，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I−0.0255.0−0.0</span><br></pre></td></tr></table></figure></p><p>　　而mat2gray最大值和最小值都是当前矩阵中最大最小的值，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I−min(I)max(I)−min(I)</span><br></pre></td></tr></table></figure></p><p>　　另外补充一个函数，mat2str()是将数型转换为字符串类型，一般在批量处理图片，给保存图片格式的名称中有作用，这样就不需要格式化sprintf操作了，非常方便。</p><p>资源来源：<a href="https://www.cnblogs.com/psztswcbyy/p/7489516.html" target="_blank" rel="noopener">https://www.cnblogs.com/psztswcbyy/p/7489516.html</a></p><hr><h3 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h3><h3 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h3><h3 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Source Insight 4.0 破解和使用</title>
      <link href="/2019/10/21/SouceInsight4/"/>
      <url>/2019/10/21/SouceInsight4/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Source Insight 4.0 破解和使用<br><a id="more"></a><br>转自博客：<a href="https://blog.csdn.net/xiaoxu2050/article/details/82752799" target="_blank" rel="noopener">https://blog.csdn.net/xiaoxu2050/article/details/82752799</a></p><h2 id="Source-Insight-4-0-破解安装"><a href="#Source-Insight-4-0-破解安装" class="headerlink" title="Source Insight 4.0 破解安装"></a>Source Insight 4.0 破解安装</h2><p>1.从官网下载source insight4.0版本(不用下载，在后面已经把所有需要的文件都准备好了);</p><p>2.安装source insightt4.0;</p><p>3.使用下载好的sourceinsight4.exe替换安装在program file(x86)目录下的sourceinsight4.exe;</p><p>4.启动sourceinsight，导入下载好的后缀名为.lic的license文件</p><p>所有需要用到的文件已打包，请自取：</p><p>链接：<a href="https://pan.baidu.com/s/1dF729UT" target="_blank" rel="noopener">https://pan.baidu.com/s/1dF729UT</a> 密码：9nx6</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_1.png" alt></p><h2 id="安装卸载附录："><a href="#安装卸载附录：" class="headerlink" title="安装卸载附录："></a>安装卸载附录：</h2><p>如果安装或者安装后提示有问题，请进行完全卸载后，再重装一遍即可。<br>完全卸载方式：</p><h3 id="1、清除注册表信息："><a href="#1、清除注册表信息：" class="headerlink" title="1、清除注册表信息："></a>1、清除注册表信息：</h3><p>“win ”+ R  或者  “开始” -&gt; “运行”，输入“regedit”，回车；<br>在弹出的注册表管理器中，选择“编辑”-&gt; “查找”-&gt;“source insight”，或按照下述路径展开：HKEY_CURRENT_USER -&gt; software -&gt; Source Dynamics -&gt; Source Insight;<br>将该项下面的source insight 需要清除的对应版本项目选中，右键“删除“。</p><h3 id="2、删除全局配置信息："><a href="#2、删除全局配置信息：" class="headerlink" title="2、删除全局配置信息："></a>2、删除全局配置信息：</h3><p>在 ./user/document/source insight 3.0/4.0 下的所有文件及该文件夹<br> 注意此处的路径可能不同  也可能是:“库”-&gt;“用户”(也可能是你的名字) -&gt; 文档 -&gt; source insight3.0/4.0<br> 或者  你上次安装的时候所指定的其他位置<br>Source Insight4.0软件打开C程序中文注释乱码的解决方法<br>更改Options—Preference—Files中最下面的Default encoding中程序默认的UTF-8改为System Default（windows ANSI）。<br>附录：source insight 安装序列号（如果以上没用）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SI3US-751793-52670</span><br><span class="line">SI3US-205035-36448</span><br><span class="line">SI3US-466908-65897</span><br><span class="line">SI3US-368932-59383</span><br><span class="line">SI3US-065458-30661</span><br><span class="line">SI3US-759512-70207</span><br></pre></td></tr></table></figure></p><p>SourceInsight4.0的使用<br>创建一个SI工程管理代码<br>整体思路：告诉SI要解析哪些文件 -&gt; 告诉SI这些文件在哪 -&gt; 告诉SI文件选好了，解析它吧 。<br>首先，这里演示的是C代码工程，其它编程语言也差不多。<br>在解析C代码工程时，你可能希望SI连 .CC 和 .S结尾的文件也一同解析。那么点击 option -&gt; File Type Options -&gt; C/C++ Source File，我们在右边添加 <em>.S;</em>.cc。这里 *号是通配符，用英文;号隔开。<br>代码类型设置</p><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><p>选择我们的代码工程位置，比如我选择了 D:\linux-to-windows-share\target 这个目录，我的工程代码全在这个目录下（注意不是SI的工程目录），然后点击 OK 继续。</p><h3 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h3><p>点击Project-&gt;New Project。</p><p>点击Browse，选择你的源代码所在目录。</p><p>给新建的Source Insight工程取个名字，然后点击OK。</p><p>弹出窗口点击OK，然后点击Add Tree，添加目录结构下所有文件到工程。最后点击Close，项目就建立完成。</p><p>SynchronizeFile，双击Project Files窗口中的文件，即可打开文件，进行阅读或编辑。</p><h3 id="新建一个项目"><a href="#新建一个项目" class="headerlink" title="新建一个项目"></a>新建一个项目</h3><p>快捷键Alt+Shift+N可以打开新建项目对话框，然后根据提示填好项目存储位置，源文件位置等，然后会出现添加删除项目文件对话框，选中自己想要编辑和浏览的文件添加即可，这样就建好了一个项目。</p><h3 id="添加和删除项目文件"><a href="#添加和删除项目文件" class="headerlink" title="添加和删除项目文件"></a>添加和删除项目文件</h3><p>（1）在添加删除文件前，可以先设置文件过滤器，菜单栏-选项-文档选项，就可以看到文件过滤器了，怎么设置应该是一目了然的。</p><p>（2）菜单栏-项目-添加或删除文件，即可打开添加和删除项目文件对话框。</p><h3 id="同步文件-SynchronizeFile"><a href="#同步文件-SynchronizeFile" class="headerlink" title="同步文件 SynchronizeFile"></a>同步文件 SynchronizeFile</h3><p>快捷键Alt+Shift+S可以同步文件，同步文件后就可以自动找到源代码之间的依赖关系了（如：可以自动找到调用某个函数或变量的位置）</p><h3 id="项目报告"><a href="#项目报告" class="headerlink" title="项目报告"></a>项目报告</h3><p>菜单栏-项目-项目报告，获取当前项目的文件个数，代码行数等。</p><h3 id="重建项目"><a href="#重建项目" class="headerlink" title="重建项目"></a>重建项目</h3><p>菜单栏-项目-重建项目，重新同步代码依赖关系。<br>具体操作如下：<br>依次点击 Project -&gt; new project ，弹出对话框分别是SI的 工程名字 和 工程目录，如：工程名QCA4020，目录名SI_Proj。</p><h2 id="选择代码工程目录"><a href="#选择代码工程目录" class="headerlink" title="选择代码工程目录"></a>选择代码工程目录</h2><p>这一步，进一步确定你要添加哪些代码到你的SI工程中，如果你要添加 target 这个目录下的全部，就选中它，点击 Add Tree 就好。后面你要是增删文件，也在这里。添加好了，就点击 Close 吧。</p><p>添加以后，解析它吧。这一步会把代码加到SI数据库中，使得后面查找、关联更快。解析过程有点慢，耐心等待吧。点击Project -&gt; SynchronizeFile， 并选择1，3，4打钩（勾上会强制添加和解析），点击 start 。</p><h3 id="解析代码"><a href="#解析代码" class="headerlink" title="解析代码"></a>解析代码</h3><p>如果解析完了，你突然发现忘记添加某些文件了，或者本来不用添加的你却添加了。不要担心，点击 Project -&gt; Add and Remove Project Files，再次进行添加删除，然后 再进行解析SynchronizeFile 操作才会生效。</p><h3 id="添加和删除解析文件"><a href="#添加和删除解析文件" class="headerlink" title="添加和删除解析文件"></a>添加和删除解析文件</h3><p>解析完，点一下那个书本一样的图标（Project Sympol List），尝试一下，你的代码就出来：</p><h3 id="SourceInsight-的窗口设置"><a href="#SourceInsight-的窗口设置" class="headerlink" title="SourceInsight 的窗口设置"></a>SourceInsight 的窗口设置</h3><p>这里对SourceInsight进行一些设置，你完全可以不用设置，默认就好。</p><p>选择主题：Option -&gt; Visual Theme （选择你喜欢的）。<br>设置字体大小：Option -&gt; Preference -&gt; Colors &amp; Fonts -&gt; Style -&gt; size 。</p><p>显示文件全路径：Option -&gt; Preference -&gt; Display ， 去掉 trim long path names with ellipes。</p><p>添加配置文件（别人配置好的）：Option -&gt; Load configuration（前提是你下载了别人的配置文件）。</p><p>显示行号：view -&gt; Line Numbers 。</p><h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><p>如果要 搜索字符位置，选中该字体，点击 工具栏的R图标 或者 Ctrl + F。</p><p>在Project Window（默认右边）的对话框中输入文件名，可以搜索到文件。</p><p> 没有正确显示在右边的file list列表框需要在View菜单下找到Panels级联菜单下的Project Windows，把它勾选上。</p><h3 id="Source-Insight4-0软件打开C程序中文注释乱码的解决方法"><a href="#Source-Insight4-0软件打开C程序中文注释乱码的解决方法" class="headerlink" title="Source Insight4.0软件打开C程序中文注释乱码的解决方法"></a>Source Insight4.0软件打开C程序中文注释乱码的解决方法</h3><p>更改Options—Preference—Files中最下面的Default encoding中程序默认的UTF-8改为System Default（windows ANSI）。</p><h3 id="高亮显示选中的单词"><a href="#高亮显示选中的单词" class="headerlink" title="高亮显示选中的单词"></a>高亮显示选中的单词</h3><p>高亮显示：F8。取消高亮：再按一次F8。<br>效果如下：</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_2.jpg" alt></p><p>打开Source Insight相关窗口</p><p>（1）打开Symbol Window。<br>View-&gt;Symbol Window。快捷键：Alt+F8。</p><p>（2）打开Context Window。<br>View-&gt;Panels-&gt;Context Window。</p><p>（3）打开Relation Window。<br>View-&gt;Panels-&gt;Relation Window<br>Source Insight窗口布局我一般设置如下：</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_3.jpg" alt></p><h3 id="窗口字体大小与样式设置步骤："><a href="#窗口字体大小与样式设置步骤：" class="headerlink" title="窗口字体大小与样式设置步骤："></a>窗口字体大小与样式设置步骤：</h3><p>Preferences-&gt;Colors&amp;Fonts-&gt;Set Panel Fonts and Colors。</p><p>这里设置只对上面窗口1：符号窗口（Symbol Window）和窗口4：项目文件夹浏览窗口（Project Folder Browser）有效，另外两个窗口无效。</p><p>窗口2：上下文窗口（Context Window）字体大小设置如下：<br>在面板内右击-&gt;Context Window Options-&gt;scaling。</p><p>窗口3：引用关系窗口（Relation Window）字体大小设置如下：</p><p>窗口内右击-&gt;Relation Window Options-&gt;Font。<br>Source Insight的7种窗口的使用。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_4.png" alt></p><h3 id="1、文档窗口"><a href="#1、文档窗口" class="headerlink" title="1、文档窗口"></a>1、文档窗口</h3><p>（1）、修改窗口颜色属性：菜单栏-选项-参数-颜色标签，可以修改背景颜色、默认字体颜色、修改标记颜色等，如背景颜色改为护眼模式：R199 G237 B204。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_5.png" alt></p><p>（2）、Alt+Y打开文档类型选项窗口，修改字体显示大小、是否显示行号、解析语言选择、工程文件过滤、扩展tab键、是否显示符号窗口等。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_6.png" alt><br>扩充1：Source Insight可以定义风格，菜单栏-选项-风格，即可以打开风格窗口，可以新建一个风格或修改一个风格。风格可以继承（和C++继承差不多）。</p><p>扩充2：如何使用风格。当选中某种语言解析文档的时候，可以定义一些固定字符以不同的风格显示出来。菜单栏-选项-参数-语言标签，选中解析文档的语言，点击关键字按钮，打开语言关键字窗口，在样式这一栏选中一种风格，然后添加关键字即可。这样文档中这个关键字就以那种风格显示了。</p><p>扩充3：如何查看和修改符号（如函数名、变量等）的风格，右击该符号，选择风格，打开窗口就可以看到该符号的风格是什么，然后进行修改。</p><p>（3）、快速更名ctrl+’，选中某个函数名，然后按ctrl+’，弹出快速更名窗口，然后根据相应的选项，可以快速更换函数名。（包括函数的声明处，定义处，引用处等）。</p><p>（4）、F8，高亮</p><p>（5）、ctrl+左击，进入函数定义或变量声明处。</p><p>（6）、Alt+，：后退</p><p>（7）、Alt+.   ：前进</p><p>（8）、ctrl+g：调到固定行</p><p>（9）、Alt+左击拖动：可以进行列编辑</p><p>（10）、自动缩进：Alt+T打开文档选项窗口，点击自动选项，选中第三个smart缩进，并把后面的两个勾都去掉，这样配置比较好。可以尝试一下勾上的效果，然后和不勾的效果对比一下。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_7.png" alt><br>（11）、编码格式设置，设置完毕后需要重新打开文件进行浏览。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_8.png" alt><br>（12）、Ctrl+F打开查找界面，配置好查找选项，然后关闭查找界面，选中一个单词，按一次Shift+F3，然后只要按F3和F4即可进行查找上一个和下一个。</p><h3 id="2、符号窗口"><a href="#2、符号窗口" class="headerlink" title="2、符号窗口"></a>2、符号窗口</h3><p>这个窗口是显示文档的符号的，那么文档内容哪些是符号呢，这个应该是看文档窗口是设置哪种语言来解析文档的。</p><p>（1）、Alt+F8：打开/关闭当前文档的符号窗口。</p><p>（2）、Alt+Y打开文档选项窗口，配置所有文档是否打开符号窗口。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_10.png" alt></p><p>（3）、右击符号窗口-符号窗口选项-符号类型，可以选择显示的符号种类。</p><p>（4）、右击符号窗口-符号窗口选项，可以修改字体、背景颜色等。</p><h3 id="3、项目窗口"><a href="#3、项目窗口" class="headerlink" title="3、项目窗口"></a>3、项目窗口</h3><p>这个窗口可以使用各种模式来显示文件名、文件目录等。</p><p>（1）、右击窗口选项，修改字体或背景颜色、不显示文件大小、目录、日期等。</p><h3 id="4、关联窗口"><a href="#4、关联窗口" class="headerlink" title="4、关联窗口"></a>4、关联窗口</h3><p>这个窗口用来显示文档中的符号在哪些地方进行了引用。如哪些地方调用了函数，或该函数调用了哪些函数等。关联窗口可以有好多个。</p><p>（1）、右击关联窗口-窗口属性，可以修改字体、背景颜色等。</p><p>（2）、右击关联窗口-新建窗口，则可以打开一个新的关联窗口。</p><p>（3）、关联窗口的功能修改，右击关联窗口-窗口属性，可以修改对应符号的关系类型，选择Reference，则该窗口显示调用该函数或变量的地方，选择calls，则该窗口显示该函数调用了哪些函数。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_11.png" alt><br>（4）、如何使用该窗口：选中某个函数或变量，关联窗口会自动显示对于内容，如果不想它自己变，就锁上，然后需要找的时候刷新。（锁定、刷新按钮应该可以看到吧）</p><h3 id="5、上下文窗口"><a href="#5、上下文窗口" class="headerlink" title="5、上下文窗口"></a>5、上下文窗口</h3><p>这个窗口一般配合关联窗口使用，单机关联窗口的某一项，可以自动在上下文窗口显示该项的上下文，双击上下文内容，则可以在文档窗口打开上下文。</p><p>（1）、右击窗口-属性，修改字体、背景颜色等。</p><h3 id="6、剪辑窗口"><a href="#6、剪辑窗口" class="headerlink" title="6、剪辑窗口"></a>6、剪辑窗口</h3><p>这个窗口的作用相当于是定义了好多粘贴板的意思。一个剪辑相当于一个粘贴板。</p><p>（1）、右击窗口-属性，修改字体、背景颜色等。</p><p>（2）、新建、修改、删除一个剪辑。</p><p>（3）、如何使用新建的剪辑：菜单栏-编辑-粘贴自剪辑/拷贝到剪辑。</p><h3 id="7、代码片段窗口"><a href="#7、代码片段窗口" class="headerlink" title="7、代码片段窗口"></a>7、代码片段窗口</h3><p>（1）、右击窗口-属性，修改字体、背景颜色等</p><p>（2）、可以自定义一些代码片段，使用时直接插入即可。</p><p>打开上下文窗口context window</p><p>在view / panels/ context window</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_12.png" alt></p><h2 id="三、自定义命令"><a href="#三、自定义命令" class="headerlink" title="三、自定义命令"></a>三、自定义命令</h2><p>菜单栏-选项-自定义命令，可以添加一条命令，定义该命令的名字、执行命令语句。</p><p>如何运行命令：可以将命令显示在菜单栏（参考第五点菜单分配）或者给命令定义一个快捷键（参考第六点键分配）。</p><p>望君举一反三。</p><p>1、定义使用gvim打开当前文档的命令，前提是要先安装一个gvim程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令名：editWithGvim</span><br><span class="line">执行命令：&quot;C:\Program Files\Vim\vim63\gvim.exe&quot; --remote-silent +%l %f</span><br></pre></td></tr></table></figure></p><p>备注：—remote-silent 是如果已经打开了对应文件，就不会打开第二次，而是在已经打开的文件里跳转到对应行；%l 是当前行；%f是当前文件。</p><p>2、在资源管理器中显示当前文档，即打开当前文档位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">命令名：explorer</span><br><span class="line">执行命令：explorer /select,%f</span><br><span class="line">备注：不知道，再说吧。</span><br></pre></td></tr></table></figure></p><h2 id="四、宏的使用"><a href="#四、宏的使用" class="headerlink" title="四、宏的使用"></a>四、宏的使用</h2><p>宏语言是SourceInsight定义的一种可编程语言。安装好一个SourceInsight后，打开SourceInsight，可以看到有一个base项目。打开base项目，可以看到有一个Utils.em文件，该文件就是宏语言文件，在里面可以自己写一些宏，也可以新建一个.em文件写宏，或者下载一个别人写好的.em文件如quiker.em(lushengwen写的，用的人比较多)。新建的.em或别人的.em文件要加载到base工程中（如何加载：菜单栏-项目-添加/删除文件）。</p><p>如何调用宏：可以将宏显示在菜单栏（参考第五点菜单分配）或者给宏定义一个快捷键（参考第六点键分配）。</p><p>1、宏语言语法<br>这个再说</p><p>2、quiker.em的使用（从网络下载）<br>（1）、首先要把这个文件搞到手，然后将其加载到Base工程中，其次要定义一个快捷键调用quiker.em中的宏AutoExpand。quiker.em中写了那么多宏，为什么只调用AutoExpand宏就可以。因为调用AutoExpand宏后，AutoExpand会根据当前文本内容自动调用其他宏。一般情况下都用快捷键ctrl+enter调用AutoExpand宏。</p><p>（2）、输入文本config，然后执行AutoExpand，根据提示完成语言、姓名配置。</p><p>（3）、输入文本fu，然后执行AutoExpand，根据提示完成函数的注释。（在函数名的上一行执行）</p><p>（4）、输入文本if，然后执行AutoExpand，可以自动完成语法。其他类似。</p><p>（5）、输入文本file，然后执行AutoExpand，可以自动生成.c文件描述。</p><p>（6）、输入文本hdn，然后执行AutoExpand，根据提示完成.h文件宏定义。</p><p>（7）、在.c文件里输入hd，然后执行AutoExpand，可以自动生成.c文件对应的头文件。</p><p>（8）、后续补充</p><h3 id="3、自己写的宏"><a href="#3、自己写的宏" class="headerlink" title="3、自己写的宏"></a>3、自己写的宏</h3><p>（1）、自动注释，给这个宏定义一个快捷键，然后选中几行文本，执行快捷键，即可以进行注释与反注释操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">macro MultiLineComment()</span><br><span class="line">&#123;</span><br><span class="line">    hwnd = GetCurrentWnd()</span><br><span class="line">    selection = GetWndSel(hwnd)</span><br><span class="line">    LnFirst =GetWndSelLnFirst(hwnd)      //取首行行号</span><br><span class="line">    LnLast =GetWndSelLnLast(hwnd)      //取末行行号</span><br><span class="line">    hbuf = GetCurrentBuf()</span><br><span class="line">    if(GetBufLine(hbuf, 0) ==&quot;//magic-number:tph85666031&quot;)&#123;</span><br><span class="line">        stop</span><br><span class="line">    &#125;</span><br><span class="line">    Ln = Lnfirst</span><br><span class="line">    buf = GetBufLine(hbuf, Ln)</span><br><span class="line">    len = strlen(buf)</span><br><span class="line">    while(Ln &lt;= Lnlast) &#123;</span><br><span class="line">        buf = GetBufLine(hbuf, Ln)  //取Ln对应的行</span><br><span class="line">        if(buf ==&quot;&quot;)&#123;                   //跳过空行</span><br><span class="line">            Ln = Ln + 1</span><br><span class="line">            continue</span><br><span class="line">        &#125;</span><br><span class="line">        if(StrMid(buf, 0, 1) == &quot;/&quot;)&#123;       //需要取消注释,防止只有单字符的行</span><br><span class="line">            if(StrMid(buf, 1, 2) == &quot;/&quot;)&#123;</span><br><span class="line">                PutBufLine(hbuf, Ln, StrMid(buf, 2, Strlen(buf)))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(StrMid(buf,0,1) !=&quot;/&quot;)&#123;          //需要添加注释</span><br><span class="line">            PutBufLine(hbuf, Ln, Cat(&quot;//&quot;, buf))</span><br><span class="line">        &#125;</span><br><span class="line">        Ln = Ln + 1</span><br><span class="line">    &#125;</span><br><span class="line">    SetWndSel(hwnd, selection)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="五、菜单分配"><a href="#五、菜单分配" class="headerlink" title="五、菜单分配"></a>五、菜单分配</h3><p>菜单栏-选项-菜单分配，可以将自定义命令、宏等显示到菜单栏列表里。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_13.png" alt></p><h3 id="六、健分配"><a href="#六、健分配" class="headerlink" title="六、健分配"></a>六、健分配</h3><p>菜单栏-选项-键分配，定义快捷键，可以将自定义命令、宏等定义一个快捷键。</p><h3 id="七、配置的保存和载入"><a href="#七、配置的保存和载入" class="headerlink" title="七、配置的保存和载入"></a>七、配置的保存和载入</h3><p>菜单栏-选项-载入配置或保存配置，可以把自己的配置保存下来，或者发给别人让别人使用。获取我的配置文件：<a href="http://pan.baidu.com/s/1pKViFHp。" target="_blank" rel="noopener">http://pan.baidu.com/s/1pKViFHp。</a></p><h3 id="八、布局使用"><a href="#八、布局使用" class="headerlink" title="八、布局使用"></a>八、布局使用</h3><p>软件提供了四个布局的保存，当配置好一个界面布局后可保存到一个布局当中，这样可以方便切换软件布局。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_14.png" alt></p><h3 id="九、文件名标签设置为最近的使用靠左显示"><a href="#九、文件名标签设置为最近的使用靠左显示" class="headerlink" title="九、文件名标签设置为最近的使用靠左显示"></a>九、文件名标签设置为最近的使用靠左显示</h3><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_16.png" alt></p><h3 id="10、显示-去掉overview"><a href="#10、显示-去掉overview" class="headerlink" title="10、显示/去掉overview"></a>10、显示/去掉overview</h3><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_17.png" alt><br>附：代码格式化，自己调整，本来想上传配置文件的，我看还是算了，自己调整吧</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_18.png" alt></p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_19.png" alt></p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_20.png" alt></p><p>面是SI4.0版本官网的使用说明介绍网页。<br><a href="https://www.sourceinsight.com/doc/v4/userguide/index.html#t=Manual%2FFrontMatter%2FFrontMatter.html" target="_blank" rel="noopener">https://www.sourceinsight.com/doc/v4/userguide/index.html#t=Manual%2FFrontMatter%2FFrontMatter.html</a></p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_21.jpg" alt></p><h2 id="附简易使用说明："><a href="#附简易使用说明：" class="headerlink" title="附简易使用说明："></a>附简易使用说明：</h2><p>Source Insight导入源代码流程如下：</p><p>1）打开Source Insight；</p><p>2）选择Project-&gt;New Project，填写工程的名字，工程文件存放路径，点击OK后即创建Source Insight工程相关文件(相应目录会生成*.PR等工程文件)；</p><p>3）不断Next，你会发现Add and Remove Project Files对话框，在左边列表中选择你的源代码所在的文件夹，然后点击Add Tree，将源代码中所有文件添加到新创建的Source Insight工程中(即添加到右边列表中)，添加完成后你可以关闭该对话框，点击Project-&gt;Rebuild Project,这时你的源代码中的所有源文件全部都同步到Source Inight工程中了，这时你就可以使用Source Insight阅读源代码了；<br>点击Project-&gt;New Project，就会出现以下界面</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_30.jpg" alt><br>再New project name里面写一个项目名字，然后点击Browse，选择到你那个项目的文件夹，此次以我的一个项目为例：</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_31.jpg" alt><br>点击确定，然后出现一直ok</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_32.jpg" alt><br>直到出现这个界面</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_33.jpg" alt></p><p>然后点击Add Tree，出现这个界面</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_34.jpg" alt><br>点击确定，然后出现这个界面</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_35.jpg" alt></p><p>，然后把这个界面关掉就加载了项目</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_36.jpg" alt><br>然后点击右边操作栏中，下面被选中这个按钮</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_37.jpg" alt><br>然后会弹出一个提示框，是否要将这些代码关联，确认，然后加载完就可以，此时出现的是所有识别的函数名的列表，然后点击第一个按钮，回到下面这个界面，显示的是文件代码</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_38.jpg" alt></p><p>双击其中Main.cpp文件，出现这个界面</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_39.jpg" alt></p><p>然后随便选择这个文件中一个函数，就可以在下面看到他的定义</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_40.jpg" alt></p><p>下面查看这个函数的全部调用，右击这个函数，选择Lookup References</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_41.jpg" alt></p><p>然后选择Search</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_42.jpg" alt></p><p>如果有弹出下面的框，可以随便选择Replace还是Append</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_43.jpg" alt></p><p>然后就出现下面的界面</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_source_44.jpg" alt></p><p>来源：<a href="https://blog.csdn.net/biubiuibiu/article/details/78044232" target="_blank" rel="noopener">https://blog.csdn.net/biubiuibiu/article/details/78044232</a><br><a href="https://www.jianshu.com/p/adca6c2f94f6" target="_blank" rel="noopener">https://www.jianshu.com/p/adca6c2f94f6</a><br><a href="https://blog.csdn.net/qq_39660930/article/details/77499455" target="_blank" rel="noopener">https://blog.csdn.net/qq_39660930/article/details/77499455</a><br><a href="https://baijiahao.baidu.com/s?id=1608656406591755295&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1608656406591755295&amp;wfr=spider&amp;for=pc</a><br><a href="https://zhuanlan.zhihu.com/p/32754019" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32754019</a><br><a href="https://www.sourceinsight.com/doc/v4/userguide/index.html#t=Manual%2FFrontMatter%2FFrontMatter.htm" target="_blank" rel="noopener">https://www.sourceinsight.com/doc/v4/userguide/index.html#t=Manual%2FFrontMatter%2FFrontMatter.htm</a><br><a href="https://zhuanlan.zhihu.com/p/36543793" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36543793</a></p><hr><h3 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h3><h3 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h3><h3 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红外图分特点析及红外图像分割</title>
      <link href="/2019/10/18/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_IRImageSeg/"/>
      <url>/2019/10/18/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_IRImageSeg/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>红外图分特点析及红外图像分割<br><a id="more"></a></p><h3 id="红外热图像"><a href="#红外热图像" class="headerlink" title="红外热图像"></a>红外热图像</h3><p>所有高于绝对零度（-273℃）的物体都会发出红外辐射。<br>红外热成像仪是利用红外探测器、光学成像物镜和光机扫描系统接受被测目标的红外辐射能量分布图形反映到红外探测器的光敏元上，在光学系统和红外探测器之间，有一个光机扫描机构对被测物体的红外热像进行扫描，并聚焦在单元或分光探测器上，由探测器将红外辐射能转换成电信号，经放大处理、转换或标准视频信号通过电视屏或监测器显示红外热像图。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog_IR1.jpg" alt="红外图"></p><p>这种热像图与物体表面的热分布场相对应，但实际被测目标物体各部分红外辐射的热像分布图由于信号非常弱，与可见光图像相比，缺少层次和立体感，因此，在实际过程中为更有效地判断被测目标的红外热分布场，常采用一些辅助措施来增加仪器的实用功能，如图像亮度、对比度的控制，实标校正，伪色彩描绘等高线和直方进行数学运算和处理等。红外热图像是人眼不能直接看到目标的表面温度分布，变成人眼可以看到的代表目标表面温度分布的热图像。</p><h3 id="红外图特点"><a href="#红外图特点" class="headerlink" title="红外图特点"></a>红外图特点</h3><p>由于红外图像是通过“测量”物体向外辐射的热量而获得的，与可见光图像相比有以下特点：</p><p>1、分辨率差<br>2、对比度低<br>3、信噪比低<br>4、视觉效果模糊<br>5、信息量少</p><h3 id="红外图分割"><a href="#红外图分割" class="headerlink" title="红外图分割"></a>红外图分割</h3><p>红外图信息量少，根据红外图明显的亮度特征，可以考虑阈值分割，<br><img src="https://img-blog.nos-eastchina1.126.net/blog_huo.jpg" alt="红外图"></p><p><img src="https://img-blog.nos-eastchina1.126.net/blog_huo2.jpg" alt="红外图"></p><hr><h3 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h3><h3 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h3><h3 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iphone拍照的历史顽固问题-鬼影</title>
      <link href="/2019/10/07/ISP_%E9%AC%BC%E5%BD%B1/"/>
      <url>/2019/10/07/ISP_%E9%AC%BC%E5%BD%B1/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>iphone11系列拍照的历史顽固问题-鬼影<br><a id="more"></a></p><h2 id="iphone11-系列的鬼影问题"><a href="#iphone11-系列的鬼影问题" class="headerlink" title="iphone11 系列的鬼影问题"></a>iphone11 系列的鬼影问题</h2><p>近期苹果 iPhone 11 系列的手机又出现了新问题，其中有不少网友表示，自己在用手机拍照后，图片中莫名出现了“鬼影”的现象，这次的“鬼影门”是指手机对着灯光拍照时，手机屏幕内会出现倒影和炫光。</p><p><a href="https://www.zhihu.com/question/348478461/answer/840490857" target="_blank" rel="noopener">知乎上的相关讨论</a></p><p>拍摄作者是’木西AlexanDENG’，一名专业摄影师，拍摄手机是分别是 <code>iPhone XS 自动测光单张拍摄</code> 和 <code>iPhone 11 Pro Max 自动测光单张拍摄</code>和<code>Mate30 Pro 自动测光单张拍摄</code></p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_guiying_1.jpg" alt="iPhone XS 自动测光单张拍摄"></p><blockquote><p>图1 iPhone XS 自动测光单张拍摄</p></blockquote><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_guiying_3_i11.jpg" alt="iPhone 11 Pro Max 自动测光单张拍摄"></p><blockquote><p>图2 iPhone 11 Pro Max 自动测光单张拍摄</p></blockquote><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_guiying_2.jpg" alt="Mate30 Pro 自动测光单张拍摄"></p><blockquote><p>图3 Mate30 Pro 自动测光单张拍摄</p></blockquote><p>从他拍的图片上我们可以看到，在iphone拍摄的图片的上方有鬼影。这种现象在晚上格外的明显，给用户带来了很大的烦恼，用户体验较差。</p><hr><h2 id="鬼影产生的原理"><a href="#鬼影产生的原理" class="headerlink" title="鬼影产生的原理"></a>鬼影产生的原理</h2><p><a href="https://www.bilibili.com/video/av69411194?from=search&amp;seid=12798611946182658204" target="_blank" rel="noopener">趣体验评测的科普</a></p><p>不论是专业相机还是手机，能成为拍照系统的几个重要组成部分中，除了影像传感器外，就是镜头。而镜头是由多枚镜片构成的，大部分镜片由玻璃或塑料等材料制造的，如果不进行特殊处理，镜片表面就容易形成反射光。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_guiying_Q1.jpg" alt></p><p>当在夜景或者暗光环境下拍摄强光时，强光进入镜头，内部的各枚镜片的表面就会和传感器等形成反射，从而就形成了“鬼影”。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_guiying_Q2.jpg" alt></p><p>专业相机出现鬼影的情况比较少，因为专业相机把图像效果放在第一位，并且使用先进高成本的镜头镀膜工艺，来减少鬼影情况。<br><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_guiying_Q3.jpg" alt><br>而手机终端在日常生活中使用场景复杂，会兼顾考虑到镜头成本和镜头耐磨性，新推出的iphone 11系列配备蓝宝石镜头就是提高镜头的耐磨性，但是按照摄影师’木西AlexanDENG’拍的样片来看，iphone的鬼影问题并不是新一代引入的问题。</p><hr><h2 id="华为联合徕卡，镜头镀改善鬼影情况"><a href="#华为联合徕卡，镜头镀改善鬼影情况" class="headerlink" title="华为联合徕卡，镜头镀改善鬼影情况"></a>华为联合徕卡，镜头镀改善鬼影情况</h2><p>而华为在P9系列之后的旗舰手机都会给镜头镀膜来减少鬼影。</p><p><a href="http://m.sohu.com/a/166216300_99907693" target="_blank" rel="noopener">媒体报道徕卡与华为的合作</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">手机虽小，五脏俱全。除了尺寸小一点，手机拍照机构的每个部分都和数码相机相对应。但手机的光学设计，有着天然的限制：塑料镜头的光学素质跟光学镜片之间有差距；由于尺寸的限制，传统光学镜头的设计经验可能无法完全继承；镜头模组的加工难度较大，必须考虑生产的良率、量产和成本。</span><br><span class="line"></span><br><span class="line">所以，当徕卡专家提出镜头模组的光学设计指标时，挑战就排山倒海地来了：</span><br><span class="line"></span><br><span class="line">发展1 -- 如何提升镜头模组的良率？</span><br><span class="line"></span><br><span class="line">光学系统的设计在高中低各个频段达到均衡，才能保证图像的细节、层次和轮廓的品质。同时，徕卡专家在镜头的鬼影和炫光指标上也提出了很高的要求。鬼影和炫光是指在有较强的光线进入到镜头里，因为在镜片间多次反射，从而在视野中形成了像骷髅头一样的影子（鬼影）和点状的光斑（炫光）；绝大部分情况下，鬼影和炫光的影响要通过光学系统的设计，尽可能降到最低。徕卡把他们的测试方法介绍给华为的专家和我们的供应商时，把大家都惊呆了。因为徕卡测试鬼影和炫光用的光源相当于投影机的光源，比我们平时用的测试光源强了几十倍，因为只有在这种极端的强光源下，才能彻底暴露镜头在鬼影和炫光上的缺陷。徕卡坚持把徕卡镜头的测试标准用在手机镜头测试，因为这是优秀图像的基础。</span><br><span class="line"></span><br><span class="line">前面说过，要做出一组符合要求的镜头是可能的，但是要满足大规模量产的要求和成本要求，还要克服更大的工程挑战。</span><br><span class="line"></span><br><span class="line">一开始的试制良率结果是令人崩溃的，类似于每做出100组镜片，最后只能出品不超过10套符合要求的双镜头模组。我们的光学技术团队接受了这个挑战，事实证明在追求极致的路上华为的研发人是不妥协的，除了聚焦攻克技术难题，还与供应商与徕卡的专家并肩作战，徕卡的专家团队多次和我们一起拜访生产厂家，一起讨论改进方案，充分发挥他们在光学系统设计和生产上的经验，指导我们如何调整镜片形状和间隔，如何考虑周边系统对光学部分的影响。在大家夜以继日的努力下，良率在不断提升，终于在最终deadline来临前，达到了量产的标准。</span><br><span class="line"></span><br><span class="line">P9/P9 Plus的镜头是真正徕卡品质的镜头，属于SUMMARIT系列（光圈2.2-2.5）。大家可以试一下，用手机对着一个强光源拍照，可以发现很少鬼影和炫光，光晕柔和，稍加调整，就可以拍出不错的“吃光”作品。</span><br><span class="line"></span><br><span class="line">试产时的每一批次镜头，都要拍摄大量样张做评测。有一次，徕卡专家针对一批和某TOP品牌手机的对比样张，给出了热情洋溢的评测结果。仔细看了他的评测意见，主要是学习从专家的角度如何从样张上评价光学素质；按照他的观点，镜头的素质已经达到业界一流的水准。</span><br><span class="line"></span><br><span class="line">这封邮件对我们团队的信心提升很大，但同时也带来了新的担心：毕竟这是专家的视角，众多的普通消费者不会这么去看一张图片，我们如何从消费者的角度去呈现一张优秀的照片？</span><br><span class="line"></span><br><span class="line">发展2 -- 力出一孔，只为表现出“色”</span><br><span class="line"></span><br><span class="line">——如何拍出有“徕卡味儿”的照片</span><br><span class="line"></span><br><span class="line">华为负责图像质量的专家最先和徕卡专家交流时，是轻松愉快的，因为发现在对图像的客观评估方面，双方使用的测试仪器和平台都是一样的，这就使交流有了共同的语言。但是很快我们发现徕卡使用的测试标准要高很多！比如用来测试色彩还原的色卡，我们一般测试要求准确还原几十个色块就不错了，徕卡的标准是140个色块的准确还原。要达到徕卡的标准，对手机的器件、ISP算法以及后处理都提出了更高的要求。</span><br><span class="line"></span><br><span class="line">图像质量的测试包括颜色、对焦、纹理、噪声、畸变、动态等很多个维度，这是一个综合的系统工程；同时，对图像的评测分为客观和主观两个部分。客观的指标是可量化可重复的，主观的评测主要是针对有代表性的场景。研发多媒体部有一个专门的图像评测团队，光是有代表性的固定场景就有100多种，还有随机的场景。我们邀请了摄影协会的很多同事来帮我们做Beta测试，他们不仅提供了各种场景下的照片，而且即时反馈了很多的技术问题，和我们的专家一起分析；他们有精湛的摄影技术，而且给我们提供了第一批精彩的样片。P9摄影的成功有他们重要的贡献！</span><br></pre></td></tr></table></figure><p>文章中提到，徕卡对于鬼影的要求更高，这促进的手机成像的改进和优化。</p><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>iphone 11的这个问题属于设计缺陷。除了镀膜的问题还有可能是镜片排列及距离的问题。iPhone的祖传鬼影问题一直没有妥善解决，愧对其旗舰机的地位。在大连拍摄测评时我们发现不论是MATE30还是NEX3，鬼影都没有这么严重，甚至可以说好得多。而随着这代iPhone感光能力增强，夜景曝光向右，在黑暗背景里出现的眩光比前几代更加明显。</p><p>总之，这次iphone 11系列出现的问题不是小问题，影响程度非常大，以至于在逆光，光比强的白天，夜景灯光，等场景都无法使用。更不是很多人说的所谓“正常，很有可能是因为镜片镀膜存在问题。</p><hr><h3 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h3><h3 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h3><h3 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>光敏电阻遇上日夜切换</title>
      <link href="/2019/09/27/ISP_ICR_%E5%85%89%E6%95%8F%E7%94%B5%E9%98%BB/"/>
      <url>/2019/09/27/ISP_ICR_%E5%85%89%E6%95%8F%E7%94%B5%E9%98%BB/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>光敏电阻遇上日夜切换<br><a id="more"></a></p><h3 id="光敏电阻简介"><a href="#光敏电阻简介" class="headerlink" title="光敏电阻简介"></a>光敏电阻简介</h3><p>光敏电阻是用硫化隔或硒化隔等半导体材料制成的特殊电阻器，其工作原理是基于内光电效应。光照愈强，阻值就愈低，随着光照强度的升高，电阻值迅速降低，亮电阻值可小至1KΩ以下。光敏电阻对光线十分敏感，其在无光照时，呈高阻状态，暗电阻一般可达1.5MΩ。光敏电阻的特殊性能，随着科技的发展将得到极其广泛应用。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_guangmin.png" alt></p><h3 id="光敏电阻工作原理"><a href="#光敏电阻工作原理" class="headerlink" title="光敏电阻工作原理"></a>光敏电阻工作原理</h3><p>光敏电阻器是利用半导体的光电导效应制成的一种电阻值随入射光的强弱而改变的电阻器，又称为光电导探测器；入射光强，电阻减小，入射光弱，电阻增大。还有另一种入射光弱，电阻减小，入射光强，电阻增大。</p><h3 id="光敏电阻分类"><a href="#光敏电阻分类" class="headerlink" title="光敏电阻分类"></a>光敏电阻分类</h3><p>根据光敏电阻的光谱特性，可分为三种光敏电阻器：紫外光敏电阻器、红外光敏电阻器、可见光光敏电阻器。</p><p>1、紫外光敏电阻器：对紫外线较灵敏，包括硫化镉、硒化镉光敏电阻器等，用于探测紫外线。</p><p>2、红外光敏电阻器：主要有硫化铅、碲化铅、硒化铅。锑化铟等光敏电阻器，广泛用于导弹制导、天文探测、非接触测量、人体病变探测、红外光谱，红外通信等国防、科学研究和工农业生产中。</p><p>3、可见光光敏电阻器：包括硒、硫化镉、硒化镉、碲化镉、砷化镓、硅、锗、硫化锌光敏电阻器等。主要用于各种光电控制系统，如光电自动开关门户，航标灯、路灯和其他照明系统的自动亮灭，自动给水和自动停水装置，机械上的自动保护装置和“位置检测器”，极薄零件的厚度检测器，照相机自动曝光装置，光电计数器，烟雾报警器，光电跟踪系统等方面。</p><h3 id="光敏电阻的作用"><a href="#光敏电阻的作用" class="headerlink" title="光敏电阻的作用"></a>光敏电阻的作用</h3><p>光敏电阻器一般用于光的测量、光的控制和光电转换（将光的变化转换为电的变化）。常用的光敏电阻器硫化镉光敏电阻器，它是由半导体材料制成的。光敏电阻器对光的敏感性（即光谱特性）与人眼对可见光（0.4~0.76）μm的响应很接近，只要人眼可感受的光，都会引起它的阻值变化。设计光控电路时，都用白炽灯泡（小电珠）光线或自然光线作控制光源，使设计大为简化。</p><p>随着的光照强度的增加，光敏电阻的阻值开始迅速下降。若进一步增大光照强度，则电阻值变化减小，然后逐渐趋向平缓。在大多数情况下，该特性为非线性。 可见光敏电阻具有灵敏度高，反应速度快，稳定可靠的特点，根据光敏电阻的这个特性，可用它来设计光控可调光电路，光控开关等。</p><h3 id="安防摄像机上的用途"><a href="#安防摄像机上的用途" class="headerlink" title="安防摄像机上的用途"></a>安防摄像机上的用途</h3><p>光敏电阻模块对环境可见光强最敏感，一般用来检测周围环境的亮度和光强。应用在监控摄像机上可以辅助判断切换日夜模式，在白天可见光充足的条件下，光敏电阻阻值较低，其光敏电阻模块电压较高，可以作为可见光充足的判断条件。摄像机在白天使用红外截止滤光片，过滤掉红外光，避免红外光对图像的干扰。在夜晚可见光不够的低照度场景中，光敏电阻阻值较高，其光敏电阻模块电压较低，可以作为可见光不够的判断条件。摄像机在白天使用全透滤光片，图像切换到黑白模式。</p><h3 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h3><h3 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h3><h3 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滤光片相关</title>
      <link href="/2019/09/21/filter/"/>
      <url>/2019/09/21/filter/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>滤光片相关<br><a id="more"></a></p><h2 id="滤光片相关"><a href="#滤光片相关" class="headerlink" title="滤光片相关"></a>滤光片相关</h2><p> 滤光片作为一种光学元器件，是用来选取所需辐射波段的工具，是塑料或玻璃片再加入特种染料做成的，其主要特点是尺寸可做得相当大。薄膜滤光片，一般通过长波较长的光，常用作红外高透滤光片。后者是由高折射率或低折射率的金属介质金属膜或一定厚度的全介质膜通过真空镀膜在一定的衬底上形成的一种低阶、多级串联固体干涉仪。</p><h2 id="滤光片分类"><a href="#滤光片分类" class="headerlink" title="滤光片分类"></a>滤光片分类</h2><h3 id="红外截止滤光片"><a href="#红外截止滤光片" class="headerlink" title="红外截止滤光片"></a>红外截止滤光片</h3><p>英文名叫IR-cut filter，它放在于LENS与Sensor之间。因人眼与CMOS传感器对各波长的光响应不一样，人的肉眼看不到红外光，但传感器可以感受近红外光，这样会造成sensor对红光感受过强，形成色偏。因此需要红外截止滤光片阻隔近红外光。主要在超薄光学玻璃上镀制IR-cut膜，使之能与镜头产品进行叠装组合。</p><p>IR-cut滤光片分为<code>反射式</code>及<code>吸收式</code>两种。反射式IR-cut滤光片在可见光波段有较高透过率，同时有较低的反射率，而在红外区域正好相反，反射较高。因此，当相机以一定角度拍摄时，红外光会对胶片产生较大的反射。当光线被透镜组反射多次后，就会在照片上形成光晕。</p><p><code>吸收式IR-cut滤光片</code>是采用蓝玻璃，它本身是一种吸收玻璃，玻璃中的铜离子对红外线有吸收作用，不存在很大反射，当相机在成角度拍摄照片时，光线通过蓝玻璃的主要吸收，经镜头组多次反射的红外光很弱，不会在照片上形成光晕现象。</p><p><code>IR-cut滤光片</code>主要应用于手机摄像头、数码相机、数码摄像机、电脑摄像头、安防监控器（CCTV）摄像头、可视电话、可视门铃等CCD/CMOS数码成像系统，能有效改善红外线对CCD/CMOS成像的影响，防止图像传感器产生的伪色和波纹，提高彩色CCD、CMOS图像传感器有效分辨率和彩色还原性。</p><h3 id="日夜两用双通滤光片"><a href="#日夜两用双通滤光片" class="headerlink" title="日夜两用双通滤光片"></a>日夜两用双通滤光片</h3><p>红外光在白天等可见光条件下对彩色监视摄像机来说是一种杂散光，会降低彩色监视摄像机的清晰度和色彩恢复性。目前有两种方法可以让彩色监控摄像头在夜晚的条件下感应到红外光。</p><p>首先，打开滤光片，用可见光覆盖红外线。在没有可见光的情况下，取下滤光片，让红外线进入。该方案获得了良好的图像质量，但需要使用一种称为切换器的硬件。不仅会增加成本，而且开关的故障率也很高。</p><p>第二，在滤光片上打开一个特定的红外线通道，允许与红外灯波长相同的红外光线进来，这就是日夜两用双通道滤光片，该滤光片由光学玻璃基体以及沉积在光学玻璃基体上的滤光膜组成，可阻断混合光源中的紫外线和红外线，有助于数码相机CCD或CMOS不再受紫外线和红外线的信号影响，得到更加鲜明清晰的影像；同时该滤光片还能根据红外灯的不同特性有选择性地通过部分红外光谱，起到增强数码相机的夜视功能的效果。</p><p>日夜两用滤光片能通过可见光420nm-620nm和850nm的红外光，阻止近红外线920nm-1100nm的红外光，白天可以获得真彩色图像，晚上可以获得清晰的黑白图像。主要用于CCD芯片彩色摄像机和CMOS成像系统，安防监控器摄像头，数码相机，网络摄像机，可视电话，门铃，数字望远镜，车牌识别摄像机等，抗强光和杂光干扰能力强，色彩失真少。</p><h3 id="摄像用滤光片的主要作用有："><a href="#摄像用滤光片的主要作用有：" class="headerlink" title="摄像用滤光片的主要作用有："></a>摄像用滤光片的主要作用有：</h3><h4 id="滤除红外线"><a href="#滤除红外线" class="headerlink" title="滤除红外线"></a>滤除红外线</h4><p>彩色CCD也能感应红外线，因为它能感应红外线，这将导致无法计算出正确的颜色，所以你必须添加一个过滤器来分离红外线部分的光线，所以只有彩色CCD需要安装的过滤器，而不是黑白。</p><h4 id="修整进来的光线"><a href="#修整进来的光线" class="headerlink" title="修整进来的光线"></a>修整进来的光线</h4><p>由于CCD由许多光感受器（细胞）组成，光直接进入，但为了避免干扰相邻的光感受器，需要对光进行修剪。因此，过滤器不是玻璃，而是石英。它利用石英的物理偏振特性来保持入射光的直射部分，反射斜射部分，避免影响附近的敏感点。</p><h2 id="安防监控用的滤光片有什么功能？"><a href="#安防监控用的滤光片有什么功能？" class="headerlink" title="安防监控用的滤光片有什么功能？"></a>安防监控用的滤光片有什么功能？</h2><p>现在的摄像机都有夜视功能，这个夜视靠的是什么能在完全黑暗的状态下看到物体，靠得是红外灯LED发出红外光，反射后进入CCD成像的，这样就出现一个矛盾。为了滤除白天太阳产生的红外光，我们将蓝色玻璃粘贴在CCD前面，将红外光切断，LED夜间发出的红外光被蓝色玻璃滤除，无法成像。如何解决这一矛盾？在白天截止红外光使图像清晰、真实，晚上又能使LED发出的红外光完全进入CCD完成夜视功能这就是双滤光片的功能了，它是靠一个机械装置来完成白天在CCD前面放截止红外光的滤光片，到了夜晚自动切换成全通透的滤光片，这样就满足了红外夜视摄像机的要求。这种机械装置称为双滤波器切换器。</p><h2 id="彩色滤光片分类"><a href="#彩色滤光片分类" class="headerlink" title="彩色滤光片分类"></a>彩色滤光片分类</h2><h3 id="吸收型彩色滤光片"><a href="#吸收型彩色滤光片" class="headerlink" title="吸收型彩色滤光片"></a>吸收型彩色滤光片</h3><p>吸收型彩色滤光片是借助材料对可见光的吸收作用实现滤光的，常见的照相机/摄像机滤色片实际上是一种混有颜料的有色玻璃，利用了颜料对光的选择性吸收，它可以帮助实现白平衡或者破坏白平衡，使画面色彩正常或者偏向某一色彩。这种滤光片也可以用于显微镜，帮助校正色差或提高分辨率，也有均匀减弱光强，不改变光谱成分的中性滤光片，它依靠吸收率高的金属层工作，一般用来衰减入射光强。由于一些颜料经过长时问的紫外线照射会分解，对光的吸收能力降低，所以某些吸收型彩色滤光片并不耐久，平板显示中使用的吸收型彩色滤光片有60％的光损耗，降低了它的光能利用效率。</p><h3 id="光学薄膜彩色滤光片"><a href="#光学薄膜彩色滤光片" class="headerlink" title="光学薄膜彩色滤光片"></a>光学薄膜彩色滤光片</h3><p>光学薄膜滤光片通过多层薄膜结构对在其中传播的光的相位或振幅进行调整，使一定波段内光的偏振态被改变或者强度重新分布。光学薄膜滤光片一般包括带通滤光片、截止滤光片和特殊用途的其他滤光片，常用于光谱仪器、光谱修正、光通讯、激光系统等领城。光学薄膜彩色滤光片其有以下优点：</p><blockquote><p>1、性质稳定，不易褪色<br>       2、反射或透射率高，色彩鲜艳<br>       3、材料环保，生产过程污染小</p></blockquote><h2 id="镀膜工艺"><a href="#镀膜工艺" class="headerlink" title="镀膜工艺"></a>镀膜工艺</h2><h3 id="蒸发沉积镀膜技术"><a href="#蒸发沉积镀膜技术" class="headerlink" title="蒸发沉积镀膜技术"></a>蒸发沉积镀膜技术</h3><p>在蒸发沉积镀膜技术中，真空室中源材料被电子束加热或蒸发，蒸气在光学表面凝结。在蒸发过程中，通过精确控制加热、真空压力、基片定位和旋转，可以获得比厚度均匀的光学涂层。蒸发这种技术性质比较温和，就会导致涂层变得松散或多孔。这种疏松涂层具有吸水性，改变了薄膜的有效折射率，导致性能下降。离子束辅助沉积可以增强蒸发涂层，其中离子束将对准基片表面。这增加了源材料与光学表面的附着力，产生更大的应力，并使涂层更致密、更耐用。</p><h3 id="离子束溅射（IBS）镀膜技术"><a href="#离子束溅射（IBS）镀膜技术" class="headerlink" title="离子束溅射（IBS）镀膜技术"></a>离子束溅射（IBS）镀膜技术</h3><p>当离子束溅射时，高能电场会加速离子束的产生，这个加速度给离子很大的动能。当与源材料碰撞时，离子束溅射出目标的原子。这些溅射靶离子（由于电离区的影响原子转变为离子）也具有动能，在与光学表面接触时会产生致密的薄膜。</p><h3 id="等离子体溅射镀膜技术"><a href="#等离子体溅射镀膜技术" class="headerlink" title="等离子体溅射镀膜技术"></a>等离子体溅射镀膜技术</h3><p>等离子体溅射是一系列技术的总称，如先进的磁控溅射和等离子体溅射，不管该技术如何，包括等离子体的产生，等离子体中的离子被加速进入源材料，与松散的能量源离子碰撞，然后溅射到目标光学元件上。虽然不同类型的等离子溅射具有其独特的特性和优点和缺点，但是这种涂覆技术比本文所涉及的其它涂覆技术要小得多。</p><h3 id="原子层沉积镀膜技术"><a href="#原子层沉积镀膜技术" class="headerlink" title="原子层沉积镀膜技术"></a>原子层沉积镀膜技术</h3><p>与蒸发沉积不同，原子层沉积的源材料不需要从固体中蒸发，而是直接以气体的形式存在，尽管该技术使用气体，但是在真空室中仍然需要高温。在ALD过程中，气体前驱体通过非重叠脉冲传输，脉冲是自限幅的，该工艺具有独特的化学设计，每个脉冲仅粘附一层，并且对于光学部件的表面几何形状没有特殊要求，因此，这一工艺可以使我们控制涂层厚度和设计，但它会降低沉积速率。</p><hr><p><a href="https://www.ruiccn.com/industrytrends/ircutlvguangpian.html" target="_blank" rel="noopener">参考文章</a></p><hr><h3 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h3><h3 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h3><h3 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> ISP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像增强—自适应直方图均衡化（AHE）-限制对比度自适应直方图均衡（CLAHE）</title>
      <link href="/2019/09/21/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%A2%9E%E5%BC%BA_CLAHE/"/>
      <url>/2019/09/21/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%A2%9E%E5%BC%BA_CLAHE/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>图像增强—自适应直方图均衡化（AHE）-限制对比度自适应直方图均衡（CLAHE）<br><a id="more"></a></p><h3 id="一、自适应直方图均衡化-Adaptive-histgram-equalization-AHE"><a href="#一、自适应直方图均衡化-Adaptive-histgram-equalization-AHE" class="headerlink" title="一、自适应直方图均衡化(Adaptive histgram equalization/AHE)"></a>一、自适应直方图均衡化(Adaptive histgram equalization/AHE)</h3><h4 id="1-简述"><a href="#1-简述" class="headerlink" title="1.简述"></a>1.简述</h4><p>自适应直方图均衡化(AHE)用来提升图像的对比度的一种计算机图像处理技术。和普通的直方图均衡算法不同，AHE算法通过计算图像的局部直方图，然后重新分布亮度来来改变图像对比度。因此，该算法更适合于改进图像的局部对比度以及获得更多的图像细节。<br>不过，AHE有过度放大图像中相同区域的噪音的问题，另外一种自适应的直方图均衡算法即限制对比度直方图均衡（CLAHE）算法能有限的限制这种不利的放大。</p><h4 id="2-普通直方图均衡算法与AHE算法的解释"><a href="#2-普通直方图均衡算法与AHE算法的解释" class="headerlink" title="2. 普通直方图均衡算法与AHE算法的解释"></a>2. 普通直方图均衡算法与AHE算法的解释</h4><p>普通的直方图均衡算法对于整幅图像的像素使用相同的直方图变换，对于那些像素值分布比较均衡的图像效果比较好。然后，如果图像中包括明显比图像其它区域暗或者亮的部分，在这些部分的对比度将得不到有效的增强。</p><p>AHE算法通过对局部区域执行响应的直方图均衡来改变上述问题。该算法首先被开发出来适用于改进航天器驾驶舱的显示效果。其最简单的形式，就是每个像素通过其周边一个矩形范围内的像素的直方图进行均衡化。均衡的方式则完全同普通的均衡化算法：变换函数同像素周边的累积直方图函数（CDF）成比例。</p><p>图像边缘的像素需要特殊处理，因为边缘像素的领域不完全在图像内部。这个通过镜像图像边缘的行像素或列像素来解决。直接复制边缘的像素进行扩充是不合适的。因为这会导致带有剑锋的领域直方图。</p><h4 id="3-AHE算法的缺点"><a href="#3-AHE算法的缺点" class="headerlink" title="3. AHE算法的缺点"></a>3. AHE算法的缺点</h4><p>算法设定的邻域参数小，对比度得到增强，邻域参数大，则对比度会降低。</p><p>当某个区域包含的像素值非常接近，其区域的直方图就会尖状化，此时直方图的变换函数会将一个很窄范围内的像素映射到整个像素范围。这将使得某些平坦区域中的少量噪音经AHE处理后过度放大。</p><h3 id="二、限制对比度自适应直方图均衡（Contrast-Limited-Adaptive-histgram-equalization-CLAHE"><a href="#二、限制对比度自适应直方图均衡（Contrast-Limited-Adaptive-histgram-equalization-CLAHE" class="headerlink" title="二、限制对比度自适应直方图均衡（Contrast Limited Adaptive histgram equalization/CLAHE)"></a>二、限制对比度自适应直方图均衡（Contrast Limited Adaptive histgram equalization/CLAHE)</h3><h4 id="1-简述-1"><a href="#1-简述-1" class="headerlink" title="1.简述"></a>1.简述</h4><p>CLAHE同普通的自适应直方图均衡不同的地方主要是其对比度限幅。这个特性也可以应用到全局直方图均衡化中，即构成所谓的限制对比度直方图均衡（CLHE），但这在实际中很少使用。在CLAHE中，对于每个小区域都必须使用对比度限幅。CLAHE主要是用来克服AHE的过度放大噪音的问题。</p><p>这主要是通过限制AHE算法的对比提高程度来达到的。在指定的像素值周边的对比度放大主要是由变换函数的斜度决定的。这个斜度和领域的累积直方图的斜度成比例。CLAHE通过在计算CDF前用预先定义的阈值来裁剪直方图以达到限制放大幅度的目的。这限制了CDF的斜度因此，也限制了变换函数的斜度。直方图被裁剪的值，也就是所谓的裁剪限幅，取决于直方图的分布因此也取决于领域大小的取值。<br>通常，直接忽略掉那些超出直方图裁剪限幅的部分是不好的，而应该将这些裁剪掉的部分均匀的分布到直方图的其他部分。如下图所示。<br>这个重分布的过程可能会导致那些倍裁剪掉的部分由重新超过了裁剪值（如上图的绿色部分所示）。如果这不是所希望的，可以不带使用重复不的过程指导这个超出的部分已经变得微不足道了。</p><h4 id="2-通过插值加快计算速度"><a href="#2-通过插值加快计算速度" class="headerlink" title="2. 通过插值加快计算速度"></a>2. 通过插值加快计算速度</h4><p>如上所述的直接的自适应直方图，不管是否带有对比度限制，都需要对图像中的每个像素计算器领域直方图以及对应的变换函数，这使得算法及其耗时。</p><p>而插值使得上述算法效率上有极大的提升，并且质量上没有下降。首先，将图像均匀分成等份矩形大小，如下图的右侧部分所示（8行8列64个块是常用的选择）。然后计算个块的直方图、CDF以及对应的变换函数。这个变换函数对于块的中心像素（下图左侧部分的黑色小方块）是完全符合原始定义的。而其他的像素通过哪些于其临近的四个块的变换函数插值获取。位于图中蓝色阴影部分的像素采用双线性查插值，而位于便于边缘的（绿色阴影）部分采用线性插值，角点处（红色阴影处）直接使用块所在的变换函数。</p><p>这样的过程极大的降低了变换函数需要计算的次数，只是增加了一些双线性插值的计算量。</p><h3 id="效果对比"><a href="#效果对比" class="headerlink" title="效果对比"></a>效果对比</h3><p>测试图像，见下图：<br><img src="https://img-blog.nos-eastchina1.126.net/PersonalPhoto/SpaceMan.jpg" alt></p><p>直方图均衡化图像(HE)，见下图：<br><img src="https://img-blog.nos-eastchina1.126.net/PersonalPhoto/SpaceMan-HE.jpg" alt="HE"></p><p>自适应直方图均衡化参数1（AHE），见下图：<br><img src="https://img-blog.nos-eastchina1.126.net/PersonalPhoto/SpaceMan-AHE4256.jpg" alt="AHE"><br>自适应直方图均衡化参数2（AHE），见下图：<br><img src="https://img-blog.nos-eastchina1.126.net/PersonalPhoto/SpaceMan-AHE16256.jpg" alt="AHE"></p><p>限制对比度自适应直方图均衡（CLAHE），见下图：<br><img src="https://img-blog.nos-eastchina1.126.net/PersonalPhoto/SpaceMan-CLAHE.jpg" alt></p><p>从效果上来看，CLAHE算法效果比较好，提亮了暗处，高亮处不至于过曝；AHE算法需要添加参数，参数不同，影响增强效果不同，并且影响很大；HE算法全局提亮，整体略亮。</p><p>感兴趣的同学可以到我的github下载这些代码运行看看，链接如下：<br><a href="https://github.com/AomanHao/Matlab-Image-Dehazing-Enhazing" target="_blank" rel="noopener">Matlab代码链接</a></p><hr><p><a href="https://www.cnblogs.com/Imageshop/archive/2013/04/07/3006334.html" target="_blank" rel="noopener">参考文章</a><br><a href="https://blog.csdn.net/baimafujinji/article/details/50660189" target="_blank" rel="noopener">参考文章</a><br><a href="https://blog.csdn.net/kl1411/article/details/89100740" target="_blank" rel="noopener">参考文章</a><br><a href="https://blog.csdn.net/gdymind/article/details/82357139" target="_blank" rel="noopener">参考文章</a></p><hr><h3 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h3><h3 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h3><h3 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> 图像增强 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理评价指标之模糊度（更新中）</title>
      <link href="/2019/09/21/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87_%E6%A8%A1%E7%B3%8A%E5%BA%A6/"/>
      <url>/2019/09/21/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87_%E6%A8%A1%E7%B3%8A%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>图像处理评价指标之模糊度<br><a id="more"></a></p><p>图像和视频在采集、压缩、传输、存储过程中，无可避免地会引入失真。模糊失真是图像、视频质量下降最主要的因素之一，研究图像模糊度评价方法有非常重要的意义。通过对模糊失真进行评测和度量，可以对整个图像传输或处理系统的质量进行监控，进而采取措施提高系统性能</p><h3 id="模糊度和清晰度概念"><a href="#模糊度和清晰度概念" class="headerlink" title="模糊度和清晰度概念"></a>模糊度和清晰度概念</h3><p>图像模糊是一种很重要的图像降质因素，在图像获取、传输、处理过程中都有很多因素可能造成图像模糊，比如在获取图像时，不正确的聚焦会产生离焦模糊，景物和照相机的相对运动会造成运动模糊，图像压缩后的高频丢失造成的模糊。模糊降低了图像的清晰度，严重影响图像质量，导致图像分析、处理、接收的困难甚至失败，因此必须要使用有效的模糊评价方法来控制模糊图像的使用，<br>从而提高系统整体性能。<br>模糊度和清晰度是描述图像清晰程度（模糊程度）的两个相对但又相互联系的两个概念。图像越清晰，质量越高，清晰度越大，模糊度越小；图像越不清晰（越模糊），质量越低，清晰度越小，模糊度越大。因此描述一幅图像清晰程度时，既可以使用清晰度也可以使用模糊度，只是两个指标数值上成反比；本文采用模图像模糊度评价研究模糊度来描述。</p><p>客观评价也可以根据对参考图像的依赖程度分为：全参考图像模糊度评价（Full Reference Image Blur Assessment，FR-IBA）、部分参考图像模糊度评价（Reduced Reference Image Blur Assessment，RR-IBA）、无参考图像模糊度评价（No Reference Image Blur Assessment，NR-IBA）。客观模糊度评价的方法也可以参考客观图像质量评价的方法，但由于只关注模糊度一个指标，在算法设计时更有针对性，应该把重点放在模糊特征参量的提取上。</p><p>模糊度评价算法可以分成几个较大的类别，（1）基于像素的技术，包括分析像素灰度值的统计特性以及像素之间的相关性；（2）基于变换域的技术，这利用了在变换域高频成分越多图像越清晰，高频成分越少图像越模糊的原理；（3）基于图像梯度的技术，它利用图像边缘的梯度来衡量图像模糊程度，梯度越大图像越清晰。另外，也有较少的算法是基于直方图。</p><h3 id="模糊度分类"><a href="#模糊度分类" class="headerlink" title="模糊度分类"></a>模糊度分类</h3><p>实际应用中有多种模糊情况，模糊产生的原因很多，一般用下面通用的数学模型来表示图像模糊降质</p><script type="math/tex; mode=display">g(x, y) = f(x, y) \otimes d(x, y) + n(x, y)</script><p>式中$f (x, y)$是原始图像，$d(x, y)$是点扩散函数（Point Spread Function，PSF），$\otimes$ 是卷积，$n(x, y) $是加性噪声。</p><h4 id="1、运动模糊"><a href="#1、运动模糊" class="headerlink" title="1、运动模糊"></a>1、运动模糊</h4><p>运动模糊是在捕获图像时，快门在打开时间内成像系统和拍摄<br>对象的短暂相对运动，造成成像在某个方向上形成的模糊。</p><p>假设图像$f (x, y)$ 在一个平面运动，令$x_0(t) $、$y_0(t) $分别是$x$ 和$y$ 方向上运动的变化分量，$T$ 表示曝光时间，那么模糊后的图像可以看作是在快门开启时间内原始图像在$x$ 、$y$ 方向上的积分：</p><script type="math/tex; mode=display">g(x,y)=\int_0^T f[x-x_0(t) , y - y_0(t)] dt</script><h4 id="2、压缩模糊"><a href="#2、压缩模糊" class="headerlink" title="2、压缩模糊"></a>2、压缩模糊</h4><p>压缩模糊是图像在进行有损压缩丢失部分信息。</p><h4 id="3、高斯模糊"><a href="#3、高斯模糊" class="headerlink" title="3、高斯模糊"></a>3、高斯模糊</h4><p>高斯模糊是人为引入的一种模糊，使用高斯低通滤波器对原始图像进行滤波得到的。它的点扩散函数可以表示为</p><script type="math/tex; mode=display">d(x,y) = \frac{1}{2 \pi\sigma^2 }* e^ {- \frac{(x^2 +y^2)} {2 \sigma^2 }}</script><h3 id="模糊度计算方法"><a href="#模糊度计算方法" class="headerlink" title="模糊度计算方法"></a>模糊度计算方法</h3><p>模糊度的计算可以广泛应用到相机自动聚焦、显微镜自动聚焦、电子显微镜自动聚焦等场景。</p><h4 id="1、灰度方差算法"><a href="#1、灰度方差算法" class="headerlink" title="1、灰度方差算法"></a>1、灰度方差算法</h4><p>该算法以图像所有像素的灰度平均值为参考，对每个像素点的灰度值求差后求平方和，然后用像素总数标准化，它表征了图像灰度变化的平均程度，灰度变化的平均程度越大，图像越清晰，灰度变化平均程度越小，图像越模糊。</p><h4 id="2、Roberts-梯度和"><a href="#2、Roberts-梯度和" class="headerlink" title="2、Roberts 梯度和"></a>2、Roberts 梯度和</h4><p>定义为相邻四个像素对角线像素灰度值差的绝对值之和</p><script type="math/tex; mode=display">s =\sum (f(x,y) - f(x+1,y+1) )+(f(x+1,y)-f(x,y-1))</script><h4 id="3、拉普拉斯梯度和1"><a href="#3、拉普拉斯梯度和1" class="headerlink" title="3、拉普拉斯梯度和1"></a>3、拉普拉斯梯度和1</h4><p>f(x,y)+f(x+1,y)+(f(x,y+1)-f(x,y-1</p><h4 id="4、拉普拉斯梯度和2"><a href="#4、拉普拉斯梯度和2" class="headerlink" title="4、拉普拉斯梯度和2"></a>4、拉普拉斯梯度和2</h4><hr><h3 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h3><h3 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h3><h3 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10句话读懂图像频域滤波（转载）</title>
      <link href="/2019/09/21/ISP_Filter/"/>
      <url>/2019/09/21/ISP_Filter/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>10句话读懂图像频域滤波<br><a id="more"></a></p><p>今天的图像处理依靠各类方便易用的工具箱与函数库似乎已然成为上手就能用的应用科学。但没有那种算法是普适的，知其所以然才能真正理解原理，深刻的理解才能针对具体应用行成独到见解。图像处理是信号与信息处理学科的分支，图像滤波的理论当然得从信号与系统说起。尽管很多文献都有详细的论述，但如果你对LSI系统、空间卷积、二维傅里叶变换、空域与频域、滤波与变换的理论概念虽耳熟能详但仍一知半解，本文将尽力用简单的文字将这些关系屡屡清楚，总结并告诉我们一些不可不知的图像频域滤波处理基本理论。</p><h2 id="10句话读懂图像频域滤波基本理论"><a href="#10句话读懂图像频域滤波基本理论" class="headerlink" title="10句话读懂图像频域滤波基本理论"></a>10句话读懂图像频域滤波基本理论</h2><p>数字图像信号为离散二维或三维信号。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_filter_1.png" alt></p><p>二维灰度图像                                                                  三维视频图像</p><p>图像处理很简单，给一幅输入图像x得到一幅输出图像y(n1,n2)，通常将这个过程视为一个二维信号处理系统T：</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_filter_1.2.png" alt></p><p>线性移不变(LSI)系统有很多优良的性质，这类系统必须同时具有线性与空间移不变性：输出对任意输入都满足均匀性与叠加性（合称线性），输出与系统的坐标原点位置无关（移不变性）</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_filter_1.4.png" alt></p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_filter_2.png" alt></p><p>单位冲激函数δ(n1,n2)通过LSI系统，输出为系统的冲激响应h(n1,n2)：</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_filter_3.png" alt></p><p>想得到输出图像其实不难：若已知LSI系统的冲激响应h(n1,n2)，则输出图像=输入图像与冲激响应的二维卷积：</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_filter_4.png" alt></p><p>傅里叶很牛，可将图像信号从空域x(n1,n2)变到到频域X(ω1,ω2)，也可以将图像信号从频域变回空域，(ω1,ω2)分别表示频域中的垂直与水平频率</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_filter_5.png" alt><br><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_filter_6.png" alt></p><p> LSI系统冲激响应h(n1,n2)的傅里叶变换就是该系统的频率响应H(ω1,ω2)，它给出了系统在频点(ω1,ω2)处的响应特性：</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_filter_7.png" alt></p><p>有了卷积定理，一切变得简单：LSI系统在空域的二维卷积运算，等于该系统在频域的乘积运算：</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_filter_8.png" alt></p><h3 id="结论-频域滤波就是设计合适的LSI系统频谱响应H-ω1-ω2-，即可实现对输入图像中某些频率的放大、衰减或不通过（拒绝）："><a href="#结论-频域滤波就是设计合适的LSI系统频谱响应H-ω1-ω2-，即可实现对输入图像中某些频率的放大、衰减或不通过（拒绝）：" class="headerlink" title="结论:频域滤波就是设计合适的LSI系统频谱响应H(ω1,ω2)，即可实现对输入图像中某些频率的放大、衰减或不通过（拒绝）："></a>结论:频域滤波就是设计合适的LSI系统频谱响应H(ω1,ω2)，即可实现对输入图像中某些频率的放大、衰减或不通过（拒绝）：</h3><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_filter_9.png" alt></p><p>那么问题来了，到底怎么分析呢(｡･∀･)ﾉﾞ~图像滤波中所用的滤波核或模板就是系统的冲激响应h，每个滤波核都已其特定的频率响应函数H，例如：</p><p>低通滤波器：频率响应曲线中间凸、四周低表示低频部分系数高：低频分量通过，高频被抑制</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_filter_10.png" alt>        </p><p>高通滤波器：频率响应曲线四周高、中间凹表示高频部分系数高：高频分量通过，低频被抑制</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_filter_11.png" alt></p><p>P.S. 如果还想更进一步，请参考博文“如何构造频域滤波器——图像频域滤波的信号与系统基本理论”。</p><p>版权声明：本文为CSDN博主「iracer」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/iracer/article/details/49311463" target="_blank" rel="noopener">https://blog.csdn.net/iracer/article/details/49311463</a></p><h3 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h3><h3 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h3><h3 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《乌合之众》</title>
      <link href="/2019/09/21/wuhezhizhong/"/>
      <url>/2019/09/21/wuhezhizhong/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>《乌合之众》<br><a id="more"></a><br>勒庞的《乌合之众》长期以来都是我的枕边书。今天不知谁整理出了《乌合之众》的60条基本观点，如下：</p><p>1.人一到群体中，智商就严重降低，为了获得认同，个体愿意抛弃是非，用智商去换取那份让人备感安全的归属感。</p><p>2.我们始终有一种错觉，以为我们的感情源自于我们自己的内心。</p><p>3.群体只会干两种事——锦上添花或落井下石。</p><p>4.个人一旦成为群体的一员，他所作所为就不会再承担责任，这时每个人都会暴露出自己不受到的约束的一面。群体追求和相信的从来不是什么真相和理性，而是盲从、残忍、偏执和狂热，只知道简单而极端的感情。</p><p>5.我们以为自己是理性的，我们以为自己的一举一动都是有其道理的。但事实上，我们的绝大多数日常行为，都是一些我们自己根本无法了解的隐蔽动机的结果。</p><p>6.所谓的信仰，它能让一个人变得完全受自己的梦想奴役。</p><p>7.在与理性永恒的冲突中，感情从未失过手。</p><p>8.有时不真实的东西比真实的东西包含更多的真理。</p><p>9.群众没有真正渴求过真理，面对那些不合口味的证据，他们会充耳不闻…凡是能向他们提供幻觉的，都可以很容易地成为他们的主人；凡是让他们幻灭的，都会成为他们的牺牲品。</p><p>10.数量，即是正义。</p><p>11.掌握了影响群众想象力的艺术，也就掌握了统治他们的艺术。</p><p>12.没有传统，就没有文明；没有对传统的缓慢淘汰，就没有进步。</p><p>13.孤立的个人很清楚，在孤身一人时，他不能焚烧宫殿或洗劫商店，即使受到这样做的诱惑，他也很容易抵制这种诱惑。但是在成为群体的一员时，他就会意识到人数赋予他的力量，这足以让他生出杀人劫掠的念头，并且会立刻屈从于这种诱惑。出乎预料的障碍会被狂暴地摧毁。人类的机体的确能够产生大量狂热的激情，因此可以说，愿望受阻的群体所形成的正常状态，也就是这种激愤状态。</p><p>14.一个国家为其年轻人所提供的教育，可以让我们看到这个国家未来的样子。</p><p>15.能够感觉到的现象可以比作波浪，是海洋深处我们一无所知的那些乱象在洋面上的表象。</p><p>16.昨天受群众拥戴的英雄一旦失败，今天就会受到侮辱。当然名望越高，反应就会越强烈。在这种情况下，群众就会把末路英雄视为自己的同类，为自己曾向一个已不复存在的权威低头哈腰而进行报复。</p><p>17.群体在智力上总是低于孤立的个人，但是从感情及其激发的行动这个角度看，群体可以比个人表现得更好或更差，这全看环境如何。一切取决于群体所接受的暗示具有什么性质。</p><p>18.群体因为夸大自己的感情，因此它只会被极端感情所打动。希望感动群体的演说家，必须出言不逊，信誓旦旦。夸大其辞、言之凿凿、不断重复、绝对不以说理的方式证明任何事情——这些都是公众集会上的演说家惯用的论说技巧。</p><p>19.令人难忘的历史事件，只是人类思想无形的变化造成的有形的后果而已。</p><p>20.孤立的个体具有控制自身反应行为的能力，而群体则不具备。</p><p>21.专横和偏执是一切类型的群体的共性。</p><p>22.影响民众想象力的，并不是事实本身，而是它们发生和引起注意的方式。</p><p>23.群体总是对强权俯首帖耳，却很少为仁慈善行感动！在他们看来，仁慈善良只不过是软弱可欺的代名词。</p><p>24.大众没有辨别能力，因而无法判断事情的真伪，许多经不起推敲的观点，都能轻而易举的得到普遍赞同!</p><p>25.群体盲从意识会淹没个体的理性，个体一旦将自己归入该群体，其原本独立的理性就会被群体的无知疯狂所淹没。</p><p>26.从长远看，不断重复的说法会进入我们无意识的自我的深层区域，而我们的行为动机正是在这里形成的。到了一定的时候，我们会忘记谁是那个不断被重复的主张的作者，我们最终会对它深信不移。</p><p>27.群体中的个人是沙中之沙，风可以随意搅动他们。</p><p>28.群体表现出来的感情不管是好是坏，其突出的特点就是极为简单而夸张。</p><p>29.但凡能够成就大业的领袖人物，他重要的品质不是博学多识，而是必须具备强大而持久的意志力，这是一种极为罕见，极为强大的品质，它足以征服一切。</p><p>30.文明向来只由少数知识贵族阶级而非群体来创造。</p><p>31.身为一位领袖，如果想要让自己创立的宗教或政治信条站住脚，就必须成功地激起群众想入非非的感情。</p><p>32.结群后，由于人多势众，个人会产生一种幻觉，感到自己力大无穷，不可战胜，好像没有什么事情是办不到的。</p><p>33.当一个人融入社会之中时，他便失去了自我。</p><p>34.在迫不得已的情况下，我们也许还是会愿意接受传统教育当中所有的弊端，因为尽管它只会培养一些被社会所抛弃的人、心怀不满的人，但起码，对冗繁知识的肤浅掌握，对成堆教科书的完美背诵，或许可以提高智力水平。但事实上它真的能提高智力吗？不可能！在生活中，判断力、经验、进取心和个性，这些才是取得成功的条件，这些都不是书本所能够给予的。书本是可供查询的有用字典，但倘若把这些冗长的词条都装在脑子里，那可是一点用都没有。</p><p>35.文明赖以形成的道德力量失去效力时，它的最终瓦解总是由无意识且野蛮的群体来完成的。</p><p>36.一切政治、神学或社会信条，要想在群众中扎根，都必须采取宗教的形式——能够把危险的讨论排除在外的形式。</p><p>37.群体精神最需要的不是自由而是服从。他们如此甘愿听从别人的意志，以至于只要有人自称是它们的主人，他们就会本能地听命于他。</p><p>38.尽管在那一天的那两个小时里他们做到了或者几乎做到了，到一个月以后他们却不再具备这种能力。他们无法再次通过考试。他们脑中不断丢失大量过于沉重的知识，而且没有新的知识来填充。他们的思想活力开始衰退，促进成长的才能渐渐干涸，这时一个得到充分发展的人诞生了，但此时的他早已疲惫不堪。结婚过上安定的生活，陷入某种循环，并永无止境地重复下去；他将自己封闭在狭隘的工作中，尽职尽责，仅此而已。他们最终变为了平庸之辈。</p><p>39.个人一旦融入群体，他的个性便会被湮没，群体的思想便会占据绝对的统治地位，而与此同时，群体的行为也会表现出排斥异议，极端化、情绪化及低智商化等特点。进而对社会产生破坏性的影响。</p><p>40.所有时代和所有国家的伟大政客，包括最专横的暴君，也都把群众的想象力视为他们权力的基础，他们从来没有设想过通过与它作对而进行统治。要想掌握这种本领，万万不可求助于智力或推理，也就是说，绝对不可以采用论证的方式。</p><p>41.群体的叠加只是愚蠢的叠加，而真正的智慧被愚蠢的洪流淹没。</p><p>42.人们经常说起那家大众剧院，它只演令人压抑的戏剧，散场后，必须保护扮演叛徒的演员，免得他遭到观众的暴打。他所犯的罪行，当然是想象出来的，引起了群众的巨大愤怒。我觉得这是群体精神状态最显著的表现之一，这清楚地说明，要给他们什么暗示是一件多么容易的事情。对他们来说，假与真几乎同样奏效。他们明显地表现出真假不分的倾向。</p><p>43.各种制度并没有固定的优点，就它们本身而言，它们无所谓好坏。因为在特定的时刻对一个民族有益的制度，对另一个民族也许是极为有害的 。</p><p>44.群体也许永远是无意识的，但这种无意识本身，可能就是它力量强大的秘密之一。在自然界，绝对服从本能的生物，其行为会复杂得让我们不敢相信。理智是人类新近才有的东西，太不完美了，不能向我们揭示无意识的规律，更不能替代它。在我们的行为举止中，无意识部分占的比重很大，理智所占的比例却很小。无意识现在仍作为未知的力量在起作用。</p><p>45.到了一定的时候我们不会记得那个不断被重复的主张的人是谁，我们最终会对它深信不疑，广告能有令人吃惊的威力，这就是原因 。</p><p>46.教育既不会让人更道德，同样不会使他更幸福，它既不能将他的本能改变 ，也不能将他天生的热情改变，而且有在进行不良引导后，它的害处远大于好处。</p><p>47.单独一个人必须要为他的行为承担责任——法律上或者道德上。但是，群体则不然，群体不需要承担任何责任，群体就是责任，群体就是道德，群体就是法律，群体就是道德，群体的行为自然是合理的。</p><p>48.名望的产生与若干因素有关，而成功永远是其中最重要的一个。</p><p>49.学习课程，把一种语法或一篇纲要牢记在心，重复得好，模仿也出色——这实在是一种十分可笑的教育方式，它的每项工作都是一种信仰行为，即默认教师不可能犯错误。这种教育的唯一结果，就是贬低自我，让我们变得无能。</p><p>50.民众的想象力是政客的权力基础。</p><p>51.在决定人们历史地位上起着更大作用的，不是他们的“真实”面目，而是后人对他们的认识和感受。</p><p>52.群体会让每个人在其中的错误缩小，同时让每个人的恶意被无限放大。</p><p>54.束缚个人行为的责任感一消失，人便会随心所欲，肆意妄为。</p><p>55.群体的无意识行为取代了个体有意识的行为，这是现时代最显著的特征之一。</p><p>56.偶像崇拜的五大标识：<br>第一，偶像总是凌驾于信徒，处于高高在上的地位，这一点有着决定性地作用。<br>第二，信徒总是盲目服从偶像的命令。<br>第三，信徒没有能力，也不愿意对偶像规定的信条进行讨论。<br>第四，信徒有着狂热的愿望，希望把偶像的信条广加传播。<br>第五，信徒倾向于把不接受它们的任何人视为仇敌。<br>当群体符合第一条，其形式就等同于宗教，而这种情感就变成了宗教信仰。<br>对群体来说，也许最不合理的才是最合理的选择</p><p>57.群众日益被大众文化所湮没，这种文化把平庸低俗当作最有价值的东西。</p><p>58.所以不要轻易地成为集体的一份子，这样很容易被别有用心的人利用，即使你以为自己只不过是随声附和了一下而已，实际上你已经成了帮凶。</p><p>59.群体的夸张倾向只作用于感情，对智力不起任何作用。</p><p>60.群体不善推理，却又急于行动。</p><h3 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h3><h3 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h3><h3 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Raw数据相关概念</title>
      <link href="/2019/09/15/ISP_RawData/"/>
      <url>/2019/09/15/ISP_RawData/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Raw数据相关概念<br><a id="more"></a></p><h2 id="什么是“RAW”？"><a href="#什么是“RAW”？" class="headerlink" title="什么是“RAW”？"></a>什么是“RAW”？</h2><p>维基百科的字面解释是：原始图像文件包含从数码相机、扫描器或电影胶片扫描仪的图像传感器所处理数据。RAW文件包含创建一个可视图像所必须的相机传感器数据信息。</p><p>通俗讲就是摄像机、相机拍摄并记录下来的带有原始信息的视频或者图片，包含传感器元数据、传感器尺寸、颜色属性、配置文件等等信息，以方便后期对视频及图片做更大幅度的处理。几乎未经压缩，也完全没进行各种处理，与记录拍摄时“用户的相机设置信息”数据被一同保存下来。</p><p>既然是原始文件，一定很大，对传输带宽、存储空间都有特别的要求，而且每个摄像机、照相机厂家对自己的原始文件（RAW）开放程度、记录方式等要求都不一样。</p><h2 id="Raw格式"><a href="#Raw格式" class="headerlink" title="Raw格式"></a>Raw格式</h2><p>Q:RAW格式是一种非压缩格式吗？</p><p>A:有一部分是。有损压缩表示在压缩处理过程中，部分图像数据将会被丢弃。但是抛弃这些信息后，能得到比无损压缩小得多的文件。有些RAW格式，例如尼康公司的.NEF格式就能通过这种形式进行保存，从而可以得到占据空间更小的文件。但这样做会造成画质的下降，在天空等影调过渡较为平滑的部分表现得尤为明显。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/Blog_Raw_1.gif" alt></p><p>所有JPEG文件均使用有损压缩算法。JPEG文件在保存时会提供一个画质设置供我们选择，我们选择的画质越低，丢弃的图像数据越多，得到的图像文件也就越小。反之，画质较高的JPEG文件和画质较低的相比文件尺寸也更大一些。</p><h2 id="Raw数据位数"><a href="#Raw数据位数" class="headerlink" title="Raw数据位数"></a>Raw数据位数</h2><p>Q:RAW文件的8位、12位、14位、16位等有什么区别？</p><p>A:我们拍摄的每张照片均由从黑到白之间的不同影调组成，而“位”则表示黑白之间影调范围的多少。位越大，黑白之间的影调就越丰富。所有的JPEG格式文件都是8位图像文件，因此在黑白之间只包含256级影调变化。而RAW格式文件大多为12位或14位，在黑白之间至少包含4096级影调变化。普遍观点认为，想表达柔和、自然的画面至少需要250级左右的影调，所以包含256级影调变化的8位图像文件能满足大多数情况下的需要。</p><p>单反/无反相机上的 RAW 和手机上的 RAW,最大的区别在于描述明暗数据的位深不同。手机的CMOS考虑到成本和功耗，一般使用的是<code>10bit</code>的输出模式，部分单反相机则可以输出<code>12bit</code>，安防类相机可以输出<code>16bit</code>。输出<code>16bit</code>的相机可以展现更细腻的色调和颜色，后期修改空间更大。</p><h2 id="RAW格式的优缺点"><a href="#RAW格式的优缺点" class="headerlink" title="RAW格式的优缺点"></a>RAW格式的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*转换结果画质更高。</span><br><span class="line"></span><br><span class="line">*与生俱来的非破坏性调整能力不会造成任何图像信息的损失。</span><br><span class="line"></span><br><span class="line">*和标准JPEG格式相比高光、阴影细节更加丰富。</span><br><span class="line"></span><br><span class="line">*进行色彩、白平衡、锐化等后期调整时范围更大。</span><br></pre></td></tr></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*和JPEG相比文件更大。</span><br><span class="line"></span><br><span class="line">*写入速度慢，会显著影响连拍速率。</span><br><span class="line"></span><br><span class="line">*编辑处理耗时更长。</span><br><span class="line"></span><br><span class="line">*交流、输出前需将其转换为JPEG或其他格式。</span><br><span class="line"></span><br><span class="line">*RAW文件的调整需要一定时间学习。</span><br></pre></td></tr></table></figure><p>声明：</p><p>此资料部分转载自网络，仅供学习参考。</p><h1 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h1><h1 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h1><h1 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> ISP </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3D降噪，视频实时降噪利器</title>
      <link href="/2019/09/12/ISP_3DNR/"/>
      <url>/2019/09/12/ISP_3DNR/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>3D降噪，视频实时降噪利器<br><a id="more"></a></p><p>3D降噪原理是对图像中的运动物体采取2D降噪，静止部分（称为背景）采取3D降噪以防止运动物体模糊（blur）。</p><h2 id="1）第一步为运动估计"><a href="#1）第一步为运动估计" class="headerlink" title="1）第一步为运动估计"></a>1）第一步为运动估计</h2><p>   在参考帧（为前一帧已经过降噪的图像）中搜索和当前帧中16*16当前块相近的参考块，其中最相近的块为匹配块。<br>   根据匹配块，获得运动向量（motion vector）。</p><p>   为减小计算，一般仅在以当前块为中心的一个小范围内搜索参考块，如在20*20的小范围内。</p><h2 id="2）滤波模式判断"><a href="#2）滤波模式判断" class="headerlink" title="2）滤波模式判断"></a>2）滤波模式判断</h2><p>   设置两个门限值：</p><ul><li>参考块和当前块差值残差阈值TH1 （通常为一个较小的值，如 5 ~ 20之间）</li><li><p>运动向量阈值TH2 （该阈值通常在+/-1 ~  +/- 3）</p><p>a）若每一像素点处的残差小于TH1，且参考块和当前块的运动向量值小于TH2，则可认为当前块为背景，即非运动物体。滤波策略是：使能2D滤波，同时使能3D滤波。3D滤波即当前块和参考块的平均。<br>b）若残差大于TH1，则，判断为非背景，只使用2D滤波。<br>c）若残差小于TH1，但运动向量大于TH2，则判断为非背景，只使用2D滤波（因背景几乎是不动的）。</p></li></ul><h2 id="3）梯度计算、边缘判断和快效应改善"><a href="#3）梯度计算、边缘判断和快效应改善" class="headerlink" title="3）梯度计算、边缘判断和快效应改善"></a>3）梯度计算、边缘判断和快效应改善</h2><p>   计算水平和垂直方向相邻像素的差值，获得一个梯度矩阵。<br>   比较两个方向的梯度大小。若梯度超过设定的阈值，则以值较大的一个方向来计算该点的像素值：<br>   pxl_new =( (a+4<em>pxl_old+4</em>c + d)/10  + e )/2</p><p>声明：<br>版权声明：本文为CSDN博主「tbzj_2000」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/tbzj_2000/article/details/82466180" target="_blank" rel="noopener">https://blog.csdn.net/tbzj_2000/article/details/82466180</a></p><p>此资料部分转载自网络，仅供学习参考。</p><h1 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h1><h1 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h1><h1 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> ISP </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解同为4800W像素的相机传感器，三星GM1和索尼IMX586区别在哪里？</title>
      <link href="/2019/09/07/ISP_4800Wsensor/"/>
      <url>/2019/09/07/ISP_4800Wsensor/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>详解同为4800W像素的相机传感器，三星GM1和索尼IMX586区别在哪里？<br><a id="more"></a></p><p>数字影像之父Bryce Bayer基于RGB模式，通过在感光元件前加上一个滤镜的方法终于实现了彩色照片。Bayer滤镜跨出了照片从黑白到彩色的一大步，但是对于挑剔的人眼来说，每个像素只有一个颜色是远远不够的，所以还需要后期色彩还原去猜色，最后形成一张完整的彩色照片。这一整套流程，就叫做Bayer阵列。数码相机包括手机拍摄照片的大致流程：感光元件→Bayer滤镜→色彩还原。可以看下图</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_4800W_sensor.png" alt></p><p>IMX586是索尼适用于手机的全新堆栈式CMOS感光元件，这颗感光元件有效像素高达4800万。通过Quad Bayer的排列结构变换，合成之后能够将感光度提升至1.6μm像素尺寸的水平。就是说，搭载IMX586传感器的手机，正常模式下是4800万像素，在使用夜景模式时，则会转换成高曝光、低噪点的拍照模式。</p><p>IMX586最大的特色就是使用 Quad Bayer 阵列，不同于经典的Bayer阵列是以2x2共四格分散RGB的方式成像，Quad Bayer 阵列扩大到了4x4，并且以2x2的方式将RGB相邻排列。在使用搭载IMX586传感器手机拍照的时候，Quad Bayer 阵列会让每一个像素点就近计算周围的颜色，并且通过独立的信号处理变换像素结构，从而实时输出4800万像素的高清照片。换句话说，IMX586的4800万个感光单元每个都能独立显示并且输出数据。4800万像素的照片是硬件直出的，无需软件插值。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_4800W_1.jpg" alt></p><p>三星GM1的输出方式如下图所示，阵列也扩大到了4x4，但是和IMX586相比，每个2x2阵列只能识别同样的颜色，且只能一起输出数据。也就是说，GM1传感器直出的照片素质跟1200万传感器输出的图像结果大体相同。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_4800W_2.jpg" alt></p><h3 id="索尼imx586及更新的imx600都是可以直出4800W像素的传感器，且用在华为的高端旗舰上，三星GM1是不能直出4800W像素的，用在中端手机终端上，宣传4800W是一个吆喝点。"><a href="#索尼imx586及更新的imx600都是可以直出4800W像素的传感器，且用在华为的高端旗舰上，三星GM1是不能直出4800W像素的，用在中端手机终端上，宣传4800W是一个吆喝点。" class="headerlink" title="索尼imx586及更新的imx600都是可以直出4800W像素的传感器，且用在华为的高端旗舰上，三星GM1是不能直出4800W像素的，用在中端手机终端上，宣传4800W是一个吆喝点。"></a>索尼imx586及更新的imx600都是可以直出4800W像素的传感器，且用在华为的高端旗舰上，三星GM1是不能直出4800W像素的，用在中端手机终端上，宣传4800W是一个吆喝点。</h3><p>声明：</p><p>此资料部分转载自网络，仅供学习参考。<br><a href="http://dy.163.com/v2/article/detail/E5KN3O100511HI42.html" target="_blank" rel="noopener">参考资料</a></p><h1 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h1><h1 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h1><h1 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> ISP </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BM3D算法的坑</title>
      <link href="/2019/09/07/ISP_BM3D/"/>
      <url>/2019/09/07/ISP_BM3D/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>BM3D算法的坑<br><a id="more"></a></p><p>声明：</p><p>此资料部分转载自网络，仅供学习参考。</p><h1 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h1><h1 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h1><h1 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> ISP </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XXXTENTACION，音乐使之重生</title>
      <link href="/2019/08/31/RIP_XXXTENTACION/"/>
      <url>/2019/08/31/RIP_XXXTENTACION/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>XXXTENTACION，音乐使之重生<br><a id="more"></a></p><iframe src="//player.bilibili.com/player.html?aid=56015687&cid=97913257&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>熟悉的街头却变成炼狱，愿你在另一个地方重获新生。Rest In Peace</p><p>XXXTentacion - 《Look At Me》</p><p>look at me, FXXK me!</p><iframe src="//player.bilibili.com/player.html?aid=19563684&cid=31901784&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="//music.163.com/outchain/player?type=0&id=2966459451&auto=1&height=430"></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> Music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ISP图像处理——白平衡AWB</title>
      <link href="/2019/08/25/ISP_%E7%99%BD%E5%B9%B3%E8%A1%A1AWB/"/>
      <url>/2019/08/25/ISP_%E7%99%BD%E5%B9%B3%E8%A1%A1AWB/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>ISP图像处理——白平衡AWB<br><a id="more"></a></p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>　　白平衡是一个很抽象的概念，最通俗的理解就是让白色所成的像依然为白色，那其他景物的影像就会接近人眼的色彩视觉习惯。调整白平衡的过程叫做白平衡调整，白平衡调整在前期设备上一般有三种方式：预置白平衡、手动白平衡调整和自动跟踪白平衡调整。通常按照白平衡调整的程序，推动白平衡的调整开关，白平衡调整电路开始工作，自动完成调校工作，并记录调校结果。</p><h2 id="色温曲线"><a href="#色温曲线" class="headerlink" title="色温曲线"></a>色温曲线</h2><p>色温的概念,并且知道sensor原始图像中的白色如果不经AWB处理,在高色温(如阴天)下偏蓝,低色温下偏黄,如宾馆里的床头灯(WHY!OTZ) (如下图).</p><p>  <img src="https://img-blog.nos-eastchina1.126.net/blog/BLOG_AWB_1.jpeg" alt></p><h2 id="白平衡调整"><a href="#白平衡调整" class="headerlink" title="白平衡调整"></a>白平衡调整</h2><p>在生活中日光的色温是不断变化的，可以说没有两个地方的色温会完全一样，不同的地域、季节、地面白平衡环境、天气、早晚等等都会对色温造成影响，还有大量的人工光源，色温也不尽相同。摄像师调整白平衡的方法大体分粗调、精细调整和自动跟踪(ATW)三种：粗调指在预置情况下改变色温滤光片，使色温接近到3200K的出厂设置;精细调整是指在色温滤光片的配合下通过摄像机白平衡调整功能，针对特定环境色温得到一个更为精确的调整结果;自动跟踪是指依靠摄像机的自动跟踪功能(ATW)，摄像机自身根据画面的色温变化随时调整。</p><p>流程原理很简单:</p><blockquote><p>1,在各个色温下(2500~7500)拍几张白纸照片,假设拍6张(2500,3500…7500),可以称作色温照.<br>2,把色温照进行矫正,具体是对R/G/B通道进行轿正,让偏色的白纸照变成白色,并记录各个通道的矫正参数.<br> 实际上只矫正R和B通道就可以,这样就得到了6组矫正参数(Rgain,Bgain).<br>3,上面是做前期工作,只要知道当前场景是什么色温,再轿正一下就可以了</p></blockquote><p>所以,<font size="5" color="red">AWB算法的核心就是判断图像的色温</font></p><p>之前拍了6张色温照以及6组矫正参数. 插值一下可以得到无数个值,我们把点连成线, 得到了色温曲线.大概是下面这个样子.<br><img src="http://img.blog.csdn.net/20140808093139634" alt></p><p>上面提到了三个值<font color="red">(RG,BG,色温)</font>,这应该是个三维的.没关系,我们再来一条RG跟色温的曲线,这样只要知道色温,就知道RG,知道RG,就知道BG,知道RG,BG就能轿正了</p><p> <img src="http://img.blog.csdn.net/20140808093207074?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p3eGlhb3poZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><p>至此,我们的前期工作已经全部做完了, 并得到了AWB的色温曲线,下一步只要计算得到当前色温,顺藤摸瓜就能得到当前的矫正参数(Rgain,Bgain),那白平衡的工作就完成了</p><h3 id="2，色温计算"><a href="#2，色温计算" class="headerlink" title="2，色温计算"></a>2，色温计算</h3><p>本节主要讲解了白平衡算法中估算当前场景色温的流程.</p><h4 id="简述流程"><a href="#简述流程" class="headerlink" title="简述流程:"></a>简述流程:</h4><p>1, 取一帧图像数据,并分成MxN块,假设是25x25,并统计每一块的基本信息(,白色像素的数量及R/G/B通道的分量的均值).</p><p> <img src="https://img-blog.nos-eastchina1.126.net/blog/BLOG_AWB_2.jpeg" alt></p><p>2, 根据第1步中的统计值, 找出图像中所有的白色块,并根据色温曲线判断色温.</p><p>3, 至此,我们得出来了图像中所有的可能色温,如果是单一光源的话,可以取色温最多的,当作当前色温.</p><p>   比如25x25=625 个块中,一共找出了100个有效白色块, 里面又有80个白色块代表了色温4500左右, 那当前色温基本就是4500.</p><p>   根据4500色温得出的Rgain,Bgain来调整当前图像</p><p><img src="http://img.blog.csdn.net/20141029145413687?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p3eGlhb3poZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><h3 id="详解步骤"><a href="#详解步骤" class="headerlink" title="详解步骤"></a>详解步骤</h3><p>第1步, 计算每一块的基本信息.</p><p>关于白色像素统计,大家知道sensor原始图像是偏色的,怎么统计块中的白色点呢,那只有设置一个颜色范围,只要在范围中,就可以认为是白色像素,范围见下图:</p><p>统计白色像素个数的用处是,1,如果块中的白色像素太少,可以抛弃掉. 2,如果白色像素太多,多到每一个像素点都是,那也要抛弃掉,因为很可能在该区域过曝了</p><p>   接着把统计到的白色像素点R/G/B取均值, 并得到该block 的R/G,  B/G值</p><p>   至此,我们得到了每一块的白点数目及R/G,B/G的值. (请自动对应第1部分中色温曲线).</p><p>第二步 计算当前色温</p><p>   这个比较复杂, 大自然绚丽多彩,景色万千. 上一步中统计的”白色点”难免会有失误的地方,比较常见的如黄色皮肤容易被误判为低色温下的白点,淡蓝色的窗帘,容易被误判为高色温下的白点,一张图中既有白色,也有黄色,也有蓝色的时候,是不是感觉情况有点复杂,其它的大家可继续脑补.</p><p>   这时我们需要一定的策略来正确的判断出到哪个才是真的白.</p><p>   通常我们会把取到的白色块,计算一下到曲线的距离,再设置相应的权重.话不多说,上个图大家就都明白了.</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/BLOG_AWB_SE1.jpeg" alt></p><p>假设有上面这样一幅图,该图是在没有开AWB的前提下截取的,可以看到左边白色地方略有偏绿,当前色温是室内白炽灯,大概4000~5000k左右.(请忽略颜色不正的问题,我们在讨论白平衡)</p><p>下面我们就根据之前的统计信息和测量好的色温曲线进行白平衡矫正.</p><p>首先要找出白区,如下图:</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/BLOG_AWB_SE2.jpeg" alt></p><p>上面这个图中的数字标示出了检测到的白色区域,数字相同的表示一个白区,根据统计信息(白点数,rg/bg值)来区分的.可以看到有误判的地方,比如色卡左上第二块的肤色块.还有最右边从上面数第二块也是容易被判断成低色温白块的情况.</p><p>针对这种误判的情况,对不同块根据统计信息进行权重设置,以求让误判的区域对最终结果影响小一些.</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/BLOG_AWB_SE3.jpeg" alt></p><p>上面这个图标注了权重,基本是根据统计信息中白点数来确定的.可以看到图中一片白色被标识了高权重.其它情况被标识了低权重. 权重高低一是看块中白色点数量,二是看rg/bg到色温曲线的距离.</p><p>   通过上面两个图,大家就可以明显的找到白色区,并根据曲线来矫正,即使不通过曲线矫正,把白色区的r/g,b/g值向1趋近,让r=g=b,也会得到非常好的白平衡效果.如下图所示:</p><p><img src="http://img.blog.csdn.net/20141029145720071?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3p3eGlhb3poZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><p>至此,白平衡的基本流程就讲完了,有图有真相,大家一定看着也方便.</p><p>总结一下:第一次做白平衡,感觉理论很简单,不用什么基础也能看懂.实际算法调试时,可谓差之毫厘,失之千里.总是感觉不由自主就走上歪路.中间参考了大量资料,比如网上有许多基于色温/灰度世界/白点检测的白平衡算法,实际个人感觉应该把它们都结合起来,让算法强壮,健康才是我们想要的.</p><p>本文转载wzwxiaozheng的白平衡算法，主要包括两部分：色温曲线和色温计算。原文<a href="http://blog.csdn.net/wzwxiaozheng/article/details/38434391" target="_blank" rel="noopener">http://blog.csdn.net/wzwxiaozheng/article/details/38434391</a></p><p>声明：</p><p>此资料部分转载自网络，仅供学习参考。</p><h1 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h1><h1 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h1><h1 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> ISP </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安防行业监控摄像机的四大透雾技术</title>
      <link href="/2019/08/10/ISP_%E5%AE%89%E9%98%B2%E9%80%8F%E9%9B%BE/"/>
      <url>/2019/08/10/ISP_%E5%AE%89%E9%98%B2%E9%80%8F%E9%9B%BE/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>安防行业监控摄像机的四大透雾技术<br><a id="more"></a></p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>随着人类对自然的过度开发，环境问题日益凸显，近年来新增的问题之一则是雾霾的出现，雾霾对视频监控系统提出了严峻考验，主要表现在几个方面：物体表面的反射光由于大气粒子的散射而产生衰减，造成物体成像的亮度减弱，图像色彩暗淡;反射光经大气粒子前向散射作用参与其它像素点成像，导致图像模糊、分辨率下降;部分大气粒子的粒径较大，在成像过程中成为噪声，成像上布满糙点;与成像无关的自然光经过大气粒子的散射，进入图像传感器参与成像，造成图像饱和度、对比度降低及色调偏移，一些重要目标的细节更是难以辨识。</p><p>透雾技术主要分为四种：</p><h3 id="一代透雾技术-光学透雾"><a href="#一代透雾技术-光学透雾" class="headerlink" title="一代透雾技术-光学透雾"></a>一代透雾技术-光学透雾</h3><p>一般的可见光无法穿透云雾和烟尘，但近红外线可以穿透一定浓度的雾霭烟尘，根据波长不同需要对摄像机进行处理，以达到对其聚焦的目的,同时还需在摄像机上进行重新设计，来将这一频率的不可见光进行成像，由于这个不可见光没有对应的可见光色彩图，所以呈现的图像为黑白色。透过云雾、水气拍摄物体，相当于透过了两重透镜(水珠与实际透镜)，除了R光线可以正确聚焦在CCD成像面上，RGB光线中的GB均无法正常的投射在CCD成像面上，从而阻碍普通模式镜头从云雾、水气中得到正常、清晰的图像。</p><p>透雾镜头是指在红外光领域的长波长光线(700nm-950nm)的透过率非常高,且同时具备能控制这种高波长光线成像面(摄像机CCD靶面)功能的镜头.通过将这种镜头与高性能日夜两用摄像机配套使用,即使在雾气,灰尘,烟雾,小雨等可见光(彩色图像)环境中,普通镜头只能得到模模糊糊画面,有效观察距离大大缩短的恶劣条件下,也可拍摄到非常清晰,高对比度的黑白影像,提升远距离观察效果.<br>利用近红外光线可绕射微小颗粒原理，在薄雾天气采用近红外滤色片、镀膜技术及电子图像增强技术,能穿透薄雾.监控距离达到能见度的1.5倍以上,远距离全天候安全监控不再有盲点。</p><p>光学透雾就利用近红外线可以绕射微小颗粒的原理，实现准确快速聚焦。技术的关键主要在镜头和滤光片。 通过物理的方式，利用光学成像的原理提升画面清晰度。缺点是只能得到黑白监控画面。</p><p><a href="http://www.tpy888.cn/news/201301/21/71377_2.html" target="_blank" rel="noopener">参考文章</a></p><h3 id="二代透雾技术-数字透雾（算法）"><a href="#二代透雾技术-数字透雾（算法）" class="headerlink" title="二代透雾技术-数字透雾（算法）"></a>二代透雾技术-数字透雾（算法）</h3><p>为了弥补光学透雾的黑白成像，实现更好的透雾效果，同时减低成本，不少厂商为了进入民用市场开始进一步在透雾技术上做文章，从而出现了第二代透雾技术数字透雾。与光学透雾实现原理不同，数字透雾主要是通过对图像的二次处理，是一种算法矫正，强调图像当中某些感兴趣的特征，抑制不感兴趣的特征，使得图像的质量改善，信息量得到增强。数字算法透雾可根据物理上雾霾的形成模型，通过局部区域灰白程度判断雾霾的浓度，从而复原出清晰的无雾霾图像。采用算法透雾技术能够保留图像的原来色彩，在光学透雾的基础上大幅提升图像透雾效果。</p><p><a href="http://www.aomanhao.top/2018/07/16/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE/">我的文章-经典暗通道去雾</a><br><a href="https://github.com/AomanHao/Matlab-Image-Dehazing" target="_blank" rel="noopener">我的代码-图像去雾算法Matlab实现</a></p><h3 id="三代透雾技术-光电透雾"><a href="#三代透雾技术-光电透雾" class="headerlink" title="三代透雾技术-光电透雾"></a>三代透雾技术-光电透雾</h3><p>光电透雾是结合上述两种功能，通过机芯一体化通过内嵌的FPGA芯片和ISP/DSP进行运算处理实现彩色画面输出。一方面，该透雾技术可区分远景、近景，雾气浓淡等因素，选择透雾级别，可实现区域效果最佳，不同于过去对画面对比度整体的提高，且没有延时。另一方面，芯片的高速运算必将产生噪声点，夜间光照不足时影响尤为突出，所以一体机芯普遍需要采用CCD传感器和大光圈镜头，以达到良好的低照效果。它是目前市场上透雾效果最好的技术。</p><p>前两种透雾技术各有千秋，却也都存在一定的缺陷，且具有互补性，于是第三代透雾技术便将前两代透雾技术进行融合，打造“光学+算法”的透雾技术，配置低照度性能更好的感光芯片和专门的透雾滤光片，同时配合光学透雾镜头增加了相应的算法透雾，成为目前市场上透雾效果最好的技术。</p><p><a href="http://www.tpy888.cn/news/201512/15/86271.html" target="_blank" rel="noopener">参考文章</a></p><h3 id="假透雾"><a href="#假透雾" class="headerlink" title="假透雾"></a>假透雾</h3><p>这主要是通过人为调节对比度、锐度、饱和度、亮度等数值，或做一些滤镜切换装置，让图像重点突出，从而改善主观视觉效果。 缺点是不能对景物重新进行聚焦，难以满足视觉体验。<br>随着工业的发展以及其对气候的影响，雾霾越来越成为一种常见的天气现象，这对户外应用的监控系统的画面品质造成很大的影响。而去雾技术能够从多个角度提升视频监控的质量，可以用于各种有雾天气条件的透雾处理;能明显提升图像的对比度、使图像变通透、清晰;能够显著增强图像的细节信息，使原来被隐藏的图像细节被充分展示;能够提升图像的饱和度，使图像色彩鲜艳活泼、生动，透雾处理后的图像保持准确的色调、自然的外观，因而获得了良好的图像质量与视觉感受</p><h1 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h1><h1 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h1><h1 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> ISP </tag>
            
            <tag> 图像处理 </tag>
            
            <tag> 安防 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客迁移到托管平台Netlify</title>
      <link href="/2019/07/23/hexo_%E8%BF%81%E7%A7%BB%E6%89%98%E7%AE%A1NetLify/"/>
      <url>/2019/07/23/hexo_%E8%BF%81%E7%A7%BB%E6%89%98%E7%AE%A1NetLify/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Hexo个人博客迁移到托管平台Netlify<br><a id="more"></a></p><p>Netlify是一家国外的静态网站的托管平台，提供免费的https，自动化部署和升级，可以监控GitHub、GitLab或者Bitbucket做到自动更新发布。</p><font color="DeepPink" size="6">个人体会访问速度不是很理想，不如部署在GitHub上。</font><h3 id="一、使用github或者gitlab登陆netlify"><a href="#一、使用github或者gitlab登陆netlify" class="headerlink" title="一、使用github或者gitlab登陆netlify"></a>一、使用github或者gitlab登陆netlify</h3><p>打开<a href="https://app.netlify.com/" target="_blank" rel="noopener">Netlify网站</a><br>然后点击右上角Sign up注册账号，选择GitHub关联登录。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5ub3MtZWFzdGNoaW5hMS4xMjYubmV0L2Jsb2cvaGV4b19uZXRsaXR5X3N0ZXAxLnBuZw" alt></p><h3 id="二、根据github-gitlab仓库创建网站"><a href="#二、根据github-gitlab仓库创建网站" class="headerlink" title="二、根据github/gitlab仓库创建网站"></a>二、根据github/gitlab仓库创建网站</h3><p>创建站点，点击New site from Git按钮：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5ub3MtZWFzdGNoaW5hMS4xMjYubmV0L2Jsb2cvaGV4b19uZXRsaXR5X3N0ZXAwLjUuanBn" alt></p><h3 id="三、选择代码托管空间"><a href="#三、选择代码托管空间" class="headerlink" title="三、选择代码托管空间"></a>三、选择代码托管空间</h3><p>可以选择GitHub、GitLab或者BitBucket。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5ub3MtZWFzdGNoaW5hMS4xMjYubmV0L2Jsb2cvaGV4b19uZXRsaXR5X3N0ZXAyLnBuZw" alt></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5ub3MtZWFzdGNoaW5hMS4xMjYubmV0L2Jsb2cvaGV4b19uZXRsaXR5X3N0ZXAzLnBuZw" alt></p><h3 id="四、选择要部署的项目仓库"><a href="#四、选择要部署的项目仓库" class="headerlink" title="四、选择要部署的项目仓库"></a>四、选择要部署的项目仓库</h3><p>点击你已经建好的库，选好分支（默认master即可），然后点击“Deploy site”，系统就会自动编译你的静态页面了。网站的控制台去进行设置域名绑定和https申请即可，部署成功后会自动进行cdn加速的。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5ub3MtZWFzdGNoaW5hMS4xMjYubmV0L2Jsb2cvaGV4b19uZXRsaXR5X3N0ZXA0LnBuZw" alt></p><p>之后我们就不需要这么麻烦了以后编辑好文章之后，只需要执行 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 即可自动化部署，然后要记得将我们的项目文件 push 到 github 的 master分支上去哦。</p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><h3 id="网站引导"><a href="#网站引导" class="headerlink" title="网站引导"></a>网站引导</h3><p>Netlify网站 提供的网站域名是该网站的二级域名，看起来不太美观，如果你拥有自己的域名，可以通过绑定自己的域名然后跳转到Netlify的二级域名。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5ub3MtZWFzdGNoaW5hMS4xMjYubmV0L2Jsb2cvaGV4b19uZXRsaXR5X3N0ZXA3LmpwZw" alt></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWctYmxvZy5ub3MtZWFzdGNoaW5hMS4xMjYubmV0L2Jsb2cvaGV4b19uZXRsaXR5X3N0ZXA4LnBuZw" alt></p><h3 id="域名控制台"><a href="#域名控制台" class="headerlink" title="域名控制台"></a>域名控制台</h3><p>添加两条解析记录，一条A记录，一条CNAME记录。A记录的记录值IP是你的<code>https://xxx.netlify.com</code>域名对应的<code>ip</code>，这个可以网上查。<br>CNAME记录的记录值是<code>https://xxx.netlify.com</code>的<code>xxx.netlify.com</code>值，添加完解析后就可将你的域名绑定到<code>Netlify</code>了。</p><h2 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h2><p>想要部署在Netlify的初衷是部署在Coding上需要备案，且已经被公安催了要备案，需要一个不用备案的代码托管网站。在网站部署操作不是很麻烦，但是实际部署下来访问速度不是很理想，不如部署在GitHub上。纠结一下</p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> Netlify </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理评价指标_划分系数Vpc划分熵Vpe</title>
      <link href="/2019/07/09/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87_VpcVpe/"/>
      <url>/2019/07/09/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87_VpcVpe/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>图像处理评价指标_划分系数Vpc划分熵Vpe</p><a id="more"></a><h2 id="划分系数划分熵"><a href="#划分系数划分熵" class="headerlink" title="划分系数划分熵"></a>划分系数划分熵</h2><p>评价指标划分系数<code>Vpc</code>和划分熵<code>Vpe</code>能够反映分割矩阵的模糊程度，<code>Vpc</code>数值越大，分割矩阵的模糊性越小，分割效果越好；<code>Vpe</code>数值越小，像素分类越准确，分割效果越好。</p><p>（1）划分系数Vpc评价指标的定义为：</p><script type="math/tex; mode=display">V_{pc} = \sum_{i=1}^{n}\sum_{k=1}^K u_{ki}^2/n</script><p>其中，$K$表示聚类数目，$u_{ki}$ 是隶属度函数，表示第$i$个像素属于第$k$分类的隶属度，$n$是像素总数。</p><p>（2）划分熵Vpe评价指标的定义为： </p><script type="math/tex; mode=display">V_{pe} = -\sum_{i=1}^{n}\sum_{k=1}^K u_{ki}*log(u_{ki})/n</script><h2 id="Matlab代码"><a href="#Matlab代码" class="headerlink" title="Matlab代码"></a>Matlab代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function [V_pc,V_pe_10,V_pe_e]=V_pcpe(u)</span><br><span class="line">%评价函数指标 划分系数V_pc，划分熵V_pe</span><br><span class="line"></span><br><span class="line">%% u是隶属度函数</span><br><span class="line">[m,n]=size(u);</span><br><span class="line">%% 划分系数V_pc</span><br><span class="line">V_pc = sum(sum(u.^2))/n;</span><br><span class="line"></span><br><span class="line">%% 划分熵V_pe</span><br><span class="line">V_pe_10=-sum(sum(u.*log10(u)))/n;</span><br><span class="line">V_pe_e=-sum(sum(u.*log(u)))/n;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> 图像分割 </tag>
            
            <tag> 评价指标 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理_ISP_坏点矫正</title>
      <link href="/2019/07/08/ISP_%E5%9D%8F%E7%82%B9%E7%9F%AB%E6%AD%A3/"/>
      <url>/2019/07/08/ISP_%E5%9D%8F%E7%82%B9%E7%9F%AB%E6%AD%A3/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>图像处理<em>ISP</em>坏点矫正<br><a id="more"></a></p><h2 id="1-坏点介绍"><a href="#1-坏点介绍" class="headerlink" title="1 坏点介绍"></a>1 坏点介绍</h2><p>图像坏点(Bad pixel) : 图像传感器上光线采集点(像素点)所形成的阵列存在工艺上的缺陷，或光信号进行转化为电信号的过程中出现错误，从而会造成图像上像素信息错误，导致图像中的像素值不准确，这些有缺陷的像素即为图像坏点。</p><p>由于来自不同工艺技术和传感器制造商，尤其对一些低成本、消费品的sensor来说，坏点数会有很多。另外，sensor在长时间、高温环境下坏点也会越来越多，从而破坏了图像的清晰度和完整性。坏点校正的目的就是修复这类问题，通常坏点分为一下两种：</p><pre><code>    (1) 静态坏点：分为静态亮点和静态暗点。         静态亮点：一般来说像素点的亮度值是正比于入射光的，而亮点的亮度值明显大于入射光乘以相应比例，并且随着曝光时间的增加，该点的亮度会显著增加；         静态坏点：无论在什么入射光下，该点的值接近于0;    (2) 动态坏点：在一定像素范围内，该点表现正常，而超过这一范围，该点表现的比周围像素要亮。与sensor 温度、增益有关，sensor 温度升高或者gain 值增大时，动态坏点会变的更加明 显；</code></pre><h2 id="2-坏点校正成因"><a href="#2-坏点校正成因" class="headerlink" title="2 坏点校正成因"></a>2 坏点校正成因</h2><p>　　 为什么图像处理的过程中需要做坏点校正，而且坏点校正(DPC)通常在ISP的pipeline靠前位置？主要有如下原因：</p><pre><code>    (1) 如果图像中存在坏点的话，ISP后续进行插值和滤波处理时，会影响周围的像素点值，因此需要在插值和滤波之前对坏点进行校正 ;    (2) 图像存在坏点比较多或动态坏点很多的情况下，会造成图像的边缘出现伪色彩的情况，这种现象不但影响图像的清晰度，而且会影响边缘的色彩;    (3) 坏点也会造成图像部分pixel闪烁的现象;</code></pre><h2 id="3-坏点校正策略"><a href="#3-坏点校正策略" class="headerlink" title="3 坏点校正策略"></a>3 坏点校正策略</h2><p>图像的坏点校正(DPC)通常在Bayer域(灰度图原理一致)进行。若Bayer域为R/G/B三通道，则分别进行坏点校正;若Bayer域为RGBIR格式，则分别对R/Gr/Gb/B四通道独立进行。动态坏点校正和静态坏点校正是两个相互独立的过程，可以同时开启，也可以只开启一个，视需要设置。</p><pre><code>    静态坏点校正：基于已有的静态坏点表，比较当前点的坐标是否与静态坏点表中的某个坐标一致，若一致则判定为坏点，然后再计算校正结果对其进行校正。一般情况下，每个sensor的坏点都不一样，需要sensor厂商给出每个sensor的静态坏点表，但是出于成本的考虑，很多sensor厂商并没有给出，而用户校正的话只能一个一个对其进行校正，因此对于一些低成本的sensor，静态坏点校正的实用性不是很强。另外，由于在硬件设计的时候需要占用大量的memory，考虑到芯片面积以及一些其他原因，因此静态坏点有大小的限制，不可以无限制的校正。    动态坏点校正：可以实时的检测和校正sensor 的亮点与暗点，并且校正的坏点个数不受限制。动态坏点校正相对静态坏点校正具有更大的不确定性。动态dpc可以分为两个步骤，分别为坏点检测和坏点校正。</code></pre><h2 id="4-源码实现-Matlab-Version"><a href="#4-源码实现-Matlab-Version" class="headerlink" title="4 源码实现(Matlab Version)"></a>4 源码实现(Matlab Version)</h2><p>该算法是动态坏点校正策略实现，算法使用梯度百分比的方式去检测坏点，检测到坏点之后通过中值滤波进行坏点校正，最终通过alpha混合的方式计算出最终的计算结果。代码如下：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">close all;</span><br><span class="line">clear;</span><br><span class="line">clc;</span><br><span class="line">%% variable</span><br><span class="line">dp_slope = 0.02;</span><br><span class="line">dp_thresh = -0.3;</span><br><span class="line">r=3;        %Stencil radius</span><br><span class="line"></span><br><span class="line">%% read raw image</span><br><span class="line">% x = 0:255;</span><br><span class="line">% y = dp_slope * x + dp_thresh;</span><br><span class="line">% y(y&lt;0) = 0;</span><br><span class="line">% y(y&gt;1) = 1;</span><br><span class="line">% figure,</span><br><span class="line">% plot(0:255,y)</span><br><span class="line">% axis([0 255 0 1.5])</span><br><span class="line"></span><br><span class="line">[filename, pathname] = ...</span><br><span class="line">    uigetfile(&#123;&apos;*.raw&apos;&#125;, &apos;select picture&apos;);</span><br><span class="line">str = [pathname filename];</span><br><span class="line">fp = fopen(str, &apos;rb&apos;);</span><br><span class="line">[X,l] = fread(fp, [1920,1080], &apos;uint16&apos;);</span><br><span class="line">fclose(fp);</span><br><span class="line">img = uint8(X/16)&apos;;</span><br><span class="line">[height, width] = size(img);</span><br><span class="line">img_correct = zeros(height, width);</span><br><span class="line"></span><br><span class="line">%% Image edge extension</span><br><span class="line">imgn=zeros(height+2*r,width+2*r);</span><br><span class="line">imgn(r+1:height+r,r+1:width+r)=img;</span><br><span class="line">imgn(1:r,r+1:width+r)=img(1:r,1:width);                 </span><br><span class="line">imgn(1:height+r,width+r+1:width+2*r+1)=imgn(1:height+r,width:width+r);    </span><br><span class="line">imgn(height+r+1:height+2*r+1,r+1:width+2*r+1)=imgn(height:height+r,r+1:width+2*r+1);    </span><br><span class="line">imgn(1:height+2*r+1,1:r)=imgn(1:height+2*r+1,r+1:2*r);</span><br><span class="line"></span><br><span class="line">%% dp algorithm</span><br><span class="line">for i = r+1:height-r</span><br><span class="line">    for j = r+1:width-r</span><br><span class="line"></span><br><span class="line">        img_r = imgn(i-r:2:i+r, j-r:2:j+r);</span><br><span class="line">        data_r_center = img_r(r, r);</span><br><span class="line">        data_r_diff(1:r+1, 1:r+1) = abs(img_r - img_r(r,r));</span><br><span class="line">        data_r_sort = sort(img_r(:));</span><br><span class="line">        data_r_median = data_r_sort(r*2+1);</span><br><span class="line">        data_r_detect = data_r_diff * dp_slope + dp_thresh;</span><br><span class="line">        data_r_detect(data_r_detect &lt; 0) = 0;</span><br><span class="line">        data_r_detect(data_r_detect &gt; 1) = 1;</span><br><span class="line">        data_r_judge = sum(sum(data_r_detect &gt; 0));</span><br><span class="line">        data_r_weight = sum(sum(data_r_detect)) / data_r_judge;</span><br><span class="line">        if i-r == 18 &amp;&amp; j-r == 43</span><br><span class="line">            a = 1;</span><br><span class="line">        end</span><br><span class="line">        if data_r_judge &gt;= 7</span><br><span class="line">            data_r_correct = data_r_median * data_r_weight + (1-data_r_weight) * data_r_center;</span><br><span class="line">        else</span><br><span class="line">            data_r_correct = data_r_center;</span><br><span class="line">        end</span><br><span class="line">        img_correct(i-r, j-r) = data_r_correct;</span><br><span class="line"></span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">%% show</span><br><span class="line">figure,imshow(uint8(img));</span><br><span class="line">figure,imshow(uint8(img_correct));</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/qiqibaby/p/8597057.html" target="_blank" rel="noopener">参考文章</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ISP </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理评价指标_PSNR峰值信噪比和SSIM结构相似度</title>
      <link href="/2019/07/07/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87_PSNR_SSIM/"/>
      <url>/2019/07/07/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87_PSNR_SSIM/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>图像处理评价指标_PSNR峰值信噪比</p><a id="more"></a><h2 id="PSNR"><a href="#PSNR" class="headerlink" title="PSNR"></a>PSNR</h2><p><code>psnr</code>是“Peak Signal to Noise Ratio”的缩写，即峰值信噪比，是一种评价图像的客观标准。<br>为了衡量经过处理后的影像品质，我们通常会参考<code>PSNR</code>值来衡量某个处理程序能否令人满意。PSNR的单位是dB，数值越大表示失真越小。n为每像素的比特数，一般的灰度图像取8，即像素灰阶数为256。它是原图像与被处理图像之间的均方误差相对于<code>(2n-1)2</code>的对数值(信号最大值的平方，n是每个采样值的比特数)，所以PSNR值越大，就代表失真越少。<br>MATLAB用法的公式如下：</p><script type="math/tex; mode=display">PSNR=10*log10((2n-1)2/MSE)</script><p>其中，<code>MSE</code>是原图像与处理图像之间均方误差。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>PSNR是最普遍，最广泛使用的评鉴画质的客观量测法，不过许多实验结果都显示，PSNR的分数无法和人眼看到的视觉品质完全一致，有可能PSNR较高者看起来反而比PSNR较低者差。这是因为人眼的视觉对于误差的敏感度并不是绝对的，其感知结果会受到许多因素的影响而产生变化（例如：人眼对空间频率较低的对比差异敏感度较高，人眼对亮度对比差异的敏感度较色度高，人眼对一个区域的感知结果会受到其周围邻近区域的影响）。</p><h3 id="Matlab代码"><a href="#Matlab代码" class="headerlink" title="Matlab代码"></a>Matlab代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function [PSNR, MSE] = psnr(X, Y)</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><br><span class="line">%</span><br><span class="line">% 计算峰值信噪比PSNR</span><br><span class="line">% 将RGB转成YCbCr格式进行计算</span><br><span class="line">% 如果直接计算会比转后计算值要小2dB左右（当然是个别测试）</span><br><span class="line">%</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><br><span class="line"> if size(X,3)~=1   %判断图像时不是彩色图，如果是，结果为3，否则为1</span><br><span class="line">   org=rgb2ycbcr(X);</span><br><span class="line">   test=rgb2ycbcr(Y);</span><br><span class="line">   Y1=org(:,:,1);</span><br><span class="line">   Y2=test(:,:,1);</span><br><span class="line">   Y1=double(Y1);  %计算平方时候需要转成double类型，否则uchar类型会丢失数据</span><br><span class="line">   Y2=double(Y2);</span><br><span class="line"> else              %灰度图像，不用转换</span><br><span class="line">     Y1=double(X);</span><br><span class="line">     Y2=double(Y);</span><br><span class="line"> end</span><br><span class="line"> </span><br><span class="line">if nargin&lt;2    </span><br><span class="line">   D = Y1;</span><br><span class="line">else</span><br><span class="line">  if any(size(Y1)~=size(Y2))</span><br><span class="line">    error(&apos;The input size is not equal to each other!&apos;);</span><br><span class="line">  end</span><br><span class="line"> D = Y1 - Y2; </span><br><span class="line">end</span><br><span class="line">MSE = sum(D(:).*D(:)) / numel(Y1); </span><br><span class="line">PSNR = 10*log10(255^2 / MSE);</span><br></pre></td></tr></table></figure><h2 id="SSIM"><a href="#SSIM" class="headerlink" title="SSIM"></a>SSIM</h2><p>SSIM(structural similarity index)，结构相似性，是一种衡量两幅图像相似度的指标。该指标首先由德州大学奥斯丁分校的图像和视频工程实验室(Laboratory for Image and Video Engineering)提出。SSIM使用的两张图像中，一张为未经压缩的无失真图像，另一张为失真后的图像。</p><p>给定两个图像 x和y , 两张图像的结构相似性可按照以下方式求出</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/formula_SSIM.png" alt></p><p>其中，$μ_X$、$μ_Y$分别表示图像$X$和$Y$的均值，$σ_X$、$σ_Y$分别表示图像$X$和$Y$的方差，$σ_XY$表示图像$X$和$Y$的协方差。</p><p>SSIM分别从亮度、对比度、结构三方面度量图像相似性。<br><img src="https://img-blog.nos-eastchina1.126.net/blog/formula_SSIM_2.png" alt></p><p>$C1$、$C2$、$C3$为常数，为了避免分母为0的情况，通常取$C1=(K1∗L)2$,$ C2=(K2∗L)2$, $C3=C22$, 一般地K1=0.01, K2=0.03, L=255 则,</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/formula_SSIM_3.png" alt></p><h3 id="Matlab公式"><a href="#Matlab公式" class="headerlink" title="Matlab公式"></a>Matlab公式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br></pre></td><td class="code"><pre><span class="line">function [ssimval, ssimmap] = ssim(varargin)</span><br><span class="line">%SSIM Structural Similarity Index for measuring image quality</span><br><span class="line">%   SSIMVAL = SSIM(A, REF) calculates the Structural Similarity Index</span><br><span class="line">%   (SSIM) value for image A, with the image REF as the reference. A and</span><br><span class="line">%   REF can be 2D grayscale or 3D volume images, and must be of the same</span><br><span class="line">%   size and class. </span><br><span class="line">% </span><br><span class="line">%   [SSIMVAL, SSIMMAP] = SSIM(A, REF) also returns the local SSIM value for</span><br><span class="line">%   each pixel in SSIMMAP. SSIMMAP has the same size as A.</span><br><span class="line">%</span><br><span class="line">%   [SSIMVAL, SSIMMAP] = SSIM(A, REF, NAME1, VAL1,...) calculates the SSIM</span><br><span class="line">%   value using name-value pairs to control aspects of the computation.</span><br><span class="line">%   Parameter names can be abbreviated.</span><br><span class="line">%</span><br><span class="line">%   Parameters include:</span><br><span class="line">%</span><br><span class="line">%   &apos;Radius&apos;                 - Specifies the standard deviation of </span><br><span class="line">%                              isotropic Gaussian function used for</span><br><span class="line">%                              weighting the neighborhood pixels around a</span><br><span class="line">%                              pixel for estimating local statistics. This</span><br><span class="line">%                              weighting is used to avoid blocking</span><br><span class="line">%                              artifacts in estimating local statistics.</span><br><span class="line">%                              The default value is 1.5.</span><br><span class="line">% </span><br><span class="line">%   &apos;DynamicRange&apos;           - Positive scalar, L, that specifies the</span><br><span class="line">%                              dynamic range of the input image. By</span><br><span class="line">%                              default, L is chosen based on the class of</span><br><span class="line">%                              the input image A, as L =</span><br><span class="line">%                              diff(getrangefromclass(A)). Note that when</span><br><span class="line">%                              class of A is single or double, L = 1 by</span><br><span class="line">%                              default.</span><br><span class="line">% </span><br><span class="line">%   &apos;RegularizationConstants&apos;- Three-element vector, [C1 C2 C3], of </span><br><span class="line">%                              non-negative real numbers that specifies the</span><br><span class="line">%                              regularization constants for the luminance,</span><br><span class="line">%                              contrast, and structural terms (see [1]),</span><br><span class="line">%                              respectively. The regularization constants</span><br><span class="line">%                              are used to avoid instability for image</span><br><span class="line">%                              regions where the local mean or standard</span><br><span class="line">%                              deviation is close to zero. Therefore, small</span><br><span class="line">%                              non-zero values should be used for these</span><br><span class="line">%                              constants. By default, C1 = (0.01*L).^2, C2</span><br><span class="line">%                              = (0.03*L).^2, and C3 = C2/2, where L is the</span><br><span class="line">%                              specified &apos;DynamicRange&apos; value. If a value</span><br><span class="line">%                              of &apos;DynamicRange&apos; is not specified, the</span><br><span class="line">%                              default value is used (see name-value pair</span><br><span class="line">%                              &apos;DynamicRange&apos;).</span><br><span class="line">% </span><br><span class="line">%   &apos;Exponents&apos;               - Three-element vector [alpha beta gamma],</span><br><span class="line">%                               of non-negative real numbers that specifies</span><br><span class="line">%                               the exponents for the luminance, contrast,</span><br><span class="line">%                               and structural terms (see [1]),</span><br><span class="line">%                               respectively. By default, all the three</span><br><span class="line">%                               exponents are 1, i.e. the vector is [1 1</span><br><span class="line">%                               1].</span><br><span class="line">% </span><br><span class="line">%   Notes </span><br><span class="line">%   -----</span><br><span class="line">%   1. A and REF can be arrays of upto three dimensions. All 3D arrays</span><br><span class="line">%      are considered 3D volumetric images. RGB images will also be</span><br><span class="line">%      processed as 3D volumetric images.</span><br><span class="line">% </span><br><span class="line">%   2. Input image A and reference image REF are converted to</span><br><span class="line">%      floating-point type for internal computation.</span><br><span class="line">% </span><br><span class="line">%   3. For signed-integer images (int16), an offset is applied to bring the</span><br><span class="line">%      gray values in the non-negative range before computing the SSIM</span><br><span class="line">%      index.</span><br><span class="line">% </span><br><span class="line">%   Example</span><br><span class="line">%   ---------</span><br><span class="line">%   This example shows how to compute SSIM value for a blurred image given</span><br><span class="line">%   the original reference image.</span><br><span class="line">% </span><br><span class="line">%   ref = imread(&apos;pout.tif&apos;);</span><br><span class="line">%   H = fspecial(&apos;Gaussian&apos;,[11 11],1.5);</span><br><span class="line">%   A = imfilter(ref,H,&apos;replicate&apos;);</span><br><span class="line">% </span><br><span class="line">%   subplot(1,2,1); imshow(ref); title(&apos;Reference Image&apos;);</span><br><span class="line">%   subplot(1,2,2); imshow(A);   title(&apos;Blurred Image&apos;);</span><br><span class="line">% </span><br><span class="line">%   [ssimval, ssimmap] = ssim(A,ref);</span><br><span class="line">% </span><br><span class="line">%   fprintf(&apos;The SSIM value is %0.4f.\n&apos;,ssimval);</span><br><span class="line">% </span><br><span class="line">%   figure, imshow(ssimmap,[]);</span><br><span class="line">%   title(sprintf(&apos;SSIM Index Map - Mean SSIM Value is %0.4f&apos;,ssimval));</span><br><span class="line"></span><br><span class="line">%   Class Support</span><br><span class="line">%   -------------</span><br><span class="line">%   Input arrays A and REF must be one of the following classes: uint8,</span><br><span class="line">%   int16, uint16, single, or double. Both A and REF must be of the same</span><br><span class="line">%   class. They must be nonsparse. SSIMVAL is a scalar and SSIMMAP is an</span><br><span class="line">%   array of the same size as A. Both SSIMVAL and SSIMMAP are of class</span><br><span class="line">%   double, unless A and REF are of class single in which case SSIMVAL and</span><br><span class="line">%   SSIMMAP are of class single.</span><br><span class="line">% </span><br><span class="line">%   References:</span><br><span class="line">%   -----------</span><br><span class="line">%   [1] Z. Wang, A. C. Bovik, H. R. Sheikh, and E. P. Simoncelli, &quot;Image </span><br><span class="line">%       Quality Assessment: From Error Visibility to Structural</span><br><span class="line">%       Similarity,&quot; IEEE Transactions on Image Processing, Volume 13,</span><br><span class="line">%       Issue 4, pp. 600- 612, 2004.</span><br><span class="line">%</span><br><span class="line">%   See also IMMSE, MEAN, MEDIAN, PSNR, SUM, VAR.</span><br><span class="line"></span><br><span class="line">%   Copyright 2013-2014 The MathWorks, Inc. </span><br><span class="line"></span><br><span class="line">narginchk(2,10);</span><br><span class="line"></span><br><span class="line">[A, ref, C, exponents, radius] = parse_inputs(varargin&#123;:&#125;);</span><br><span class="line"></span><br><span class="line">if isempty(A)</span><br><span class="line">    ssimval = zeros(0, &apos;like&apos;, A);</span><br><span class="line">    ssimmap = A;</span><br><span class="line">    return;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if isa(A,&apos;int16&apos;) % int16 is the only allowed signed-integer type for A and ref.</span><br><span class="line">    % Add offset for signed-integer types to bring values in the</span><br><span class="line">    % non-negative range.</span><br><span class="line">    A = double(A) - double(intmin(&apos;int16&apos;));</span><br><span class="line">    ref = double(ref) - double(intmin(&apos;int16&apos;));</span><br><span class="line">elseif isinteger(A)</span><br><span class="line">    A = double(A);</span><br><span class="line">    ref = double(ref);</span><br><span class="line">end</span><br><span class="line">      </span><br><span class="line">% Gaussian weighting function</span><br><span class="line">gaussFilt = getGaussianWeightingFilter(radius,ndims(A));</span><br><span class="line"></span><br><span class="line">% Weighted-mean and weighted-variance computations</span><br><span class="line">mux2 = imfilter(A, gaussFilt,&apos;conv&apos;,&apos;replicate&apos;);</span><br><span class="line">muy2 = imfilter(ref, gaussFilt,&apos;conv&apos;,&apos;replicate&apos;);</span><br><span class="line">muxy = mux2.*muy2;</span><br><span class="line">mux2 = mux2.^2;</span><br><span class="line">muy2 = muy2.^2;</span><br><span class="line"></span><br><span class="line">sigmax2 = imfilter(A.^2,gaussFilt,&apos;conv&apos;,&apos;replicate&apos;) - mux2;</span><br><span class="line">sigmay2 = imfilter(ref.^2,gaussFilt,&apos;conv&apos;,&apos;replicate&apos;) - muy2;</span><br><span class="line">sigmaxy = imfilter(A.*ref,gaussFilt,&apos;conv&apos;,&apos;replicate&apos;) - muxy;</span><br><span class="line"></span><br><span class="line">% Compute SSIM index</span><br><span class="line">if (C(3) == C(2)/2) &amp;&amp; isequal(exponents(:),ones(3,1))</span><br><span class="line">    % Special case: Equation 13 from [1]</span><br><span class="line">    num = (2*muxy + C(1)).*(2*sigmaxy + C(2));</span><br><span class="line">    den = (mux2 + muy2 + C(1)).*(sigmax2 + sigmay2 + C(2));</span><br><span class="line">    if (C(1) &gt; 0) &amp;&amp; (C(2) &gt; 0)</span><br><span class="line">        ssimmap = num./den;</span><br><span class="line">    else</span><br><span class="line">        % Need to guard against divide-by-zero if either C(1) or C(2) is 0.</span><br><span class="line">        isDenNonZero = (den ~= 0);           </span><br><span class="line">        ssimmap = ones(size(A));</span><br><span class="line">        ssimmap(isDenNonZero) = num(isDenNonZero)./den(isDenNonZero);</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">else</span><br><span class="line">    % General case: Equation 12 from [1] </span><br><span class="line">    % Luminance term</span><br><span class="line">    if (exponents(1) &gt; 0)</span><br><span class="line">        num = 2*muxy + C(1);</span><br><span class="line">        den = mux2 + muy2 + C(1); </span><br><span class="line">        ssimmap = guardedDivideAndExponent(num,den,C(1),exponents(1));</span><br><span class="line">    else </span><br><span class="line">        ssimmap = ones(size(A), &apos;like&apos;, A);</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    % Contrast term</span><br><span class="line">    sigmaxsigmay = [];</span><br><span class="line">    if (exponents(2) &gt; 0)  </span><br><span class="line">        sigmaxsigmay = sqrt(sigmax2.*sigmay2);</span><br><span class="line">        num = 2*sigmaxsigmay + C(2);</span><br><span class="line">        den = sigmax2 + sigmay2 + C(2); </span><br><span class="line">        ssimmap = ssimmap.*guardedDivideAndExponent(num,den,C(2),exponents(2));        </span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    % Structure term</span><br><span class="line">    if (exponents(3) &gt; 0)</span><br><span class="line">        num = sigmaxy + C(3);</span><br><span class="line">        if isempty(sigmaxsigmay)</span><br><span class="line">            sigmaxsigmay = sqrt(sigmax2.*sigmay2);</span><br><span class="line">        end</span><br><span class="line">        den = sigmaxsigmay + C(3); </span><br><span class="line">        ssimmap = ssimmap.*guardedDivideAndExponent(num,den,C(3),exponents(3));        </span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">ssimval = mean(ssimmap(:));</span><br><span class="line">    </span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">% -------------------------------------------------------------------------</span><br><span class="line">function component = guardedDivideAndExponent(num, den, C, exponent)</span><br><span class="line"></span><br><span class="line">if C &gt; 0</span><br><span class="line">    component = num./den;</span><br><span class="line">else</span><br><span class="line">    component = ones(size(num),&apos;like&apos;,num);</span><br><span class="line">    isDenNonZero = (den ~= 0);</span><br><span class="line">    component(isDenNonZero) = num(isDenNonZero)./den(isDenNonZero);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if (exponent ~= 1)</span><br><span class="line">    component = component.^exponent;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function gaussFilt = getGaussianWeightingFilter(radius,N)</span><br><span class="line">% Get 2D or 3D Gaussian weighting filter</span><br><span class="line"></span><br><span class="line">filtRadius = ceil(radius*3); % 3 Standard deviations include &gt;99% of the area. </span><br><span class="line">filtSize = 2*filtRadius + 1;</span><br><span class="line"></span><br><span class="line">if (N &lt; 3)</span><br><span class="line">    % 2D Gaussian mask can be used for filtering even one-dimensional</span><br><span class="line">    % signals using imfilter. </span><br><span class="line">    gaussFilt = fspecial(&apos;gaussian&apos;,[filtSize filtSize],radius);</span><br><span class="line">else </span><br><span class="line">    % 3D Gaussian mask</span><br><span class="line">     [x,y,z] = ndgrid(-filtRadius:filtRadius,-filtRadius:filtRadius, ...</span><br><span class="line">                    -filtRadius:filtRadius);</span><br><span class="line">     arg = -(x.*x + y.*y + z.*z)/(2*radius*radius);</span><br><span class="line">     gaussFilt = exp(arg);</span><br><span class="line">     gaussFilt(gaussFilt&lt;eps*max(gaussFilt(:))) = 0;</span><br><span class="line">     sumFilt = sum(gaussFilt(:));</span><br><span class="line">     if (sumFilt ~= 0)</span><br><span class="line">         gaussFilt  = gaussFilt/sumFilt;</span><br><span class="line">     end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function [A, ref, C, exponents, radius] = parse_inputs(varargin)</span><br><span class="line"></span><br><span class="line">validImageTypes = &#123;&apos;uint8&apos;,&apos;uint16&apos;,&apos;int16&apos;,&apos;single&apos;,&apos;double&apos;&#125;;</span><br><span class="line"></span><br><span class="line">A = varargin&#123;1&#125;;</span><br><span class="line">validateattributes(A,validImageTypes,&#123;&apos;nonsparse&apos;,&apos;real&apos;&#125;,mfilename,&apos;A&apos;,1);</span><br><span class="line"></span><br><span class="line">ref = varargin&#123;2&#125;;</span><br><span class="line">validateattributes(ref,validImageTypes,&#123;&apos;nonsparse&apos;,&apos;real&apos;&#125;,mfilename,&apos;REF&apos;,2);</span><br><span class="line"></span><br><span class="line">if ~isa(A,class(ref))</span><br><span class="line">    error(message(&apos;images:validate:differentClassMatrices&apos;,&apos;A&apos;,&apos;REF&apos;));</span><br><span class="line">end</span><br><span class="line">    </span><br><span class="line">if ~isequal(size(A),size(ref))</span><br><span class="line">    error(message(&apos;images:validate:unequalSizeMatrices&apos;,&apos;A&apos;,&apos;REF&apos;));</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if (ndims(A) &gt; 3)</span><br><span class="line">    error(message(&apos;images:validate:tooManyDimensions&apos;,&apos;A and REF&apos;,3));</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">% Default values for parameters</span><br><span class="line">dynmRange = diff(getrangefromclass(A));        </span><br><span class="line">C = [];</span><br><span class="line">exponents = [1 1 1];</span><br><span class="line">radius = 1.5;</span><br><span class="line"></span><br><span class="line">args_names = &#123;&apos;dynamicrange&apos;, &apos;regularizationconstants&apos;,&apos;exponents&apos;,...</span><br><span class="line">              &apos;radius&apos;&#125;;</span><br><span class="line"></span><br><span class="line">for i = 3:2:nargin</span><br><span class="line">    arg = varargin&#123;i&#125;;</span><br><span class="line">    if ischar(arg)        </span><br><span class="line">        idx = find(strncmpi(arg, args_names, numel(arg)));</span><br><span class="line">        if isempty(idx)</span><br><span class="line">            error(message(&apos;images:validate:unknownInputString&apos;, arg))</span><br><span class="line">            </span><br><span class="line">        elseif numel(idx) &gt; 1</span><br><span class="line">            error(message(&apos;images:validate:ambiguousInputString&apos;, arg))</span><br><span class="line">            </span><br><span class="line">        elseif numel(idx) == 1</span><br><span class="line">            if (i+1 &gt; nargin) </span><br><span class="line">                error(message(&apos;images:validate:missingParameterValue&apos;));             </span><br><span class="line">            end</span><br><span class="line">            if idx == 1</span><br><span class="line">                dynmRange = varargin&#123;i+1&#125;;</span><br><span class="line">                validateattributes(dynmRange,&#123;&apos;numeric&apos;&#125;,&#123;&apos;positive&apos;, ...</span><br><span class="line">                    &apos;finite&apos;, &apos;real&apos;, &apos;nonempty&apos;,&apos;scalar&apos;&#125;, mfilename, ...</span><br><span class="line">                    &apos;DynamicRange&apos;,i);</span><br><span class="line">                dynmRange = double(dynmRange);</span><br><span class="line">                </span><br><span class="line">            elseif idx == 2</span><br><span class="line">                C = varargin&#123;i+1&#125;;</span><br><span class="line">                validateattributes(C,&#123;&apos;numeric&apos;&#125;,&#123;&apos;nonnegative&apos;,&apos;finite&apos;, ...</span><br><span class="line">                    &apos;real&apos;,&apos;nonempty&apos;,&apos;vector&apos;, &apos;numel&apos;, 3&#125;, mfilename, ...</span><br><span class="line">                    &apos;RegularizationConstants&apos;,i);                              </span><br><span class="line">                C = double(C);                              </span><br><span class="line">                              </span><br><span class="line">            elseif idx == 3</span><br><span class="line">                exponents = varargin&#123;i+1&#125;;</span><br><span class="line">                validateattributes(exponents,&#123;&apos;numeric&apos;&#125;,&#123;&apos;nonnegative&apos;, ...</span><br><span class="line">                    &apos;finite&apos;, &apos;real&apos;, &apos;nonempty&apos;,&apos;vector&apos;, &apos;numel&apos;, 3&#125;, ...</span><br><span class="line">                    mfilename,&apos;Exponents&apos;,i);</span><br><span class="line">                exponents = double(exponents);</span><br><span class="line">                </span><br><span class="line">            elseif idx == 4</span><br><span class="line">                radius = varargin&#123;i+1&#125;;</span><br><span class="line">                validateattributes(radius,&#123;&apos;numeric&apos;&#125;,&#123;&apos;positive&apos;,&apos;finite&apos;, ...</span><br><span class="line">                    &apos;real&apos;, &apos;nonempty&apos;,&apos;scalar&apos;&#125;, mfilename,&apos;Radius&apos;,i);</span><br><span class="line">                radius = double(radius);</span><br><span class="line">            end</span><br><span class="line">        end    </span><br><span class="line">    else</span><br><span class="line">        error(message(&apos;images:validate:mustBeString&apos;)); </span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">% If &apos;RegularizationConstants&apos; is not specified, choose default C.</span><br><span class="line">if isempty(C)</span><br><span class="line">    C = [(0.01*dynmRange).^2 (0.03*dynmRange).^2 ((0.03*dynmRange).^2)/2];</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/xiaohaijiejie/article/details/48053595" target="_blank" rel="noopener">参考文章1</a></p><p><a href="https://blog.csdn.net/qq_35608277/article/details/85671519" target="_blank" rel="noopener">参考文章2</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> 图像分割 </tag>
            
            <tag> 评价指标 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Valine评论插件因为LeanCloud国内域名解析问题无法正常使用的解决方法</title>
      <link href="/2019/06/23/Valine_leancloud_error/"/>
      <url>/2019/06/23/Valine_leancloud_error/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Valine评论插件无法正常使用的解决方法</p><a id="more"></a><p>近日，LeanCloud 国内域名解析存在问题，valine评论插件的评论内容都储存在LeanCloud，使用valine评论插件的个人博客的评论及阅读数会显示失败。</p><p>关于 LeanCloud 国内域名解析问题的情况更新（6 月 21 日)<br><a href="https://blog.avoscloud.com/6841" target="_blank" rel="noopener">声明地址</a></p><p>Valine评论插件的GitHub，关于此问题的issues区<br><a href="https://github.com/xCss/Valine/issues/188" target="_blank" rel="noopener">issues地址</a></p><p>因为LeanCloud域名解析出现问题，其提供的资源也无法指向，有小伙伴分享了新的资源连接，然后替换掉即可。</p><p>替换资源的文件路径<code>blog路径/theme/next/_config.yml</code>，编辑<code>_config.yml</code>，替换如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># valine</span><br><span class="line">  # See: https://github.com/xCss/Valine</span><br><span class="line">  # Example:</span><br><span class="line">leancloud: http://pirogue.org/js/av-min.js</span><br></pre></td></tr></table></figure></p><p>替换效果如下:<br><img src="https://img-blog.nos-eastchina1.126.net/blog/leancloud_link.jpg" alt></p><p>然后平常一样部署博客就可以</p><hr><p>感谢提供资源的小伙伴，<a href="http://pirogue.org" target="_blank" rel="noopener">他的门户</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeanCloud 国内域名解析问题，博客评论及阅读数显示失败</title>
      <link href="/2019/06/23/Leancloud_error/"/>
      <url>/2019/06/23/Leancloud_error/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>博客评论及阅读数显示失败</p><a id="more"></a><p>近日，LeanCloud 国内域名解析存在问题，个人博客基于LeanCloud构建的评论及阅读数显示失败。</p><p><a href="http://www.aomanhao.top/">个人博客地址</a><br>关于 LeanCloud 国内域名解析问题的情况更新（6 月 21 日)<br><a href="https://blog.avoscloud.com/6841" target="_blank" rel="noopener">声明地址</a></p><p>声明内容如下：</p><blockquote><p>各位 LeanCloud 的用户大家好，我是 LeanCloud 的联合创始人江宏。<br>大部分用户都已经知道我们的两个域名目前无法解析，具体的情况我们昨天给大家发了邮件和博客说明，今天又再次发了短信通知。虽然这件事还没有解决，但本着对事件处理过程透明的原则，我想向大家更新一下最新进展，以及我们已经采取的措施。<br>由于在域名被禁用前没有事先通知我们，所以昨天我们在事情发生一段时间之后也不知道具体的原因。后来经过和阿里云一段时间的沟通后得知是因为某违规应用被查封，所以该应用访问的所有域名都受到牵连。事实上工信部在约一个月前因为该应用联系过我们，我们当时在接到通知约一小时内完成了清查和处理，禁用了相关账号并将结果回复给工信部，而这次却不知为何仍然被该应用影响导致两个域名被设为 ClientHold。我在今天下午拜访了工信部信息通信管理局互联网处，递交了我们的处理情况说明、申诉和保证。但因为工信部只是执行网信办的通知，所以仍需要等待网信办确认才可以解禁。很抱歉目前原有域名的恢复时间完全取决于政府部门之间的沟通进展，我们也无法给用户准确的估计。<br>在我们可控制的范围内，我们针对这件事已经完成的应对措施有：<br>为可以替换域名的用户提供可用的替代域名，说明见博客。<br>我们 iOS、Android、JS、Unity 等 SDK 都做了紧急更新，以避免国际版的应用受国内域名的影响。<br>为避免在解决问题过程中出现其它问题，华北和华东节点暂停新开发版应用的创建。如果您有需要可以用邮件联系我们创建，或者使用国际版。<br>华北节点提供了自助绑定 API 自定义域名的功能，自定义域名可用于访问数据存储、云函数、短信、推送以及即时通讯服务。你可以在控制台的「存储 -&gt; 设置 -&gt; 自定义 API 服务域名」中提供一个已备案的域名（如需开启 HTTPS 还需提供对应的证书）来自助绑定。我们之后会再发布一个详细文档说明自定义域名的配置和使用见博客说明。<br>我们还有一些正在实施的措施，既为了应对目前情况，也为了在更长期能把特殊国情带来的特殊风险限制在尽量小的范围。我们也会把后续的和有关部门的沟通结果同步给用户。</p></blockquote><p>有一些用户因为域名解析问题无法联系我们，请注意我们的各个线上联系渠道有的使用了临时域名：</p><p>博客：<a href="https://blog.avoscloud.com（临时域名）" target="_blank" rel="noopener">https://blog.avoscloud.com（临时域名）</a><br>主站：<a href="https://avoscloud.com（临时域名）" target="_blank" rel="noopener">https://avoscloud.com（临时域名）</a><br>邮件：<a href="http://support@leancloud.rocks" target="_blank" rel="noopener">http://support@leancloud.rocks</a> (不变)<br>工单：<a href="https://leanticket.cn（不变）" target="_blank" rel="noopener">https://leanticket.cn（不变）</a><br>很多用户在此次事件的沟通中给予了我们宝贵的宽容、支持和信任。我想特别向我们的用户表达感谢，并将继续尽我们所能克服未来可能遇到的困难，服务好用户。</p><hr><p>希望早日解决问题，继续服务消费者</p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爱礼（爱的礼物——谐音爱你），送给你对象的爱的礼物</title>
      <link href="/2019/06/22/LoveHeart/"/>
      <url>/2019/06/22/LoveHeart/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>爱礼</p><a id="more"></a><p>项目制作给我的女朋友，可以写一些恋爱情话，记录恋爱时间线，恋爱时间等。</p><p>原始项目由<code>hackerzhou</code>发起，作者预览网址失效，项目地址如下:<br><a href="https://github.com/hackerzhou/Love" target="_blank" rel="noopener">项目地址</a></p><p>我在原始项目上改了改，项目地址如下：<br><a href="https://github.com/AomanHao/loveheart" target="_blank" rel="noopener">我的项目地址</a></p><p>项目效果预览网址如下：<br><a href="http://www.aomanhao.top/loveheart/">效果预览</a></p><p>项目放在我的主域名下的子域名内，主域名对应<code>Github Page</code>的主仓库<code>ID.github.io</code>。</p><hr><p>可以修改index.html中的BGM区域和土味情话部分，实现内容自定义。</p><hr><p>编辑中</p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《重庆森林》</title>
      <link href="/2019/06/13/Movie_ChongQingSenLin/"/>
      <url>/2019/06/13/Movie_ChongQingSenLin/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>《重庆森林》</p><a id="more"></a><p>发条张讲解的B站视频<br><a href="https://www.bilibili.com/video/av55359824/" target="_blank" rel="noopener">视频链接</a></p><iframe height="498" width="510" src="//player.bilibili.com/player.html?aid=55359824&cid=96800122&page=1" frameborder="0" allowfullscreen></iframe><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>《重庆森林》是泽东电影公司出品的一部都市时装片，由王家卫执导，林青霞、梁朝伟、王菲、金城武等主演。1994年7月14日，该片在香港上映。<br>影片讲述了两个爱情故事：失恋的警察与神秘女杀手一段都市邂逅以及巡警663与快餐店女孩的爱情故事。1995年，该片获得了第14届香港电影金像奖最佳影片、最佳导演等奖项</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>重庆大厦坐落于香港九龙尖沙咀，位于弥敦道36-44号。于1961年落成，是一座混合型大厦，拥有很多廉价宾馆、商店、食肆、外汇兑换店及其他服务行业。重庆大厦里有着密密匝匝的商铺。一个挨着一个，大多是来自东南亚的商人开的店。</p><h2 id="经典台词"><a href="#经典台词" class="headerlink" title="经典台词"></a>经典台词</h2><p>1.我和她最接近的时候，我们之间的距离只有0.01公分，我对她一无所知，六个钟头之后，她喜欢了另一个男人。</p><p>2.如果一个人哭，你只要给他一包纸巾就行;如果一个房子哭，你要做的事就多了。</p><p>3.不知道从什么时候开始，在什么东西上面都有个日期，秋刀鱼会过期，肉罐头会过期，连保鲜纸都会过期，我开始怀疑，在这个世界上，还有什么东西是不会过期的?</p><p>5.每次我失恋的时候我都会去跑步，因为跑步是能够把我体内多余的水分蒸发掉，那样比较不容易流泪。</p><p>6.如果记忆也是一个罐头的话，我希望这罐罐头不会过期;如果一定要加一个日子的话，我希望她是一万年。</p><p>7.每天你都有机会和很多人擦身而过，有些人可能会变成你的朋友或者是知己。所以我从来没有放弃任何跟人磨擦的机会。有时候搞得自己头破血流，管他呢!开心就行了。</p><p>8.其实了解一个人并不代表什么，人是会变的，今天他喜欢凤梨，明天他可以喜欢别的。</p><p>9.不知道是我不记得关水龙头，还是这间屋越来越有感情，我一直以为它很坚强，没想到它哭得最历害，一个人哭，你只须要给他包纸巾，但一间屋哭，你却要做很多很多工夫。(梁朝伟的房间进水)</p><p>10.在1994年的5月1号，有一个女人跟我讲了一声“生日快乐”，因为这一句话，我会一直记住这个女人。如果记忆也是一个罐头的话，我希望这罐罐头不会过期;如果一定要加一个日子的话，我希望她是一万年</p><p>11.一个女人这么晚了还戴墨镜，只有三个理由：第一个呢，就说明她是个盲子;第二个呢，就说明她在耍帅，所以要戴墨镜;第三个呢，就因为她失恋，因为她不想让人家看出来她哭过” 。</p><p>12.在1994年的5月1号，有一个女人跟我讲了一声“生日快乐”，因为这一句话，我会一直记住这个女人。</p><p>13.我对她一无所知，57个小时之后，我爱上了她，六个钟头之后，她喜欢了另一个男人。</p><p>14.我今天心情好，想看子夜场。</p><p>15.有时候我会回家吃饭，因为每一次回来我都可以有个希望。梁走到柜子前，对柜子说：“我知道你回来了，快点出来啊，我数三下，一、二、三”她以前很爱突如其来从衣柜里扑出来吓我，最近少了很多，也对啊，玩多了也腻啦。不知道她会不会躲在厕所里呢?</p><p>16.每一个人都有一个习惯，我的习惯呢?就是来这边等阿may下班。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>我是因为一首歌喜欢上《重庆森林》，在《California dreaming》背景音乐的伴奏下，王菲在快餐店里摇头晃脑，很是自由。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有趣GitHub项目之每日自动给女朋友发微信暖心话</title>
      <link href="/2019/06/08/EverydayWechat/"/>
      <url>/2019/06/08/EverydayWechat/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>有趣GitHub项目之每日自动给女朋友发微信暖心话</p><a id="more"></a><p><a href="https://github.com/sfyc23/EverydayWechat" target="_blank" rel="noopener">GitHub项目地址</a></p><h2 id="以下为作者的参考文档，有待学习"><a href="#以下为作者的参考文档，有待学习" class="headerlink" title="以下为作者的参考文档，有待学习"></a>以下为作者的参考文档，有待学习</h2><p>用 Python + itchat 写一个爬虫脚本每天定时给多个女友发给微信暖心话<br>项目介绍：<br>开发环境：Python &gt;= 3.6</p><h2 id="使用库"><a href="#使用库" class="headerlink" title="使用库"></a>使用库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">itchat - 微信个人号接口</span><br><span class="line">requests - 网络请求库</span><br><span class="line">beautifulsoup4 - 解析网页</span><br><span class="line">APScheduler - 定时任务</span><br></pre></td></tr></table></figure><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>定时给女朋友发送每日天气、提醒、每日一句。</p><h2 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h2><p>每日一句和上面的大佬一样也是来自 ONE●一个<br>天气信息来自 SOJSON</p><h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><p>目录结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">city_dict.py ：城市对应编码字典</span><br><span class="line">config.yaml ：设置定时时间，女友微信名称等参数</span><br><span class="line">GFWeather.py：核心代码</span><br><span class="line">requirements.txt：需要安装的库</span><br><span class="line">run.py：项目运行类</span><br></pre></td></tr></table></figure><p>核心代码</p><h3 id="1-定时任务。"><a href="#1-定时任务。" class="headerlink" title="1.定时任务。"></a>1.定时任务。</h3><p>每天 9：30 给女朋友们开始给女朋友发送内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">### 定时任务</span><br><span class="line">scheduler = BlockingScheduler()</span><br><span class="line"># 每天9：30给女朋友发送每日一句</span><br><span class="line"># scheduler.add_job(start_today_info, &apos;cron&apos;, hour=9, minute=30)</span><br><span class="line">scheduler.start()</span><br><span class="line">start_today_info 是方法处理类。</span><br></pre></td></tr></table></figure></p><h3 id="2-获取每日一句。"><a href="#2-获取每日一句。" class="headerlink" title="2.获取每日一句。"></a>2.获取每日一句。</h3><p>数据来源 1： ONE●一个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def get_dictum_info(self):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    获取格言信息（从『一个。one』获取信息 http://wufazhuce.com/）</span><br><span class="line">    :return: str 一句格言或者短语</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    print(&apos;获取格言信息..&apos;)</span><br><span class="line">    user_url = &apos;http://wufazhuce.com/&apos;</span><br><span class="line">    resp = requests.get(user_url, headers=self.headers)</span><br><span class="line">    soup_texts = BeautifulSoup(resp.text, &apos;lxml&apos;)</span><br><span class="line">    # 『one -个』 中的每日一句</span><br><span class="line">    every_msg = soup_texts.find_all(&apos;div&apos;, class_=&apos;fp-one-cita&apos;)[0].find(&apos;a&apos;).text</span><br><span class="line">    return every_msg</span><br></pre></td></tr></table></figure></p><p>数据来源 2： 金山词霸 ● 每日一句</p><p>有英文和中文翻译，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">When you finally get your own happiness, you will understand the previous sadness is a kind of treasure, which makes you better to hold and cherish the people you love. 等你获得真正属于你的幸福之后，你就会明白一起的伤痛其实是一种财富，它让你学会更好地去把握和珍惜你爱的人。</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">代码实现 ：</span><br><span class="line"></span><br><span class="line"> def get_ciba_info(self):</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    从词霸中获取每日一句，带英文。</span><br><span class="line">    :return:</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    resp = requests.get(&apos;http://open.iciba.com/dsapi&apos;)</span><br><span class="line">    if resp.status_code == 200 and self.isJson(resp):</span><br><span class="line">        conentJson = resp.json()</span><br><span class="line">        content = conentJson.get(&apos;content&apos;)</span><br><span class="line">        note = conentJson.get(&apos;note&apos;)</span><br><span class="line">        # print(f&quot;&#123;content&#125;\n&#123;note&#125;&quot;)</span><br><span class="line">        return f&quot;&#123;content&#125;\n&#123;note&#125;\n&quot;</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;没有获取到数据&quot;)</span><br><span class="line">        return None</span><br></pre></td></tr></table></figure><h3 id="3-获取今日天气-。"><a href="#3-获取今日天气-。" class="headerlink" title="3. 获取今日天气 。"></a>3. 获取今日天气 。</h3><p>天气数据来源：SOJSON<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def get_weather_info(self, city_code=&apos;&apos;）：</span><br><span class="line">    weather_url = f&apos;http://t.weather.sojson.com/api/weather/city/&#123;city_code&#125;&apos;</span><br><span class="line">    resp = requests.get(url=weather_url)</span><br><span class="line">    if resp.status_code == 200 and resp.json().get(&apos;status&apos;) == 200:</span><br><span class="line">        weatherJson = resp.json()</span><br><span class="line">        # 今日天气</span><br><span class="line">        today_weather = weatherJson.get(&apos;data&apos;).get(&apos;forecast&apos;)[1]</span><br><span class="line">city_code 城市对应 id。 http://cdn.sojson.com/_city.json</span><br></pre></td></tr></table></figure></p><ol><li>登录微信并发送内容。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">itchat.auto_login()</span><br><span class="line">itchat.send(today_msg, toUserName=name_uuid)</span><br><span class="line">项目运行</span><br><span class="line">安装依赖</span><br><span class="line">使用 pip install -r requirements.txt 安装所有依赖</span><br></pre></td></tr></table></figure></li></ol><p>参数配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">config.yaml</span><br><span class="line"># 定时时间</span><br><span class="line"></span><br><span class="line">alarm_timed: &apos;9:30&apos;</span><br><span class="line"></span><br><span class="line"># 格言渠道</span><br><span class="line"># 1 : ONE●一个</span><br><span class="line"># 2 : 词霸（每日英语）</span><br><span class="line">dictum_channel: 2</span><br><span class="line"></span><br><span class="line">girlfriend_infos:</span><br><span class="line">  -</span><br><span class="line">    #女友微信昵称</span><br><span class="line">    wechat_name: &apos;古典&apos;</span><br><span class="line">    #女友所在桂林</span><br><span class="line">    city_name: &apos;桂林&apos;</span><br><span class="line">    # 从那天开始勾搭的（可空）</span><br><span class="line">    start_date: &apos;2017-11-11&apos;</span><br><span class="line">    # 短句的最后留言（可空）</span><br><span class="line">    sweet_words: &apos;来自最爱你的我。&apos;</span><br><span class="line"></span><br><span class="line">  #如果有你多个人需要发送，则参照这个样式，复制即可</span><br><span class="line">  -</span><br><span class="line">    wechat_name: &apos;陈老师&apos;</span><br><span class="line">    city_name: &apos;朝阳区&apos;</span><br><span class="line">    start_date: &apos;2018-11-11&apos;</span><br><span class="line">    sweet_words: &apos;来自你俊美的老公。&apos;</span><br></pre></td></tr></table></figure></p><p>开始运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python run.py</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雷米粉丝见面签售会</title>
      <link href="/2019/05/27/LeiMi/"/>
      <url>/2019/05/27/LeiMi/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>雷米粉丝见面签售会</p><a id="more"></a><p>雷米,原名刘鹏，中国刑事警察学院学院犯罪心理学教师，精通犯罪心理学和刑侦学，洞悉形形色色的罪恶，甚至超过自己的掌纹。以《心理罪》（网络原名《画像》）等犯罪心理小说闻名于网络，主要作品有《第七位读者》、《心理罪》、《教化场》、《暗河》、《城市之光》等。雷米新书，杂志版《教化场》将于08年10月登陆《今古传奇·故事版》 心理学知识仍然是本书主线，不过犯罪心理画像不再是主线。在《心理罪》中，雷米创造了一个血肉丰盈的人物——方木，如果说叙事的线索构成这部小说硬朗的结构，那么关于方木这个人的一切，则形成了小说的骨血和灵魂，他的命运牵动着我们的每一根神经。</p><p><img src="https://img-blog.nos-eastchina1.126.net/PersonalPhoto/LeiMi_Photo.jpg" alt></p><p><img src="https://img-blog.nos-eastchina1.126.net/PersonalPhoto/LeiMi_Signatrue.jpg" alt></p><p><img src="https://img-blog.nos-eastchina1.126.net/PersonalPhoto/LeiMi_Talk.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客Next主题DaoVoice实现在线联系</title>
      <link href="/2019/05/18/Hexo_Daovoice/"/>
      <url>/2019/05/18/Hexo_Daovoice/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Hexo博客Next主题DaoVoice实现在线联系<br><a id="more"></a></p><h2 id="注册登录DaoVoice"><a href="#注册登录DaoVoice" class="headerlink" title="注册登录DaoVoice"></a>注册登录DaoVoice</h2><p>注册地址如下:<br><a href="http://www.daovoice.io/" target="_blank" rel="noopener">http://www.daovoice.io/</a></p><p>在官网注册帐号需要邀请码，可以输入我的邀请码 b69005f1 </p><p>复制粘贴代码<br>修改的<code>hexo</code>的文件路劲如下: <code>博客/themes/next/layout/_partials/head/head.swig</code> 末尾添加下面的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.daovoice %&#125;</span><br><span class="line"> &lt;script&gt;(function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/b6dbddb6.js&quot;,&quot;daovoice&quot;)</span><br><span class="line"> daovoice(&apos;init&apos;, &#123;</span><br><span class="line">  app_id: &quot;用户ID&quot;</span><br><span class="line">&#125;);</span><br><span class="line">daovoice(&apos;update&apos;);</span><br><span class="line"> &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>用户ID需要自行填写，查找的的位置在下图片中显示出来了</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/Hexo_Daovoice1.png" alt></p><h2 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h2><p>在Next主题的配置文件<code>博客/themes/next/_config.yml</code>末尾中添加用户ID:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">daovoice: true</span><br><span class="line">daovoice_app_id: 用户ID</span><br></pre></td></tr></table></figure></p><h2 id="修改聊天图标等设置"><a href="#修改聊天图标等设置" class="headerlink" title="修改聊天图标等设置"></a>修改聊天图标等设置</h2><p>应用设置—聊天设置，然后定制欢迎辞，设置聊天窗口样式等<br><img src="https://img-blog.nos-eastchina1.126.net/blog/Hexo_Daovoice2.png" alt></p><h2 id="部署Daovoice"><a href="#部署Daovoice" class="headerlink" title="部署Daovoice"></a>部署Daovoice</h2><p>清理缓存，生成缓存，部署服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure></p><p>登陆本地服务：<code>http://localhost:4000/</code>，可以看到Daovoice已经成功运行。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/Hexo_Daovoice3.png" alt></p><p>DaoVoice官网会提示，服务接入成功</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/Hexo_Daovoice4.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo个人博客迁移到托管平台Netlify</title>
      <link href="/2019/05/03/Hexo_Netlify/"/>
      <url>/2019/05/03/Hexo_Netlify/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>个人博客迁移到托管平台Netlify上<br><a id="more"></a><br>Netlify是一家国外的静态网站的托管平台，提供免费的https，自动化部署和升级，可以监控GitHub、GitLab或者Bitbucket做到自动更新发布。</p><font color="DeepPink" size="6">个人体会访问速度不是很理想，不如部署在GitHub上。</font><h3 id="一、使用github或者gitlab登陆netlify"><a href="#一、使用github或者gitlab登陆netlify" class="headerlink" title="一、使用github或者gitlab登陆netlify"></a>一、使用github或者gitlab登陆netlify</h3><p>打开<a href="https://app.netlify.com/" target="_blank" rel="noopener">Netlify网站</a><br>然后点击右上角Sign up注册账号，选择GitHub关联登录。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/hexo_netlity_step1.png" alt></p><h3 id="二、根据github-gitlab仓库创建网站"><a href="#二、根据github-gitlab仓库创建网站" class="headerlink" title="二、根据github/gitlab仓库创建网站"></a>二、根据github/gitlab仓库创建网站</h3><p>创建站点，点击New site from Git按钮：<br><img src="https://img-blog.nos-eastchina1.126.net/blog/hexo_netlity_step0.5.jpg" alt></p><h3 id="三、选择代码托管空间"><a href="#三、选择代码托管空间" class="headerlink" title="三、选择代码托管空间"></a>三、选择代码托管空间</h3><p>可以选择GitHub、GitLab或者BitBucket。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/hexo_netlity_step2.png" alt></p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/hexo_netlity_step3.png" alt></p><h3 id="四、选择要部署的项目仓库"><a href="#四、选择要部署的项目仓库" class="headerlink" title="四、选择要部署的项目仓库"></a>四、选择要部署的项目仓库</h3><p>点击你已经建好的库，选好分支（默认master即可），然后点击“Deploy site”，系统就会自动编译你的静态页面了。网站的控制台去进行设置域名绑定和https申请即可，部署成功后会自动进行cdn加速的。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/hexo_netlity_step4.png" alt></p><p>之后我们就不需要这么麻烦了以后编辑好文章之后，只需要执行 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 即可自动化部署，然后要记得将我们的项目文件 push 到 github 的 master分支上去哦。</p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><h3 id="网站引导"><a href="#网站引导" class="headerlink" title="网站引导"></a>网站引导</h3><p>Netlify网站 提供的网站域名是该网站的二级域名，看起来不太美观，如果你拥有自己的域名，可以通过绑定自己的域名然后跳转到Netlity的二级域名。<br><img src="https://img-blog.nos-eastchina1.126.net/blog/hexo_netlity_step7.jpg" alt></p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/hexo_netlity_step8.png" alt></p><h3 id="域名控制台"><a href="#域名控制台" class="headerlink" title="域名控制台"></a>域名控制台</h3><p>添加两条解析记录，一条A记录，一条CNAME记录。A记录的记录值IP是你的<code>https://xxx.netlify.com</code>域名对应的<code>ip</code>，这个可以网上查。<br>CNAME记录的记录值是<code>https://xxx.netlify.com</code>的<code>xxx.netlify.com</code>值，添加完解析后就可将你的域名绑定到<code>Netlify</code>了。</p><h2 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h2><p>想要部署在Netlity的初衷是部署在Coding上需要备案，且已经被公安催了要备案，需要一个不用备案的代码托管网站。在网站部署操作不是很麻烦，但是实际部署下来访问速度不是很理想，不如部署在GitHub上。纠结一下</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客建立标签云及效果展示</title>
      <link href="/2019/04/20/hexo_Tag_cloud/"/>
      <url>/2019/04/20/hexo_Tag_cloud/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Hexo博客建立标签云及效果展示</p><a id="more"></a><h2 id="hexo-tag-cloud插件介绍"><a href="#hexo-tag-cloud插件介绍" class="headerlink" title="hexo-tag-cloud插件介绍"></a><code>hexo-tag-cloud</code>插件介绍</h2><p><code>hexo-tag-cloud</code>插件是作者写的一个Hexo博客的标签云插件，旨在直观的展示标签的种类，美观大方且非常优雅。</p><p>插件地址：<br><a href="https://github.com/MikeCoder/hexo-tag-cloud" target="_blank" rel="noopener">插件的GitHub地址</a></p><p>插件说明：<br><a href="https://github.com/MikeCoder/hexo-tag-cloud/blob/master/README.ZH.md" target="_blank" rel="noopener">说明地址</a></p><p>标签云效果展示：<br><a href="http://www.aomanhao.top/">我的博客主页</a></p><p><a href="https://mikecoder.github.io/archives/" target="_blank" rel="noopener">插件作者提供的效果预览</a></p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>进入到 <code>hexo</code> 的根目录，在 <code>package.json</code> 中添加依赖: <code>&quot;hexo-tag-cloud&quot;: &quot;2.0.*&quot;</code> 操作如下：</p><h3 id="使用命令行进行安装"><a href="#使用命令行进行安装" class="headerlink" title="使用命令行进行安装"></a>使用命令行进行安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-tag-cloud@^2.0.* --save</span><br></pre></td></tr></table></figure><h3 id="Git-clone-下载"><a href="#Git-clone-下载" class="headerlink" title="Git clone 下载"></a>Git clone 下载</h3><p>使用命令行安装插件包的过程中可能会出现问题，安装失败，安装不完全。可以直接克隆插件到博客的插件文件夹<code>blog/node_modules</code>里。或者克隆到桌面，复制到博客的插件文件夹<code>blog/node_modules</code>里。<br><img src="https://img-blog.nos-eastchina1.126.net/blog/hexo_tag_cloud2.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/MikeCoder/hexo-tag-cloud</span><br></pre></td></tr></table></figure><h2 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h2><p>插件的配置需要对应的环境，可以在主题文件夹里找一下，有没有对应的渲染文件，然后根据渲染文件的类型，选择对应的插件配置方法。</p><h3 id="swig-用户-Next主题在列"><a href="#swig-用户-Next主题在列" class="headerlink" title="swig 用户 (Next主题在列)"></a>swig 用户 (Next主题在列)</h3><p>在主题文件夹找到文件 <code>theme/next/layout/_macro/sidebar.swig</code>, 然后添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if site.tags.length &gt; 1 %&#125;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcloud.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcanvas.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;div class=&quot;widget-wrap&quot;&gt;</span><br><span class="line">    &lt;h3 class=&quot;widget-title&quot;&gt;Tag Cloud&lt;/h3&gt;</span><br><span class="line">    &lt;div id=&quot;myCanvasContainer&quot; class=&quot;widget tagcloud&quot;&gt;</span><br><span class="line">        &lt;canvas width=&quot;250&quot; height=&quot;250&quot; id=&quot;resCanvas&quot; style=&quot;width=100%&quot;&gt;</span><br><span class="line">            &#123;&#123; list_tags() &#125;&#125;</span><br><span class="line">        &lt;/canvas&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>代码添加到后面即可，添加示意图如下:<br><img src="https://img-blog.nos-eastchina1.126.net/blog/hexo_tag_cloud_code.jpg" alt></p><h3 id="对于ejs的用户-默认主题landscape在列"><a href="#对于ejs的用户-默认主题landscape在列" class="headerlink" title="对于ejs的用户 (默认主题landscape在列)"></a>对于<code>ejs</code>的用户 (默认主题landscape在列)</h3><p>在主题文件夹找到文件<code>hexo/themes/landscape/layout/_widget/tagcloud.ejs</code>,将这个文件修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (site.tags.length) &#123; %&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcloud.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcanvas.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;div class=&quot;widget-wrap&quot;&gt;</span><br><span class="line">        &lt;h3 class=&quot;widget-title&quot;&gt;Tag Cloud&lt;/h3&gt;</span><br><span class="line">        &lt;div id=&quot;myCanvasContainer&quot; class=&quot;widget tagcloud&quot;&gt;</span><br><span class="line">            &lt;canvas width=&quot;250&quot; height=&quot;250&quot; id=&quot;resCanvas&quot; style=&quot;width=100%&quot;&gt;</span><br><span class="line">                &lt;%- tagcloud() %&gt;</span><br><span class="line">            &lt;/canvas&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></p><h3 id="对于jade用户-Apollo主题在列"><a href="#对于jade用户-Apollo主题在列" class="headerlink" title="对于jade用户 (Apollo主题在列)"></a>对于<code>jade</code>用户 (Apollo主题在列)</h3><p>找到 apollo/layout/archive.jade 文件，并且把 container 代码块修改为如下内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">block container</span><br><span class="line">    include mixins/post</span><br><span class="line">    .archive</span><br><span class="line">        h2(class=&apos;archive-year&apos;)= &apos;Tag Cloud&apos;</span><br><span class="line">        script(type=&apos;text/javascript&apos;, charset=&apos;utf-8&apos;, src=&apos;/oj-code/js/tagcloud.js&apos;)</span><br><span class="line">        script(type=&apos;text/javascript&apos;, charset=&apos;utf-8&apos;, src=&apos;/oj-code/js/tagcanvas.js&apos;)</span><br><span class="line">        #myCanvasContainer.widget.tagcloud(align=&apos;center&apos;)</span><br><span class="line">            canvas#resCanvas(width=&apos;500&apos;, height=&apos;500&apos;, style=&apos;width=100%&apos;)</span><br><span class="line">                !=tagcloud()</span><br><span class="line">            !=tagcloud()</span><br><span class="line">    +postList()</span><br></pre></td></tr></table></figure></p><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>在博客根目录，找到 <code>_config.yml</code>配置文件然后在最后添加如下的配置项，可以自定义标签云的字体和颜色，还有突出高亮:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># hexo-tag-cloud</span><br><span class="line">tag_cloud:</span><br><span class="line">    textFont: Trebuchet MS, Helvetica</span><br><span class="line">    textColor: &apos;#333&apos;</span><br><span class="line">    textHeight: 25</span><br><span class="line">    outlineColor: &apos;#E2E1D1&apos;</span><br><span class="line">    maxSpeed: 0.1</span><br></pre></td></tr></table></figure></p><p>textColor: ‘#333’   字体颜色<br>textHeight: 25      字体高度，根据部署的效果调整<br>maxSpeed: 0.1       文字滚动速度，根据自己喜好调整</p><h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p>本地预览<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure></p><h2 id="博客部署"><a href="#博客部署" class="headerlink" title="博客部署"></a>博客部署</h2><p>博客部署<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></p><p>推荐使用 <code>&amp;&amp;</code> 作为组合命令的串联符号</p><p>注：一定要严格清理缓存，这样不容易出现问题，即需要执行<code>hexo clean</code></p><hr><p><a href="https://github.com/MikeCoder/hexo-tag-cloud/blob/master/README.ZH.md" target="_blank" rel="noopener">参考文章1</a></p><p><a href="https://blog.csdn.net/DreamHome_S/article/details/78250692" target="_blank" rel="noopener">参考文章2</a></p><h3 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h3><h3 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h3><h3 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>道路监控网络摄像头常见问题</title>
      <link href="/2019/04/03/Security_road/"/>
      <url>/2019/04/03/Security_road/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>道路监控网络摄像头常见问题<br><a id="more"></a></p><h2 id="1-水波纹（FLICK）问题"><a href="#1-水波纹（FLICK）问题" class="headerlink" title="1. 水波纹（FLICK）问题"></a>1. 水波纹（FLICK）问题</h2><p>CMOS高画质传感器在快门速度超过1/200sec以上，因无法处理同步问题，画面上会产生黑条状之水波纹而影响画质（如图一），并会在画面上产生缓慢飘移现象，但快门值低于1/200sec以下则不会产生水波纹问题，CCD高画质传感器就不会有水波纹问题。</p><p>设计建议：若车速低于30km/hr，可以采用CMOS摄像头。若车速高于30km/hr，则应采用CCD等级摄像头。</p><h2 id="2-夜间低照度噪点问题"><a href="#2-夜间低照度噪点问题" class="headerlink" title="2. 夜间低照度噪点问题"></a>2. 夜间低照度噪点问题</h2><p>百万画素传感器多以<code>1/2.8</code>或<code>1/3</code>寸传感器构成，由于传感器面积未放大但画素密度增加，造成单位画素进光量低，因此一般而言感度效果较传统类比CCD差。一般低照度下传感器会启动自动增益（Auto Gain），等级较差传感器与处理芯片会造成画面噪点颗粒粗大（如图二），使得影像锐利度大幅降低，严重影响画质。</p><p>设计建议：采用高感度传感器与处理芯片，并实测自动增益是否维持高锐利度。Sony第二代传感器Xeria比前一代Exmor的感度提升许多，建议采用新一代传感器的摄像头，而CCD的低照度效果与自动增益噪点均比CMOS来的较佳。此外，透过足够的补光灯投射器予以适度补光，也是改善夜间画质的重要方式。</p><h2 id="3-车速快时画面拖影问题"><a href="#3-车速快时画面拖影问题" class="headerlink" title="3. 车速快时画面拖影问题"></a>3. 车速快时画面拖影问题</h2><p>若道路监控摄像头快门值设定过低，对于高速行驶车辆会无法冻结车牌，产生拖影问题，造成车牌清晰度下降。道路监控摄像头通常在快门值设计在1/250sec（40km/hr）到1/750sec（100km/hr）下，会有较好的冻结效果，但因曝光值低需克服夜间照度不足问题。在传感器方面，CMOS较易发生拖影问题。由于CMOS传感器取像原理为Rolling Shutter，非全域曝光，因此易有拖影问题，但可透过后端芯片补偿为全域曝光来改善。而CCD传感器为Global Shutter全域曝光，无画面拖影问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安防 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相机镜头参数介绍(待更新)</title>
      <link href="/2019/03/30/Camera/"/>
      <url>/2019/03/30/Camera/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>相机镜头基本参数介绍<br><a id="more"></a></p><p>镜头参数：<code>CANON ZOOM LENS EF-S 18 -55mm 1：3.5-5.6 IS</code></p><p>参数解释：焦距范围<code>18 -55</code>mm；最大光圈系数 <code>3.5-5.6</code>；镜头带有防抖功能。</p><p>18-55MM是这款镜头的焦段，焦段：简单说就是变焦镜头焦距的变化范围。18指的是镜头广角端的焦段，55指的是镜头长焦端的焦段。</p><blockquote><p>10mm左右的焦段，是超广角焦段，照出来的角度非常大，用于风景摄影，纪实摄影等。<br>24mm左右的焦段，是小广角焦段。<br>50mm左右的焦段，是标准焦段，视角平易近人，变形少，主要用于风景摄影，人像摄影，纪实摄影等。<br>85mm左右的焦段，是中焦段，这个焦段主要用于拍人像，静物等。<br>200mm左右的焦段，是长焦段，这个焦段常用于抓拍，特写等。</p></blockquote><p>光圈是一个用来控制光线透过镜头，进入机身内感光面光量的装置，它通常是在镜头内。表达光圈大小我们是用f值。对于已经制造好的镜头，我们不可能随意改变镜头的直径，但是我们可以通过在镜头内部加入多边形或者圆形，并且面积可变的孔状光栅来达到控制镜头通光量，这个装置就叫做光圈。</p><p>比如某单反镜头参数是“18-50mm、0.5m-无限大、F2.8-3.5”，表示它的焦段为18-50mm，焦点为0.5米，在18mm广角端的最大光圈值是2.8，在50mm广角端最大光圈值是3.5。</p><p>　　就单反镜头来说，肯定是光圈值越大它的镜头质量就会越好，同等情况下大炮长焦价格最贵，广角次之，标准最便宜;恒定光圈也会比非恒定光圈值要好一些，但也有其他的影响因素，比如有无有色散片、MACRO，制作材料是金属还是材料等等，都会影响到它的效果和价格。</p><p>　　此外在单反相机镜头中，比较重要的参数是相机的像素以及传感器尺寸，像素越大、传感器尺寸越大，价格肯定是会越贵;对焦速度、快门声音等参数并不是最重要的，像一般中等的单反镜头的对焦、快门等表现就非常好，对于拍摄并不会造成太大影响，因此在购买的时候可以不考虑这两方面因素。</p><hr><p>待更新</p>]]></content>
      
      
      
        <tags>
            
            <tag> Camera </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云储存选择做Hexo博客图床（腾讯云、七牛云、网易云）</title>
      <link href="/2019/02/26/hexo_cloud/"/>
      <url>/2019/02/26/hexo_cloud/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>博客图床<br><a id="more"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>博客里需要添加很多图片作为内容的补充，但是把图片放在本地博客文件夹里，上传到网上后，加载这些图片就是一个很大的问题，他们会拖累网页加载的速度，所以建议把图片放图床里，通过外链来访问和加载这些图片。</p><h2 id="云对象储存服务商"><a href="#云对象储存服务商" class="headerlink" title="云对象储存服务商"></a>云对象储存服务商</h2><p>国内免费的云对象储存的服务商(网易云、七牛云、腾讯云)</p><h3 id="1-网易云"><a href="#1-网易云" class="headerlink" title="1.网易云"></a>1.网易云</h3><p>官网：<a href="https://www.163yun.com/" target="_blank" rel="noopener">https://www.163yun.com/</a><br><img src="https://img-blog.nos-eastchina1.126.net/blog/cloud163.jpg" alt="网易云"><br>网易NOS（Netease Object Storage）网易对象存储为你提供基于互联网的数据存取服务，通过使用 NOS，你可以随时通过网络将你的文本、图片、音视频等各类文件存储到 NOS 系统中，并随时可以通过网络进行安全访问。</p><p>NOS 对象存储从三个维度进行计量收费：存储容量、流量、接口调用次数。存储容量0-50 GB是免费，下载流量在0-20 GB免费，每月前 10 万次 Put 请求免费，每月前 100 万次 Get 请求免费。</p><h3 id="2-七牛云"><a href="#2-七牛云" class="headerlink" title="2.七牛云"></a>2.七牛云</h3><p>官网：<a href="https://www.qiniu.com/" target="_blank" rel="noopener">https://www.qiniu.com/</a></p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/cloud_qiniu.jpg" alt="七牛云"></p><p>七牛云存储提供云存储、云处理、云加速分发一站式服务，注册成为标准用户后可获得10GB免费存储空间、每月10GB下载流量、每月10万次Put请求、每月100万次Get请求。</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>临时域名仅有三个月，三个月后没有自己的备案域名，所有图片均会失效</p><h3 id="3-腾讯云"><a href="#3-腾讯云" class="headerlink" title="3.腾讯云"></a>3.腾讯云</h3><p>官网：<a href="https://cloud.tencent.com/" target="_blank" rel="noopener">https://cloud.tencent.com/</a></p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/cloud_tencent.png" alt></p><p>腾讯云对象存储服务COS，全称为Cloud Object Service，主要是为开发者提供安全、稳定、高效、实惠的对象存储服务，开发者可以将任意动态、静态生成的数据，存放到COS上，再通过HTTP的方式进行访问。</p><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><p>自2019年后新建用户可以领取一个6月有效期，50G的存储量。6月过后，按照存储量和流量收费。</p><hr><h2 id="在线图床选择"><a href="#在线图床选择" class="headerlink" title="在线图床选择"></a>在线图床选择</h2><p><a href="https://sm.ms" target="_blank" rel="noopener">https://sm.ms</a> SM图床</p><p><a href="https://tu.aixinxi.net/" target="_blank" rel="noopener">https://tu.aixinxi.net/</a> 爱信息图床</p><p><a href="https://imgchr.com/" target="_blank" rel="noopener">https://imgchr.com/</a> 路过图床</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>云储存选择<code>网易云</code>，因为网易云对新用户的限制，免费的云储存有待选择</p><p>图床选择<code>路过图床</code></p><p>目前还在用路过图床，缺点是图片链接不能看到任何图片名称等图片信息，不方便插入在博客里</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo主题Next配置及加载优化</title>
      <link href="/2019/02/25/theme_Nextpro/"/>
      <url>/2019/02/25/theme_Nextpro/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Hexo主题Next配置及加载优化</p><a id="more"></a><h2 id="主题源加载优化"><a href="#主题源加载优化" class="headerlink" title="主题源加载优化"></a>主题源加载优化</h2><p>把在NexT主题的_config.yml里面的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Uri of fonts host. E.g. //fonts.googleapis.com (Default)</span><br><span class="line">host:</span><br></pre></td></tr></table></figure></p><p>改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Uri of fonts host. E.g. //fonts.googleapis.com (Default)</span><br><span class="line">host: //fonts.lug.ustc.edu.cn</span><br></pre></td></tr></table></figure></p><p>因为<code>fonts.lug.ustc.edu.cn</code>是中科大的源，相比之前能快一下</p><hr><h2 id="博客双线部署"><a href="#博客双线部署" class="headerlink" title="博客双线部署"></a>博客双线部署</h2><p><a href="https://www.ieclipse.cn/2016/08/29/Web/Hexo-deploy-lines/" target="_blank" rel="noopener">参考文章地址</a></p><hr><h2 id="压缩网页静态资源"><a href="#压缩网页静态资源" class="headerlink" title="压缩网页静态资源"></a>压缩网页静态资源</h2><p><a href="https://blog.csdn.net/lewky_liu/article/details/82432003" target="_blank" rel="noopener">参考文章地址</a><br><a href="https://github.com/rozbo/hexo-neat" target="_blank" rel="noopener">hexo-neat插件github地址</a></p><p>常规的做法是使用<code>gulp</code>来进行压缩，每次压缩时还需要输入额外的命令，比较繁琐</p><h3 id="配置hexo-neat压缩插件"><a href="#配置hexo-neat压缩插件" class="headerlink" title="配置hexo-neat压缩插件"></a>配置hexo-neat压缩插件</h3><h4 id="在站点根目录下安装hexo-neat"><a href="#在站点根目录下安装hexo-neat" class="headerlink" title="在站点根目录下安装hexo-neat"></a>在站点根目录下安装hexo-neat</h4><p>博客目录下运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-neat --save</span><br></pre></td></tr></table></figure></p><p>如果报错，选择克隆插件，然后手动复制到插件目录里面<code>hexo目录\node_modules\</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/rozbo/hexo-neat</span><br></pre></td></tr></table></figure></p><h4 id="站点配置文件添加相关配置"><a href="#站点配置文件添加相关配置" class="headerlink" title="站点配置文件添加相关配置"></a>站点配置文件添加相关配置</h4><p>配置信息添加到博客目录文件夹下的<code>hexo目录\_config.yml</code>的末尾，可以安装自己的需求去自定义配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># hexo-neat</span><br><span class="line"># 博文压缩</span><br><span class="line">neat_enable: true</span><br><span class="line"># 压缩html</span><br><span class="line">neat_html:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line"># 压缩css  </span><br><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - &apos;**/*.min.css&apos;</span><br><span class="line"># 压缩js</span><br><span class="line">neat_js:</span><br><span class="line">  enable: true</span><br><span class="line">  mangle: true</span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">    - &apos;**/*.min.js&apos;</span><br><span class="line">    - &apos;**/jquery.fancybox.pack.js&apos;</span><br><span class="line">    - &apos;**/index.js&apos;</span><br></pre></td></tr></table></figure></p><h4 id="报错及相应解决"><a href="#报错及相应解决" class="headerlink" title="报错及相应解决"></a>报错及相应解决</h4><p><a href="https://blog.csdn.net/dataiyangu/article/details/84963491" target="_blank" rel="noopener">参考文章地址</a></p><h4 id="1、跳过压缩文件的正确配置方式"><a href="#1、跳过压缩文件的正确配置方式" class="headerlink" title="1、跳过压缩文件的正确配置方式"></a>1、跳过压缩文件的正确配置方式</h4><p>如果按照官方插件的文档说明来配置exclude，你会发现完全不起作用。这是因为配置的文件路径不对，压缩时找不到你配置的文件，自然也就无法跳过了。你需要给这些文件指定正确的路径，万能的配置方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">neat_css:</span><br><span class="line">enable: true</span><br><span class="line">exclude:</span><br><span class="line">- &apos;**/*.min.css&apos;</span><br></pre></td></tr></table></figure></p><h4 id="2、压缩html时不要跳过-md文件"><a href="#2、压缩html时不要跳过-md文件" class="headerlink" title="2、压缩html时不要跳过.md文件"></a>2、压缩html时不要跳过.md文件</h4><p>.md文件就是我们写文章时的markdown文件，如果跳过压缩.md文件，而你又刚好在文章中使用到了NexT自带的tab标签，那么当hexo在生成静态页面时就会发生解析错误。这会导致使用到了tab标签的页面生成失败而无法访问。</p><h4 id="3、压缩html时不要跳过-swig文件"><a href="#3、压缩html时不要跳过-swig文件" class="headerlink" title="3、压缩html时不要跳过.swig文件"></a>3、压缩html时不要跳过.swig文件</h4><p>.swig文件是模板引擎文件，简单的说hexo可以通过这些文件来生成对应的页面。如果跳过这些文件，那么你将会发现，你的所有页面完全没有起到压缩的效果，页面源代码里依然存在着一大堆空白。</p><h4 id="4、点击的桃心效果消失"><a href="#4、点击的桃心效果消失" class="headerlink" title="4、点击的桃心效果消失"></a>4、点击的桃心效果消失</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 压缩js</span><br><span class="line">neat_js:</span><br><span class="line">  enable: true</span><br><span class="line">  mangle: true</span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">    - &apos;**/*.min.js&apos;</span><br><span class="line">    - &apos;**/jquery.fancybox.pack.js&apos;</span><br><span class="line">    - &apos;**/index.js&apos;  </span><br><span class="line">    - &apos;**/love.js&apos;</span><br></pre></td></tr></table></figure><p>gitalk js文件报错<br>在上面的代码底部加入如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &apos;**/comments.gitalk.js&apos;</span><br></pre></td></tr></table></figure></p><h4 id="5、jquery-pjax-min-js报错"><a href="#5、jquery-pjax-min-js报错" class="headerlink" title="5、jquery pjax min js报错"></a>5、jquery pjax min js报错</h4><p>我这里的 jquery pjax min js是指的加入pjax前需要以来的两个cdn文件，一个是jq，一个是它，我将它下载到了本地，不要在意这些细节~<br>同样加入如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &apos;**/jquery_pjax_min_js.js&apos;</span><br></pre></td></tr></table></figure></p><hr><h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><p><a href="http://www.zhaojun.im/hexo-lazyload/" target="_blank" rel="noopener">参考文章地址</a></p><p>懒加载，在需要的时候才加载图片，而不是一次性加载完整个页面的图片<br>使用<code>lazyload</code>插件，适用于本地图片很多的情况</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>在<code>Hexo</code>博客目录下，执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-lazyload --save</span><br></pre></td></tr></table></figure></p><p>然后在你的 <code>Hexo</code>目录的配置文件 <code>_config.yml</code> 中添加配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lazyload:</span><br><span class="line">  enable: true</span><br><span class="line">  # className: #可选 e.g. .J-lazyload-img</span><br><span class="line">  # loadingImg: #可选 eg. ./images/loading.png</span><br></pre></td></tr></table></figure></p><p>参数：<br><code>loadingImg</code> - 图片未加载时的代替图</p><p>默认路径: <code>/js/lazyload-plugin/loading.svg</code><br>如果需要自定义，添填入 <code>loading</code> 图片地址，如果是本地图片，不要忘记把图片添加到你的主题目录下。</p><p><code>className</code> - 需要延迟加载的图片 <code>class</code>选择器</p><p>默认会延迟加载文章中的所有图片。<br>如果不为空，请填入需要延迟加载的图片<code>class</code> 选择器</p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客使用valine评论系统无效果及终极解决方案</title>
      <link href="/2019/02/20/hexo_valine/"/>
      <url>/2019/02/20/hexo_valine/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p> Hexo博客使用valine评论系统无效果及终极解决方案<br><a id="more"></a></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>有一些博主valine评论系统无效果，有一些原因：</p><blockquote><p>1、很大程度是因为next的版本升级导致某些参数设置不同<br>2、valine评论是基于LeanCloud，还有一个文章阅读次数功能也是用LeanCloud，两者会有一点冲突</p></blockquote><p>之后会给出一些解决方案</p><h2 id="评论系统选择"><a href="#评论系统选择" class="headerlink" title="评论系统选择"></a>评论系统选择</h2><p>Hexo可用的评论系统有很多，如下：  </p><p>来必力：<a href="https://livere.com" target="_blank" rel="noopener">https://livere.com</a> （需要邮箱注册，加载慢，较卡顿）</p><p>畅言： <a href="http://changyan.kuaizhan.com" target="_blank" rel="noopener">http://changyan.kuaizhan.com</a> （安装需要备案号）</p><p>Gitment： <a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">https://github.com/imsun/gitment</a> （加载慢，有Bug）</p><p>Valine: <a href="https://github.com/xCss/Valine" target="_blank" rel="noopener">https://github.com/xCss/Valine</a> (简约，实用，使用Leancloud作为线上数据库）</p><h2 id="评论系统配置过程"><a href="#评论系统配置过程" class="headerlink" title="评论系统配置过程"></a>评论系统配置过程</h2><p><code>next</code> 集成了 <code>leancloud</code> 。可以在<code>leancloud</code>进行账号注册。</p><h3 id="1、注册LeanCloud"><a href="#1、注册LeanCloud" class="headerlink" title="1、注册LeanCloud"></a>1、注册LeanCloud</h3><p>注册地址 <a href="https://leancloud.cn/" target="_blank" rel="noopener">https://leancloud.cn/</a></p><h3 id="2、配置LeanCloud"><a href="#2、配置LeanCloud" class="headerlink" title="2、配置LeanCloud"></a>2、配置LeanCloud</h3><p>创建一个新的应用<br><img src="https://s2.ax1x.com/2019/02/20/k2FG0s.png" alt="k2FG0s.png"></p><p>随便取个名字，自己看着取吧<br><img src="https://s2.ax1x.com/2019/02/20/k2FdpT.png" alt="k2FdpT.png"></p><p>应用创建完成，点开配置按钮<br><img src="https://s2.ax1x.com/2019/02/20/k2F8mj.png" alt="k2F8mj.png"></p><p>点击<code>设置</code> &gt; <code>应用Key</code> 复制App ID 和 App Key<br><img src="https://s2.ax1x.com/2019/02/20/k2FNt0.png" alt="k2FNt0.png"></p><p>点击<code>设置</code> &gt; <code>安全中心</code> 把自己博客网址添加到安全中心，保证数据的调用安全。<br><img src="https://s2.ax1x.com/2019/02/20/k2FUhV.png" alt="k2FUhV.png"></p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>在主题<code>themes</code>目录下有第三方提供的主题配置文件<code>\themes\next\_config.yml</code><br>打开主题配置文件 添加<code>appid</code> 和<code>appkey</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Valine</span><br><span class="line"># You can get your appid and appkey from https://leancloud.cn</span><br><span class="line"># More info available at https://valine.js.org</span><br><span class="line">valine:</span><br><span class="line">  enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version.</span><br><span class="line">  appid: 粘贴id</span><br><span class="line">  appkey: 粘贴key</span><br><span class="line">  notify: false # mail notifier, See: https://github.com/xCss/Valine/wiki</span><br><span class="line">  verify: false # Verification code</span><br><span class="line">  placeholder: 欢迎交流讨论... # comment box placeholder</span><br><span class="line">  avatar: mm # gravatar style</span><br><span class="line">  guest_info: nick,mail,link # custom comment header</span><br><span class="line">  pageSize: 10 # pagination size</span><br></pre></td></tr></table></figure><h2 id="阅读次数功能配置过程"><a href="#阅读次数功能配置过程" class="headerlink" title="阅读次数功能配置过程"></a>阅读次数功能配置过程</h2><h3 id="创建阅读次数Class类"><a href="#创建阅读次数Class类" class="headerlink" title="创建阅读次数Class类"></a>创建阅读次数Class类</h3><p>在应用里面创建名称为<code>Counter</code>的<code>Class</code>，名称必须为<code>Counter</code><br><img src="https://s2.ax1x.com/2019/02/20/k2Ftkq.png" alt="k2Ftkq.png"></p><p>创建完成，效果如下：<br><img src="https://s2.ax1x.com/2019/02/20/k2FJ7n.png" alt="k2FJ7n.png"></p><h2 id="修改配置文件-1"><a href="#修改配置文件-1" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  appid: 粘贴id</span><br><span class="line">  appkey: 粘贴key</span><br></pre></td></tr></table></figure><h2 id="评论系统无效原因及解决方案"><a href="#评论系统无效原因及解决方案" class="headerlink" title="评论系统无效原因及解决方案"></a>评论系统无效原因及解决方案</h2><h3 id="1、next的版本不同导致某些参数设置不同"><a href="#1、next的版本不同导致某些参数设置不同" class="headerlink" title="1、next的版本不同导致某些参数设置不同"></a>1、next的版本不同导致某些参数设置不同</h3><p>next为5.X版本的时候，配置文件<code>themes\next\_config.yml</code>的<code>valine</code>的<code>id</code>和<code>key</code>的书写方式为<code>appid</code>和<code>appkey</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">valine:</span><br><span class="line">  appid: 粘贴id</span><br><span class="line">  appkey: 粘贴key</span><br></pre></td></tr></table></figure><p>next为6.X版本的时候，配置文件<code>themes\next\_config.yml</code>的<code>valine</code>的<code>id</code>和<code>key</code>的书写方式为<code>app_id</code>和<code>app_key</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">valine:</span><br><span class="line">  app_id: 粘贴id</span><br><span class="line">  app_key: 粘贴key</span><br></pre></td></tr></table></figure></p><p>而<code>Valine</code>文件<code>themes\next\layout\_third-party\comments\valine.swig</code>内调用函数依旧为<code>appid</code>和<code>appkey</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appId: &apos;&#123;&#123; theme.valine.appid &#125;&#125;&apos;,</span><br><span class="line">   appKey: &apos;&#123;&#123; theme.valine.appkey &#125;&#125;&apos;,</span><br></pre></td></tr></table></figure></p><h3 id="参数设置不同解决方案"><a href="#参数设置不同解决方案" class="headerlink" title="参数设置不同解决方案"></a>参数设置不同解决方案</h3><p>配置文件<code>themes\next\_config.yml</code>的<code>valine</code>的<code>id</code>和<code>key</code>的书写方式统一为为<code>appid</code>和<code>appkey</code></p><h3 id="2、valine评论和文章阅读次数功能均基于LeanCloud，两者有冲突"><a href="#2、valine评论和文章阅读次数功能均基于LeanCloud，两者有冲突" class="headerlink" title="2、valine评论和文章阅读次数功能均基于LeanCloud，两者有冲突"></a>2、valine评论和文章阅读次数功能均基于LeanCloud，两者有冲突</h3><p>valine评论和文章阅读次数功能均基于LeanCloud，在配置文件<code>themes\next\_config.yml</code>中，<code>valine</code>的配置项和文章阅读次数的配置项均需要填写<code>LeanCloud</code>的<code>id</code>和<code>key</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: 粘贴id</span><br><span class="line">  app_key: 粘贴key</span><br><span class="line"></span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  appid: 粘贴id</span><br><span class="line">  appkey: 粘贴key</span><br></pre></td></tr></table></figure></p><p>即valine评论和文章阅读功能不能同时为<code>true</code>，只能单选一个功能。</p><h3 id="功能冲突解决方案"><a href="#功能冲突解决方案" class="headerlink" title="功能冲突解决方案"></a>功能冲突解决方案</h3><p>valine作者已经给出了方案，一个两种合一的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">valine:</span><br><span class="line">  ...</span><br><span class="line">  visitor: true # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors&apos; for counter compatibility. Article reading statistic https://valine.js.org/visitor.html</span><br><span class="line">  comment_count: true # if false, comment count will only be displayed in post page, not in home page</span><br></pre></td></tr></table></figure><p>相比之前的配置项多了<code>visitor</code>和<code>comment_count</code>两项参数。即要想拥有Valine评论与文章阅读次数可见，设置<code>Valine:</code>为<code>true</code>，<code>leancloud_visitors:</code>为<code>false</code>，配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Valine</span><br><span class="line"># You can get your appid and appkey from https://leancloud.cn</span><br><span class="line"># More info available at https://valine.js.org</span><br><span class="line">valine:</span><br><span class="line">  enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version.</span><br><span class="line">  appid: 粘贴id</span><br><span class="line">  appkey: 粘贴key </span><br><span class="line">  notify: false # mail notifier, See: https://github.com/xCss/Valine/wiki</span><br><span class="line">  verify: false # Verification code</span><br><span class="line">  placeholder: 欢迎交流讨论... # comment box placeholder</span><br><span class="line">  avatar: mm # gravatar style</span><br><span class="line">  guest_info: nick,mail,link # custom comment header</span><br><span class="line">  pageSize: 10 # pagination size</span><br><span class="line">  visitor: true # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors&apos; for counter compatibility. Article reading statistic https://valine.js.org/visitor.html</span><br><span class="line">  comment_count: true # if false, comment count will only be displayed in post page, not in home page</span><br><span class="line"></span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: false</span><br></pre></td></tr></table></figure><h2 id="Valine的CDN修改"><a href="#Valine的CDN修改" class="headerlink" title="Valine的CDN修改"></a>Valine的CDN修改</h2><p>官方自带的CDN加载慢，建议将CDN改成第三方CDN<code>valine:</code>，修改如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># valine</span><br><span class="line"> # See: https://github.com/xCss/Valine</span><br><span class="line"> # Example:</span><br><span class="line"> # valine: //cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js</span><br><span class="line"> #valine: //cdnjs.cloudflare.com/ajax/libs/valine/1.3.4/Valine.min.js</span><br><span class="line"> valine: //cdn.jsdelivr.net/npm/valine@1.3.4/dist/Valine.min.js</span><br></pre></td></tr></table></figure><p>以上内容完成Valine评论的配置相关，都是自己踩的坑，合并了文章阅读次数的功能。</p><p> <a href="http://www.aomanhao.top/2019/02/20/hexo_valine/#more">我的个人博客文章地址，欢迎访问</a><br> <a href="https://blog.csdn.net/Aoman_Hao/article/details/87809762" target="_blank" rel="noopener">我的CSDN文章地址，欢迎访问</a><br> <a href="https://www.jianshu.com/p/f4658df66a15" target="_blank" rel="noopener">我的简书文章地址，欢迎访问</a><br> <a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字数统计和阅读时长(网站底部/文章内)</title>
      <link href="/2019/01/30/hexo_next_wordcount/"/>
      <url>/2019/01/30/hexo_next_wordcount/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>字数统计和阅读时长（旧版本新版本）<br><a id="more"></a><br>插件地址：<br><a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">https://github.com/theme-next/hexo-symbols-count-time</a><br>安装插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure><p>修改 站点配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line"> #文章内是否显示</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line"> # 网页底部是否显示</span><br><span class="line">  total_symbols: true</span><br><span class="line">  total_time: true</span><br></pre></td></tr></table></figure></p><p>修改 主题配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span><br><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true</span><br><span class="line">  #文章中的显示是否显示文字（本文字数|阅读时长） </span><br><span class="line">  item_text_post: true</span><br><span class="line">  #网页底部的显示是否显示文字（站点总字数|站点阅读时长） </span><br><span class="line">  item_text_total: false</span><br><span class="line">  # Average Word Length (chars count in word)</span><br><span class="line">  awl: 4</span><br><span class="line">  # Words Per Minute</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客Next主题站内搜索模块相关，解决搜索无效、一直loading的问题</title>
      <link href="/2019/01/30/hexo_theme_next_search/"/>
      <url>/2019/01/30/hexo_theme_next_search/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Hexo博客Next主题站内搜索模块相关，解决搜索无效、一直loading的问题</p><a id="more"></a><h2 id="站内搜索配置"><a href="#站内搜索配置" class="headerlink" title="站内搜索配置"></a>站内搜索配置</h2><p>设置方法：<br>首先安装<code>hexo-generator-searchdb</code>插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><p>编辑博客根目录下的<code>博客本地目录/_config.yml</code>站点配置文件，新增以下内容到任意位置，<code>search</code>顶格放否则可能没效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/klzbon" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/30/klzbon.md.png" alt="klzbon.md.png"></a></p><p>编辑<code>博客本地目录/themes/next/_config.yml</code> 主题配置文件，启用本地搜索功能,将<code>local_search:</code>下面的<code>enable:</code>的值，改成<code>true</code>，<code>local_search</code>顶格放置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  # unescape html strings to the readable one</span><br><span class="line">  unescape: false</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/k1pk7j" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/30/k1pk7j.md.png" alt="k1pk7j.md.png"></a></p><p>可以输入以下命令，先清理缓存，然后本地部署调试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></p><p>命令输入完成，提示：<strong>Hexo is running at <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></strong>，可以把网址复制到浏览器上，查看本地生成的博客搜索功能</p><hr><h2 id="搜索无效、一直loading的问题"><a href="#搜索无效、一直loading的问题" class="headerlink" title="搜索无效、一直loading的问题"></a>搜索无效、一直loading的问题</h2><p>根据以上配置出的搜索框有可能出现无法加载，搜索无效，动画一直loading的问题，如下图：</p><p><a href="https://imgchr.com/i/klzjzT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/30/klzjzT.md.jpg" alt="klzjzT.md.jpg"></a></p><p>按F12可以查看请求命令的状态，状态码<code>200</code>表示请求成功。但是搜索动画还是一直在转。</p><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>为了解决以上问题，也是花了很多时间在寻找办法，找个几个办法，终于解决了我的问题。</p><p><a href="https://www.sqlsec.com/2017/12/hexosearch.html" target="_blank" rel="noopener">国光的博客地址</a></p><p><a href="https://linchao1002.github.io/linchao1002.github.io/2019/01/23/Next%20%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">Linchao的博客地址</a></p><p>现给出比较详细的解决方法，如果搜索不成功，可能是以下原因之一</p><h3 id="1、搜索插件没有配置好"><a href="#1、搜索插件没有配置好" class="headerlink" title="1、搜索插件没有配置好"></a>1、搜索插件没有配置好</h3><p>配置就按照文章前面配置的步骤走就行了</p><h3 id="2、文章中包含特殊字符，文件编码时出错"><a href="#2、文章中包含特殊字符，文件编码时出错" class="headerlink" title="2、文章中包含特殊字符，文件编码时出错"></a>2、文章中包含特殊字符，文件编码时出错</h3><p>一般情况下，博客部署到网上想要进行本地调试，输入以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></p><p><a href="https://imgchr.com/i/klzLiq" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/30/klzLiq.md.png" alt="klzLiq.md.png"></a></p><p>报错先不用管，命令输入完成，提示：<strong>Hexo is running at <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></strong>。可以把网址复制到浏览器上，查看本地生成的博客，体验跟网站版的差不多，不出所料搜索框的动画还是会一直loading。<br><img src="https://s2.ax1x.com/2019/01/30/klzxQU.png" alt="klzxQU.png"></p><p>现在就要检查<code>search.xml</code> 文件，复制以下网址到浏览器，查看<code>search.xml</code>文件内容，是否报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost:4000/search.xml</span><br></pre></td></tr></table></figure></p><p>效果图如下：<br><a href="https://imgchr.com/i/klzzyF" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/30/klzzyF.md.png" alt="klzzyF.md.png"></a></p><p>可以看到，有报错，报错内容就是说<code>search.xml</code> 文件有一些不能读取的内容，因为xml文件是有特殊符号不能使用。如果报错，浏览器右侧滑条拉到底，看看是哪里的文章出现问题。</p><p>效果图如下：<br><a href="https://imgchr.com/i/klzOJ0" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/30/klzOJ0.md.png" alt="klzOJ0.md.png"></a></p><p>从最后的文字中找到<code>一些信息</code>，打开博客根目录下的<code>search.xml</code>文件</p><p><a href="https://imgchr.com/i/klzXWV" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/30/klzXWV.png" alt="klzXWV.png"></a></p><p>打开<code>search.xml</code>文件，找到包含那<code>一些信息</code>的那篇文章，最好是能开MarkDown在线编辑，也可以把有问题的<code>.md</code>文件拿出来，重新部署博客。</p><p>修改完成后，照平时那样部署博客就行。如果还有错，继续排查。</p><h3 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h3><h3 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h3><h3 id="我的简书主页，欢迎访问"><a href="#我的简书主页，欢迎访问" class="headerlink" title="我的简书主页，欢迎访问"></a><a href="https://www.jianshu.com/u/4082f682db35" target="_blank" rel="noopener">我的简书主页，欢迎访问</a></h3><h3 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客Next主题阅读次数热度不能读取的问题，报错Counter not initialized! More info at console err msg.</title>
      <link href="/2019/01/30/theme_next_leancloud/"/>
      <url>/2019/01/30/theme_next_leancloud/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Hexo博客Next主题阅读次数热度不能读取的问题<br><a id="more"></a></p><h3 id="加入valine在线评论"><a href="#加入valine在线评论" class="headerlink" title="加入valine在线评论"></a>加入valine在线评论</h3><p>设置效果：</p><p>设置方法：<br>首先要先去<a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a>注册一个帐号.然后再创建一个应用.</p><p>拿到<code>appid</code>和<code>appkey</code>之后，打开<code>themes/next/_config.yml</code>主题配置文件，查找<code>valine</code>，填入<code>appid</code>和 <code>appkey</code><br>我的配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># You can get your appid and appkey from https://leancloud.cn</span><br><span class="line"># More info available at https://valine.js.org</span><br><span class="line">valine:</span><br><span class="line">  enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version.</span><br><span class="line">  appid: </span><br><span class="line">  appkey: </span><br><span class="line">  notify: true # mail notifier, See: https://github.com/xCss/Valine/wiki</span><br><span class="line">  verify: true # Verification code</span><br><span class="line">  placeholder: 欢迎交流讨论... # comment box placeholder</span><br><span class="line">  avatar: mm # gravatar style</span><br><span class="line">  guest_info: nick,mail,link # custom comment header</span><br><span class="line">  pageSize: 10 # pagination size</span><br><span class="line">  visitor: false # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors&apos; for counter compatibility. Article reading statistic https://valine.js.org/visitor.html</span><br><span class="line">  comment_count: true # if false, comment count will only be displayed in post page, not in home page</span><br></pre></td></tr></table></figure><hr><h2 id="Hexo添加阅读次数"><a href="#Hexo添加阅读次数" class="headerlink" title="Hexo添加阅读次数"></a>Hexo添加阅读次数</h2><p><code>next</code> 集成了 <code>leancloud</code> 。可以在<code>leancloud</code>进行账号注册。<br>创建一个新的应用。点击应用进入。<br>创建名称为<code>Counter</code>的<code>Class</code>，名称必须为<code>Counter</code></p><p><a href="https://imgchr.com/i/k1gdSK" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/31/k1gdSK.md.png" alt="k1gdSK.md.png"></a></p><p>点击设置 &gt; 应用Key 复制App ID 和 App Key<br><a href="https://imgchr.com/i/k1gUW6" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/31/k1gUW6.md.png" alt="k1gUW6.md.png"></a></p><p>修改配置文件<br>在主题<code>themes</code>目录下有第三方提供的主题配置文件<code>\themes\next_config.yml</code><br>打开主题配置文件 添加<code>app_id</code> 和<code>app_key</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Show number of visitors to each article.</span><br><span class="line"># You can visit https://leancloud.cn get AppID and AppKey.文章热度</span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: llBsNPTabKsl2d4aU3OvrmSz-gzGzoHsz</span><br><span class="line">  app_key: gzSQowSIzhnuc5eYPj4k7c7z</span><br><span class="line">  # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security</span><br><span class="line">  # If you don&apos;t care about security in leancloud counter and just want to use it directly</span><br><span class="line">  # (without hexo-leancloud-counter-security plugin), set `security` to `false`.</span><br><span class="line">  security: false</span><br><span class="line">  betterPerformance: false</span><br></pre></td></tr></table></figure></p><p>修改统计设置<br>打开主题配置文件 定位到 <code>post_wordcount</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https://github.com/willin/hexo-wordcount</span><br><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: true</span><br><span class="line">  min2read: true</span><br><span class="line">  totalcount: false</span><br><span class="line">  separated_meta: true</span><br></pre></td></tr></table></figure></p><p>Web安全性<br>为了保证应用的统计计数功能仅应用于自己的博客，你可以在应用 &gt; 设置 &gt; 安全中心的Web安全域名中加入自己的博客域名，保证数据的调用安全。</p><p><a href="https://imgchr.com/i/k1gwQO" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/31/k1gwQO.md.png" alt="k1gwQO.md.png"></a></p><hr><h2 id="显示文章热度"><a href="#显示文章热度" class="headerlink" title="显示文章热度"></a>显示文章热度</h2><p>首先要先去<a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a>注册一个帐号.然后再创建一个应用.</p><p>设置方法：<br><code>next</code>主题集成<code>leanCloud</code>，打开<code>themes/next/layout/_macro/post.swig</code>,准备添加<code>℃</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;# LeanCloud PageView #&#125;</span><br><span class="line">&#123;% if theme.leancloud_visitors.enable or (theme.valine.enable and theme.valine.appid and theme.valine.appkey and theme.valine.visitor) %&#125;</span><br><span class="line">  &lt;span id=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; class=&quot;leancloud_visitors&quot; data-flag-title=&quot;&#123;&#123; post.title &#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &#123;% if theme.post_meta.item_text %&#125;</span><br><span class="line">      &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123; __(&apos;post.views&apos;) + __(&apos;symbol.colon&apos;) &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">      &lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;℃&lt;/span&gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>插入摄氏度到倒数第三句，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;℃&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><p>打开，<code>themes/next/languages/zh-CN.yml</code>,将<code>views</code>后的文字描述改为热度.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">views: 热度</span><br></pre></td></tr></table></figure></p><p>有的版本不一样，打开，<code>themes/next/languages/zh-Hans.yml</code>，将以下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visitors: 热度</span><br></pre></td></tr></table></figure><p>然后打开<code>themes/next/_config.yml</code>找到<code>leancloud_visitors</code>,将<code>enable:</code>改成<code>true</code>,再填上自己<code>LeanCloud</code>的<code>app_id</code>和<code>app_key</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Show number of visitors to each article.</span><br><span class="line"># You can visit https://leancloud.cn get AppID and AppKey.文章热度</span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: 你自己的id</span><br><span class="line">  app_key: 你自己的key</span><br><span class="line">  # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security</span><br><span class="line">  # If you don&apos;t care about security in leancloud counter and just want to use it directly</span><br><span class="line">  # (without hexo-leancloud-counter-security plugin), set `security` to `false`.</span><br><span class="line">  security: true</span><br><span class="line">  betterPerformance: false</span><br></pre></td></tr></table></figure></p><h3 id="报错Counter-not-initialized-More-info-at-console-err-msg"><a href="#报错Counter-not-initialized-More-info-at-console-err-msg" class="headerlink" title="报错Counter not initialized! More info at console err msg."></a>报错Counter not initialized! More info at console err msg.</h3>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo主题Next配置algolia站内搜索</title>
      <link href="/2019/01/30/hexo_theme_next_algolia/"/>
      <url>/2019/01/30/hexo_theme_next_algolia/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Hexo主题Next配置algolia站内搜索</p><a id="more"></a><p><code>Algolia</code>是一家为网站与移动应用提供托管式搜索API的初创企业，成立于2012年，总部位于旧金山，曾参加过去年的YC训练营。网站或移动应用只需嵌入简单代码数分钟即可实现搜索功能。</p><p>实现的效果如下</p><h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>注册<code>Algolia</code><br>打开<code>Algolia</code>进行注册。可直接使用github账号进行注册。</p><p>创建<code>index</code><br>点击 <code>NEW INDEX</code>创建一个新的<code>index</code>。<code>Index Name</code> 后面会使用到。<br><code>INDEX</code></p><p>编辑<code>KEY</code><br>点击侧边栏<code>API Keys</code>可以看到 <code>Application ID</code>、 <code>Search-Only API Key</code> 、 <code>Admin API Key</code>。后面我们需要用到。 点击 <code>ALL API KEYS</code>，编辑KEY。</p><p>安装<code>hexo-algoliasearch</code>插件<br>在<code>Hexo</code>的根目录下执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-algoliasearch --save</span><br></pre></td></tr></table></figure></p><p>配置站点信息<br>打开 站点配置文件，添加algolia配置信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">algolia:</span><br><span class="line">  applicationID: </span><br><span class="line">  apiKey: </span><br><span class="line">  adminApiKey: </span><br><span class="line">  indexName: #创建index使用的Index Name</span><br><span class="line">  chunkSize: 5000</span><br></pre></td></tr></table></figure></p><p>打开 主题配置文件，添加algolia配置信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Algolia Search</span><br><span class="line">algolia_search:</span><br><span class="line">  enable: true</span><br><span class="line">  hits:</span><br><span class="line">    per_page: 10</span><br><span class="line">  labels:</span><br><span class="line">    input_placeholder: Search for Posts</span><br><span class="line">    hits_empty: &quot;We didn&apos;t find any results for the search: $&#123;query&#125;&quot;</span><br><span class="line">    hits_stats: &quot;$&#123;hits&#125; results found in $&#123;time&#125; ms&quot;</span><br></pre></td></tr></table></figure></p><p>在环境变量中添加 <code>HEXO_ALGOLIA_INDEXING_KEY</code>， 在Hexo的根目录执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export HEXO_ALGOLIA_INDEXING_KEY=粘贴上一步复制的 API KEY</span><br></pre></td></tr></table></figure></p><p>再次执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo algolia</span><br></pre></td></tr></table></figure></p><p>至此，我们的工作就完成了。</p><hr><p>参考：</p><p><a href="http://sophieb.cn/hexo/build-blog-hexo-next-algolia/" target="_blank" rel="noopener">Hexo+next 添加搜索功能</a></p><p><a href="http://www.qingpingshan.com/m/view.php?aid=386198" target="_blank" rel="noopener">Hexo+Next集成Algolia搜索</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo主题Next配置（二）</title>
      <link href="/2019/01/20/theme_NextConfig2/"/>
      <url>/2019/01/20/theme_NextConfig2/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Hexo主题Next配置（二）</p><a id="more"></a><h2 id="随机背景图片加载"><a href="#随机背景图片加载" class="headerlink" title="随机背景图片加载"></a>随机背景图片加载</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>自动更换背景是修改添加背景的css样式实现</p><h3 id="图片来源"><a href="#图片来源" class="headerlink" title="图片来源"></a>图片来源</h3><p><a href="https://source.unsplash.com/" target="_blank" rel="noopener">https://source.unsplash.com/</a></p><h3 id="修改背景样式"><a href="#修改背景样式" class="headerlink" title="修改背景样式"></a>修改背景样式</h3><p>修改<code>themes\next\source\css\ _custom\custom.styl</code>文件，这个是Next故意留给用户自己个性化定制一些样式的文件，添加以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background:url(https://source.unsplash.com/random/1600x900);</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">    background-position:50% 50%;</span><br><span class="line">    background-size:cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参数细节"><a href="#参数细节" class="headerlink" title="参数细节"></a>参数细节</h4><p><code>url</code>可更换为自己喜欢的图片的地址。<br><code>repeat：</code>是否重复出现<br><code>attachment：</code>定义背景图片随滚动轴的移动方式<br><code>position：</code>设置背景图像的起始位置。<br><code>background-size:cover</code>为可能有助于大分辨率下背景图的显示</p><h3 id="修改不透明度（可加可不加，看实际效果）"><a href="#修改不透明度（可加可不加，看实际效果）" class="headerlink" title="修改不透明度（可加可不加，看实际效果）"></a>修改不透明度（可加可不加，看实际效果）</h3><p>因为next主题的背景是纯透明的，这样子就造成背景图片的影响看不见文字，这对于博客来说肯定不行。</p><p>调整背景的不透明度可以更加美观，参数<code>opacity:</code>建议调整<code>0.8</code>至<code>0.95</code>之间。<br>修改<code>themes\next\source\css\ _custom\custom.styl</code>文件。在后面添加如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.main-inner &#123; </span><br><span class="line">    margin-top: 60px;</span><br><span class="line">    padding: 60px 60px 60px 60px;</span><br><span class="line">    background: #fff;</span><br><span class="line">    opacity: 0.9;</span><br><span class="line">    min-height: 500px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中：<code>background: #fff;</code> 白色<br><code>opacity: 0.9;</code>为不透明度</p><p>注：效果还可以，但是博客备份在github上，网速限制加载的比较忙，建议博客放在国内的Coding上</p><hr><h2 id="固定背景图片加载"><a href="#固定背景图片加载" class="headerlink" title="固定背景图片加载"></a>固定背景图片加载</h2><p><code>hexo\themes\next\source\images\</code> 的路径下；<br>在文件的最上方加上一代码 body { background:url(/images/backGround.jpg（这是你之前加的背景图片的名字）);} 就完事了。</p><h3 id="修改背景样式-1"><a href="#修改背景样式-1" class="headerlink" title="修改背景样式"></a>修改背景样式</h3><p>修改<code>themes\next\source\css\ _custom\custom.styl</code>文件，添加以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background:url(/images/图片.jpg);</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">    background-position:50% 50%;</span><br><span class="line">    background-size:cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="侧边栏社交小图标设置"><a href="#侧边栏社交小图标设置" class="headerlink" title="侧边栏社交小图标设置"></a>侧边栏社交小图标设置</h3><p>侧边栏默认只有<br>打开主题配置文件（_config.yml），搜索social_icons:,在fontawesome图标库（<a href="https://fontawesome.com/" target="_blank" rel="noopener">网址</a>）找自己喜欢的小图标，并将名字复制在如下位置配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/yourname || github</span><br><span class="line">  E-Mail: mailto:邮箱地址 || envelope</span><br><span class="line">  Weibo: https://weibo.com/yourname || weibo</span><br><span class="line">  CSDN: https://me.csdn.net/yourname || book</span><br><span class="line">  #Google: https://plus.google.com/yourname || google</span><br><span class="line">  #Twitter: https://twitter.com/yourname || twitter</span><br><span class="line">  #FB Page: https://www.facebook.com/yourname || facebook</span><br><span class="line">  #VK Group: https://vk.com/yourname || vk</span><br><span class="line">  #StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span><br><span class="line">  #YouTube: https://youtube.com/yourname || youtube</span><br><span class="line">  #Instagram: https://instagram.com/yourname || instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || skype</span><br></pre></td></tr></table></figure><h3 id="设置网站图标"><a href="#设置网站图标" class="headerlink" title="设置网站图标"></a>设置网站图标</h3><h4 id="下载图标"><a href="#下载图标" class="headerlink" title="下载图标"></a>下载图标</h4><p><a href="https//www.easyicon.net/">图标网站</a></p><p>下载尺寸32 X 32的图标，文件名必须是favicon.ico。</p><h4 id="图标放在"><a href="#图标放在" class="headerlink" title="图标放在"></a>图标放在</h4><p>2.将图标放在下一个/源极/图像文件夹目录下面。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>3.配置主题目录中的配置文件（敲黑板，重点）</p><p>之前网上查到的方法如下:(并没有成功）</p><h2 id="放大文章内图片"><a href="#放大文章内图片" class="headerlink" title="放大文章内图片"></a>放大文章内图片</h2><p>使用了图片浏览放大功能fancybox插件<br><a href="https://github.com/theme-next/theme-next-fancybox" target="_blank" rel="noopener">插件地址</a></p><h3 id="下载插件安装包"><a href="#下载插件安装包" class="headerlink" title="下载插件安装包"></a>下载插件安装包</h3><p>下载插件安装包到blog的lib目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd themes/next</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/theme-next/theme-next-fancybox source/lib/fancybox</span><br></pre></td></tr></table></figure><p>注意删掉fancybox文件夹里的 <code>.git``.github</code>文件夹</p><h3 id="更改主题配置文件"><a href="#更改主题配置文件" class="headerlink" title="更改主题配置文件"></a>更改主题配置文件</h3><p>更改<code>next/_config.yml</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fancybox: true</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo主题Next配置</title>
      <link href="/2019/01/20/theme_NextConfig1/"/>
      <url>/2019/01/20/theme_NextConfig1/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Hexo主题Next配置</p><a id="more"></a><h3 id="新建404界面"><a href="#新建404界面" class="headerlink" title="新建404界面"></a>新建404界面</h3><p>在站点根目录下，输入<code>hexo new page 404</code>，在默认<code>Hexo站点下/source/404/index.md</code><br>打开新建的404界面，编辑属于自己的404界面，可以显示腾讯公益404界面，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;</span><br><span class="line">  &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt;</span><br><span class="line">  &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://qzone.qq.com/gy/404/style/404style.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script type=&quot;text/plain&quot; src=&quot;http://www.qq.com/404/search_children.js&quot;</span><br><span class="line">          charset=&quot;utf-8&quot; homePageUrl=&quot;/&quot;</span><br><span class="line">          homePageName=&quot;回到我的主页&quot;&gt;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;https://qzone.qq.com/gy/404/data.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;https://qzone.qq.com/gy/404/page.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="静态资源压缩"><a href="#静态资源压缩" class="headerlink" title="静态资源压缩"></a>静态资源压缩</h3><p>静态资源压缩</p><p>在站点目录下安装插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install gulp -g</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp-minify-css --save</span><br><span class="line">npm install gulp-uglify --save</span><br><span class="line">npm install gulp-htmlmin --save</span><br><span class="line">npm install gulp-htmlclean --save</span><br><span class="line">npm install gulp-imagemin --save</span><br></pre></td></tr></table></figure><p>在Hexo站点下添加<code>gulpfile.js</code>文件，文件内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;);</span><br><span class="line">var minifycss = require(&apos;gulp-minify-css&apos;);</span><br><span class="line">var uglify = require(&apos;gulp-uglify&apos;);</span><br><span class="line">var htmlmin = require(&apos;gulp-htmlmin&apos;);</span><br><span class="line">var htmlclean = require(&apos;gulp-htmlclean&apos;);</span><br><span class="line">var imagemin = require(&apos;gulp-imagemin&apos;);</span><br><span class="line">// 压缩css文件</span><br><span class="line">gulp.task(&apos;minify-css&apos;, function() &#123;</span><br><span class="line">  return gulp.src(&apos;./public/**/*.css&apos;)</span><br><span class="line">  .pipe(minifycss())</span><br><span class="line">  .pipe(gulp.dest(&apos;./public&apos;));</span><br><span class="line">&#125;);</span><br><span class="line">// 压缩html文件</span><br><span class="line">gulp.task(&apos;minify-html&apos;, function() &#123;</span><br><span class="line">  return gulp.src(&apos;./public/**/*.html&apos;)</span><br><span class="line">  .pipe(htmlclean())</span><br><span class="line">  .pipe(htmlmin(&#123;</span><br><span class="line">    removeComments: true,</span><br><span class="line">    minifyJS: true,</span><br><span class="line">    minifyCSS: true,</span><br><span class="line">    minifyURLs: true,</span><br><span class="line">  &#125;))</span><br><span class="line">  .pipe(gulp.dest(&apos;./public&apos;))</span><br><span class="line">&#125;);</span><br><span class="line">// 压缩js文件</span><br><span class="line">gulp.task(&apos;minify-js&apos;, function() &#123;</span><br><span class="line">    return gulp.src([&apos;./public/**/.js&apos;,&apos;!./public/js/**/*min.js&apos;])</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(&apos;./public&apos;));</span><br><span class="line">&#125;);</span><br><span class="line">// 压缩 public/demo 目录内图片</span><br><span class="line">gulp.task(&apos;minify-images&apos;, function() &#123;</span><br><span class="line">    gulp.src(&apos;./public/demo/**/*.*&apos;)</span><br><span class="line">        .pipe(imagemin(&#123;</span><br><span class="line">           optimizationLevel: 5, //类型：Number  默认：3  取值范围：0-7（优化等级）</span><br><span class="line">           progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片</span><br><span class="line">           interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染</span><br><span class="line">           multipass: false, //类型：Boolean 默认：false 多次优化svg直到完全优化</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(&apos;./public/uploads&apos;));</span><br><span class="line">&#125;);</span><br><span class="line">// 默认任务</span><br><span class="line">gulp.task(&apos;default&apos;, [</span><br><span class="line">  &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;,&apos;minify-images&apos;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure></p><p>需要只在每次执行generate命令后执行gulp就可以实现对静态资源的压缩，完成压缩后执行deploy命令同步到服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">gulp</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><hr><h3 id="隐藏网页底部powered-By-Hexo-强力驱动"><a href="#隐藏网页底部powered-By-Hexo-强力驱动" class="headerlink" title="隐藏网页底部powered By Hexo / 强力驱动"></a>隐藏网页底部powered By Hexo / 强力驱动</h3><p>打开<code>themes/next/layout/_partials/footer.swig</code>,使用<code>&lt;!--</code>与<code>--&gt;</code>隐藏之间的代码即可，或者直接删除。位置如图：<br><img src="http://upload-images.jianshu.io/upload_images/5308475-8e8340c7a0489bce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hexo"></p><hr><h3 id="各版块透明度修改"><a href="#各版块透明度修改" class="headerlink" title="各版块透明度修改"></a>各版块透明度修改</h3><h4 id="内容板块透明"><a href="#内容板块透明" class="headerlink" title="内容板块透明"></a>内容板块透明</h4><p>根博客目录<code>themes\next\source\css\_schemes\Pisces\_layout.styl</code>文件<code>.content-wrap</code>标签下<code>background: white</code>修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: rgba(255,255,255,0.7); //0.7是透明度</span><br></pre></td></tr></table></figure></p><h4 id="菜单栏背景"><a href="#菜单栏背景" class="headerlink" title="菜单栏背景"></a>菜单栏背景</h4><p>根博客目录<code>themes\next\source\css\_schemes\Pisces\_layout.styl</code>文件<code>.header-inner</code>标签下<code>background: white</code>修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: rgba(255,255,255,0.7); //0.7是透明度</span><br></pre></td></tr></table></figure></p><h4 id="站点概况背景"><a href="#站点概况背景" class="headerlink" title="站点概况背景"></a>站点概况背景</h4><p>根博客目录<code>themes\next\source\css\_schemes\Pisces\_sidebar.styl</code>文件<code>.sidebar-inner</code>标签下<code>background: white</code>修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: rgba(255,255,255,0.7); //0.7是透明度</span><br></pre></td></tr></table></figure></p><p>修改然后根博客目录<code>themes\next\source\css\_schemes\Pisces\_layout.styl</code>文件<code>.sidebar</code>标签下<code>background: $body-bg-color</code>修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: rgba(255,255,255,0.7); //0.7是透明度</span><br></pre></td></tr></table></figure></p><hr><h3 id="网站底部字数统计"><a href="#网站底部字数统计" class="headerlink" title="网站底部字数统计"></a>网站底部字数统计</h3><p>具体方法实现</p><p>切换到根目录下，然后运行如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure></p><p>然后在<code>/themes/next/layout/_partials/footer.swig</code>文件尾部加上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;theme-info&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><hr><h3 id="添加侧栏推荐阅读"><a href="#添加侧栏推荐阅读" class="headerlink" title="添加侧栏推荐阅读"></a>添加侧栏推荐阅读</h3><p>编辑主题配置文件，如下配置即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Blog rolls</span><br><span class="line">links_icon: link</span><br><span class="line">links_title: 推荐阅读</span><br><span class="line">#links_layout: block</span><br><span class="line">links_layout: inline</span><br><span class="line">links:</span><br><span class="line">  Swift 4: https://developer.apple.com/swift/</span><br><span class="line">  Objective-C: https://developer.apple.com/documentation/objectivec</span><br></pre></td></tr></table></figure></p><hr><h3 id="博文置顶"><a href="#博文置顶" class="headerlink" title="博文置顶"></a>博文置顶</h3><p>修改<code>hexo-generator-index</code>插件，把<code>node_modules/hexo-generator-index/lib/generator.js</code>中代码替换为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">var pagination = require(&apos;hexo-pagination&apos;);</span><br><span class="line">module.exports = function(locals)&#123;</span><br><span class="line">  var config = this.config;</span><br><span class="line">  var posts = locals.posts;</span><br><span class="line">    posts.data = posts.data.sort(function(a, b) &#123;</span><br><span class="line">        if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义</span><br><span class="line">            if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排</span><br><span class="line">            else return b.top - a.top; // 否则按照top值降序排</span><br><span class="line">        &#125;</span><br><span class="line">        else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else return b.date - a.date; // 都没定义按照文章日期降序排</span><br><span class="line">    &#125;);</span><br><span class="line">  var paginationDir = config.pagination_dir || &apos;page&apos;;</span><br><span class="line">  return pagination(&apos;&apos;, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [&apos;index&apos;, &apos;archive&apos;],</span><br><span class="line">    format: paginationDir + &apos;/%d/&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>文章添加Top值，值越大，越靠前：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo-NexT主题配置</span><br><span class="line">date: 2018-01-20 20:41:08</span><br><span class="line">categories: Hexo</span><br><span class="line">tags:</span><br><span class="line">- Hexo</span><br><span class="line">- NexT</span><br><span class="line">top: 100</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><hr><h3 id="网页底部信息隐藏"><a href="#网页底部信息隐藏" class="headerlink" title="网页底部信息隐藏"></a>网页底部信息隐藏</h3><p>网页底默认最新一次使用，需要取消<code>since</code>注释，设定年份</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">footer:</span><br><span class="line">  # Specify the date when the site was setup.</span><br><span class="line">  # If not defined, current year will be used.</span><br><span class="line">  since: 2017</span><br><span class="line"></span><br><span class="line">  # Icon between year and copyright info.</span><br><span class="line">  icon:</span><br><span class="line">    # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons/</span><br><span class="line">    # `heart` is recommended with animation in red (#ff0000).</span><br><span class="line">    name: user #设置图标，想修改图标从https://fontawesome.com/v4.7.0/icons获取</span><br><span class="line">    # If you want to animate the icon, set it to true.</span><br><span class="line">    animated: false</span><br><span class="line">    # Change the color of icon, using Hex Code.</span><br><span class="line">    color: &quot;#808080&quot;</span><br><span class="line"></span><br><span class="line">  # If not defined, `author` from Hexo main config will be used.</span><br><span class="line">  copyright:  by AomanHao  #版权</span><br></pre></td></tr></table></figure><hr><h3 id="显示文章阅读进度百分比"><a href="#显示文章阅读进度百分比" class="headerlink" title="显示文章阅读进度百分比"></a>显示文章阅读进度百分比</h3><p>设置方法：<br>打开<code>themes/next/_config.yml</code>主题配置文件,找到<code># Scroll percent label in b2t button</code>将<code>scrollpercent:</code>的值,改成<code>true</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Scroll percent label in b2t button</span><br><span class="line">  scrollpercent: true</span><br></pre></td></tr></table></figure><hr><h3 id="浏览页面的时候显示当前浏览进度"><a href="#浏览页面的时候显示当前浏览进度" class="headerlink" title="浏览页面的时候显示当前浏览进度"></a>浏览页面的时候显示当前浏览进度</h3><p>如果想把top按钮放在侧边栏,打开<code>themes/next</code>下的<code>_config.yml</code>,搜索关键字<code>b2t</code>,把<code>false</code>改为<code>true</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Back to top in sidebar</span><br><span class="line"> b2t: true</span><br><span class="line">    </span><br><span class="line"> # Scroll percent label in b2t button</span><br><span class="line"> scrollpercent: true</span><br></pre></td></tr></table></figure><hr><h3 id="加入valine在线评论"><a href="#加入valine在线评论" class="headerlink" title="加入valine在线评论"></a>加入valine在线评论</h3><p>设置效果：</p><p>设置方法：<br>首先要先去<a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a>注册一个帐号.然后再创建一个应用.</p><p>拿到<code>appid</code>和<code>appkey</code>之后，打开<code>themes/next/_config.yml</code>主题配置文件，查找<code>valine</code>，填入<code>appid</code>和 <code>appkey</code><br>我的配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># You can get your appid and appkey from https://leancloud.cn</span><br><span class="line"># More info available at https://valine.js.org</span><br><span class="line">valine:</span><br><span class="line">  enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version.</span><br><span class="line">  appid: </span><br><span class="line">  appkey: </span><br><span class="line">  notify: true # mail notifier, See: https://github.com/xCss/Valine/wiki</span><br><span class="line">  verify: true # Verification code</span><br><span class="line">  placeholder: 欢迎交流讨论... # comment box placeholder</span><br><span class="line">  avatar: mm # gravatar style</span><br><span class="line">  guest_info: nick,mail,link # custom comment header</span><br><span class="line">  pageSize: 10 # pagination size</span><br><span class="line">  visitor: false # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors&apos; for counter compatibility. Article reading statistic https://valine.js.org/visitor.html</span><br><span class="line">  comment_count: true # if false, comment count will only be displayed in post page, not in home page</span><br></pre></td></tr></table></figure><hr><h3 id="Hexo添加阅读次数"><a href="#Hexo添加阅读次数" class="headerlink" title="Hexo添加阅读次数"></a>Hexo添加阅读次数</h3><p><code>next</code> 集成了 <code>leancloud</code> 。可以在<code>leancloud</code>进行账号注册。<br>创建一个新的应用。点击应用进入。<br>创建名称为<code>Counter</code>的<code>Class</code>，名称必须为<code>Counter</code></p><p><a href="https://imgchr.com/i/k1gdSK" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/31/k1gdSK.md.png" alt="k1gdSK.md.png"></a></p><p>点击设置 &gt; 应用Key 复制App ID 和 App Key<br><a href="https://imgchr.com/i/k1gUW6" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/31/k1gUW6.md.png" alt="k1gUW6.md.png"></a></p><p>修改配置文件<br>在主题<code>themes</code>目录下有第三方提供的主题配置文件<code>\themes\next_config.yml</code><br>打开主题配置文件 添加<code>app_id</code> 和<code>app_key</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Show number of visitors to each article.</span><br><span class="line"># You can visit https://leancloud.cn get AppID and AppKey.文章热度</span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: </span><br><span class="line">  app_key: </span><br><span class="line">  # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security</span><br><span class="line">  # If you don&apos;t care about security in leancloud counter and just want to use it directly</span><br><span class="line">  # (without hexo-leancloud-counter-security plugin), set `security` to `false`.</span><br><span class="line">  security: false</span><br><span class="line">  betterPerformance: false</span><br></pre></td></tr></table></figure></p><p>Web安全性<br>为了保证应用的统计计数功能仅应用于自己的博客，你可以在应用 &gt; 设置 &gt; 安全中心的Web安全域名中加入自己的博客域名，保证数据的调用安全。</p><p><a href="https://imgchr.com/i/k1gwQO" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/31/k1gwQO.md.png" alt="k1gwQO.md.png"></a></p><hr><h3 id="显示文章热度"><a href="#显示文章热度" class="headerlink" title="显示文章热度"></a>显示文章热度</h3><p>首先要先去<a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a>注册一个帐号.然后再创建一个应用.</p><p>设置方法：<br><code>next</code>主题集成<code>leanCloud</code>，打开<code>themes/next/layout/_macro/post.swig</code>,准备添加<code>℃</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;# LeanCloud PageView #&#125;</span><br><span class="line">&#123;% if theme.leancloud_visitors.enable or (theme.valine.enable and theme.valine.appid and theme.valine.appkey and theme.valine.visitor) %&#125;</span><br><span class="line">  &lt;span id=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; class=&quot;leancloud_visitors&quot; data-flag-title=&quot;&#123;&#123; post.title &#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &#123;% if theme.post_meta.item_text %&#125;</span><br><span class="line">      &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123; __(&apos;post.views&apos;) + __(&apos;symbol.colon&apos;) &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">      &lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;℃&lt;/span&gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>插入摄氏度到倒数第三句，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;℃&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><p>打开，<code>themes/next/languages/zh-CN.yml</code>,将<code>views</code>后的文字描述改为热度.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">views: 热度</span><br></pre></td></tr></table></figure></p><p>有的版本不一样，打开，<code>themes/next/languages/zh-Hans.yml</code>，将以下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visitors: 热度</span><br></pre></td></tr></table></figure><p>然后打开<code>themes/next/_config.yml</code>找到<code>leancloud_visitors</code>,将<code>enable:</code>改成<code>true</code>,再填上自己<code>LeanCloud</code>的<code>app_id</code>和<code>app_key</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Show number of visitors to each article.</span><br><span class="line"># You can visit https://leancloud.cn get AppID and AppKey.文章热度</span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: 你自己的id</span><br><span class="line">  app_key: 你自己的key</span><br><span class="line">  # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security</span><br><span class="line">  # If you don&apos;t care about security in leancloud counter and just want to use it directly</span><br><span class="line">  # (without hexo-leancloud-counter-security plugin), set `security` to `false`.</span><br><span class="line">  security: true</span><br><span class="line">  betterPerformance: false</span><br></pre></td></tr></table></figure></p><hr><h3 id="添加网站已运行时间"><a href="#添加网站已运行时间" class="headerlink" title="添加网站已运行时间"></a>添加网站已运行时间</h3><p>在<code>themes/layout/_parrials/footer.swing</code>后添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var now = new Date(); </span><br><span class="line">    function createtime() &#123; </span><br><span class="line">        var grt= new Date(&quot;11/27/2017 12:00:00&quot;);//在此处修改你的建站时间</span><br><span class="line">        now.setTime(now.getTime()+250); </span><br><span class="line">        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); </span><br><span class="line">        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); </span><br><span class="line">        if(String(hnum).length ==1 )&#123;hnum = &quot;0&quot; + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); </span><br><span class="line">        mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = &quot;0&quot; + mnum;&#125; </span><br><span class="line">        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); </span><br><span class="line">        snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = &quot;0&quot; + snum;&#125; </span><br><span class="line">        document.getElementById(&quot;timeDate&quot;).innerHTML = &quot; Runing &quot;+dnum+&quot; D &quot;; </span><br><span class="line">        document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; H &quot; + mnum + &quot; M &quot; + snum + &quot; S&quot;; </span><br><span class="line">    &#125; </span><br><span class="line">setInterval(&quot;createtime()&quot;,250);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="添加头像"><a href="#添加头像" class="headerlink" title="添加头像"></a>添加头像</h3><p>打开<code>themes/next下的_config.yml</code>文件，搜索 <code>Avatar</code>关键字，修改url的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">avatar:</span><br><span class="line">  # in theme directory(source/images): /images/avatar.gif</span><br><span class="line">  # in site  directory(source/uploads): /uploads/avatar.gif</span><br><span class="line">  # You can also use other linking images.</span><br><span class="line">  url: /images/avatar.gif</span><br><span class="line">  # If true, the avatar would be dispalyed in circle.</span><br><span class="line">  rounded: true</span><br><span class="line">  # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar.</span><br><span class="line">  opacity: 1</span><br><span class="line">  # If true, the avatar would be rotated with the cursor.</span><br><span class="line">  rotated: false</span><br></pre></td></tr></table></figure></p><p>url链接默认是<code>themes/next/source/images</code>下的<code>avatar.gif</code>文件,有两种方法修改连接</p><p>1、本地连接，不建议用比较大的图片（大于1M文件），加载图片需要时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url: /images/avatar.gif</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">url: /images/xx.jpg等类型图片</span><br></pre></td></tr></table></figure></p><p>2、图床外链，建议使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url: http://example.com/avatar.png</span><br></pre></td></tr></table></figure></p><hr><h3 id="添加站内搜索"><a href="#添加站内搜索" class="headerlink" title="添加站内搜索"></a>添加站内搜索</h3><p>设置效果：</p><p>设置方法：<br>安装<code>hexo-generator-searchdb</code>插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></p><p>编辑<code>_config.yml</code>站点配置文件，新增以下内容到任意位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></p><p>编辑<code>themes/next/_config.yml</code>主题配置文件，启用本地搜索功能,将<code>local_search:</code>下面的<code>enable:</code>的值，改成<code>true</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><hr><h3 id="底部跳动图标实现"><a href="#底部跳动图标实现" class="headerlink" title="底部跳动图标实现"></a>底部跳动图标实现</h3><p>注意点：需要到<code>next\layout_partials下的footer.swig</code>文件中，在你所需要调动的图标所对应的span中增加对应的ID<br>去到主体的<code>css</code>文件（<code>next\source\css_variables\custom.styl</code>，增加以下代码即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//底部爱心小图标跳动</span><br><span class="line">keyframes heartAnimate &#123;</span><br><span class="line">    0%,100%&#123;transform:scale(1);&#125;</span><br><span class="line">    10%,30%&#123;transform:scale(0.9);&#125;</span><br><span class="line">    20%,40%,60%,80%&#123;transform:scale(1.1);&#125;</span><br><span class="line">    50%,70%&#123;transform:scale(1.1);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//图标所对应的span中的ID</span><br><span class="line">#heart &#123;</span><br><span class="line">    animation: heartAnimate 1.33s ease-in-out infinite;</span><br><span class="line">&#125;</span><br><span class="line">.with-love &#123;</span><br><span class="line">    color: rgb(255, 113, 113);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="实现统计功能"><a href="#实现统计功能" class="headerlink" title="实现统计功能"></a>实现统计功能</h3><p>具体实现方法:在根目录下安装 <code>hexo-wordcount</code>,运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure></p><p>然后在主题的配置文件中，配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https://github.com/willin/hexo-wordcount</span><br><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: true</span><br><span class="line">  min2read: true</span><br></pre></td></tr></table></figure></p><hr><h3 id="修改界面内容显示区域宽度"><a href="#修改界面内容显示区域宽度" class="headerlink" title="修改界面内容显示区域宽度"></a>修改界面内容显示区域宽度</h3><p><code>Next</code>主题默认的设置，两边留白的区域很大。当然我们可以修改设置<br>在<code>themes\next\source\css\_custom的custom.styl</code>添加下面参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 屏幕宽度小于1600px</span><br><span class="line">$content-desktop = 700px</span><br><span class="line"></span><br><span class="line">// 屏幕宽度大于或等于 1600px</span><br><span class="line">$content-desktop-large = 900px</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理_噪声检测</title>
      <link href="/2018/12/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%99%AA%E5%A3%B0%E6%A3%80%E6%B5%8B/"/>
      <url>/2018/12/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%99%AA%E5%A3%B0%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>噪声检测</p><a id="more"></a><h2 id="噪声检测方法"><a href="#噪声检测方法" class="headerlink" title="噪声检测方法"></a>噪声检测方法</h2><p>将噪声和信号区分开来是影响去噪效果好坏的重要因素之一。近年来，学者们提出了诸多噪声判断方法，其中较经典的方法包括：开关阈值法、极值法、两级门限法，下面对这三种方法进行介绍，并进行对比。<br>1.1 常见的噪声检测方法<br>（1）开关阈值法<br>开关阈值判断法[1]基本思想是：该方法通过一定的规则将噪声点和信号点进行判断，区分成两种类别来控制开关单元。若该像素点被判断为噪声点，则开关单元与滤波器相连接，即该点经过滤波后输出；若该像素点被判断为信号点，则开关单元对该点保持原像素值输出。开关阈值法的重点在于噪声检测器的设置，<br>其中较为常见的一种开关阈值判断法表示如下： </p><script type="math/tex; mode=display">X_(i,j=)\begin{cases}S,|f(i,j)-average(W[x_(i,j)])|<=T\\N,其他\\\end{cases}</script><p>式中 $x<em>(i,j)$是像素点，$S$是信号点，$N$是噪声点 ，$f(x,y)$是像素灰度值，$averageW(x</em>(i,j))$是邻域系统内所有灰度值的平均值，$T$ 为开关阈值。 </p><script type="math/tex; mode=display">T=(1/3)[\sqrt{\sum_{k=-1}^{k=1}\sum_{r=-1}^{r=1}[f(i+k,j+r)-average(W[x_(i,j)])]^2}</script><p>上述开关阈值判断法的优点是利用了图像邻域内的所有灰度值信息，缺点是阈值$T$ 的值对噪声点和信号点的判断影响很大。 </p><p>（2）极值法 </p><p>极值法[2]的基本思想是：在一幅图像中，邻域内的像素点和其它像素点存在较大的关联性，大多数情况下信号点与邻近像素点的灰度值差别不是太大，但噪声点相差较大；被椒盐噪声污染的像素点通常以最大值或最小值（纯黑或纯白）的灰度值出现，在噪声点检测时，若灰度值在最大值和最小值的区间范围内，则判断该像素点为信号点，反之为噪声点。具体方法如下： </p><script type="math/tex; mode=display">X_(i,j=)\begin{cases}S,minW[x_(i,j)]<f(i,j)<maxW[x_(i,j)]\\N,f(i,j)=minW[x_(i,j)]或者f(i,j)=maxW[x_(i,j)]\\\end{cases}</script><p>其中$x<em>(i,j)$为像素点，$S$为像素点，$N$为噪声点，$f(i,j)$是像素灰度值。<br>$minW[x</em>(i,j)]$是某邻域内所有像素点灰度值的最小值，$maxW[x_(i,j)]$是某邻域内所有像素点灰度值的最大值。<br>极值判断法在一定程度上能区分噪声点和信号点，尤其椒盐噪声图像，且该方法不用设置阈值，传统的自适应中值去噪方法即采用的是极值法，但该方法对椒盐去噪时，邻域内的某些极值信号像素点在判断过程中易被误判为噪声点。</p><p>（3）两级门限法<br>两级门限法[3]的思想是：椒盐噪声点的灰度值通常是集中在 255 或 0 附近，有一个大致的范围，并不一定就以最大值或最小值的形式出现；所以通过给定一个范围来判断像素值是否为噪声点，若像素灰度值落在范围内，则判断为噪声点，反之为信号点。检测方法如下： </p><script type="math/tex; mode=display">X_(i,j=)\begin{cases}S,\alpha<f(i,j)<255-\alpha\\N,0<=f(i,j)<\alpha或者255-\alpha\alpha\\\end{cases}</script><p>其中$x<em>(i,j)$为像素点，$S$为像素点，$N$为噪声点，$f(i,j)$是像素灰度值。<br>判断方法：首先设置一个阈值$\alpha$ ，规定盐点灰度值范围为 [255-$\alpha$,255]，椒点的灰度值范围为 [0,$\alpha$]。若中心像素点$x</em>(i,j)$的灰度值在盐点和椒点范围内，则该像素点为噪声点，反之是信号点。阈值$\alpha$既不能设置太大，否则易噪声误判；也不能设置太小，否则易造成漏判，文献[3]通过研究给出$\alpha=10$。该方法充分考虑到了椒盐噪声的特点，弥补了极值法的不足，提高了噪声点检测的准确性。但该方法仍需设置阈值。 </p><h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><ol><li>Sun T, Neuvo Y. Detail-preserving median based filters in image processing[J]. Pattern Recognition Letters, 1994, 15(4): 341-347.</li><li>邢藏菊 ,王守觉 ,邓浩江 ,罗予普 .一种基于极值中值的新型去噪算法 [J].中国图<br>象图形学报,2001, 6A(6):533-536</li><li>董继扬 ,  张军英 .  一种简单的椒盐噪声去噪 算法 .  计算机工程与 应用 ,  2003,<br>39(20): 28-31 </li></ol><h3 id="章节来源："><a href="#章节来源：" class="headerlink" title="章节来源："></a>章节来源：</h3><p>《图像椒盐噪声去噪算法研究及应用》-邓中东</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理_DCT（占坑）</title>
      <link href="/2018/10/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_DCT/"/>
      <url>/2018/10/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_DCT/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>DCT<br><a id="more"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理_图像噪声</title>
      <link href="/2018/10/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E5%99%AA%E5%A3%B0/"/>
      <url>/2018/10/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E5%99%AA%E5%A3%B0/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>图像噪声</p><a id="more"></a><h2 id="噪声"><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h2><p>加性噪声一般指热噪声、散弹噪声等，它们与信号的关系是相加，不管有没有信号，噪声都存在。 </p><blockquote><p>高斯白噪声包括热噪声和散粒噪声。在通信信道测试和建模中，高斯噪声被用作加性白噪声以产生加性白高斯噪声。</p><p>加性高斯白噪声只是白噪声的一种，另有泊松白噪声等,加性高斯白噪声在通信领域中指的是一种各频谱分量服从均匀分布（即白噪声），且幅度服从高斯分布的噪声信号。因其可加性、幅度服从高斯分布且为白噪声的一种而得名。</p></blockquote><p>而乘性噪声一般由信道不理想引起，它们与信号的关系是相乘，信号在它在，信号不在他也就不在。 </p><p>一般通信中把加性随机性看成是系统的背景噪声； </p><p>而乘性随机性看成系统的时变性（如衰落或者多普勒）或者非线性所造成的。</p><h3 id="椒盐噪声"><a href="#椒盐噪声" class="headerlink" title="椒盐噪声"></a>椒盐噪声</h3><p>定义：椒盐噪声又称为双极脉冲噪声，这种噪声表现的特点是噪声像素的灰度值与邻域像素有着明显差异，而其余像素的灰度值保持不变，因此在图像中造成过亮或过暗的像素点。椒盐噪声严重影响图像的视觉质量，给图像的边缘检测、纹理或者特征点提取等造成困难。</p><p>去椒盐噪声办法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、中值滤波</span><br><span class="line"></span><br><span class="line">2、开关中值滤波器 SMF（Switching Median Filter）[参考文献](Detail - preserving median based filters in image rocessing)</span><br><span class="line"></span><br><span class="line">3、自适应中值滤波器 AMF（Adaptive Median Filter）[参考文献](Adaptive median filters : New algorithms and results)</span><br><span class="line"></span><br><span class="line">4、自适应中心加权中值滤波器 ACWMF（Adaptive Center Weighted Median Filter） [参考文献](adaptive impulse detection using center Weighted median filter)</span><br><span class="line"></span><br><span class="line">5、基于决策的算法ＤＢＡ ( Decision Based Algorithm) [参考文献](A new fast and efficient decision Based algorithm for removal of high density impulse noises)</span><br></pre></td></tr></table></figure></p><p>一般会选择先检测再滤波的思路，通过开关机制抑制噪声，上述方法对低噪声水平的椒盐噪声处理效果良好，噪声水平过高无法得到理想的结果。因为基于中值的滤波方法仅考虑图像局部区域像素点的顺序阶信息，没有充分利用像素点之间的相关性或相似性。噪声像素点的估计值可能与真实值有较大偏差，很难保持图像的细节信息。</p><h3 id="高斯噪声"><a href="#高斯噪声" class="headerlink" title="高斯噪声"></a>高斯噪声</h3><p>高斯噪声是指概率密度函数服从高斯分布（即正态分布）的一类噪声。如果一个噪声，它的幅度服从高斯分布，而它的功率谱密度又是分布均匀的，则称它为高斯白噪声。高斯白噪声的二阶矩不想关，一阶矩为常数，是指先后信号在时间上的相关性。高斯白噪声包括热噪声和散粒噪声。高斯噪声完全由其时变平均值和两瞬时的协方差函数来确定，若噪声为平稳的，则平均值与时间无关，而协方差函数则变成仅和所考虑的两瞬时之方差有关的相关函数，它在意义上等效于功率谱密度。高斯噪声可以由大量独立的脉冲产生，从而在任何有限时间间隔内，这些脉冲中的每一个脉冲值与所有脉冲值的总和相比都可以忽略不计</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客添加相册</title>
      <link href="/2018/09/23/Hexo%E7%9B%B8%E5%86%8C/"/>
      <url>/2018/09/23/Hexo%E7%9B%B8%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>相册<br><a id="more"></a></p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>1.在主页上必须有一个可供点击的相册连接<br>2.要用 <code>hexo</code> 生成一个<code>photos.html</code>文件<br>3.<code>photos.html</code>中的图片数据来源?因为这是一个静态页面所有要有一个 <code>json</code>文件<br>4.<code>json</code>文件中有含有信息,图片的文件名.<br>5.图片要有一个完整的路径,用<code>github</code>的空间<br>6.<code>Python</code>脚本剪裁、压缩、上传图片到自定义的<code>github</code>备份仓库中</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="1-在主页上必须有一个可供点击的连接"><a href="#1-在主页上必须有一个可供点击的连接" class="headerlink" title="1.在主页上必须有一个可供点击的连接"></a>1.在主页上必须有一个可供点击的连接</h3><p><code>BLOG\source</code>目录下创建一个<code>photos</code>目录，目的是存放利用脚本生成的<code>json</code>文件和渲染文件。</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog_photos_1.png" alt></p><p>配置 Yilia 主题让其显示出来.<br><code>yourBlog/themes/yilia/_config.yml</code>文件<br>添加相册</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相册: /photos/</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.nos-eastchina1.126.net/blog_head_photo1.png" alt></p><h3 id="2-如何生成-photos-html-文件来"><a href="#2-如何生成-photos-html-文件来" class="headerlink" title="2.如何生成 photos.html 文件来"></a>2.如何生成 photos.html 文件来</h3><p>在<code>github</code>上新建一个仓库，主要用于存储图片，可以通过<code>url</code>访问到，也方便管理，备份图片和其他东西</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog_backup1.png" alt></p><p><code>git clone</code> 到本地，模仿作者的文件目录结构</p><p><code>source</code>文件夹是备份图片，<code>theme</code>是备份yilia配置文件等<br><img src="https://img-blog.nos-eastchina1.126.net/blog_backup2.png" alt></p><p><code>min_photos</code>是缩略图文件夹，<code>photos</code>是原图文件夹，<code>blog_photos_copy</code>是渲染文件备份，最后再弄<br><img src="https://img-blog.nos-eastchina1.126.net/blog_backup3.png" alt></p><p>备份渲染文件，最后再弄<br><img src="https://img-blog.nos-eastchina1.126.net/blog_backup4.png" alt></p><p><code>ejs</code>文件是以后要<code>hexo</code> 渲染的文件.</p><p><code>ins.js</code>文件设置自己的东西.</p><h3 id="3-修改-ejs-模板文件"><a href="#3-修改-ejs-模板文件" class="headerlink" title="3.修改 ejs 模板文件"></a>3.修改 ejs 模板文件</h3><h4 id="3-1-index-ejs文件可以不用修改"><a href="#3-1-index-ejs文件可以不用修改" class="headerlink" title="3.1 index.ejs文件可以不用修改"></a>3.1 index.ejs文件可以不用修改</h4><h4 id="3-2-修改-ins-js-文件的-render-函数-这个函数是用来渲染数据的"><a href="#3-2-修改-ins-js-文件的-render-函数-这个函数是用来渲染数据的" class="headerlink" title="3.2 修改 ins.js 文件的 render()函数.这个函数是用来渲染数据的"></a>3.2 修改 ins.js 文件的 render()函数.这个函数是用来渲染数据的</h4><p>修改图片的路径地址.<code>minSrc</code> 小图的路径. <code>src</code> 大图的路径.修改为自己的图片路径(github的路径).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var minSrc = &apos;https://raw.githubusercontent.com/AomanHao/Blog-Back-Up/master/source/min_photos/&apos; + data.link[i];</span><br><span class="line">var src = &apos;https://raw.githubusercontent.com/AomanHao/Blog-Back-Up/master/source/photos/&apos; + data.link[i];</span><br></pre></td></tr></table></figure><p>这个链接不是直接的图片url，是需要点“下载”才能看到的url。</p><p>github仓库上传的图片文件<br><img src="https://img-blog.nos-eastchina1.126.net/blog_photos_git_1.png" alt></p><p>下载选项，看网址</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog_photos_git_2.png" alt></p><p>黄色画出了链接网址，路径地址.minSrc 小图的路径. src 大图的路径<br><img src="https://img-blog.nos-eastchina1.126.net/blog_photos_git_3.png" alt></p><p>我的路径有<code>source/min_photos/</code>和<code>source/photos</code>，分别是缩略图（压缩的图快速加载预览）和原图（点击查看图片）</p><h4 id="3-3生成-json-文件"><a href="#3-3生成-json-文件" class="headerlink" title="3.3生成 json 文件."></a>3.3生成 json 文件.</h4><p>这一步是关键的一步,也是最后一步.先用脚本把图片处理成一套大图和一套小图,<br>然后上传的七牛或者 github 上再回头生成这个 <code>json</code>文件.<br>每次更新图片都要执行脚本重新生成 <code>json</code>文件.这个<code>json</code>文件会出现在<br><code>yourBlog/source/photos/data.json</code></p><p><img src="https://img-blog.nos-eastchina1.126.net/blog_photos_2.png" alt></p><h3 id="4-处理图片"><a href="#4-处理图片" class="headerlink" title="4.处理图片"></a>4.处理图片</h3><p>处理脚本试用python语言写的，运行环境也是python</p><p>python脚本文件原作者GitHub地址：<code>https://github.com/lawlite19/Blog-Back-Up</code></p><p>下载python2或者3，在<code>cmd</code>运行窗口运行<code>python tool.py</code></p><p><img src="https://img-blog.nos-eastchina1.126.net/blog_python1.png" alt></p><p><code>tool.py</code>是运行主函数，<code>ImageProcess</code>图像处理功能函数，包括裁剪、压缩等</p><p><code>git_operation()</code>方法:</p><p>如果你把图片上传到你的 github上这个方法就不用更改了.但是要确保在可以push到github的文件夹里，按照之前操作兴建了博客文件备份仓库</p><p><code>handle_photo()</code>方法:<br>注意: 该脚本对图片的命名规则有要求.<br>最前面是日期，然后用<em>进行分隔；后面是图片的描述信息，注意不要包含</em>和.符号<br><img src="https://img-blog.nos-eastchina1.126.net/blog_photos_git_4.png" alt></p><h3 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5.注意事项"></a>5.注意事项</h3><p>5.1<br>最前面是日期，然后用<em>进行分隔；后面是图片的描述信息，注意不要包含</em>和.符号</p><p>图片应该这样命名: <code>2016-10-12_xxx.jpg/png</code>；存放在<code>photos</code>中，然后脚本运行会生成压缩图片，放置在<code>min_photos</code>文件夹中。</p><p>5.2</p><p><code>tool.py</code>文件中<code>open</code>里面的设置的是本地博客路径</p><p>如<code>D:/GitHub/AomanHao.github.io/source/photos/data.json</code></p><p><code>D:/GitHub/AomanHao.github.io/</code>是你的博客在本地的路径，<code>data.json</code>是图片信息文件</p><p>5.3<br>点开图片可以显示，缩略图不显示</p><p>下载empty图，<a href="https://raw.githubusercontent.com/wardseptember/BlogPicture/master/assets/img/empty.png" target="_blank" rel="noopener">下载地址</a>，直接右键另存，保存为“empty.png”。</p><p>在你博客的本地仓库source下新建一个文件夹命名为assets,再在assets下新建一个文件夹命名为img。最后把empty.png放到img里面。</p><p>我的目录如下：<br><img src="https://img-blog.nos-eastchina1.126.net/blog_photos_git_5.png" alt></p><p>结尾：<br>在github上新建一个仓库，主要用于存储图片，可以通过url访问到，也方便管理<br>将要放到相册的图片处理成json格式的数据，然后进行访问，这里json的格式需要配合要使用的样式，所以需要处理成特定格式的json数据，下面会给出<br>图片裁剪，因为相册显示的样式最好是正方形的的图片，这里使用脚本处理一下<br>图片压缩，相册显示的图片是压缩后的图片，提高加载的速度，打开后的图片是原图。</p><p>问题：<br>当我用中文作为相册名字的时候，无法生成data.json文件，很纳闷，报错 UTF8的编码错误</p><p>算了，暂时找不改正的方法，可能是python是2.多的原因吧，我的相片都是用了英文命名</p><p><a href="https://www.jianshu.com/p/a9f309aaa0e0" target="_blank" rel="noopener">参考文章1</a><br><a href="http://lawlite.me/2017/04/13/Hexo-Github%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%86%8C%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">参考文章2</a><br><a href="https://blog.csdn.net/wardseptember/article/details/82780684" target="_blank" rel="noopener">参考文章3</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git配置</title>
      <link href="/2018/09/19/Git%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/09/19/Git%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Git配置</p><a id="more"></a><h3 id="右键菜单配置-Git-Bash-Here-功能键"><a href="#右键菜单配置-Git-Bash-Here-功能键" class="headerlink" title="右键菜单配置 Git Bash Here 功能键"></a>右键菜单配置 Git Bash Here 功能键</h3><p>运行regedit.exe进入注册表，在HKEY_CLASSES_ROOT\Directory\Background\shell中进行设置。</p><p>1.新建项Git Bush Here，此时你可以看到在桌面右键会出现“Git Bush Here”菜单。</p><p>2.添加Git Bush Icon，在第一步的新建项Git Bush Here下，新建字符串值Icon，然后编辑该值为“C:\Program Files\Git\mingw64\share\git\git-for-windows.ico”，你需要根据你安装的Git 目录进行配置修改。完成此步后，你会发现右键菜单“Git Bush Here”会多出一个Icon。</p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/git_bash1.png" alt></p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/git_bash2.png" alt></p><p>3.添加Command项。在“Git Bush Here”下再新建项“Command”，将其默认值改为“C:\Program Files\Git\bin\bash.exe —login -i”，这样，你就可以通过右键菜单的方式快速进入Git命令行工具，进行代码版本管理。</p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/git_command1.png" alt></p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/git_command2.png" alt></p><h3 id="git-命令"><a href="#git-命令" class="headerlink" title="git 命令"></a>git 命令</h3><p>1.git config</p><p>该命令允许你获得和设置配置变量；这些变量可以控制Git的外观和操作的各个方面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用方法: git config –global user.name “[name]”</span><br><span class="line"></span><br><span class="line">使用方法: git config –global user.email “[email address]”</span><br></pre></td></tr></table></figure></p><p>2.git init</p><p>git init命令创建一个空的Git仓库或重新初始化一个现有仓库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用方法：git init [repository name]</span><br></pre></td></tr></table></figure></p><p>3.git clone</p><p>git clone命令将存储库克隆到新目录中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用方法：git clone [url]</span><br></pre></td></tr></table></figure></p><p>4.git add</p><p>git add命令将文件内容添加到索引(将修改添加到暂存区)。也就是将要提交的文件的信息添加到索引库中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用方法: git add [file] ;</span><br></pre></td></tr></table></figure></p><p>5.git commit<br>该命令用于将更改记录(提交)到存储库。将索引的当前内容与描述更改的用户和日志消息一起存储在新的提交中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用方法: git commit -m “[ Type in the commit message]”</span><br><span class="line"></span><br><span class="line">使用方法：git commit -a</span><br></pre></td></tr></table></figure><p>在修改文件后,需要使用gitadd把文件加入暂存区,这样gitcommit时才能把已经修改的信息加入版本库,而使用gitcommit-a可以不用再git add。</p><p>6.git diff</p><p>该命令用于显示提交和工作树等之间的更改。此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用方法: git diff</span><br><span class="line"></span><br><span class="line">使用方法：git diff –staged</span><br></pre></td></tr></table></figure></p><p>gitdiff—staged显示的是暂存区和版本库差异</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用方法：git diff [first branch] [second branch]</span><br></pre></td></tr></table></figure><p>命令显示两个分支之间的差异。</p><p>7.git reset<br>git reset命令用于将当前HEAD复位到指定状态。一般用于撤消之前的一些操作(如:git add,git commit等)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用方法: git reset [file]</span><br><span class="line"></span><br><span class="line">使用方法: git reset [commit]</span><br></pre></td></tr></table></figure></p><p>撤消指定提交后的所有提交，并在本地保留更改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用方法：git reset –hard [commit]</span><br></pre></td></tr></table></figure><p>丢弃所有历史记录并返回到指定的提交。</p><p>8.git status<br>该命令用于显示工作目录和暂存区的状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用方法: git status</span><br></pre></td></tr></table></figure></p><p>9.git rm<br>该命令用于从工作区和索引中删除文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用方法: git rm [file]</span><br></pre></td></tr></table></figure></p><p>10.git log<br>该命令用于显示提交日志信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用方法: git log</span><br><span class="line"></span><br><span class="line">使用方法：git log –follow[file]</span><br></pre></td></tr></table></figure></p><p>列出文件的版本历史记录，包括文件的重命名。</p><p>11.git show<br>该命令用于显示各种类型的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用方法: git show [commit]</span><br></pre></td></tr></table></figure></p><p>12.git tag<br>该命令用于创建,列出,删除或验证使用GPG签名的标签对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用方法: git tag [commitID]</span><br></pre></td></tr></table></figure></p><p>13.git branch</p><p>该命令列出当前存储库中的所有本地分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用方法: git branch</span><br><span class="line"></span><br><span class="line">使用方法：git branch [branch name]</span><br></pre></td></tr></table></figure></p><p>创建一个新分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用方法：git branch -d [branch name]</span><br></pre></td></tr></table></figure><p>删除分支</p><p>14.git checkout</p><p>该命令命令用于从一个分支切换到另一个分支。</p><p>使用方法：git checkout [branch name]</p><p>使用方法: git checkout -b [branch name]</p><p>该命令创建一个新分支并切换过去。</p><p>15.git merge<br>该命令用于将两个或两个以上的开发历史加入(合并)一起。</p><p>使用方法: git merge [branch name]</p><p>16.git remote<br>该命令管理一组跟踪的存储库。</p><p>使用方法: git remote add [variable name] [Remote Server Link]</p><p>17.git push<br>该命令用于将本地分支的更新,推送到远程主机。</p><p>使用方法: git push [variable name] master</p><p>使用方法：git push [variable name] [branch]</p><p>将分支提交到远程存储库。</p><p>使用方法：git push –all [variable name]</p><p>将所有分支推送到远程存储库。</p><p>使用方法: git push [variable name] :[branch name]</p><p>删除远程存储库上的分支。</p><p>18.git pull<br>该命令用于从另一个存储库或本地分支获取并集成(整合)。</p><p>使用方法: git pull [Repository Link]</p><p>19.git stash<br>该命令临时存储所有已修改的跟踪文件。。</p><p>使用方法: git stash save</p><p>使用方法：git stash pop</p><p>可恢复最近隐藏的文件。</p><p>使用方法：git stash list</p><p>列出所有存储的更改集。</p><p>使用方法：git stash drop</p><p>移除stash</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VScode配置</title>
      <link href="/2018/09/19/VScode%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/09/19/VScode%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>VScode配置</p><a id="more"></a><h3 id="VScode插件"><a href="#VScode插件" class="headerlink" title="VScode插件"></a>VScode插件</h3><p>Git History（装完输入 git log有惊喜)</p><p>Git Lens（让本就集成了 git 的 VSC 更加强大</p><p>Markdown Preview Enhanced(markdown 预览)</p><p>Emoji Code</p><p>Dracula Official 吸血鬼主题，暗黑风格</p><p>Code Runner  —- 支持多种语言例如： C，C++，Java，JavaSript，PHP，Python，Perl，Perl6 等</p><p>Bracket Pair Colorizer 和 Indent Rainbow，这两个插件可以让不同缩减的括号显示不同的颜色。</p><p>Auto Close Tag 和 Auto Rename Tag 插件，自动补全标签和联动重名标签</p><p>Studio Icons 图标展示，丰富界面</p><h3 id="VScode设置中文界面"><a href="#VScode设置中文界面" class="headerlink" title="VScode设置中文界面"></a>VScode设置中文界面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、按f1，搜索 Configore Display Language </span><br><span class="line"></span><br><span class="line">设置 zh-cn 关闭软件重启。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、如果重启菜单等还是英文的，在商店查看已安装的插件，把中文插件重新安装一遍，然后重启软件。</span><br><span class="line"></span><br><span class="line">应用商店搜索插件-chinese(simplified)</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/p930318/article/details/80491499?utm_source=copy" target="_blank" rel="noopener">参考文章</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> VScode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理_灰度变换_直方图</title>
      <link href="/2018/09/07/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2_%E7%9B%B4%E6%96%B9%E5%9B%BE/"/>
      <url>/2018/09/07/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2_%E7%9B%B4%E6%96%B9%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>图像处理<em>灰度变换</em>直方图</p><a id="more"></a><h2 id="直方图均衡化-Histogram-Equalization"><a href="#直方图均衡化-Histogram-Equalization" class="headerlink" title="直方图均衡化 Histogram Equalization"></a>直方图均衡化 Histogram Equalization</h2><p>假如图像的灰度分布不均匀，其灰度分布集中在较窄的范围内，使图像的细节不够清晰，对比度较低。通常采用<strong>直方图均衡化</strong>及<strong>直方图规定化</strong>两种变换，使图像的灰度范围拉开或使灰度均匀分布，从而增大反差，使图像细节清晰，以达到增强的目的。<br>直方图均衡化，对图像进行非线性拉伸，重新分配图像的灰度值，使一定范围内图像的灰度值大致相等。这样，原来直方图中间的峰值部分对比度得到增强，而两侧的谷底部分对比度降低，输出图像的直方图是一个较为平坦的直方图。</p><h3 id="均衡化算法"><a href="#均衡化算法" class="headerlink" title="均衡化算法"></a>均衡化算法</h3><p>直方图的均衡化实际也是一种灰度的变换过程，将当前的灰度分布通过一个变换函数，变换为范围更宽、灰度分布更均匀的图像。也就是将原图像的直方图修改为在整个灰度区间内大致均匀分布，因此扩大了图像的动态范围，增强图像的对比度。通常均衡化选择的变换函数是灰度的累积概率，直方图均衡化算法的步骤：</p><p>1、计算原图像的灰度直方图 $P(S_k)=n_kn$，其中$n$为像素总数，$n_k$为灰度级$S_k$的像素个数</p><p>2、计算原始图像的累积直方图<br>$CDF(S<em>k)=\sum</em>{i=0}^kn<em>in=\sum</em>{i=0}^kPs(Si)$<br>$D_j=L⋅CDF(S_i)$<br>其中 $D_j$是目的图像的像素，$CDF(S_i)$是源图像灰度为i的累积分布，$L$是图像中最大灰度级（灰度图为255）直接应用该方法得到图像的灰度直方图</p><p>3、将灰度直方图进行归一化，计算灰度的累积概率；<br>创建灰度变化的查找表<br>应用查找表，将原图像变换为灰度均衡的图像</p><h4 id="均衡化过程中，必须要保证两个条件"><a href="#均衡化过程中，必须要保证两个条件" class="headerlink" title="均衡化过程中，必须要保证两个条件"></a>均衡化过程中，必须要保证两个条件</h4><blockquote><p>1、像素无论怎么映射，一定要保证原来的大小关系不变，较亮的区域，依旧是较亮的，较暗依旧暗，只是对比度增大，绝对不能明暗颠倒；<br><br>2、如果是八位图像，那么像素映射函数的值域应在0和255之间的，不能越界。</p></blockquote><p>综合以上两个条件，累积分布函数是个好的选择，因为<strong>累积分布函数</strong>是<strong>单调增函数</strong>（控制大小关系），并且值域是0到1（控制越界问题），所以直方图均衡化中使用的是累积分布函数。</p><h4 id="累积分布函数"><a href="#累积分布函数" class="headerlink" title="累积分布函数"></a>累积分布函数</h4><p>累积分布函数具有一些好的性质，那么如何运用累积分布函数使得直方图均衡化？比较概率分布函数和累积分布函数，前者的二维图像是参差不齐的，后者是单调递增的。直方图均衡化过程中，映射方法是</p><script type="math/tex; mode=display">S_k = \sum_{j=0}^k\frac{n_j}{n} . k=0,1...,L-1</script><p>$n$是图像素总和，$n_k$是当前灰度级的像素个数，$L$是图像中灰度级总数</p><p>操作步骤有:<br><img src="https://img-blog.nos-eastchina1.126.net/huidu_junheng1.png" alt></p><h3 id="直方图规定化"><a href="#直方图规定化" class="headerlink" title="直方图规定化"></a>直方图规定化</h3><p>直方图规定化，就是对原始图像做变换，使得变换后的图像的直方图跟我们规定的一样。</p><p>具体步骤如下：</p><p>1、首先对原始图像做直方图均衡化，得到每个像素s和累积分布T(s);</p><p>2、根据需要的规定化直方图，求累积分布G(Z)；</p><p>3、显然，如果累积直方图中有0值，那么是不会分配像素值的，因为0乘以255还是零。</p><p>4、对于每一个T（s）（假设其像素值为ss）,找到在G（Z）中与其差值最小的那个G（z）值（假设对应的像素值为zz），那么规定化后就把ss变换为zz。</p><p>直方图规定化流程下图：<br><img src="https://img-blog.nos-eastchina1.126.net/huidu_guiding1.png" alt></p><p>1、计算原图像的累积直方图</p><p>2、计算规定直方图的累积直方图</p><p>3、计算两累积直方图的差值的绝对值</p><p>4、根据累积直方图差值建立灰度级的映射</p><h3 id="局部直方图处理-amp-直方图统计"><a href="#局部直方图处理-amp-直方图统计" class="headerlink" title="局部直方图处理&amp;直方图统计"></a>局部直方图处理&amp;直方图统计</h3><h3 id="Opencv代码"><a href="#Opencv代码" class="headerlink" title="Opencv代码"></a>Opencv代码</h3><h4 id="灰度直方图均衡"><a href="#灰度直方图均衡" class="headerlink" title="灰度直方图均衡"></a>灰度直方图均衡</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">// HistogramGrayEqualizeHist.cpp : 定义控制台应用程序的入口点。</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;opencv2/core/core.hpp&gt;   //cvGetSize  cvCreateImage</span><br><span class="line">#include &lt;opencv2/highgui/highgui.hpp&gt;</span><br><span class="line">#include &lt;opencv2/opencv.hpp&gt;  //cvResize cvInitMatHeader cvGetMinMaxHistValue cvCvtColor</span><br><span class="line">#include &lt;opencv2/imgproc/imgproc.hpp&gt;</span><br><span class="line"></span><br><span class="line">#ifdef _DEBUG</span><br><span class="line">#pragma comment(lib, &quot;opencv_core244d&quot;)</span><br><span class="line">#pragma comment(lib, &quot;opencv_highgui244d&quot;)</span><br><span class="line">#pragma comment(lib, &quot;opencv_imgproc244d&quot;)  //cvResize</span><br><span class="line">#else</span><br><span class="line">#pragma comment(lib, &quot;opencv_core244d&quot;)</span><br><span class="line">#pragma comment(lib, &quot;opencv_highgui244d&quot;)</span><br><span class="line">#pragma comment(lib, &quot;opencv_imgproc244d&quot;)  //cvResize</span><br><span class="line">#endif</span><br><span class="line">#define cvQueryHistValue_1D(hist,idx0) ((float)cvGetReal1D( (hist)-&gt;bins, (idx0)))</span><br><span class="line"></span><br><span class="line">using namespace std;  </span><br><span class="line">#pragma comment(linker, &quot;/subsystem:\&quot;windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;)  </span><br><span class="line">void FillWhite(IplImage *pImage)  </span><br><span class="line">&#123;  </span><br><span class="line">    cvRectangle(pImage, cvPoint(0, 0), cvPoint(pImage-&gt;width, pImage-&gt;height), CV_RGB(255, 255, 255), CV_FILLED);  </span><br><span class="line">&#125;  </span><br><span class="line">// 创建灰度图像的直方图  </span><br><span class="line">CvHistogram* CreateGrayImageHist(IplImage **ppImage)  </span><br><span class="line">&#123;  </span><br><span class="line">    int nHistSize = 256;  </span><br><span class="line">    float fRange[] = &#123;0, 255&#125;;  //灰度级的范围    </span><br><span class="line">    float *pfRanges[] = &#123;fRange&#125;;    </span><br><span class="line">    CvHistogram *pcvHistogram = cvCreateHist(1, &amp;nHistSize, CV_HIST_ARRAY, pfRanges);  </span><br><span class="line">    cvCalcHist(ppImage, pcvHistogram);  </span><br><span class="line">    return pcvHistogram;  </span><br><span class="line">&#125;  </span><br><span class="line">// 根据直方图创建直方图图像  </span><br><span class="line">IplImage* CreateHisogramImage(int nImageWidth, int nScale, int nImageHeight, CvHistogram *pcvHistogram)  </span><br><span class="line">&#123;  </span><br><span class="line">    IplImage *pHistImage = cvCreateImage(cvSize(nImageWidth * nScale, nImageHeight), IPL_DEPTH_8U, 1);  </span><br><span class="line">    FillWhite(pHistImage);  </span><br><span class="line">  </span><br><span class="line">    //统计直方图中的最大直方块  </span><br><span class="line">    float fMaxHistValue = 0;  </span><br><span class="line">    cvGetMinMaxHistValue(pcvHistogram, NULL, &amp;fMaxHistValue, NULL, NULL);  </span><br><span class="line">  </span><br><span class="line">    //分别将每个直方块的值绘制到图中  </span><br><span class="line">    int i;  </span><br><span class="line">    for(i = 0; i &lt; nImageWidth; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        float fHistValue = cvQueryHistValue_1D(pcvHistogram, i); //像素为i的直方块大小  </span><br><span class="line">        int nRealHeight = cvRound((fHistValue / fMaxHistValue) * nImageHeight);  //要绘制的高度  </span><br><span class="line">        cvRectangle(pHistImage,  </span><br><span class="line">            cvPoint(i * nScale, nImageHeight - 1),  </span><br><span class="line">            cvPoint((i + 1) * nScale - 1, nImageHeight - nRealHeight),  </span><br><span class="line">            cvScalar(i, 0, 0, 0),   </span><br><span class="line">            CV_FILLED  </span><br><span class="line">            );   </span><br><span class="line">    &#125;  </span><br><span class="line">    return pHistImage;  </span><br><span class="line">&#125;  </span><br><span class="line">int main( int argc, char** argv )  </span><br><span class="line">&#123;     </span><br><span class="line">    const char *pstrWindowsSrcTitle = &quot;原图&quot;;  </span><br><span class="line">    const char *pstrWindowsGrayTitle = &quot;灰度图&quot;;  </span><br><span class="line">    const char *pstrWindowsHistTitle = &quot;直方图&quot;;  </span><br><span class="line">    const char *pstrWindowsGrayEqualizeTitle = &quot;灰度图-均衡化后&quot;;  </span><br><span class="line">    const char *pstrWindowsHistEqualizeTitle = &quot;直方图-均衡化后&quot;;  </span><br><span class="line">      </span><br><span class="line">    // 从文件中加载原图  </span><br><span class="line">    // IplImage *pSrcImage = cvLoadImage(&quot;./images/yangmi.jpg&quot;, CV_LOAD_IMAGE_UNCHANGED);  </span><br><span class="line">    IplImage *pSrcImage = cvLoadImage(&quot;./images/beauty.png&quot;, CV_LOAD_IMAGE_UNCHANGED);  </span><br><span class="line">    IplImage *pGrayImage = cvCreateImage(cvGetSize(pSrcImage), IPL_DEPTH_8U, 1);  </span><br><span class="line">    IplImage *pGrayEqualizeImage = cvCreateImage(cvGetSize(pSrcImage), IPL_DEPTH_8U, 1);  </span><br><span class="line">      </span><br><span class="line">    // 灰度图  </span><br><span class="line">    cvCvtColor(pSrcImage, pGrayImage, CV_BGR2GRAY);  </span><br><span class="line">    // 直方图图像数据  </span><br><span class="line">    int nHistImageWidth = 255;  </span><br><span class="line">    int nHistImageHeight = 150;   </span><br><span class="line">    int nScale = 2;    </span><br><span class="line">  </span><br><span class="line">    // 灰度直方图及直方图图像  </span><br><span class="line">    CvHistogram *pcvHistogram = CreateGrayImageHist(&amp;pGrayImage);  </span><br><span class="line">    IplImage *pHistImage = CreateHisogramImage(nHistImageWidth, nScale, nHistImageHeight, pcvHistogram);  </span><br><span class="line">  </span><br><span class="line">    // 均衡化 </span><br><span class="line">    //函数功能：直方图均衡化，该函数能归一化图像亮度和增强对比度</span><br><span class="line">    //第一个参数表示输入图像，必须为灰度图（8位，单通道图）</span><br><span class="line">    //第二个参数表示输出图像</span><br><span class="line">    //该函数采用如下法则对输入图像进行直方图均衡化：</span><br><span class="line">        //1：计算输入图像的直方图H。</span><br><span class="line">        //2：直方图归一化，因此直方块和为255。</span><br><span class="line">        //3：计算直方图积分，H&apos;(i) = Sum(H(j)) (0&lt;=j&lt;=i)。</span><br><span class="line">        //4：采用H&apos;作为查询表：dst(x, y) = H&apos;(src(x, y))进行图像变换。</span><br><span class="line">    cvEqualizeHist(pGrayImage, pGrayEqualizeImage);  </span><br><span class="line">  </span><br><span class="line">    // 均衡化后的灰度直方图及直方图图像  </span><br><span class="line">    CvHistogram *pcvHistogramEqualize = CreateGrayImageHist(&amp;pGrayEqualizeImage);         </span><br><span class="line">    IplImage *pHistEqualizeImage = CreateHisogramImage(nHistImageWidth, nScale, nHistImageHeight, pcvHistogramEqualize);  </span><br><span class="line">  </span><br><span class="line">    // 显示  </span><br><span class="line">    cvNamedWindow(pstrWindowsSrcTitle); </span><br><span class="line">    cvNamedWindow(pstrWindowsGrayTitle); </span><br><span class="line">    cvNamedWindow(pstrWindowsGrayEqualizeTitle); </span><br><span class="line">    cvNamedWindow(pstrWindowsHistTitle); </span><br><span class="line">    cvNamedWindow(pstrWindowsHistEqualizeTitle); </span><br><span class="line">    cvShowImage(pstrWindowsSrcTitle,pSrcImage);</span><br><span class="line">    cvShowImage(pstrWindowsGrayTitle,pGrayImage);</span><br><span class="line">    cvShowImage(pstrWindowsGrayEqualizeTitle,pGrayEqualizeImage);</span><br><span class="line">    cvShowImage(pstrWindowsHistTitle,pHistImage);</span><br><span class="line">    cvShowImage(pstrWindowsHistEqualizeTitle,pHistEqualizeImage);</span><br><span class="line">    cvWaitKey(0);  </span><br><span class="line">    //回收资源代码…  </span><br><span class="line">    cvDestroyWindow(pstrWindowsSrcTitle);</span><br><span class="line">    cvDestroyWindow(pstrWindowsGrayTitle);</span><br><span class="line">    cvDestroyWindow(pstrWindowsGrayEqualizeTitle);</span><br><span class="line">    cvDestroyWindow(pstrWindowsHistTitle);</span><br><span class="line">    cvDestroyWindow(pstrWindowsHistEqualizeTitle);</span><br><span class="line">    cvReleaseImage(&amp;pSrcImage);</span><br><span class="line">    cvReleaseImage(&amp;pGrayImage);</span><br><span class="line">    cvReleaseImage(&amp;pGrayEqualizeImage);</span><br><span class="line">    cvReleaseImage(&amp;pHistImage);</span><br><span class="line">    cvReleaseImage(&amp;pHistEqualizeImage);</span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="直方图规定化-1"><a href="#直方图规定化-1" class="headerlink" title="直方图规定化"></a>直方图规定化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">void hist_specify(const Mat &amp;src, const Mat &amp;dst,Mat &amp;result)</span><br><span class="line">&#123;</span><br><span class="line">    Histogram1D hist1D;</span><br><span class="line">    MatND src_hist = hist1D.getHistogram(src);</span><br><span class="line">    MatND dst_hist = hist1D.getHistogram(dst);</span><br><span class="line"></span><br><span class="line">    float src_cdf[256] = &#123; 0 &#125;;</span><br><span class="line">    float dst_cdf[256] = &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">    // 源图像和目标图像的大小不一样，要将得到的直方图进行归一化处理</span><br><span class="line">    src_hist /= (src.rows * src.cols);</span><br><span class="line">    dst_hist /= (dst.rows * dst.cols);</span><br><span class="line"></span><br><span class="line">    // 计算原始直方图和规定直方图的累积概率</span><br><span class="line">    for (int i = 0; i &lt; 256; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (i == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            src_cdf[i] = src_hist.at&lt;float&gt;(i);</span><br><span class="line">            dst_cdf[i] = dst_hist.at&lt;float&gt;(i);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            src_cdf[i] = src_cdf[i - 1] + src_hist.at&lt;float&gt;(i);</span><br><span class="line">            dst_cdf[i] = dst_cdf[i - 1] + dst_hist.at&lt;float&gt;(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 累积概率的差值</span><br><span class="line">    float diff_cdf[256][256];</span><br><span class="line">    for (int i = 0; i &lt; 256; i++)</span><br><span class="line">        for (int j = 0; j &lt; 256; j++)</span><br><span class="line">            diff_cdf[i][j] = fabs(src_cdf[i] - dst_cdf[j]);</span><br><span class="line"></span><br><span class="line">    // 构建灰度级映射表</span><br><span class="line">    Mat lut(1, 256, CV_8U);</span><br><span class="line">    for (int i = 0; i &lt; 256; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        // 查找源灰度级为ｉ的映射灰度</span><br><span class="line">        //　和ｉ的累积概率差值最小的规定化灰度</span><br><span class="line">        float min = diff_cdf[i][0];</span><br><span class="line">        int index = 0;</span><br><span class="line">        for (int j = 1; j &lt; 256; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (min &gt; diff_cdf[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                min = diff_cdf[i][j];</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lut.at&lt;uchar&gt;(i) = static_cast&lt;uchar&gt;(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 应用查找表，做直方图规定化</span><br><span class="line">    LUT(src, lut, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> Opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习面试</title>
      <link href="/2018/09/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%B2%BE%E5%8D%8E/"/>
      <url>/2018/09/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%B2%BE%E5%8D%8E/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>机器学习面试</p><a id="more"></a><h3 id="SVM："><a href="#SVM：" class="headerlink" title="SVM："></a>SVM：</h3><blockquote><p>简单介绍SVM（详细原理）：从分类平面，到求两类间的最大间隔，到转化为求间隔分之一，等优化问题，然后就是优化问题的解决办法，首先是用拉格拉日乘子把约束优化转化为无约束优化，对各个变量求导令其为零，得到的式子带入拉格朗日式子从而转化为对偶问题， 最后再利用SMO（序列最小优化）来解决这个对偶问题。svm里面的c有啥用</p><p>SVM的推导，解释原问题和对偶问题，SVM原问题和对偶问题的关系，KKT限制条件，KKT条件用哪些，完整描述；软间隔问题，解释支持向量、核函数（哪个地方引入、画图解释高维映射，高斯核可以升到多少维，如何选择核函数），引入拉格朗日的优化方法的原因，最大的特点，损失函数解释，</p><p>SVM与LR最大区别，LR和SVM对于outlier的敏感程度分析，逻辑回归与SVM的区别</p><p>为什么要把原问题转换为对偶问题？因为原问题是凸二次规划问题，转换为对偶问题更加高效。为什么求解对偶问题更加高效？因为只用求解alpha系数，而alpha系数只有支持向量才非0，其他全部为0.alpha系数有多少个？样本点的个数</p><p>加大训练数据量一定能提高SVM准确率吗？</p><p>与感知器的联系和优缺点比较</p><p>如何解决多分类问题、可以做回归吗，怎么做</p><p>它与其他分类器对比的优缺点，它的速度</p><p>机器学习有很多关于核函数的说法，核函数的定义和作用是什么？<a href="https://www.zhihu.com/question/24627666" target="_blank" rel="noopener">https://www.zhihu.com/question/24627666</a></p><p>支持向量机(SVM)是否适合大规模数据？<a href="https://www.zhihu.com/question/19591450" target="_blank" rel="noopener">https://www.zhihu.com/question/19591450</a></p><p>SVM和逻辑斯特回归对同一样本A进行训练，如果某类中增加一些数据点，那么原来的决策边界分别会怎么变化？<a href="https://www.zhihu.com/question/30123068" target="_blank" rel="noopener">https://www.zhihu.com/question/30123068</a></p><p>各种机器学习的应用场景分别是什么？例如，k近邻,贝叶斯，决策树，svm，逻辑斯蒂回归和最大熵模型。<a href="https://www.zhihu.com/question/26726794" target="_blank" rel="noopener">https://www.zhihu.com/question/26726794</a></p><p>Linear SVM 和 LR 有什么异同？<a href="https://www.zhihu.com/question/26768865" target="_blank" rel="noopener">https://www.zhihu.com/question/26768865</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VM转化为对偶问题后，分类只需要计算与少数几个支持向量的距离，这个在进行复杂核函数计算时优势很明显，能够大大简化模型和计算量。</span><br></pre></td></tr></table></figure><h3 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h3><blockquote><p>LR推导（伯努利过程，极大似然，损失函数，梯度下降）有没有最优解？</p><p>LR可以用核么？可以怎么用？l1和l2正则项是啥？lr加l1还是l2好？加哪个可以用核（加l2正则项，和svm类似，加l2正则项可以用核方便处理）</p><p>LR可以用来处理非线性问题么？（还是lr啊 只不过是加了核的lr 这里加核是显式地把特征映射到高维 然后再做lr）怎么做？可以像SVM那样么？为什么？</p><p>为什么LR需要归一化或者取对数，为什么LR把特征离散化后效果更好，为什么把特征组合之后还能提升，反正这些基本都是增强了特征的表达能力，或者说更容易线性可分吧</p><p>美团技术团队《Logistic Regression 模型简介》<a href="https://tech.meituan.com/intro_to_logistic_regression.html" target="_blank" rel="noopener">https://tech.meituan.com/intro_to_logistic_regression.html</a></p><p>SVM和logistic回归分别在什么情况下使用？<a href="https://www.zhihu.com/question/21704547" target="_blank" rel="noopener">https://www.zhihu.com/question/21704547</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">两种方法都是常见的分类算法，</span><br><span class="line">svm-统计的方法      LR-几何的方法   </span><br><span class="line"></span><br><span class="line">区别在于</span><br><span class="line">1、</span><br><span class="line">（损失函数的目的都是增加对分类影响较大的数据点的权重）</span><br><span class="line">逻辑回归采用的是logistical loss</span><br><span class="line">svm采用的是hinge loss</span><br><span class="line"></span><br><span class="line">2、LR~不带核函数的svm</span><br><span class="line">特征少，样本数量适中--用svm算法</span><br><span class="line">特征多，样本数量少  --用LR或者不带核函数的svm   </span><br><span class="line">特征少，样本数量很多--先增加更多的feature，再使用LR算法或者不带核函数的SVM    </span><br><span class="line"></span><br><span class="line">3、</span><br><span class="line">svm对异常点敏感</span><br><span class="line">LR对异常点不敏感</span><br></pre></td></tr></table></figure><blockquote><p>逻辑斯蒂回归能否解决非线性分类问题？<a href="https://www.zhihu.com/question/29385169" target="_blank" rel="noopener">https://www.zhihu.com/question/29385169</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对特征做非线性变换 比如kernel，最后一层看成是lr 前面看成是提特征。lr的应用场景主要是特征很多的情况</span><br><span class="line">LR用kernel容易过拟合，svm不容易过拟合</span><br></pre></td></tr></table></figure><blockquote><p>为什么LR可以用来做CTR预估？<a href="https://www.zhihu.com/question/23652394" target="_blank" rel="noopener">https://www.zhihu.com/question/23652394</a></p><p>逻辑回归估计参数时的目标函数 （就是极大似然估计那部分），逻辑回归估计参数时的目标函数 （呵呵，第二次） 逻辑回归估计参数时的目标函数 如果加上一个先验的服从高斯分布的假设，会是什么样（天啦。我不知道，其实就是在后面乘一个东西，取log后就变成加一个东西，实际就变成一个正则项）</p><p>逻辑回归估计参数时的目标函数逻辑回归的值表示概率吗？（值越大可能性越高，但不能说是概率）</p><p>手推逻辑回归目标函数，正类是1，反类是-1，这里挖了个小坑，一般都是正例是1，反例是0的，他写的时候我就注意到这个坑了，然而写的太快又给忘了，衰，后来他提醒了一下，改了过来，就是极大似然函数的指数不一样，然后说我这里的面试就到这了。</p><p>看没看过scikit-learn源码LR的实现？（回头看了一下是调用的liblinear，囧）</p></blockquote><p>为什么LR需要归一化或者取对数，为什么LR把特征离散化后效果更好，为什么把特征组合之后还能提升，反正这些基本都是增强了特征的表达能力，或者说更容易线性可分吧<br>naive bayes和logistic regression的区别<a href="http://m.blog.csdn.net/blog/muye5/19409615" target="_blank" rel="noopener">http://m.blog.csdn.net/blog/muye5/19409615</a></p><blockquote><p>LR为什么用sigmoid函数。这个函数有什么优点和缺点？为什么不用其他函数？sigmoid函数由那个指数族分布，加上二项分布导出来的。损失函数是由最大似然估计求出的。<br>了解其他的分类模型吗，问LR缺点，LR怎么推导（当时我真没准备好，写不出来）写LR目标函数，目标函数怎么求最优解（也不会）讲讲LR的梯度下降，梯度下降有哪几种，逻辑函数是啥</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="L1和L2"><a href="#L1和L2" class="headerlink" title="L1和L2"></a>L1和L2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">L2正则化，为什么L2正则化可以防止过拟合？L1正则化是啥？</span><br><span class="line">深度学习里面怎么防止过拟合？（data aug；dropout；multi-task learning）如何防止过拟合，我跟他列举了4中主要防止过拟合方法：Early Stopping、数据集扩充、正则化法以及dropout，还详细跟他说了每种方法原理及使用的场景，并解释我在哪些项目里具体用到了这些方法，</span><br><span class="line">机器学习中使用「正则化来防止过拟合」到底是一个什么原理？为什么正则化项就可以防止过拟合？https://www.zhihu.com/question/20700829</span><br><span class="line">机器学习中常常提到的正则化到底是什么意思？https://www.zhihu.com/question/20924039</span><br><span class="line">什么是正则项，L1范式，L2范式区别是什么，各自用在什么地方？L1 与 L2 的区别以及如何解决 L1 求导困难；</span><br><span class="line">L1正则为什么能让系数变为0？L1正则怎么处理0点不可导的情形？（这个谁会？近端梯度下降）</span><br><span class="line">L0，L1，L2正则化(如果能推导绝对是加分项，一般人最多能画个等高线，L0是NP问题)其实上面的这些问题基本都能在《李航：统计学习方法》《周志华：机器学习》里面找到，能翻个4，5遍基本就无压力了</span><br><span class="line">避免过拟合策略、如何提高模型泛化能力、L1与L2正则区别，优缺点、生成式，判别式模型、深度学习这块了解多少、</span><br><span class="line">如何克服过拟合，欠拟合</span><br><span class="line">L1 与 L2 的区别以及如何解决 L1 求导困难；</span><br><span class="line">L1正则为什么可以把系数压缩成0，坐标下降法的具体实现细节</span><br><span class="line">为什么L1正则可以实现参数稀疏，而L2正则不可以？为什么L1很多系数可以被压缩为0，L2是被压缩至接近于0？</span><br><span class="line">树模型</span><br></pre></td></tr></table></figure><h3 id="决策树："><a href="#决策树：" class="headerlink" title="决策树："></a>决策树：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">rf ， gbdt 的区别； gbdt ， xgboost 的区别（烂大街的问题最好从底层原理去分析回答）</span><br><span class="line">介绍决策树，谈了3种决策树及其区别和适应场景</span><br><span class="line">决策树处理连续值的方法；简单介绍决策树几种算法，有什么区别？</span><br><span class="line">决策树基本模型介绍？决策树算法中缺失值怎么处理？决策树算法在应用中有什么值得注意的地方。SVM、LR、决策树的对比？GBDT 和 决策森林 的区别？决策树的特性？（3 ）决策树处理连续值的方法；</span><br><span class="line">解释下随机森林和gbdt的区别。gbdt的boosting体现在哪里。解释下随机森林节点的分裂策略，以及它和gbdt做分类有什么区别？哪个效果更好些？为什么？哪个更容易过拟合？为什么？ 问了随机森林的损失函数，和lr的优缺点对比， adaboost和随机森林的比较，为了防止随机森林过拟合可以怎么做，是否用过随机森林，怎么用的。</span><br><span class="line">随机森林和GBDT的区别？CART（回归树用平方误差最小化准则，分类树用基尼指数最小化准则）</span><br><span class="line">GBDT（利用损失函数的负梯度在当前模型的值作为回归问题提升树算法中的残差的近似值，拟合一个回归树）</span><br><span class="line">随机森林（Bagging+CART）</span><br><span class="line">SVM与随机森林比较</span><br><span class="line">改变随机森林的训练样本数据量，是否会影响到随机森林学习到的模型的复杂度</span><br><span class="line">Logistics与随机森林比较</span><br><span class="line">GBDT与随机森林比较随机森林的学习过程；随机森林中的每一棵树是如何学习的；随机森林学习算法中CART树的基尼指数是什么？</span><br><span class="line">RF 与 GBDT 区别，原理优缺点适用场景分析，哪个具备交叉验证功能等</span><br><span class="line">接着写一下信息增益的公式。之后就是问机器学习相关算法，说了一下bagging跟boosting，之后问了GBDT（没做过，只能说说大体思路）。（2 ） rf ， gbdt 的区别； gbdt ， xgboost 的区别；</span><br><span class="line">说说xgboost、gbdt区别、Tree-based Model如何处理连续型特征。</span><br><span class="line">让我把一个完整的数据挖掘流程讲一下，从预处理，特征工程，到模型融合。介绍常用的算法，gbdt和xgboost区别，具体怎么做预处理，特征工程，模型融合常用方式，融合一定会提升吗？</span><br><span class="line">gbdt树根据什么分裂（瞎扯的梯度近似残差、梯度下降方向，其实还是信息增益这种东西）</span><br><span class="line">gbdt怎么并发（特征选择层面，树层面不能并发）</span><br><span class="line">介绍LR、RF、GBDT ，分析它们的优缺点，是否写过它们的分布式代码</span><br><span class="line">XGB和GBDT区别与联系也会经常问到：https://www.zhihu.com/question/41354392/answer/128008021?group_id=773629156532445184</span><br><span class="line">CART（回归树用平方误差最小化准则，分类树用基尼指数最小化准则）、Logistics（推导）、GBDT（利用损失函数的负梯度在当前模型的值作为回归问题提升树算法中的残差的近似值，拟合一个回归树）</span><br><span class="line">在面试过程中主动引导面试官提问，比如面试官让你讲解 gbdt 原理时，这会你可以跟他说，一般说起 gbdt ，我们都会跟 rf 以及 xgboost 一块讲，然后你就可以主动地向面试官输出你的知识；面试并不是死板地你问我答，而是一种沟通交流，所以尽可能地把面试转化成聊天式的对话，多输出自己一些有价值的观点而不是仅仅为了回答面试官的问题；</span><br><span class="line">几种树模型的原理和对比，</span><br><span class="line">特征选取怎么选？ 为什么信息增益可以用来选特征？</span><br><span class="line">信息熵和基尼指数的关系(信息熵在x=1处一阶泰勒展开就是基尼指数)</span><br><span class="line">介绍xgboost一下。写下xgboost目标函数。（因为我提到xgboost在目标函数里显式地加入了正则项..血雪崩）怎么调整XGB参数；xgboost原理</span><br></pre></td></tr></table></figure><h3 id="K-means"><a href="#K-means" class="headerlink" title="K-means"></a>K-means</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">k-means 聚类的原理以及缺点及对应的改进；kmeans 算法的优缺点。。。。</span><br><span class="line">kmeans 的原理，优缺点以及改进；</span><br><span class="line">em 与 kmeans 的关系；</span><br><span class="line">kmeans 代码；</span><br><span class="line">说说 Kmeans 算法， Kmeans 算法 K 怎么设置、适用什么样数据集、怎么评价 Kmeans 聚类结果、 Kmeans 有什么优缺点？你的项目中使用 Kmeans 遇到哪些问题，怎么解决的 ?</span><br><span class="line">用 EM 算法推导解释 Kmeans。</span><br><span class="line">KMeans的算法伪代码</span><br><span class="line">如何判断自己实现的 LR、Kmeans 算法是否正确？</span><br><span class="line">如何优化kmeans算法</span><br><span class="line">如何用hadoop实现k-means</span><br><span class="line">手写k-means的伪代码（就6行）</span><br></pre></td></tr></table></figure><h3 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bagging和boosting是怎么做的和他们的比较</span><br><span class="line">详细讨论了样本采样和bagging的问题</span><br><span class="line">聊的比较多的是如何知道一个特征的重要性，如何做ensemble哪些方法比较好。聊了聊计算广告方面FM，embedding。</span><br><span class="line">常见融合框架原理，优缺点，bagging，stacking，boosting，为什么融合能提升效果</span><br><span class="line">是否了解线性加权、bagging、boosting、cascade等模型融合方式</span><br><span class="line">K-means起始点http://www.cnki.com.cn/Article/CJFDTotal-DNZS200832067.htm</span><br></pre></td></tr></table></figure><h3 id="贝叶斯"><a href="#贝叶斯" class="headerlink" title="贝叶斯"></a>贝叶斯</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">朴素贝叶斯分类器原理以及公式，出现估计概率值为 0 怎么处理（拉普拉斯平滑），缺点；</span><br><span class="line">解释贝叶斯公式和朴素贝叶斯分类。</span><br><span class="line">贝叶斯分类，这是一类分类方法，主要代表是朴素贝叶斯，朴素贝叶斯的原理，重点在假设各个属性类条件独立。然后能根据贝叶斯公式具体推导。考察给你一个问题，如何利用朴素贝叶斯分类去分类，比如：给你一个人的特征，判断是男是女，比如身高，体重，头发长度等特征的的数据，那么你要能推到这个过程。给出最后的分类器公式。</span><br><span class="line">那你说说贝叶斯怎么分类啊？比如说看看今天天气怎么样？我：blabla，，，利用天气的历史数据，可以知道天气类型的先验分布，以及每种类型下特征数据（比如天气数据的特征：温度啊，湿度啊）的条件分布，这样我们根据贝叶斯公式就能求得天气类型的后验分布了。。。。面试官：en（估计也比较满意吧）那你了解关于求解模型的优化方法吗？一般用什么优化方法来解？</span><br><span class="line">贝叶斯分类器的优化和特殊情况的处理</span><br></pre></td></tr></table></figure><h3 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">解释一下CNN、介绍CNN、卷积公式，以及特点，假设面试官什么都不懂，详细解释 CNN 的原理；问CNN的细节特点，哪些特点使得CNN这么好用，哪些场景用CNN可以，抽象一下这些场景的特征，可以降采样但仍能保持主要信息；局部连接可以保证获取局部信息；权值共享保证高效，DNN和CNN相比有哪些区别，用过RNN么？画一下RNN的图，你在深度学习过程中遇到过哪些问题？如果出现过拟合你怎么办？dropout是什么？它有什么用？你会怎么用它？当全连接跟dropout连着用需要注意什么？你之前过拟合怎么解决的？如果本身training loss就很大你怎么办？如果数据不变，怎么调整网络结构解决这个问题？（batch normalization）梯度消失知道么？为什么会出现梯度消失？dnn和rnn中的梯度消失原理一样么？dnn中是哪个部分导致梯度消失？（激活层如sigmoid）rnn中怎么解决梯度消失问题？（lstm的结构相对普通RNN多了加和，为避免梯度消散提供了可能。线性自连接的memory是关键。）讲一下CNN吧，有哪些重要的特点？CNN可以处理哪些场景？为什么CNN要用权值共享？（每个卷积核相当于一个特征提取器，它的任务是匹配局部图像中的特征，权值共享后，匹配的特征方式都是一样的，提取若干特征后就知道学习的是啥了）CNN里面哪些层？讲一下卷积。卷积的形式是啥样？给定一个输入，算输出的feature map大小。卷积有啥用？池化有啥用？有哪些池化方式？池化除了降采样还有啥用？（就不知道了）还有哪些层你用过？讲讲dropout。dropout内部是怎么实现只让部分信号通过并不更新其余部分对于输入的权值的？讲讲BN（BatchNormalization）为什么好？全连接有什么用处？知道RNN么？讲讲RNN大致的实现思路。知道梯度消失么？为什么会出现梯度消失？RNN里的梯度消失一般怎么处理？细讲下lstm的结构，这样设计为什么好？（门关闭，当前信息不需要，只有历史依赖；门打开，历史和当前加权平均）你觉得梯度消失靠引入一些新的激活层可以完全解决么？为什么？</span><br><span class="line">问了做的比赛里面使用tensorflow的细节，LSTM里调参的细节</span><br><span class="line">用过哪些库或者工具，mkl，cuda这些会用吗？</span><br><span class="line">有一个弱分类器和大量未被标记过的图像数据，如何人工标记图像来对分类器进行提升</span><br><span class="line">介绍下RNN和它的优缺点</span><br><span class="line">让我推导BP反向传播、随机梯度下降法权重更新公式</span><br><span class="line">卷积神经网络结构特点、各参数对模型结果影响、项目进展遇到的难题、推导BP神经网络参数更新方式、随机梯度下降法（SGD）优化函数存在的缺点以及拟牛顿法在优化函数使用上更有优势、修改Caffe开源框架、开源社区代码贡献量就跟我聊了很多行业发展趋势及问题，知道目前深度学习的一个趋势，也了解到最新行业发展动态，改进相机智能化程度，也聊到了美颜相机美颜效果以及小米相机人脸分类、年龄检测等等不足之处，了解到新兴行业大佬商汤科技和旷视科技（face++脸草）在研究的热门方向</span><br><span class="line">看到有deep learning相关的项目，就问了deep learning 相关问题：如何减少参数（权值共享、VGG的感受野、GoogLeNet的inception ），激活函数的选择（sigmoid-&gt;ReLu-&gt;LReLU-&gt;PReLU ），为什么之前没有深度网络出现（数据量不够+机器性能），由数据引申到数据不平衡怎么处理（10W正例，1W负例，牛客上有原题），</span><br><span class="line">后面问了下DNN原理，应用，瞎扯一通……</span><br><span class="line">你了解神经网络吗？我：了解一些，讲感知机，然后是BP网络。简单讲了一下原理。</span><br><span class="line">图像处理题：如何找相似图片。我说用感知哈希算法，计算汉明距离，他说这种方法精度不行；我说那就用SIFT算法吧，他说SIFT效果还可以，但计算有点繁重，有没有轻量级的方法？我想起来去年在美图秀秀实习时，曾经做过一种图像滤波算法，有一步是把像素点用K-means聚类。我就说先把图片灰度化，然后用K-means聚类，把聚类后的各个中心点作为一张图片的特征向量如果两张图片的特征向量相近则说明这两张图片相似。貌似我这个答案有点出乎他的意料，他意味深长地说了个“行吧~~~~”（个人觉得颜色直方图匹配是个他期待的常规回答）</span><br><span class="line">介绍卷积神经网络，和 DBN 有什么区别？</span><br><span class="line">Deep CNN, Deep RNN, RBM的典型应用与局限，看Hinton讲义和Paper去吧</span><br><span class="line">神经网络,plsi的推导</span><br><span class="line">验证码图片的去噪和提取字符</span><br><span class="line">有限状态自动机,然后要我画状态转移图.</span><br></pre></td></tr></table></figure><h3 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用过哪些聚类算法，解释密度聚类算法。</span><br><span class="line">聚类算法中的距离度量有哪些？</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">梯度下降的优缺点；主要问最优化方面的知识，梯度下降法的原理以及各个变种（批量梯度下降，随机梯度下降法， mini 梯度下降法），以及这几个方法会不会有局部最优问题，牛顿法原理和适用场景，有什么缺点，如何改进（拟牛顿法）</span><br><span class="line">常用优化算法：1.梯度下降法：又有随机梯度下降和负梯度下降，2.牛顿法 主要是问了各自的优缺点，速度，能不能得到全局最优解，牛顿法的二次收敛等</span><br><span class="line">问你如果有若干个极小值点，如何避免陷入局部最优解。</span><br><span class="line">它们间的牛顿学习法、SGD如何训练，</span><br><span class="line">如何判断函数凸或非凸？</span><br><span class="line">线性回归的梯度下降和牛顿法求解公式的推导</span><br><span class="line">最速下降法和共轭梯度法 wolfe条件 最速下降法和共轭梯度法的收敛速度如何判断</span><br><span class="line">深刻理解常用的优化方法：梯度下降、牛顿法、各种随机搜索算法（基因、蚁群等等），深刻理解的意思是你要知道梯度下降是用平面来逼近局部，牛顿法是用曲面逼近局部等等。</span><br></pre></td></tr></table></figure><h3 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">介绍SVD、SVD++</span><br><span class="line">推荐系统的冷启动问题如何解决</span><br><span class="line">深度学习在推荐系统上可能有怎样的发挥？</span><br><span class="line">推荐系统的算法中最近邻和矩阵分解各自适用场景</span><br><span class="line">白板写SVD/SVD++公式，SGD迭代更新p，q矩阵公式，SVD/SVD++优化方法</span><br><span class="line">对推荐算法的未来看法；</span><br><span class="line">用过什么算法？最好是在项目/实习的大数据场景里用过，比如推荐里用过 CF、LR，</span><br><span class="line">我面的推荐，问了各类协同过滤的好与坏。</span><br><span class="line">问了一个很有意思的问题，现实应用中的Top-N推荐问题和学术研究中的评分预测问题之间有什么不同。问我ItemCF的工程实现，面对大数据如何实现，又追问了有没有什么工程优化算法。这个问题我没答好，一开始我说了一个MapReduce模型，他问能不能更快一点，我就卡那了。。。最后面试官告诉我，不能只从算法角度分析，要从系统设计分析，利用内存来减小MapReduce的吞吐量。（当然也许从MapReduce那一刻开始我就输了也不一定）</span><br><span class="line">推荐系统的算法中最近邻和矩阵分解各自适用场景http://www.doc88.com/p-3961053026557.html</span><br></pre></td></tr></table></figure><h3 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">那你对pca了解吗？我：了解啊，面试官：那讲一下pca是用来干嘛的？我：pca啊，可以用来分析主方向啊，降维啊，特征筛选啊，具体方法是用svd分解得到特征值矩阵和特征向量矩阵，然后根据不同的任务对选择特征值或向量进行计算。</span><br></pre></td></tr></table></figure><p>EM<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">采用 EM 算法求解的模型有哪些，为什么不用牛顿法或梯度下降法？</span><br></pre></td></tr></table></figure></p><h3 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用过哪些 NLP 算法项目中用过哪些机器学习算法。</span><br><span class="line">海量的 item 算文本相似度的优化方法；</span><br><span class="line">解释 word2vec 的原理以及哈夫曼树的改进；word2vec的原理</span><br><span class="line">二面面试官主要跟我聊简历上的几个项目，他好像不能理解词向量的形式，反复解释了很多遍，问的问题都比较简单，有TF-IDF,余弦相似度，分词工具等等。</span><br><span class="line">然后我说我做过LDA，问我，Dirichlet Distribution的定义和性质，并问我，为什么它和multinomial distribution是共轭的，顺便问了我啥叫共轭分布。</span><br></pre></td></tr></table></figure><h3 id="关联分析："><a href="#关联分析：" class="headerlink" title="关联分析："></a>关联分析：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目中涉及到频繁模式挖掘，于是问了一下如何实现的？ 用的是 Apriori算法，描述他的原理过程，关键字眼：支持度，支持度计数，k项候选频繁项集，怎么从k项到k+1项等，连接剪枝过程。</span><br></pre></td></tr></table></figure><h3 id="hadoop"><a href="#hadoop" class="headerlink" title="hadoop"></a>hadoop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">简单介绍 MapReduce 原理，有没有看过源码，说说 Map 阶段怎么实现的,</span><br><span class="line">MapReduce 实现统计出现次数最多的前 100 个访问 IP.</span><br><span class="line">MapReduce 实现统计不重复用户 ID,MapReduce 实现两个数据集求交集。</span><br><span class="line">HBase 行健怎么设计,spark 性能一般优化方法,spark streaming 和 storm 区别.给了一张笔试题， 10 道选择，一道大题。选择题是 java 基础知识，大题一个有三问：根据场景写出 Hive 建表语句； Hsql 从表中查询；</span><br><span class="line">用MapReduce写好友推荐，在一堆单词里面找出现次数最多的k个</span><br><span class="line">用分布式的方法做采样怎么保证采样结果完全符合预期？</span><br><span class="line">后面又问了Hadoop,Spark,storm下面的产品，原理，适用场景，</span><br><span class="line">写一个 Hadoop 版本的 wordcount。</span><br></pre></td></tr></table></figure><h3 id="HMM"><a href="#HMM" class="headerlink" title="HMM"></a>HMM</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">实现 hmm 的状态转移代码；</span><br><span class="line">机器学习理论</span><br><span class="line">讲机器学习中常用的损失函数有哪些？交叉熵有什么好处？（凸优化问题）</span><br><span class="line">判别模型与生成模型的本质区别是什么</span><br><span class="line">分类模型和回归模型的区别，分类模型可以做回归分析吗？反过来可以吗？（我回答是分类不可以做回归，回归倒是可以做分类，不知道对不对）</span><br><span class="line">k折交叉验证 中k取值多少有什么关系 （我不知道，随便答，然后面试官后面问我知道bias和variance吗？估计是和这两个东西有关， 知乎上有个问题讨论了k值大小与bias和variance的关系）</span><br><span class="line">解释局部相关性</span><br><span class="line">特征选择的方法；</span><br><span class="line">在模型的训练迭代中，怎么评估效果；</span><br><span class="line">特征选择方法有哪些(能说出来10种以上加分)，之后和面试官仔细聊了一下特征选择的问题，我介绍了了解的几种基本的特征选择思路（错误率选择、基于熵的选择、类内类间距离的选择）；</span><br><span class="line">有没有接触过机器学习的前沿，深度学习看过paper没有？（并没有）</span><br><span class="line">如何用尽可能少的样本训练模型同时又保证模型的性能；</span><br><span class="line">你读哪些期刊会议的论文？你遇到的比较有意思的算法？</span><br><span class="line">生成模型，判别模型</span><br><span class="line">线性分类和非线性分类各有哪些模型</span><br><span class="line">比较各个模型的Loss function，</span><br><span class="line">设计一个结构存取稀疏矩阵 （面试官最后告诉我了一个极度压缩的存法，相同行或列存偏差，我当时没听懂，还不懂装懂，最后还是没记住）</span><br><span class="line">PageRank原理，怎么用模型来查找异常用户，我讲了一大堆我的理解，然后面试官一句你怎么不用规则把我噎到了……</span><br><span class="line">无监督和有监督算法的区别？</span><br><span class="line">经典算法推导(加分项)，原理，各个损失函数之间区别，使用场景，如何并行化，有哪些关键参数</span><br><span class="line">什么叫判别模型什么叫生成模型。</span><br><span class="line">先针对项目十分细致地询问了各种细节，然后就问我如何处理数据中的噪声点、数据清洗算法（正好自己做了一个算法）、如何选择特征等。</span><br><span class="line">校招TST内推，面过了2面，还是跟之前那个有点类似的游戏开发的安全部门，因为我也玩LOL，又问到怎么来判断玩家有没有作弊之类的问题，这次我小心翼翼的说用模型怎么做，用规则怎么做，感觉这次聊的都挺开心的。</span><br><span class="line">是否了解A/B Test以及A/B Test结果的置信度特征工程经验是否了解mutual infomation、chi-square、LR前后向、树模型等特征选择方式</span><br><span class="line">深刻理解各种算法对应采用的数据结构和对应的搜索方法。比如KNN对应的KD树、如何给图结构设计数据结构？如何将算法map-red化</span><br><span class="line">矩阵的各种变换，尤其是特征值相关的知识。分布式的矩阵向量乘的算法</span><br><span class="line">线性分类器与非线性分类器的区别及优劣；特征比数据量还大时，选择什么样的分类器？对于维度很高的特征，你是选择线性还是非线性分类器？对于维度极低的特征，你是选择线性还是非线性分类器？如何解决过拟合问题？L1和L2正则的区别，如何选择L1和L2正则？</span><br><span class="line">项目中的数据是否会归一化处理，哪个机器学习算法不需要归一化处理</span><br><span class="line">并行计算、压缩算法LDA http://www.doc88.com/p-1621945750499.html</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 笔面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab背景颜色修改</title>
      <link href="/2018/09/01/matlab_%E8%83%8C%E6%99%AF/"/>
      <url>/2018/09/01/matlab_%E8%83%8C%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Matlab背景颜色修改</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>将<code>修改内容</code>添加到matlab的matlab.prf文件中，文件路径为在matlab中运行prefdir的结果,直接添加这些内容保存就好。 </p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>1， 在<code>matlab</code>命令行中运行<code>prefdir</code>， 获取<code>matlab.prf</code>文件所在路径</p><p>2， 打开<code>matlab.prf</code>所在路径， 找到<code>matlab.prf</code>文件， 作备份</p><p>3， 在新的<code>matlab.prf</code>中修改与<code>color</code>有关的属性</p><p>4，重启<code>matlab</code>，修改主题就完成了</p><h2 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h2><h3 id="黑色主题"><a href="#黑色主题" class="headerlink" title="黑色主题"></a>黑色主题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Editor.VariableHighlighting.Color=C-6931898</span><br><span class="line">ColorsText=C-460558</span><br><span class="line">Colors_M_SystemCommands=C-448910</span><br><span class="line">Editorhighlight-lines=C-11974594</span><br><span class="line">Colors_M_Warnings=C-27648</span><br><span class="line">Colors_M_Strings=C-1647756</span><br><span class="line">Editor.NonlocalVariableHighlighting.TextColor=C-5471745</span><br><span class="line">Colors_HTML_HTMLLinks=C-16732805</span><br><span class="line">Colors_M_Comments=C-8355712</span><br><span class="line">Colors_M_Errors=C-65536</span><br><span class="line">Colors_M_UnterminatedStrings=C-5111808</span><br><span class="line">ColorsBackground=C-14211038</span><br><span class="line">Colors_M_Keywords=C-10036753</span><br><span class="line">Color_CmdWinWarnings=C-39936</span><br><span class="line">ColorsMLintAutoFixBackground=C-7973573</span><br><span class="line">Colors_M_Keywords=C-10036753</span><br><span class="line">Editorhighlight-lines=C-13553108</span><br><span class="line">Editorhighlight-caret-row-boolean-color=C-2167080</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ColorsUseSystem=Bfalse</span><br></pre></td></tr></table></figure><h3 id="暖色主题"><a href="#暖色主题" class="headerlink" title="暖色主题"></a>暖色主题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Color_CmdWinErrors=C-1703936</span><br><span class="line">Color_CmdWinWarnings=C-39936</span><br><span class="line">ColorsBackground=C-198941</span><br><span class="line">ColorsMLintAutoFixBackground=C-1121868</span><br><span class="line">ColorsText=C-16304574</span><br><span class="line">ColorsUseMLintAutoFixBackground=Btrue</span><br><span class="line">ColorsUseSystem=Bfalse</span><br><span class="line">Colors_HTML_HTMLLinks=C-2935166</span><br><span class="line">Colors_M_Comments=C-7167583</span><br><span class="line">Colors_M_Errors=C-65536</span><br><span class="line">Colors_M_Keywords=C-8021760</span><br><span class="line">Colors_M_Strings=C-13983336</span><br><span class="line">Colors_M_SystemCommands=C-3454186</span><br><span class="line">Colors_M_UnterminatedStrings=C-5111808</span><br><span class="line">Colors_M_Warnings=C-27648</span><br><span class="line">Editor.NonlocalVariableHighlighting.TextColor=C-32640</span><br><span class="line">Editor.VariableHighlighting.Color=C-7167583</span><br><span class="line">EditorRightTextLimitLineColor=C-3355444</span><br></pre></td></tr></table></figure><h3 id="darkmate"><a href="#darkmate" class="headerlink" title="darkmate"></a>darkmate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ColorsUseSystem=Bfalse</span><br><span class="line">ColorsUseMLintAutoFixBackground=Btrue</span><br><span class="line">Editor.VariableHighlighting.Automatic=Btrue</span><br><span class="line">Editor.NonlocalVariableHighlighting=Btrue</span><br><span class="line">EditorCodepadHighVisible=Btrue</span><br><span class="line">EditorCodeBlockDividers=Btrue</span><br><span class="line">Editorhighlight-caret-row-boolean=Btrue</span><br><span class="line">EditorRightTextLineVisible=Btrue</span><br><span class="line">EditorRightTextLimitLineWidth=I4                             # slightly wider</span><br><span class="line">ColorsText=C-1118482                                         # white</span><br><span class="line">ColorsBackground=C-14474461                                  # carbon</span><br><span class="line">Colors_M_Keywords=C-26368                                    # ambra</span><br><span class="line">Colors_M_Comments=C-10920873                                 # asfalto</span><br><span class="line">Colors_M_Strings=C-6881536                                   # lime</span><br><span class="line">Colors_M_UnterminatedStrings=C-202417                        # yellow</span><br><span class="line">Colors_M_SystemCommands=C-16725605                           # alga</span><br><span class="line">Colors_M_Errors=C-53398                                      # red</span><br><span class="line">Colors_HTML_HTMLLinks=C-6385153                              # violet</span><br><span class="line">Colors_M_Warnings=C-26368                                    # ambra</span><br><span class="line">ColorsMLintAutoFixBackground=C-11184811                      # </span><br><span class="line">Editor.VariableHighlighting.Color=C-4495617                  # purple</span><br><span class="line">Editor.NonlocalVariableHighlighting.TextColor=C-16725760     # green</span><br><span class="line">Editorhighlight-lines=C-15132391                             # </span><br><span class="line">Editorhighlight-caret-row-boolean-color=C-16777216           # black</span><br><span class="line">EditorRightTextLimitLineColor=C-13948117                     # </span><br><span class="line"># XML/HTML</span><br><span class="line">Editor.Language.XML.Color.pi-content=C-6425200</span><br></pre></td></tr></table></figure><h3 id="darksteel"><a href="#darksteel" class="headerlink" title="darksteel"></a>darksteel</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">ColorsUseSystem=Bfalse</span><br><span class="line">ColorsUseMLintAutoFixBackground=Btrue</span><br><span class="line">Editor.VariableHighlighting.Automatic=Btrue</span><br><span class="line">Editor.NonlocalVariableHighlighting=Btrue</span><br><span class="line">EditorCodepadHighVisible=Btrue</span><br><span class="line">EditorCodeBlockDividers=Btrue</span><br><span class="line">Editorhighlight-caret-row-boolean=Btrue</span><br><span class="line">EditorRightTextLineVisible=Btrue</span><br><span class="line">EditorRightTextLimitLineWidth=I1</span><br><span class="line">ColorsText=C-1</span><br><span class="line">ColorsBackground=C-15066598</span><br><span class="line">Colors_M_Keywords=C-1208813</span><br><span class="line">Colors_M_Comments=C-14114579</span><br><span class="line">Colors_M_Strings=C-16724992</span><br><span class="line">Colors_M_UnterminatedStrings=C-4210944</span><br><span class="line">Colors_M_SystemCommands=C-7123493</span><br><span class="line">Colors_M_Errors=C-45747</span><br><span class="line">Colors_HTML_HTMLLinks=C-10592257</span><br><span class="line">Colors_M_Warnings=C-27648</span><br><span class="line">ColorsMLintAutoFixBackground=C-9223357</span><br><span class="line">Editor.VariableHighlighting.Color=C-11184786</span><br><span class="line">Editor.NonlocalVariableHighlighting.TextColor=C-16735351</span><br><span class="line">Editorhighlight-lines=C-14408662</span><br><span class="line">Editorhighlight-caret-row-boolean-color=C-12632257</span><br><span class="line">EditorRightTextLimitLineColor=C-5723992</span><br><span class="line"># TLC</span><br><span class="line">Editor.Language.TLC.Color.Colors_M_Keywords=C-16735351</span><br><span class="line"># C/C++</span><br><span class="line">Editor.Language.C.Color.preprocessor=C-16735351</span><br><span class="line"># VHDL</span><br><span class="line">Editor.Language.VHDL.Color.operator=C-16735351</span><br><span class="line"># Verilog</span><br><span class="line">Editor.Language.Verilog.Color.operator=C-16735351</span><br><span class="line"># XML</span><br><span class="line">Editor.Language.XML.Color.operator=C-1710454</span><br><span class="line">Editor.Language.XML.Color.doctype=C-6578958</span><br><span class="line">Editor.Language.XML.Color.pi-content=C-9868801</span><br></pre></td></tr></table></figure><h3 id="monokai"><a href="#monokai" class="headerlink" title="monokai"></a>monokai</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ColorsUseSystem=Bfalse</span><br><span class="line">ColorsUseMLintAutoFixBackground=Btrue</span><br><span class="line">Editor.VariableHighlighting.Automatic=Btrue</span><br><span class="line">Editor.NonlocalVariableHighlighting=Btrue</span><br><span class="line">EditorCodepadHighVisible=Btrue</span><br><span class="line">EditorCodeBlockDividers=Btrue</span><br><span class="line">Editorhighlight-caret-row-boolean=Bfalse</span><br><span class="line">EditorRightTextLineVisible=Btrue</span><br><span class="line">EditorRightTextLimitLineWidth=I1</span><br><span class="line">ColorsText=C-460560</span><br><span class="line">ColorsBackground=C-14211038</span><br><span class="line">Colors_M_Keywords=C-448910</span><br><span class="line">Colors_M_Comments=C-9080482</span><br><span class="line">Colors_M_Strings=C-1647756</span><br><span class="line">Colors_M_UnterminatedStrings=C-65536</span><br><span class="line">Colors_M_SystemCommands=C-16711936</span><br><span class="line">Colors_M_Errors=C-65536</span><br><span class="line">Colors_HTML_HTMLLinks=C-16711681</span><br><span class="line">Colors_M_Warnings=C-27648</span><br><span class="line">ColorsMLintAutoFixBackground=C-11974594</span><br><span class="line">Editor.VariableHighlighting.Color=C-10066330</span><br><span class="line">Editor.NonlocalVariableHighlighting.TextColor=C-16729641</span><br><span class="line">Editorhighlight-lines=C-13421773</span><br><span class="line">Editorhighlight-caret-row-boolean-color=C-10066330</span><br><span class="line">EditorRightTextLimitLineColor=C-3355444</span><br><span class="line">Color_CmdWinWarnings=C-26368</span><br></pre></td></tr></table></figure><p>参考github效果：<br><a href="https://github.com/scottclowe/matlab-schemer/tree/master/schemes" target="_blank" rel="noopener">https://github.com/scottclowe/matlab-schemer/tree/master/schemes</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础</title>
      <link href="/2018/08/31/Linux%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/08/31/Linux%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Linux基础</p><a id="more"></a><h2 id="VIM-三个模式"><a href="#VIM-三个模式" class="headerlink" title="VIM 三个模式"></a>VIM 三个模式</h2><ul><li>一般指令模式（Command mode）：VIM 的默认模式，可以用于移动游标查看内容；</li><li>编辑模式（Insert mode）：按下 “i” 等按键之后进入，可以对文本进行编辑；</li><li>指令列模式（Bottom-line mode）：按下 “:” 按键之后进入，用于保存退出等操作。</li></ul><p>在指令列模式下，有以下命令用于离开或者保存文件。</p><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">:w</td><td style="text-align:center">写入磁盘</td></tr><tr><td style="text-align:center">:w!</td><td style="text-align:center">当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关</td></tr><tr><td style="text-align:center">:q</td><td style="text-align:center">离开</td></tr><tr><td style="text-align:center">:q!</td><td style="text-align:center">强制离开不保存</td></tr><tr><td style="text-align:center">:wq</td><td style="text-align:center">写入磁盘后离开</td></tr><tr><td style="text-align:center">:wq!</td><td style="text-align:center">强制写入磁盘后离开</td></tr></tbody></table></div><h2 id="磁盘的文件名"><a href="#磁盘的文件名" class="headerlink" title="磁盘的文件名"></a>磁盘的文件名</h2><p>Linux 中每个硬件都被当做一个文件，包括磁盘</p><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><h3 id="1-MBR"><a href="#1-MBR" class="headerlink" title="1. MBR"></a>1. MBR</h3><p>MBR 中，第一个扇区最重要，里面有主要开机记录（Master boot record, MBR）及分区表（partition table），其中主要开机记录占 446 bytes，分区表占 64 bytes。</p><h3 id="2-GPT"><a href="#2-GPT" class="headerlink" title="2. GPT"></a>2. GPT</h3><p>不同的磁盘有不同的扇区大小，GPT 第 1 个区块记录了主要开机记录（MBR）</p><h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><p>用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。</p><p>使用 ls 查看一个文件时，会显示一个文件的信息，例如 <code>drwxr-xr-x. 3 root root 17 May 6 00:14 .config</code>，对这个信息的解释如下：</p><ul><li>drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段</li><li>3：链接数</li><li>root：文件拥有者</li><li>root：所属群组</li><li>17：文件大小</li><li>May 6 00:14：文件最后被修改的时间</li><li>.config：文件名</li></ul><p>常见的文件类型及其含义有：</p><ul><li>d：目录</li><li>-：文件</li><li>l：链接文件</li></ul><p>9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。</p><p>文件时间有以下三种：</p><ul><li>modification time (mtime)：文件的内容更新就会更新；</li><li>status time (ctime)：文件的状态（权限、属性）更新就会更新；</li><li>access time (atime)：读取文件时就会更新。</li></ul><h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。</p><p>孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。</p><p>由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。</p><h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。</p><p>僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。</p><p>系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p><p>要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 所收养，这样 init 就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql基础</title>
      <link href="/2018/08/31/Mysql%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/08/31/Mysql%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Mysql基础</p><a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理推荐资料</title>
      <link href="/2018/08/31/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E6%8E%A8%E8%8D%90%E8%B5%84%E6%96%99/"/>
      <url>/2018/08/31/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E6%8E%A8%E8%8D%90%E8%B5%84%E6%96%99/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>图像处理推荐资料</p><a id="more"></a><p>图像处理与计算机视觉相关的书籍</p><ol><li>数学<br>   我们所说的图像处理实际上就是数字图像处理，是把真实世界中的连续三维随机信号投影到传感器的二维平面上，采样并量化后得到二维矩阵。数字图像处理就是二维矩阵的处理，而从二维图像中恢复出三维场景就是计算机视觉的主要任务之一。这里面就涉及到了图像处理所涉及到的三个重要属性：连续性，二维矩阵，随机性。所对应的数学知识是高等数学（微积分），线性代数（矩阵论），概率论和随机过程。这三门课也是考研数学的三个组成部分，构成了图像处理和计算机视觉最基础的数学基础。如果想要更进一步，就要到网上搜搜林达华推荐的数学书目了。</li><li>信号处理<br> 图像处理其实就是二维和三维信号处理，而处理的信号又有一定的随机性，因此经典信号处理和随机信号处理都是图像处理和计算机视觉中必备的理论基础。<br>2.1经典信号处理<br>信号与系统(第2版) Alan V.Oppenheim等著 刘树棠译</li></ol><p>离散时间信号处理(第2版) A.V.奥本海姆等著 刘树棠译</p><p>数字信号处理:理论算法与实现 胡广书 (编者)</p><p>2.2随机信号处理<br>现代信号处理 张贤达著</p><p>统计信号处理基础:估计与检测理论 Steven M.Kay等著 罗鹏飞等译</p><p>自适应滤波器原理(第4版) Simon Haykin著 郑宝玉等译</p><p>2.3 小波变换<br>信号处理的小波导引:稀疏方法(原书第3版) tephane Malla著, 戴道清等译</p><p>2.4 信息论<br>信息论基础(原书第2版) Thomas M.Cover等著 阮吉寿等译</p><ol><li>模式识别<br>Pattern Recognition and Machine Learning Bishop, Christopher M. Springer</li></ol><p>模式识别(英文版)(第4版) 西奥多里德斯著</p><p>Pattern Classification (2nd Edition) Richard O. Duda等著</p><p>Statistical Pattern Recognition, 3rd Edition Andrew R. Webb等著</p><p>模式识别(第3版) 张学工著</p><ol><li>图像处理与计算机视觉的书籍推荐<br>图像处理，分析与机器视觉 第三版 Sonka等著 艾海舟等译</li></ol><p>Image Processing, Analysis and Machine Vision</p><pre><code>            ( 附：这本书是图像处理与计算机视觉里面比较全的一本书了，几乎涵盖了图像视觉领域的各个方面。中文版的个人感觉也还可以，值得一看。)</code></pre><p>数字图像处理 第三版 冈萨雷斯等著</p><p>Digital Image Processing</p><p>(附：数字图像处理永远的经典，现在已经出到了第三版，相当给力。我的导师曾经说过，这本书写的很优美，对写英文论文也很有帮助，建议购买英文版的。)</p><p>计算机视觉：理论与算法 Richard Szeliski著</p><p>Computer Vision: Theory and Algorithm</p><pre><code>            (附：微软的Szeliski写的一本最新的计算机视觉著作。内容非常丰富，尤其包括了作者的研究兴趣，比如一般的书里面都没有的Image Stitching和                       Image Matting等。这也从另一个侧面说明这本书的通用性不如Sonka的那本。不过作者开放了这本书的电子版，可以有选择性的阅读。              http://szeliski.org/Book/              Multiple View Geometry in Computer Vision 第二版Harley等著             引用达一万多次的经典书籍了。第二版到处都有电子版的。第一版曾出过中文版的，后来绝版了。网上也可以找到中英文版的电子版。)</code></pre><p>计算机视觉：一种现代方法 DA Forsyth等著</p><p>Computer Vision: A Modern Approach</p><p>MIT的经典教材。虽然已经过去十年了，还是值得一读。期待第二版</p><p>Machine vision: theory, algorithms, practicalities 第三版 Davies著</p><p>(附：为数不多的英国人写的书，偏向于工业应用。)</p><p>数字图像处理 第四版 Pratt著</p><p>Digital Image Processing</p><p>(附：写作风格独树一帜，也是图像处理领域很不错的一本书。网上也可以找到非常清晰的电子版。)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客 报错 Cannot read property &#39;replace&#39; of null</title>
      <link href="/2018/08/28/hexo_error_replace/"/>
      <url>/2018/08/28/hexo_error_replace/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p><img width="800" height="800" src="http://ph04wnm2q.bkt.clouddn.com/bg/magazine-unlock-01-2.3.1003-_888F66AA592CE88202C711A7FB9371B2.jpg"></p><a id="more"></a><h3 id="报错内容-情况"><a href="#报错内容-情况" class="headerlink" title="报错内容-情况"></a>报错内容-情况</h3><p>报错内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FATAL Cannot read property &apos;replace&apos; of null</span><br><span class="line"></span><br><span class="line">TypeError: Cannot read property &apos;replace&apos; of null</span><br></pre></td></tr></table></figure></p><p>如图：<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/hexo_error_replace.png" alt></p><p>报错情况，执行 <code>hexo clean</code> 清理本地缓存或者 <code>hexo g</code> 生成本地缓存时报此错误</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>打开 hexo配置文件，配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: https://www.aomanhao.top</span><br><span class="line">root: AomanHao.github.io</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure></p><p>root，url属性配置正确，填写自己对应的</p><p><a href="https://www.jianshu.com/p/449accb044b4" target="_blank" rel="noopener">参考文章</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理_图像插值</title>
      <link href="/2018/08/28/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E6%8F%92%E5%80%BC/"/>
      <url>/2018/08/28/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E6%8F%92%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>图像插值<br><a id="more"></a></p><p>比较常用的插值算法有这么几种：最邻近插值，双线性二次插值，三次插值，Lanczos插值等等</p><h3 id="1，最邻近插值"><a href="#1，最邻近插值" class="headerlink" title="1，最邻近插值"></a>1，最邻近插值</h3><pre><code>最邻近插值算法也叫做零阶插值算法，主要原理是让输出像素的像素值等于邻域内</code></pre><p>离它距离最近的像素值。</p><p>这种放大图像的方法叫做最临近插值算法，这是一种最基本、最简单的图像缩放算法，效果也是最不好的，放大后的图像有很严重的马赛克，缩小后的图像有很严重的失真；效果不好的根源就是其简单的最临近插值方法引入了严重的图像失真。</p><h3 id="2，双线性二次插值"><a href="#2，双线性二次插值" class="headerlink" title="2，双线性二次插值"></a>2，双线性二次插值</h3><h3 id="3、三次内插法"><a href="#3、三次内插法" class="headerlink" title="3、三次内插法"></a>3、三次内插法</h3><h3 id="内插值，外插值"><a href="#内插值，外插值" class="headerlink" title="内插值，外插值"></a>内插值，外插值</h3><p>两张图像混合时通过内插与外插值方法可以实现图像亮度、对比度、饱和度、填色、锐化等常见的图像处理操作。在两张图像混合时最常见是线性插值方法，使用的混合权重公式如下：</p><script type="math/tex; mode=display">Out(x,y) = Src2(x,y) *\alpha + Src1(x,y)(1-\alpha)</script><p>$\alpha$的范围是[0,1]之间</p><p>内插值方法：常见的值属于[0,1]之间。</p><p>外插值方法：可以用来生成跟内插值效果相反的图像。</p><p>比如内插值模糊图像，通过外插值可以去模糊，外插值可以调节饱和度，可以实现图像一些列的处理比如亮度、饱和度、对比度、锐化调整。</p><h3 id="插值算法的类型："><a href="#插值算法的类型：" class="headerlink" title="插值算法的类型："></a>插值算法的类型：</h3><p>一般分为两类: 自适应和非自适应。自适应的方法可以根据插值的内容来改变（尖锐的边缘或者是平滑的纹理），非自适应的方法对所有的像素点都进行同样的处理。 </p><p>非自适应算法包括: 最邻近方法, 双线性, 双三次, 样条, sinc, lanczos 和其他。由于其复杂度, 这些插值的时候使用从0 to 256 (or more) 邻近像素。 包含越多的邻近像素，他们越精确，但是花费的时间也越长。这些算法可以用来扭曲和缩放照片。</p><p>Original<br>Enlarged 250%<br>自适应算法包含许多专利，如: Qimage, PhotoZoom Pro, Genuine Fractals和其他。许多应用他们插值的不同版本 (on a pixel-by-pixel basis)当他们检测边缘时 —目标是最小化插值干扰。</p><h4 id="最邻近插值"><a href="#最邻近插值" class="headerlink" title="最邻近插值"></a>最邻近插值</h4><p>最邻近算法在所有插值算法中时间最短，因为它只考虑一个像素点—离待插像素点最近的像素点。</p><h4 id="双线性插值"><a href="#双线性插值" class="headerlink" title="双线性插值"></a>双线性插值</h4><p>双线性插值考虑待插像素最近的 2x2 已知像素点。需要加权四个像素值来求得最终的像素值。这使得插值出来比最邻近插值平滑。</p><p>双三次插值</p><p>基于双线性插值，考虑最近的 4x4已知像素点 —总共16个像素点。由于离待插像素点的距离不同， 在计算中距离近的像素给出的权重较大。双三次产生的图像比前两次的尖锐，有理想的处理时间和输出质量。因此，在很多图像编辑程序中是标准算法 (包括 Adobe Photoshop), 打印机和相机插值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像插值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷歌浏览器加载静态文件错误，请修改DNS配置</title>
      <link href="/2018/08/24/DNS_error/"/>
      <url>/2018/08/24/DNS_error/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>谷歌浏览器加载静态文件错误，请修改DNS配置<br><a id="more"></a></p><p><img src="https://img-blog.nos-eastchina1.126.net/niuke_error.png" alt></p><p>当我登陆CSDN/牛客网的时候，页面不能正常显示，只能显示纯文字，访问百度或者视频网站的时候是可以的<br>报错提示</p><h3>静态文件加载出错，请检查当前网络情况是否正常，或者按照下面步骤修改电脑的DNS等等</h3><br>折腾了一晚上<p></p><hr><h3 id="修改DNS"><a href="#修改DNS" class="headerlink" title="修改DNS"></a>修改DNS</h3><p><img src="https://img-blog.nos-eastchina1.126.net/changedns1.png" alt><br><a href="https://jingyan.baidu.com/article/2fb0ba40833b0a00f2ec5f28.html" target="_blank" rel="noopener">百度经验修改DNS</a></p><p>按照要求修改了dns，失败，仍然不能正常加载网页</p><hr><h3 id="修改hosts文件"><a href="#修改hosts文件" class="headerlink" title="修改hosts文件"></a>修改hosts文件</h3><p><a href="http://jingyan.baidu.com/article/425e69e6e479a2be15fc16e1.html?allowHTTP=1" target="_blank" rel="noopener">百度经验修改hosts文件</a></p><p>hosts属于系统文件，需要谨慎操作，需要很高的权限<br><img src="https://img-blog.nos-eastchina1.126.net/hosts_error.png" alt></p><p>打开hosts文件，发现最后一行是<code>192.168.137.1 windows10.microdone.cn</code><br>神秘代码有没有，寻找其出处，网友指出他是<code>银联网银插件</code>修改的<br><a href="https://www.v2ex.com/t/273757" target="_blank" rel="noopener">代码解释链接</a></p><p>解决方法：<br>卸载最近安装的 网银插件/控件<br>（我没有就不用卸载了）</p><p>然后按照百度经验修改<code>hosts</code>文件，保存后，发现过一会打开又出现了<code>192.168.137.1 windows10.microdone.cn</code><br>这下怀疑中病毒了</p><h3 id="使用360断网急救箱"><a href="#使用360断网急救箱" class="headerlink" title="使用360断网急救箱"></a>使用360断网急救箱</h3><p><img src="https://img-blog.nos-eastchina1.126.net/360duanwnag.png" alt><br>诊断确实是 <code>hosts</code>文件出现异常</p><p>修复在检测，依然有问题</p><h3 id="使用360系统急救箱"><a href="#使用360系统急救箱" class="headerlink" title="使用360系统急救箱"></a>使用360系统急救箱</h3><p>深度检测，删了一些文件（可能中毒）<br>重启电脑，依然<code>CSDN/牛客网</code>的时候，页面不能正常显示</p><hr><h3 id="谷歌浏览器插件问题"><a href="#谷歌浏览器插件问题" class="headerlink" title="谷歌浏览器插件问题"></a>谷歌浏览器插件问题</h3><p>我鬼使神差的试试用微软自带的Eage浏览器登陆<code>CSDN/牛客网</code>，可以<font color="red" size="10">正常显示</font>，惊了。我这一通操作，就是换个浏览器的题</p><p>仔细回想一下，之前安装的<code>谷歌访问助手</code>插件崩溃了，我就卸载了</p><p>1、卸载<code>谷歌浏览器</code>，重新安装</p><blockquote><p>失败，不能正常显示网页<code>CSDN/牛客网</code></p></blockquote><p>2、安装<code>谷歌访问助手</code>插件</p><blockquote><p><code>CSDN/牛客网</code>可以正常显示了。</p></blockquote><p>原因：怀疑是插件的上网代理搞鬼</p><hr><h2 id="解决方法：谷歌浏览器谷歌访问助手重新安装"><a href="#解决方法：谷歌浏览器谷歌访问助手重新安装" class="headerlink" title="解决方法：谷歌浏览器谷歌访问助手重新安装"></a>解决方法：谷歌浏览器谷歌访问助手重新安装</h2>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客yilia主题首页添加helper-live2d模型插件</title>
      <link href="/2018/08/23/hexo_helper_live2d/"/>
      <url>/2018/08/23/hexo_helper_live2d/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Hexo添加helper-live2d模型插件<br><a id="more"></a></p><p>插件效果<br><a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">插件的github地址</a><br>插件作者提供了较为详细的安装步骤，我结合自己操作和图示，提供大家。</p><p>效果展示：红框内为2d模型，可以随鼠标移动而变化<br><img src="https://img-blog.nos-eastchina1.126.net/koharu4.png" alt></p><h2 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块:"></a>安装模块:</h2><p>hexo博客根目录选择<code>cmd</code>命令窗口或者<code>git bash</code> 输入以下代码，安装插件</p><h3 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.nos-eastchina1.126.net/koharu1.png" alt></p><h3 id="下载模型"><a href="#下载模型" class="headerlink" title="下载模型"></a>下载模型</h3><p>作者提供了三个下载模型的办法，我选择操作比较简单的一种<br><code>npm 模块名</code> 的方法</p><p>作者提供以下模型的模型包，模型包预览地址见下面的链接，选择你想用的模型，记住名字，选择对应的后缀模型包</p><p><a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">作者各种模型包展示</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">live2d-widget-model-chitose</span><br><span class="line">live2d-widget-model-epsilon2_1</span><br><span class="line">live2d-widget-model-gf</span><br><span class="line">live2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)</span><br><span class="line">live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)</span><br><span class="line">live2d-widget-model-haruto</span><br><span class="line">live2d-widget-model-hibiki</span><br><span class="line">live2d-widget-model-hijiki</span><br><span class="line">live2d-widget-model-izumi</span><br><span class="line">live2d-widget-model-koharu</span><br><span class="line">live2d-widget-model-miku</span><br><span class="line">live2d-widget-model-ni-j</span><br><span class="line">live2d-widget-model-nico</span><br><span class="line">live2d-widget-model-nietzsche</span><br><span class="line">live2d-widget-model-nipsilon</span><br><span class="line">live2d-widget-model-nito</span><br><span class="line">live2d-widget-model-shizuku</span><br><span class="line">live2d-widget-model-tororo</span><br><span class="line">live2d-widget-model-tsumiki</span><br><span class="line">live2d-widget-model-unitychan</span><br><span class="line">live2d-widget-model-wanko</span><br><span class="line">live2d-widget-model-z16</span><br></pre></td></tr></table></figure><p>选择好对应的模型，使用 <code>npm install 模型的包名</code>来安装，比如我选择的的是<code>live2d-widget-model-koharu</code> 模型包</p><h3 id="操作：-1"><a href="#操作：-1" class="headerlink" title="操作："></a>操作：</h3><p>在hexo博客根目录选择<code>cmd</code>命令窗口或者<code>git bash</code> 输入以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install live2d-widget-model-koharu</span><br></pre></td></tr></table></figure><p>执行安装就完事了</p><p><img src="https://img-blog.nos-eastchina1.126.net/koharu3.png" alt></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>请向<code>Hexo</code>的 <code>_config.yml</code> 文件添加配置.</p><h3 id="操作：-2"><a href="#操作：-2" class="headerlink" title="操作："></a>操作：</h3><p>打开个人Hexo博客文件根目录下的 <code>_config.yml</code> 文件，在最后添加一下代码<br>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local</span><br><span class="line">  pluginRootPath: live2dw/</span><br><span class="line">  pluginJsPath: lib/</span><br><span class="line">  pluginModelPath: assets/</span><br><span class="line">  tagMode: false</span><br><span class="line">  debug: false</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-koharu</span><br><span class="line">  display:</span><br><span class="line">    position: right</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: true</span><br></pre></td></tr></table></figure><p>注：在移动端可能会干扰阅览，可以选择取消移动端显示，<code>true</code>改为<code>fasle</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mobile:</span><br><span class="line">  show: fasle</span><br></pre></td></tr></table></figure></p><p>你需要配置的是<code>use: live2d-widget-model-koharu</code><br><code>use</code>后为你选择的安装包的全称</p><p><img src="https://img-blog.nos-eastchina1.126.net/koharu2.png" alt></p><p>插件部署与配置就完成了</p><h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p>本地预览<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure></p><h2 id="博客部署"><a href="#博客部署" class="headerlink" title="博客部署"></a>博客部署</h2><p>博客部署<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> yilia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理_Retinex图像增强</title>
      <link href="/2018/08/17/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_Retinex%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/"/>
      <url>/2018/08/17/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_Retinex%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>图像处理_Retinex图像增强</p><a id="more"></a><h3 id="单尺度SSR"><a href="#单尺度SSR" class="headerlink" title="单尺度SSR"></a>单尺度SSR</h3><p>(Single Scale Retinex)</p><p>图像$S(x,y)$分解为两个不同的图像：反射图像$R(x,y)$,入射图像$L(x,y)$<br><img src="https://img-blog.csdn.net/20170508211020962?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWppYW55aW5neGlhb3FpbmdoYW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><p>图像可以看做是入射图像和反射图像构成，入射光照射在反射物体上，通过反射物体的反射，形成反射光进入人眼。最后形成的图像$r(x,y)$可以如下公式表示</p><script type="math/tex; mode=display">r(x,y)=logR(x,y)=log\frac{S(x,y)}{L(x,y)}</script><p>R(x, y)表示了物体的反射性质，即图像内在属性，我们应该最大程度的保留；而L(x, y)表示入射光图像，决定了图像像素能达到的动态范围，我们应该尽量去除。 </p><p>我们把照射图像假设估计为空间平滑图像，原始图像为S(x, y)，反射图像为R(x, y)，亮度图像为L(x, y)，使用公式</p><script type="math/tex; mode=display">r(x,y)=logR(x,y)=log\frac{S(x,y)}{L(x,y)}</script><p>或者</p><script type="math/tex; mode=display">r(x,y)=logS(x,y)-log[F(x,y)⨂S(x,y)]</script><p>其中r(x, y)是输出图像,卷积运算，$F(x, y)$是中心环绕函数</p><script type="math/tex; mode=display">F(x,y)=\lambda*e^{-\frac{x^2+y^2}{c^2}}</script><p>其中C是高斯环绕尺度，λ是一个尺度，满足$∫∫F(x,y)dxdy=1$</p><blockquote><p>SSR算法中的卷积是对入射图像的计算，其物理意义是通过计算像素点与周围区域在加权平均的作用下，估计图像中照度的变化，并将L(x,y)去除，只保留S(x,y)属性。</p></blockquote><h3 id="多尺度MSR"><a href="#多尺度MSR" class="headerlink" title="多尺度MSR"></a>多尺度MSR</h3><p>(Multi-Scale Retinex)</p><blockquote><p>MSR是在SSR基础上发展来的，优点是可以同时保持图像高保真度与对图像的动态范围进行压缩的同时，MSR也可实现色彩增强、颜色恒常性、局部动态范围压缩、全局动态范围压缩，也可以用于X光图像增强。</p></blockquote><script type="math/tex; mode=display">r(x,y)=∑_k^Kw_klogS(x,y)-log[F_k(x,y)*S(x,y)]</script><p>K是高斯中心环绕函数的个数。当K=1时，MSR退化为SSR,K取值通常为3</p><script type="math/tex; mode=display">w1=w2=w3=\frac13</script><blockquote><p>缺点:边缘锐化不足，阴影边界突兀，部分颜色发生扭曲，纹理不清晰，高光区域细节没有得到明显改善，对高光区域敏感度小</p></blockquote><h3 id="带颜色恢复的MSR方法MSRCR"><a href="#带颜色恢复的MSR方法MSRCR" class="headerlink" title="带颜色恢复的MSR方法MSRCR"></a>带颜色恢复的MSR方法MSRCR</h3><p>(Multi-Scale Retinex with Color Restoration)<br>SSR和MSR普遍都存在明显的偏色问题</p><blockquote><p>MSRCR在MSR的基础上，加入了色彩恢复因子C来调节由于图像局部区域对比度增强而导致颜色失真的缺陷。</p></blockquote><p>改进公式：</p><script type="math/tex; mode=display">R_{MSRCR_i}(x,y)=C_i(x,y)R_{MSR_i}(x,y)</script><p>其中</p><script type="math/tex; mode=display">C_i(x,y)=f[I_i^{'}(x,y)]=f[\frac{I_i(x,y)}{∑_{j=1}^{N}I_j(x,y)}]</script><p>其中</p><script type="math/tex; mode=display">f[I_i^{'}(x,y)]=βlog[αI_i^{'}(x,y)]=β{log[αI_i^{'}i(x,y)]-log[∑_{j=1}^NI_j(x,y)]}</script><p>参数说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ii(x, y)表示第i个通道的图像</span><br><span class="line">Ci表示第i个通道的彩色回复因子，用来调节3个通道颜色的比例；</span><br><span class="line">f(·)表示颜色空间的映射函数；</span><br><span class="line">β是增益常数；</span><br><span class="line">α是受控制的非线性强度；</span><br></pre></td></tr></table></figure></p><p>MSRCR算法利用彩色恢复因子C，调节原始图像中3个颜色通道之间的比例关系，从而把相对较暗区域的信息凸显出来，达到了消除图像色彩失真的缺陷。<br>处理后的图像局部对比度提高，亮度与真实场景相似，在人们视觉感知下，图像显得更加逼真。</p><p><a href="https://blog.csdn.net/ajianyingxiaoqinghan/article/details/71435098" target="_blank" rel="noopener">参考文章</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> Opencv </tag>
            
            <tag> 图像增强 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10大数据算法排序Java_C++</title>
      <link href="/2018/08/16/10%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8FJava_C++/"/>
      <url>/2018/08/16/10%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8FJava_C++/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>10大数据算法排序Java_C++</p><a id="more"></a><p><img src="https://images0.cnblogs.com/blog2015/731178/201508/272007357503007.jpg" alt></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><blockquote><p>依次比较n与后面的数字，大的放右面，小的放左边<br>Java代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 冒泡排序</span><br><span class="line">     * 比较相邻的元素。如果第一个比第二个大，就交换他们两个。  </span><br><span class="line">     * 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。  </span><br><span class="line">     * 针对所有的元素重复以上的步骤，除了最后一个。</span><br><span class="line">     * 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 </span><br><span class="line">     * @param numbers 需要排序的整型数组</span><br><span class="line">     */</span><br><span class="line">    public static void bubbleSort(int[] numbers)</span><br><span class="line">    &#123;</span><br><span class="line">        int temp = 0;</span><br><span class="line">        int size = numbers.length;</span><br><span class="line">        for(int i = 0 ; i &lt; size-1; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">        for(int j = 0 ;j &lt; size-1-i ; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(numbers[j] &gt; numbers[j+1])  //交换两数位置</span><br><span class="line">            &#123;</span><br><span class="line">            temp = numbers[j];</span><br><span class="line">            numbers[j] = numbers[j+1];</span><br><span class="line">            numbers[j+1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>C++代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure></p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><blockquote><p>选择n个数组成的数组arr里最大的一个数，放在arr[n-1]，<br><br>然后维数n-1<br><br>选择前n-1个数组成的数组，取最大数，放在arr</p></blockquote><p>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 选择排序算法</span><br><span class="line">     * 在未排序序列中找到最小元素，存放到排序序列的起始位置  </span><br><span class="line">     * 再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。 </span><br><span class="line">     * 以此类推，直到所有元素均排序完毕。 </span><br><span class="line">     * @param numbers</span><br><span class="line">     */</span><br><span class="line">    public static void selectSort(int[] numbers)</span><br><span class="line">    &#123;</span><br><span class="line">    int size = numbers.length; //数组长度</span><br><span class="line">    int temp = 0 ; //中间变量</span><br><span class="line">    </span><br><span class="line">    for(int i = 0 ; i &lt; size ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int k = i;   //待确定的位置</span><br><span class="line">        //选择出应该在第i个位置的数</span><br><span class="line">        for(int j = size -1 ; j &gt; i ; j--)</span><br><span class="line">        &#123;</span><br><span class="line">        if(numbers[j] &lt; numbers[k])</span><br><span class="line">        &#123;</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //交换两个数</span><br><span class="line">        temp = numbers[i];</span><br><span class="line">        numbers[i] = numbers[k];</span><br><span class="line">        numbers[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>C++代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure></p><h3 id="快速排序及其改进算法C-实现"><a href="#快速排序及其改进算法C-实现" class="headerlink" title="快速排序及其改进算法C++实现"></a>快速排序及其改进算法C++实现</h3><blockquote><p>快速排序可以看成是插入排序的改进，它是一种分治的排序算法<br><img src="http://my.csdn.net/uploads/201207/20/1342782317_4426.jpg" alt="一次快排"><br><img src="http://my.csdn.net/uploads/201207/20/1342782329_8314.jpg" alt="快排流程"></p></blockquote><p>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class FastSort&#123;</span><br><span class="line"></span><br><span class="line">     public static void main(String []args)&#123;</span><br><span class="line">        System.out.println(&quot;Hello World&quot;);</span><br><span class="line">        int[] a = &#123;12,20,5,16,15,1,30,45,23,9&#125;;</span><br><span class="line">        int start = 0;</span><br><span class="line">        int end = a.length-1;</span><br><span class="line">        sort(a,start,end);</span><br><span class="line">        for(int i = 0; i&lt;a.length; i++)&#123;</span><br><span class="line">             System.out.println(a[i]);</span><br><span class="line">         &#125;</span><br><span class="line">        </span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     public void sort(int[] a,int low,int high)&#123;</span><br><span class="line">         int start = low;</span><br><span class="line">         int end = high;</span><br><span class="line">         int key = a[low];</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">         while(end&gt;start)&#123;</span><br><span class="line">             //从后往前比较</span><br><span class="line">             while(end&gt;start&amp;&amp;a[end]&gt;=key)  //如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较</span><br><span class="line">                 end--;</span><br><span class="line">             if(a[end]&lt;=key)&#123;</span><br><span class="line">                 int temp = a[end];</span><br><span class="line">                 a[end] = a[start];</span><br><span class="line">                 a[start] = temp;</span><br><span class="line">             &#125;</span><br><span class="line">             //从前往后比较</span><br><span class="line">             while(end&gt;start&amp;&amp;a[start]&lt;=key)//如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置</span><br><span class="line">                start++;</span><br><span class="line">             if(a[start]&gt;=key)&#123;</span><br><span class="line">                 int temp = a[start];</span><br><span class="line">                 a[start] = a[end];</span><br><span class="line">                 a[end] = temp;</span><br><span class="line">             &#125;</span><br><span class="line">         //此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，右边的值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用</span><br><span class="line">         &#125;</span><br><span class="line">         //递归</span><br><span class="line">         if(start&gt;low) sort(a,low,start-1);//左边序列。第一个索引位置到关键值索引-1</span><br><span class="line">         if(end&lt;high) sort(a,end+1,high);//右边序列。从关键值索引+1到最后一个</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C++代码：<br><a href="https://blog.csdn.net/liuchen1206/article/details/6954074" target="_blank" rel="noopener">cankao</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int array[]=&#123;34,65,12,43,67,5,78,10,3,70&#125;,k;</span><br><span class="line">int len=sizeof(array)/sizeof(int);</span><br><span class="line">cout&lt;&lt;&quot;The orginal arrayare:&quot;&lt;&lt;endl;</span><br><span class="line">for(k=0;k&lt;len;k++)</span><br><span class="line">cout&lt;&lt;array[k]&lt;&lt;&quot;,&quot;;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">quickSort(array,0,len-1);</span><br><span class="line">cout&lt;&lt;&quot;The sorted arrayare:&quot;&lt;&lt;endl;</span><br><span class="line">for(k=0;k&lt;len;k++)</span><br><span class="line">cout&lt;&lt;array[k]&lt;&lt;&quot;,&quot;;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void quickSort(int s[], int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">if (low&lt; high)</span><br><span class="line">&#123;      </span><br><span class="line">int i = low, j = high, x = s[low];</span><br><span class="line">while (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">while(i &lt; j &amp;&amp; s[j]&gt;= x) // 从右向左找第一个小于x的数</span><br><span class="line">j--; </span><br><span class="line">if(i &lt; j)</span><br><span class="line">s[i++] = s[j];</span><br><span class="line">while(i &lt; j &amp;&amp; s[i]&lt; x) // 从左向右找第一个大于等于x的数</span><br><span class="line">i++; </span><br><span class="line">if(i &lt; j)</span><br><span class="line">s[j--] = s[i];</span><br><span class="line">&#125;</span><br><span class="line">s[i] = x;</span><br><span class="line">quickSort(s, low, i - 1); // 递归调用</span><br><span class="line">quickSort(s, i + 1, high);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><blockquote><p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。<br><br>分治思想：<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/guibing_1.png" alt><br>合并步骤如下<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/guibing_2.png" alt></p></blockquote><p>Java代码：<a href="https://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">cankao</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package sortdemo;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by chengxiao on 2016/12/8.</span><br><span class="line"> */</span><br><span class="line">public class MergeSort &#123;</span><br><span class="line">    public static void main(String []args)&#123;</span><br><span class="line">        int []arr = &#123;9,8,7,6,5,4,3,2,1&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sort(int []arr)&#123;</span><br><span class="line">        int []temp = new int[arr.length];//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span><br><span class="line">        sort(arr,0,arr.length-1,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    private static void sort(int[] arr,int left,int right,int []temp)&#123;</span><br><span class="line">        if(left&lt;right)&#123;</span><br><span class="line">            int mid = (left+right)/2;</span><br><span class="line">            sort(arr,left,mid,temp);//左边归并排序，使得左子序列有序</span><br><span class="line">            sort(arr,mid+1,right,temp);//右边归并排序，使得右子序列有序</span><br><span class="line">            merge(arr,left,mid,right,temp);//将两个有序子数组合并操作</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static void merge(int[] arr,int left,int mid,int right,int[] temp)&#123;</span><br><span class="line">        int i = left;//左序列指针</span><br><span class="line">        int j = mid+1;//右序列指针</span><br><span class="line">        int t = 0;//临时数组指针</span><br><span class="line">        while (i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">            if(arr[i]&lt;=arr[j])&#123;</span><br><span class="line">                temp[t++] = arr[i++];</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                temp[t++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(i&lt;=mid)&#123;//将左边剩余元素填充进temp中</span><br><span class="line">            temp[t++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        while(j&lt;=right)&#123;//将右序列剩余元素填充进temp中</span><br><span class="line">            temp[t++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        t = 0;</span><br><span class="line">        //将temp中的元素全部拷贝到原数组中</span><br><span class="line">        while(left &lt;= right)&#123;</span><br><span class="line">            arr[left++] = temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C++代码：<a href="https://www.cnblogs.com/orion7/p/8242774.html" target="_blank" rel="noopener">cankao</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=500000,INF=0x3f3f3f3f;</span><br><span class="line">int L[maxn/2+2],R[maxn/2+2];</span><br><span class="line">void merge(int a[],int n,int left,int mid,int right)</span><br><span class="line">&#123;</span><br><span class="line">    int n1=mid-left,n2=right-mid;</span><br><span class="line">    for(int i=0;i&lt;n1;i++)</span><br><span class="line">        L[i]=a[left+i];</span><br><span class="line">    for(int i=0;i&lt;n2;i++)</span><br><span class="line">        R[i]=a[mid+i];</span><br><span class="line">    L[n1]=R[n2]=INF;</span><br><span class="line">    int i=0,j=0;</span><br><span class="line">    for(int k=left;k&lt;right;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(L[i]&lt;=R[j])</span><br><span class="line">            a[k]=L[i++];</span><br><span class="line">        else</span><br><span class="line">            a[k]=R[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void mergesort(int a[],int n,int left,int right)</span><br><span class="line">&#123;</span><br><span class="line">    if(left+1&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid=(left+right)/2;</span><br><span class="line">        mergesort(a,n,left,mid);</span><br><span class="line">        mergesort(a,n,mid,right);</span><br><span class="line">        merge(a,n,left,mid,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[maxn],n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    mergesort(a,n,0,n);</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i)</span><br><span class="line">            cout&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p> <a href="http://www.cnblogs.com/MOBIN/p/5374217.html" target="_blank" rel="noopener">http://www.cnblogs.com/MOBIN/p/5374217.html</a></p><blockquote><p>堆排序主要在于理解堆的构造过程和在输出最大元素后如何对堆进行重新调整</p></blockquote><p>大顶堆：父结点始终&gt;子节点<br><img src="https://images2015.cnblogs.com/blog/776259/201604/776259-20160410150915593-1435777167.png" alt="大顶堆"> </p><p>小顶堆：父结点始终&lt;子节点<br><img src="https://images2015.cnblogs.com/blog/776259/201604/776259-20160410150948406-1525110244.png" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">算法思想(以大顶堆为例)：</span><br><span class="line">1.将长度为n的待排序的数组进行堆有序化构造成一个大顶堆</span><br><span class="line">2.将根节点与尾节点交换并输出此时的尾节点</span><br><span class="line">3.将剩余的n -1个节点重新进行堆有序化</span><br><span class="line">4.重复步骤2，步骤3直至构造成一个有序序列</span><br></pre></td></tr></table></figure></p><p>我们开始只需要扫描一半的元素（n/2-1 ~ 0）,因为(n/2-1)~0的节点才有子节点<br><img src="https://images2015.cnblogs.com/blog/776259/201604/776259-20160410151057625-469827986.png" alt></p><p>构建有序堆：<br>1、第一次for循环将节点3和它的子节点7 8的元素进行比较，最大者作为父节点（即元素60作为父节点）<br>红色表示交换后的状态<br><img src="https://images2015.cnblogs.com/blog/776259/201604/776259-20160410151437250-974257904.png" alt><br>2、第二次for循环将节点2和它的子节点5 6的元素进行比较，最大者为父节点（元素80作为父节点）<br><img src="https://images2015.cnblogs.com/blog/776259/201604/776259-20160410151453015-690847102.png" alt><br>3、第三次for循环将节点1和它的子节点3 4的元素进行比较，最大者为父节点（元素70作为父节点）<br><img src="https://images2015.cnblogs.com/blog/776259/201604/776259-20160410151523218-139482913.png" alt></p><p>调整堆<br>1、堆顶元素80和尾40交换后—&gt;调整堆<br><img src="https://images2015.cnblogs.com/blog/776259/201604/776259-20160410151713156-328299797.png" alt><br>2、堆顶元素70和尾30交换后—&gt;调整堆<br><img src="https://images2015.cnblogs.com/blog/776259/201604/776259-20160410151728406-2042556892.png" alt><br>。。。<br>完成调整<br><img src="https://images2015.cnblogs.com/blog/776259/201604/776259-20160410151755062-2073568164.png" alt></p><p>左右父节点下标:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">左：i*2+1</span><br><span class="line">右：i*2+2</span><br><span class="line">父：(i-1)/2</span><br></pre></td></tr></table></figure></p><p>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class HeapSort &#123;</span><br><span class="line">private static void heapSort(int[] arr) &#123;</span><br><span class="line">int len = arr.length -1;</span><br><span class="line">//堆构造，调整结构，符合大顶堆或者小顶堆</span><br><span class="line">for(int i = len/2 ; i &gt;=0; i --)&#123; </span><br><span class="line">heapAdjust(arr,i,len);</span><br><span class="line">&#125;</span><br><span class="line">while (len &gt;=0)&#123;</span><br><span class="line">swap(arr,0,len--); //将堆顶元素与尾节点交换后，长度减1，尾元素最大</span><br><span class="line">heapAdjust(arr,0,len); //再次对堆进行调整</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void heapAdjust(int[] arr,int i,int len)&#123;</span><br><span class="line">int left = 2*i+1,right = 2*i+2,largest = i;</span><br><span class="line">if(left &lt;= len &amp;&amp; arr[left] &gt; arr[i])</span><br><span class="line">largest = left;</span><br><span class="line">if(right &lt;= len &amp;&amp; arr[right] &gt; arr[largest])</span><br><span class="line">largest = right;</span><br><span class="line">if(largest != i) &#123;</span><br><span class="line">swap(arr, i, largest);</span><br><span class="line">heapAdjust(arr,largest,len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void swap(int[] arr,int i,int len)&#123;</span><br><span class="line">int temp = arr[i];</span><br><span class="line">arr[i] = arr[len];</span><br><span class="line">arr[len] = temp;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int array[] = &#123;20,50,20,40,70,10,80,30,60&#125;;</span><br><span class="line">System.out.println(&quot;排序之前：&quot;);</span><br><span class="line">for(int element : array)&#123;</span><br><span class="line">System.out.print(element+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">heapSort(array);</span><br><span class="line">System.out.println(&quot;\n排序之后：&quot;);</span><br><span class="line">for(int element : array)&#123;</span><br><span class="line">System.out.print(element+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C++代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure></p><p>C++代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure></p><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>需要求数组中的最大数<br>1、桶排序不在是一种基于比较的排序方法，而是需要待排序列满足以下两个条件：</p><blockquote><p>1、待排序列的值处于一个可枚举的范围内<br><br>2、待排序列所在可枚举范围不应太大，不然开销会很大。</p></blockquote><p>原理：</p><blockquote><p>假设待排序的数组a中共有N个整数，并且已知数组a中数据的范围[0, MAX)。在桶排序时，创建容量为MAX的桶数组r，并将桶数组元素都初始化为0；将容量为MAX的桶数组中的每一个单元都看作一个”桶”。<br>在排序时，逐个遍历数组a，将数组a的值，作为”桶数组r”的下标。当a中数据被读取时，就将桶的值加1。例如，读取到数组a[3]=5，则将r[5]的值+1。</p></blockquote><p>桶排序适用场景:<br><br>根据桶排序的特点，桶排序一般适用于一些特定的环境，比如数据范围较为局限或者有一些特定的要求，比如需要通过哈希映射快速获取某些值，需要统计每个数的数量。但是这一切都以确认数据的范围为前提，如果范围跨度过大，则考虑用其他算法。</p><p>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 桶排序</span><br><span class="line">///</span><br><span class="line">///如果有重复的数字,则需要 List&lt;int&gt;数组,这里举的例子没有重复的数字</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;unsorted&quot;&gt;待排数组&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;maxNumber&quot;&gt;待排数组中的最大数,如果可以提供的话&lt;/param&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">static int[] bucket_sort(int[] unsorted, int maxNumber = 97)</span><br><span class="line">&#123;</span><br><span class="line"> int[] sorted = new int[maxNumber + 1];</span><br><span class="line"> for (int i = 0; i &lt; unsorted.Length; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  sorted[unsorted[i]] = unsorted[i];</span><br><span class="line"> &#125;</span><br><span class="line"> return sorted;</span><br><span class="line">&#125;</span><br><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line"> int[] x = &#123;49、 38 、 35、 97 、 76、 73 、 27、 49 &#125;;</span><br><span class="line"> var sorted = bucket_sort(x, 97);</span><br><span class="line"> for (int i = 0; i &lt; sorted.Length; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  if (sorted[i] &gt; 0)</span><br><span class="line">   Console.WriteLine(sorted[i]);</span><br><span class="line"> &#125;</span><br><span class="line"> Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C++代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure></p><p>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure></p><p>C++代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure></p><p>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure></p><p>C++代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure></p><p>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure></p><p>C++代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解</title>
      <link href="/2018/08/16/leetcode_sum/"/>
      <url>/2018/08/16/leetcode_sum/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p><img width="800" height="800" src="http://ph04wnm2q.bkt.clouddn.com/bg/magazine-unlock-01-2.3.971-_c98a796eb65a419dbcfa164bbb6563e7.jpg"></p><a id="more"></a><h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p><h3 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1    Two Sum"></a>1    Two Sum</h3><p>5    array、set    sort、Two Pointers</p><h3 id="8-String-to-Integer-atoi-5-string-Math"><a href="#8-String-to-Integer-atoi-5-string-Math" class="headerlink" title="8    String to Integer (atoi)    5    string    Math"></a>8    String to Integer (atoi)    5    string    Math</h3><h3 id="15-3Sum-5-array-Two-Pointers"><a href="#15-3Sum-5-array-Two-Pointers" class="headerlink" title="15    3Sum    5    array    Two Pointers"></a>15    3Sum    5    array    Two Pointers</h3><h3 id="20-Valid-Parentheses-5-string-Stack"><a href="#20-Valid-Parentheses-5-string-Stack" class="headerlink" title="20    Valid Parentheses    5    string    Stack"></a>20    Valid Parentheses    5    string    Stack</h3><h3 id="21-Merge-Two-Sorted-Lists-5-linked-list-sort、Two-Pointers、merge"><a href="#21-Merge-Two-Sorted-Lists-5-linked-list-sort、Two-Pointers、merge" class="headerlink" title="21    Merge Two Sorted Lists    5    linked list    sort、Two Pointers、merge"></a>21    Merge Two Sorted Lists    5    linked list    sort、Two Pointers、merge</h3><h3 id="28-Implement-strStr-5-string-Two-Pointers、KMP、rolling-hash"><a href="#28-Implement-strStr-5-string-Two-Pointers、KMP、rolling-hash" class="headerlink" title="28    Implement strStr()    5    string    Two Pointers、KMP、rolling hash"></a>28    Implement strStr()    5    string    Two Pointers、KMP、rolling hash</h3><h3 id="50-Pow-x-n-5-Binary-Search、Math"><a href="#50-Pow-x-n-5-Binary-Search、Math" class="headerlink" title="50    Pow(x, n)    5         Binary Search、Math"></a>50    Pow(x, n)    5         Binary Search、Math</h3><h3 id="56-Merge-Intervals-5-array、linked-list、red-black-tree-sort、merge"><a href="#56-Merge-Intervals-5-array、linked-list、red-black-tree-sort、merge" class="headerlink" title="56    Merge Intervals    5    array、linked list、red-black tree    sort、merge"></a>56    Merge Intervals    5    array、linked list、red-black tree    sort、merge</h3><h3 id="57-Insert-Interval-5-array-sort"><a href="#57-Insert-Interval-5-array-sort" class="headerlink" title="57    Insert Interval    5    array    sort"></a>57    Insert Interval    5    array    sort</h3><h3 id="65-Valid-Number-5-string-Math"><a href="#65-Valid-Number-5-string-Math" class="headerlink" title="65    Valid Number    5    string    Math"></a>65    Valid Number    5    string    Math</h3><h3 id="70-Climbing-Stairs-5-DP"><a href="#70-Climbing-Stairs-5-DP" class="headerlink" title="70    Climbing Stairs    5         DP"></a>70    Climbing Stairs    5         DP</h3><h3 id="73-Set-Matrix-Zeroes-5-array"><a href="#73-Set-Matrix-Zeroes-5-array" class="headerlink" title="73    Set Matrix Zeroes    5    array"></a>73    Set Matrix Zeroes    5    array</h3><h3 id="88-Merge-Sorted-Array-5-array-Two-Pointers、merge"><a href="#88-Merge-Sorted-Array-5-array-Two-Pointers、merge" class="headerlink" title="88    Merge Sorted Array    5    array    Two Pointers、merge"></a>88    Merge Sorted Array    5    array    Two Pointers、merge</h3><h3 id="98-Validate-Binary-Search-Tree-5-tree-DFS"><a href="#98-Validate-Binary-Search-Tree-5-tree-DFS" class="headerlink" title="98    Validate Binary Search Tree    5    tree    DFS"></a>98    Validate Binary Search Tree    5    tree    DFS</h3><h3 id="125-Valid-Palindrome-5-string-Two-Pointers"><a href="#125-Valid-Palindrome-5-string-Two-Pointers" class="headerlink" title="125    Valid Palindrome    5    string    Two Pointers"></a>125    Valid Palindrome    5    string    Two Pointers</h3><h3 id="127-Word-Ladder-5-graph-BFS、path"><a href="#127-Word-Ladder-5-graph-BFS、path" class="headerlink" title="127    Word Ladder    5    graph    BFS、path"></a>127    Word Ladder    5    graph    BFS、path</h3><h3 id="2-Add-Two-Numbers-4-linked-list-Two-Pointers、Math"><a href="#2-Add-Two-Numbers-4-linked-list-Two-Pointers、Math" class="headerlink" title="2    Add Two Numbers    4    linked list    Two Pointers、Math"></a>2    Add Two Numbers    4    linked list    Two Pointers、Math</h3><h3 id="12-Integer-to-Roman-4-Math"><a href="#12-Integer-to-Roman-4-Math" class="headerlink" title="12    Integer to Roman    4         Math"></a>12    Integer to Roman    4         Math</h3><h3 id="13-Roman-to-Integer-4-Math"><a href="#13-Roman-to-Integer-4-Math" class="headerlink" title="13    Roman to Integer    4         Math"></a>13    Roman to Integer    4         Math</h3><h3 id="22-Generate-Parentheses-4-string-DFS"><a href="#22-Generate-Parentheses-4-string-DFS" class="headerlink" title="22    Generate Parentheses    4    string    DFS"></a>22    Generate Parentheses    4    string    DFS</h3><h3 id="23-Merge-k-Sorted-Lists-4-linked-list、heap-sort、Two-Pointersmerge"><a href="#23-Merge-k-Sorted-Lists-4-linked-list、heap-sort、Two-Pointersmerge" class="headerlink" title="23    Merge k Sorted Lists    4    linked list、heap    sort、Two Pointersmerge"></a>23    Merge k Sorted Lists    4    linked list、heap    sort、Two Pointersmerge</h3><p>24    Swap Nodes in Pairs    4    linked list<br>27    Remove Element    4    array    Two Pointers<br>46    Permutations    4    array    permutation<br>49    Anagrams    4    string、hashtable<br>67    Add Binary    4    string    Two Pointers、Math<br>69    Sqrt(x)    4         Binary Search<br>77    Combinations    4         combination<br>78    Subsets    4    array    Recursion、combination<br>79    Word Search    4    array    DFS<br>91    Decode Ways    4    string    Recursion、DP<br>102    Binary Tree Level Order Traversal    4    tree    BFS<br>129    Sum Root to Leaf Numbers    4    tree    DFS<br>131    Palindrome Partitioning    4    string    DFS<br>4    Median of Two Sorted Arrays    3    array    Binary Search<br>7    Reverse Integer    3         Math<br>10    Regular Expression Matching    3    string    Recursion、DP<br>17    Letter Combinations of a Phone Number    3    string    DFS<br>19    Remove Nth Node From End of List    3    linked list    Two Pointers<br>26    Remove Duplicates from Sorted Array    3    array    Two Pointers<br>29    Divide Two Integers    3         Binary Search<br>33    Search in Rotated Sorted Array    3    array    Binary Search<br>34    Search for a Range    3    array    Binary Search<br>39    Combination Sum    3    array    combination<br>43    Multiply Strings    3    string    Two Pointers、Math<br>44    Wildcard Matching    3    string    Recursion、DP、greedy<br>51    N-Queens    3    array    DFS<br>52    N-Queens II    3    array    DFS<br>53    Maximum Subarray    3    array    DP<br>62    Unique Paths    3    array    DP<br>63    Unique Paths II    3    array    DP<br>64    Minimum Path Sum    3    array    DP<br>72    Edit Distance    3    string    DP<br>74    Search a 2D Matrix    3    array    Binary Search<br>81    Search in Rotated Sorted Array II    3    array    Binary Search<br>82    Remove Duplicates from Sorted List II    3    linked list    Recursion、Two Pointers<br>83    Remove Duplicates from Sorted List    3    linked list<br>86    Partition List    3    linked list    Two Pointers<br>93    Restore IP Addresses    3    string    DFS<br>94    Binary Tree Inorder Traversal    3    tree、hashtable    Recursion、morris、Stack<br>103    Binary Tree Zigzag Level Order Traversal    3    queue、tree    BFS、Stack<br>105    Construct Binary Tree from Preorder and Inorder Tr    3    array、tree    DFS<br>106    Construct Binary Tree from Inorder and Postorder T    3    array、tree    DFS<br>108    Convert Sorted Array to Binary Search Tree    3    tree    DFS<br>109    Convert Sorted List to Binary Search Tree    3    linked list    Recursion、Two Pointers<br>112    Path Sum    3    tree    DFS<br>114    Flatten Binary Tree to Linked List    3    tree    Recursion、Stack<br>116    Populating Next Right Pointers in Each Node    3    tree    DFS<br>128    Longest Consecutive Sequence    3    array<br>130    Surrounded Regions    3    array    BFS、DFS<br>132    Palindrome Partitioning II    3    string    DP<br>3    Longest Substring Without Repeating Characters    2    string、hashtable    Two Pointers<br>5    Longest Palindromic Substring    2    string<br>9    Palindrome Number    2         Math<br>11    Container With Most Water    2    array    Two Pointers<br>18    4Sum    2    array<br>25    Reverse Nodes in k-Group    2    linked list    Recursion、Two Pointers<br>31    Next Permutation    2    array    permutation<br>35    Search Insert Position    2    array<br>36    Valid Sudoku    2    array<br>37    Sudoku Solver    2    array    DFS<br>38    Count and Say    2    string    Two Pointers<br>40    Combination Sum II    2    array    combination<br>41    First Missing Positive    2    array    sort<br>42    Trapping Rain Water    2    array    Two Pointers、Stack<br>45    Jump Game II    2    array<br>47    Permutations II    2    array    permutation<br>48    Rotate Image    2    array<br>54    Spiral Matrix    2    array<br>55    Jump Game    2    array<br>59    Spiral Matrix II    2    array<br>61    Rotate List    2    linked list    Two Pointers<br>66    Plus One    2    array    Math<br>68    Text Justification    2    string<br>75    Sort Colors    2    array    sort、Two Pointers<br>76    Minimum Window Substring    2    string    Two Pointers<br>80    Remove Duplicates from Sorted Array II    2    array    Two Pointers<br>84    Largest Rectangle in Histogram    2    array    Stack<br>87    Scramble String    2    string    Recursion、DP<br>89    Gray Code    2         combination<br>90    Subsets II    2    array    Recursion、combination<br>92    Reverse Linked List II    2    linked list    Two Pointers<br>97    Interleaving String    2    string    Recursion、DP<br>99    Recover Binary Search Tree    2    tree    DFS<br>101    Symmetric Tree    2    tree    DFS<br>110    Balanced Binary Tree    2    tree    DFS<br>113    Path Sum II    2    tree    DFS<br>115    Distinct Subsequences    2    string    DP<br>117    Populating Next Right Pointers in Each Node II    2    tree    DFS<br>124    Binary Tree Maximum Path Sum    2    tree    DFS<br>6    ZigZag Conversion    1    string<br>14    Longest Common Prefix    1    string<br>16    3Sum Closest    1    array    Two Pointers<br>30    Substring with Concatenation of All Words    1    string    Two Pointers<br>32    Longest Valid Parentheses    1    string    DP<br>58    Length of Last Word    1    string<br>60    Permutation Sequence    1         permutation、Math<br>71    Simplify Path    1    string    Stack<br>85    Maximal Rectangle    1    array    DP、Stack<br>95    Unique Binary Search Trees II    1    tree    DP、DFS<br>96    Unique Binary Search Trees    1    tree    DP<br>100    Same Tree    1    tree    DFS<br>104    Maximum Depth of Binary Tree    1    tree    DFS<br>107    Binary Tree Level Order Traversal II    1    tree    BFS<br>111    Minimum Depth of Binary Tree    1    tree    DFS<br>118    Pascal’s Triangle    1    array<br>119    Pascal’s Triangle II    1    array<br>120    Triangle    1    array    DP<br>121    Best Time to Buy and Sell Stock    1    array    DP<br>122    Best Time to Buy and Sell Stock II    1    array    greedy<br>123    Best Time to Buy and Sell Stock III    1    array    DP<br>126    Word Ladder II    1</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer算法Code_Java_C++(0820更新)</title>
      <link href="/2018/08/16/%E5%89%91%E6%8C%87Offer%E7%AE%97%E6%B3%95Code_Java_C++/"/>
      <url>/2018/08/16/%E5%89%91%E6%8C%87Offer%E7%AE%97%E6%B3%95Code_Java_C++/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>剑指Offer算法Code_Java_C++</p><a id="more"></a><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><blockquote><p>思路：从左下角元素往上查找，右边元素是比这个元素大，上边是的元素比这个元素小。<br>Java代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean Find(int target, int [][] array) &#123;</span><br><span class="line">        //填写</span><br><span class="line">        int row = array.length;</span><br><span class="line">        int col = array[0].length;</span><br><span class="line">        int i=row-1,j=0;</span><br><span class="line">        while(i&gt;=0&amp;&amp;j&lt;=col-1)&#123;</span><br><span class="line">            if(target&lt;array[i][j])&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;else if(target&gt;array[i][j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;else</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>C++代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</span><br><span class="line">        // array是二维数组，这里没做判空操作</span><br><span class="line">        int rows = array.size();</span><br><span class="line">        int cols = array[0].size();</span><br><span class="line">        int i=rows-1,j=0;//左下角元素坐标</span><br><span class="line">        while(i&gt;=0 &amp;&amp; j&lt;cols)&#123;//使其不超出数组范围</span><br><span class="line">            if(target&lt;array[i][j])</span><br><span class="line">                i--;//查找的元素较少，往上找</span><br><span class="line">            else if(target&gt;array[i][j])</span><br><span class="line">                j++;//查找元素较大，往右找</span><br><span class="line">            else</span><br><span class="line">                return true;//找到</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<br>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">    String str1 = str.toString();</span><br><span class="line">        String str2 = str1.replace(&quot; &quot;,&quot;%20&quot;);</span><br><span class="line">        return str2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">        int spacenum = 0;//spacenum为计算空格数</span><br><span class="line">        for(int i=0;i&lt;str.length();i++)&#123;</span><br><span class="line">            if(str.charAt(i)==&apos; &apos;)</span><br><span class="line">                spacenum++;</span><br><span class="line">        &#125;</span><br><span class="line">        int indexold = str.length()-1; //indexold为为替换前的str下标</span><br><span class="line">        int newlength = str.length() + spacenum*2;//计算空格转换成%20之后的str长度</span><br><span class="line">        int indexnew = newlength-1;//indexold为为把空格替换为%20后的str下标</span><br><span class="line">        str.setLength(newlength);//使str的长度扩大到转换成%20之后的长度,防止下标越界</span><br><span class="line">        for(;indexold&gt;=0 &amp;&amp; indexold&lt;newlength;--indexold)&#123; </span><br><span class="line">                if(str.charAt(indexold) == &apos; &apos;)&#123;  //</span><br><span class="line">                str.setCharAt(indexnew--, &apos;0&apos;);</span><br><span class="line">                str.setCharAt(indexnew--, &apos;2&apos;);</span><br><span class="line">                str.setCharAt(indexnew--, &apos;%&apos;);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    str.setCharAt(indexnew--, str.charAt(indexold));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>c++代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">void replaceSpace(char *str,int length) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">        for (int i=0;i&lt;length;i++)&#123;</span><br><span class="line">            if (str[i]==&apos; &apos;)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i=length-1;i&gt;=0;i--)&#123;</span><br><span class="line">                if (str[i]==&apos; &apos;)&#123;</span><br><span class="line">                    count--;</span><br><span class="line">                  str[i+2*count]=&apos;%&apos;;</span><br><span class="line">                str[i+2*count+1]=&apos;2&apos;;</span><br><span class="line">                str[i+2*count+2]=&apos;0&apos;;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                      str[i+2*count]=str[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p><p>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java 递归超简洁版本</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;Integer&gt;();</span><br><span class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">        if(listNode!=null)&#123;</span><br><span class="line">            this.printListFromTailToHead(listNode.next);</span><br><span class="line">            arrayList.add(listNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        return arrayList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C++代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        vector&lt;int&gt; value;</span><br><span class="line">        if (head != NULL)&#123;</span><br><span class="line">            value.insert(value.begin(),head-&gt;val);</span><br><span class="line">            while (head-&gt;next !=NULL)&#123;</span><br><span class="line">                value.insert(value.begin(),head-&gt;next-&gt;val);</span><br><span class="line">                head = head -&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><blockquote><p>递归思想，每次将左右两颗子树当成新的子树进行处理，中序的左右子树索引很好找，前序的开始结束索引通过计算中序中左右子树的大小来计算，然后递归求解，直到startPre&gt;endPre||startIn&gt;endIn说明子树整理完到。方法每次返回左子树活右子树的根节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">    /  \</span><br><span class="line">  2     3</span><br><span class="line"> /\    /</span><br><span class="line">4  5  6</span><br><span class="line"> \    /</span><br><span class="line">  7  8</span><br></pre></td></tr></table></figure></p></blockquote><p>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123;</span><br><span class="line">        TreeNode root=reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    //前序遍历&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125;</span><br><span class="line">    private TreeNode reConstructBinaryTree(int [] pre,int startPre,int endPre,int [] in,int startIn,int endIn) &#123;</span><br><span class="line">         </span><br><span class="line">        if(startPre&gt;endPre||startIn&gt;endIn)</span><br><span class="line">            return null;</span><br><span class="line">        TreeNode root=new TreeNode(pre[startPre]);</span><br><span class="line">         </span><br><span class="line">        for(int i=startIn;i&lt;=endIn;i++)</span><br><span class="line">            if(in[i]==pre[startPre])&#123;</span><br><span class="line">                root.left=reConstructBinaryTree(pre,startPre+1,startPre+i-startIn,in,startIn,i-1);</span><br><span class="line">                root.right=reConstructBinaryTree(pre,i-startIn+startPre+1,endPre,in,i+1,endIn);</span><br><span class="line">                      break;</span><br><span class="line">            &#125;</span><br><span class="line">                 </span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。<br>n&lt;=39</p><p>Java代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int Fibonacci(int n) &#123;</span><br><span class="line">        if(n&lt;1)&#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] ints = new int[n+1];</span><br><span class="line">        ints[0] = 0;</span><br><span class="line">        ints[1] = 1;</span><br><span class="line">        </span><br><span class="line">        for(int i = 2; i &lt;= n; i++ )&#123;</span><br><span class="line">            ints[i] = ints[i-1] + ints[i-2];</span><br><span class="line">        &#125;</span><br><span class="line">        return ints[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C++代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">    int pre = 0;</span><br><span class="line">        int last=1;</span><br><span class="line">            int result =0;</span><br><span class="line">        if(n&lt;=1)&#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=2; i&lt;=n; i++)&#123;</span><br><span class="line">            result=pre+last;</span><br><span class="line">            pre=last;</span><br><span class="line">            last=result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><blockquote><p>思路：，f(1) = 1, f(2) = 2, f(3) = 3, f(4) = 5，  可以总结出f(n) = f(n-1) + f(n-2)的规律<br>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int JumpFloor(int target) &#123;</span><br><span class="line">        int[] ints= new int[target+1];</span><br><span class="line">        if(target &lt;=0 )&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;else if(target==1 || target==2)&#123;</span><br><span class="line">            return target;</span><br><span class="line">        &#125;</span><br><span class="line">        ints[0] = 1;ints[1] = 2;</span><br><span class="line">        for(int i =2; i&lt;=target; i++)&#123;</span><br><span class="line">            ints[i] = ints[i-1] + ints[i-2];</span><br><span class="line">           &#125;</span><br><span class="line">        return ints[target-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>C++代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloor(int number) &#123;</span><br><span class="line">        int first = 1;int second = 2; int result = 0;</span><br><span class="line">        if (number&lt;=0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;else if (number==1||number==2)&#123;</span><br><span class="line">            return number;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i=3; i&lt;=number; i++)&#123;</span><br><span class="line">            result = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><blockquote><p>思路：1自身左移动，然后跟原数字做<strong>与</strong>比较，如果对应相同输出为1，否则为0。<br>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int NumberOf1(int n) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">        int flag = 1;</span><br><span class="line">        while(flag != 0)&#123;</span><br><span class="line">            if((n &amp; flag) !=0 )&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            flag = flag &lt;&lt; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>C++代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">     int  NumberOf1(int n) &#123;</span><br><span class="line">         int count = 0;</span><br><span class="line">         int flag = 1;</span><br><span class="line">         while(flag != 0)&#123;</span><br><span class="line">             if((n &amp; flag)!=0)&#123;</span><br><span class="line">                 count++;    </span><br><span class="line">             &#125;</span><br><span class="line">             flag = flag &lt;&lt; 1;</span><br><span class="line">         &#125;</span><br><span class="line">        return count   ;  </span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="8"><a href="#8" class="headerlink" title="8"></a>8</h3><p>输入一个链表，反转链表后，输出新链表的表头:</p><blockquote><p>整体反转链表，但是要把断开的节点保存起来，才能继续反转链表<br>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode ReverseList(ListNode head) &#123;</span><br><span class="line">       </span><br><span class="line">        if(head==null)</span><br><span class="line">            return null;</span><br><span class="line">        //head为当前节点，如果当前节点为空的话，那就什么也不做，直接返回null；</span><br><span class="line">        ListNode pre = null;</span><br><span class="line">        ListNode next = null;</span><br><span class="line">        //当前节点是head，pre为当前节点的前一节点，next为当前节点的下一节点</span><br><span class="line">        //需要pre和next的目的是让当前节点从pre-&gt;head-&gt;next1-&gt;next2变成pre&lt;-head next1-&gt;next2</span><br><span class="line">        //即pre让节点可以反转所指方向，但反转之后如果不用next节点保存next1节点的话，此单链表就此断开了</span><br><span class="line">        //所以需要用到pre和next两个节点</span><br><span class="line">        //1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line">        //1&lt;-2&lt;-3 4-&gt;5</span><br><span class="line">        while(head!=null)&#123;</span><br><span class="line">            //做循环，如果当前节点不为空的话，始终执行此循环，此循环的目的就是让当前节点从指向next到指向pre</span><br><span class="line">            //如此就可以做到反转链表的效果</span><br><span class="line">            //先用next保存head的下一个节点的信息，保证单链表不会因为失去head节点的原next节点而就此断裂</span><br><span class="line">            next = head.next;</span><br><span class="line">            //保存完next，就可以让head从指向next变成指向pre了，代码如下</span><br><span class="line">            head.next = pre;</span><br><span class="line">            //head指向pre后，就继续依次反转下一个节点</span><br><span class="line">            //让pre，head，next依次向后移动一个节点，继续下一次的指针反转</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果head为null的时候，pre就为最后一个节点了，但是链表已经反转完毕，pre就是反转后链表的第一个节点</span><br><span class="line">        //直接输出pre就是我们想要得到的反转后的链表</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>C++代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* ReverseList(ListNode* pHead) &#123;</span><br><span class="line"></span><br><span class="line">        if(pHead == NULL)&#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* pNode = pHead;//当前指针</span><br><span class="line">        ListNode* pPre = NULL;//链表的前一个指针</span><br><span class="line">        ListNode* pNewHead = NULL;</span><br><span class="line">        </span><br><span class="line">        while(pNode != NULL)&#123;</span><br><span class="line">           ListNode* pNext = pNode-&gt;next;</span><br><span class="line">            if(pNext == NULL)&#123; //尾节点</span><br><span class="line">                pNewHead = pNode;</span><br><span class="line">            &#125;</span><br><span class="line">            pNode-&gt;next = pPre;</span><br><span class="line">            pPre = pNode;</span><br><span class="line">            pNode = pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        return pNewHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="9"><a href="#9" class="headerlink" title="9"></a>9</h3><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><blockquote><p>两两数值对比,merge可以合并两个事物，链表也行，考点在取两个链表比较小的头节点</p></blockquote><p>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode Merge(ListNode list1,ListNode list2) &#123;</span><br><span class="line">        if(list1 == null)&#123;</span><br><span class="line">            return list2;</span><br><span class="line">        &#125;</span><br><span class="line">        if(list2 == null)&#123;</span><br><span class="line">            return list1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(list1.val &lt;= list2.val)&#123;</span><br><span class="line">            list1.next = Merge(list1.next,list2);</span><br><span class="line">                return list1;</span><br><span class="line">              &#125;else&#123;</span><br><span class="line">            list2.next = Merge(list1,list2.next);</span><br><span class="line">            return list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C++代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)</span><br><span class="line">    &#123;</span><br><span class="line">     if(pHead1 == NULL)&#123;</span><br><span class="line">            return pHead2;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pHead2 == NULL)&#123;</span><br><span class="line">            return pHead1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* NewHead = NULL;</span><br><span class="line">        if(pHead1-&gt;val &lt;= pHead2-&gt;val)&#123;</span><br><span class="line">            NewHead = pHead1;</span><br><span class="line">            NewHead-&gt;next = Merge(pHead1-&gt;next,pHead2);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            NewHead = pHead2;</span><br><span class="line">            NewHead-&gt;next = Merge(pHead1,pHead2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        return NewHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="10"><a href="#10" class="headerlink" title="10"></a>10</h3><p> 从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><p>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">思路是用arraylist模拟一个队列来存储相应的TreeNode</span><br><span class="line">*/</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arr = new ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;TreeNode&gt; TN = new ArrayList&lt;&gt;();</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return arr;</span><br><span class="line">        &#125;</span><br><span class="line">        TN.add(root);</span><br><span class="line">        while(TN.size()!=0)&#123;</span><br><span class="line">            TreeNode temp = TN.remove(0);</span><br><span class="line">            if(temp.left!= null)&#123;</span><br><span class="line">                TN.add(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if(temp.right!= null)&#123;</span><br><span class="line">                TN.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            arr.add(temp.val);</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C++代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">### 11</span><br><span class="line">1个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。</span><br><span class="line">&gt;思路：两个相同数字异或=0，一个数和0异或还是它本身。&lt;br&gt;</span><br><span class="line">我们首先还是先异或，剩下的数字肯定是A、B异或的结果，这个结果的二进制中的1，表现的是A和B的不同的位。我们就取第一个1所在的位数，假设是第3位，接着把原数组分成两组，分组标准是第3位是否为1。如此，相同的数肯定在一个组，因为相同数字所有位都相同，而不同的数，肯定不在一组。然后把这两个组按照最开始的思路，依次异或，剩余的两个结果就是这两个只出现一次的数字。</span><br><span class="line"></span><br><span class="line">Java代码：</span><br></pre></td></tr></table></figure></p><p>public class Solution {<br>    public void FindNumsAppearOnce(int[] array, int[] num1, int[] num2)    {<br>        int length = array.length;<br>        if(length == 2){<br>            num1[0] = array[0];<br>            num2[0] = array[1];<br>            return;<br>        }<br>        int bitResult = 0;<br>        for(int i = 0; i &lt; length; ++i){<br>            bitResult ^= array[i];<br>        }<br>        int index = findFirst1(bitResult);<br>        for(int i = 0; i &lt; length; ++i){<br>            if(isBit1(array[i], index)){<br>                num1[0] ^= array[i];<br>            }else{<br>                num2[0] ^= array[i];<br>            }<br>        }<br>    }</p><pre><code>private int findFirst1(int bitResult){    int index = 0;    while(((bitResult &amp; 1) == 0) &amp;&amp; index &lt; 32){        bitResult &gt;&gt;= 1;        index++;    }    return index;}private boolean isBit1(int target, int index){    return ((target &gt;&gt; index) &amp; 1) == 1;}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">C++代码：</span><br></pre></td></tr></table></figure></p><p>链接：<a href="https://www.nowcoder.com/questionTerminal/e02fdb54d7524710a7d664d082bb7811" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/e02fdb54d7524710a7d664d082bb7811</a><br>来源：牛客网</p><p>class Solution {<br>public:<br>    void FindNumsAppearOnce(vector<int> data,int<em> num1,int </em>num2) {<br>  if(data.size()<2) return ; int size="data.size();" temp="data[0];" for(int i="1;i<size;i++)" if(temp="=0)" index="0;" while((temp&1)="=0){">&gt;1;<br>   ++index;<br>  }<br>  <em>num1=</em>num2=0;<br>  for(int i=0;i<size;i++) { if(isbit(data[i],index)) *num1^="data[i];" else *num2^="data[i];" } bool isbit(int num,int index) num="num">&gt;index;<br>  return (num&amp;1);<br> }<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> ^=:逐位异或 </span><br><span class="line"></span><br><span class="line">### 12</span><br><span class="line">最小的k个数</span><br><span class="line">输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</span><br><span class="line"></span><br><span class="line">Java代码：(快排/最小堆)</span><br></pre></td></tr></table></figure></size;i++)></2)></int></p><p>链接：<a href="https://www.nowcoder.com/questionTerminal/6a296eb82cf844ca8539b57c23e6e9bf" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/6a296eb82cf844ca8539b57c23e6e9bf</a><br>来源：牛客网</p><p>/<em></em>基于堆排序算法，构建最大堆。时间复杂度为O(nlogk)<br><em>如果用快速排序，时间复杂度为O(nlogn)；</em>如果用冒泡排序，时间复杂度为O(n<em>k)</em>/<br>import java.util.ArrayList;<br>public class Solution {<br>    public ArrayList<integer> GetLeastNumbers_Solution(int [] input, int k) {<br>        ArrayList<integer> list=new ArrayList<integer>();<br>        //检查输入的特殊情况<br>        if(input==null || input.length&lt;=0 || input.length<k){ return list; } 构建最大堆 for(int len="k/2-1;">=0; len—){<br>            adjustMaxHeapSort(input,len,k-1);<br>        }<br>        //从第k个元素开始分别与最大堆的最大值做比较，如果比最大值小，则替换并调整堆。<br>        //最终堆里的就是最小的K个数。<br>        int tmp;<br>        for(int i=k; i&lt;input.length; i++){<br>            if(input[i]&lt;input[0]){<br>                tmp=input[0];<br>                input[0]=input[i];<br>                input[i]=tmp;<br>                adjustMaxHeapSort(input,0,k-1);<br>            }<br>        }<br>        for(int j=0; j&lt;k; j++){<br>            list.add(input[j]);<br>        }<br>        return list;<br>    }</k){></integer></integer></integer></p><pre><code>public void adjustMaxHeapSort(int[] input, int pos, int length){    int temp;    int child;    for(temp=input[pos]; 2*pos+1&lt;=length; pos=child){        child=2*pos+1;        if(child&lt;length &amp;&amp; input[child]&lt;input[child+1]){            child++;        }        if(input[child]&gt;temp){            input[pos]=input[child];        }else{            break;        }    }    input[pos]=temp;}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### 二叉树的景象</span><br></pre></td></tr></table></figure></p><p>题目描述<br>操作给定的二叉树，将其变换为源二叉树的镜像。<br>输入描述:<br>二叉树的镜像定义：源二叉树<br>            8<br>           /  \<br>          6   10<br>         / \  / \<br>        5  7 9 11<br>        镜像二叉树<br>            8<br>           /  \<br>          10   6<br>         / \  / \<br>        11 9 7  5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++代码：</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 13</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Java代码：</span><br></pre></td></tr></table></figure><p>public class Solution {<br>    public void Mirror(TreeNode root) {<br>        if(root == null){<br>            return;<br>        }</p><pre><code>    TreeNode temp;    if(root!=null){        temp = root.left;        root.left = root.right;        root.right = temp;    }    if(root.left!=null){        Mirror(root.left);        }    if(root.right!=null){        Mirror(root.right);    }}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">C++代码：</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Java代码：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++代码：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Java代码：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">C++代码：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Java代码：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">C++代码：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Java代码：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++代码：</span><br></pre></td></tr></table></figure><p>```</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-梯度消失爆炸</title>
      <link href="/2018/08/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E7%88%86%E7%82%B8/"/>
      <url>/2018/08/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E7%88%86%E7%82%B8/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>机器学习-梯度消失爆炸</p><a id="more"></a><h3 id="梯度消失"><a href="#梯度消失" class="headerlink" title="梯度消失"></a>梯度消失</h3><p>本层的神经元的激活等于上一层神经元对应的权值进行加权和运算，<br>最后通过一个非线性函数（激活函数）如ReLu，sigmoid等函数，<br>最后得到的结果就是本层神经元的输出，<br>逐层逐神经元通过该操作向前传播，最终得到输出层的结果。 </p><p>梯度消失的影响：<br>1) 浅层基本不学习，后面几层一直在学习，失去深度的意义。<br>2) 无法收敛。</p><p>梯度消失的现象呢？因为通常神经网络所用的激活函数是sigmoid函数<br>这个函数有个特点:<br></p><blockquote><p>就是能将负无穷到正无穷的数映射到0和1之间，并且对这个函数求导的结果是f′(x)=f(x)(1−f(x))。<br>因此两个0到1之间的数相乘，得到的结果就会变得很小了。<br>神经网络的反向传播是逐层对函数偏导相乘，因此当神经网络层数非常深的时候<br>最后一层产生的偏差就因为乘了很多的小于1的数而越来越小，最终就会变为0，从而导致层数比较浅的权重没有更新</p><p>一是在深层网络中，网络层数过多二是采用了不合适的损失函数，比如sigmoid</p></blockquote><h3 id="梯度爆炸"><a href="#梯度爆炸" class="headerlink" title="梯度爆炸"></a>梯度爆炸</h3><p>就是由于初始化权值过大，前面层会比后面层变化的更快，就会导致权值越来越大，梯度爆炸的现象就发生了。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>用ReLU激活函数来替代sigmoid函数。 </p><blockquote><p>区别：（1）sigmoid函数值在[0,1],ReLU函数值在[0,+无穷]，所以sigmoid函数可以描述概率，ReLU适合用来描述实数；（2）sigmoid函数的梯度随着x的增大或减小和消失，而ReLU不会。</p></blockquote><p>早期多层神经网络如果用sigmoid函数或者hyperbolic tangent作为激活函数，如果不进行pre-training的话，会因为gradient vanishing problem而无法收敛。 </p><p>而预训练的用处：规则化，防止过拟合；压缩数据，去除冗余；强化特征，减小误差；加快收敛速度。而采用ReLu则不需要进行pre-training。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法_动态规划</title>
      <link href="/2018/08/16/%E7%AE%97%E6%B3%95_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2018/08/16/%E7%AE%97%E6%B3%95_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>算法_动态规划</p><a id="more"></a><p>求解最优化问题</p><h3 id="背包问题1"><a href="#背包问题1" class="headerlink" title="背包问题1"></a>背包问题1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Problem Description:</span><br><span class="line">   有 n 个重量和价值分别为Wi,Vi的物品，现从这些物品中挑选出总量不超过 W 的物品，求所有方案中价值总和的最大值。</span><br><span class="line">Input:</span><br><span class="line">输入包含多组测试用例，每一例的开头为两位整数 n、W（1&lt;=n&lt;=10000,1&lt;=W&lt;=1000）</span><br><span class="line">，接下来有 n 行，每一行有两位整数 Wi、Vi（1&lt;=Wi&lt;=10000,1&lt;=Vi&lt;=100）。</span><br><span class="line">Output:</span><br><span class="line">输出为一行，即所有方案中价值总和的最大值。</span><br><span class="line">Sample Input:</span><br><span class="line">3 4</span><br><span class="line">1 2</span><br><span class="line">2 5</span><br><span class="line">3 7</span><br><span class="line">Sample Output:</span><br><span class="line">9</span><br><span class="line"></span><br><span class="line">Java代码：</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">static Scanner scan = new Scanner(System.in);</span><br><span class="line">static int[] v = new int[10001];</span><br><span class="line">static int[] w = new int[10001];</span><br><span class="line">static int[] dp = new int[10001];</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">while(scan.hasNext())&#123;</span><br><span class="line">int n = scan.nextInt();</span><br><span class="line">int W = scan.nextInt();</span><br><span class="line">v = new int[n+1];</span><br><span class="line">w = new int[n+1];</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">w[i] = scan.nextInt();</span><br><span class="line">v[i] = scan.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1; i &lt;= n; i++)</span><br><span class="line">                    for(int j = W; j &gt;= 0; j--)&#123;      //每次更新容量为j，所能放下最大价值的物品</span><br><span class="line">                        if(j &gt;= w[i])&#123;        //j一定要大于w[i],要不最大容量为j的背包放不下第i件物品</span><br><span class="line">                            dp[j] = Math.max(dp[j], dp[j-w[i]] + v[i]);    //dp[j] 表示最大容量为j的背包所装下物品最大的价值，         这里求的是第i件物品放和不放的价值的最大的价值</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">System.out.println(dp[W]);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="背包问题2"><a href="#背包问题2" class="headerlink" title="背包问题2"></a>背包问题2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author miracle</span><br><span class="line"> *切割钢条问题：</span><br><span class="line"> *长度：12345678910</span><br><span class="line"> *价格：1589101717202430</span><br><span class="line"> *问长度为n的钢条的最多卖多少钱</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line"> </span><br><span class="line">int[] prices = &#123;0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30&#125;;</span><br><span class="line">int[] dp = new int[prices.length];</span><br><span class="line">public int solve(int[] prices, int n)&#123;</span><br><span class="line">if(n == 0) return 0;</span><br><span class="line">int max = Integer.MIN_VALUE;</span><br><span class="line">for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">max = Math.max(max, prices[i] + solve(prices, n - i));</span><br><span class="line">&#125;</span><br><span class="line">return max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int solveWithMemoUpToBottom(int[] prices, int n)&#123;</span><br><span class="line">if(n == 0 || dp[n] &gt; 0) return dp[n];</span><br><span class="line">int max = Integer.MIN_VALUE;</span><br><span class="line">for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">max = Math.max(max, prices[i] + solve(prices, n - i));</span><br><span class="line">&#125;</span><br><span class="line">dp[n] = max;</span><br><span class="line">return max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int solveBottomToUp(int[] prices, int n)&#123;</span><br><span class="line">int[] dp = new int[prices.length];</span><br><span class="line">for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">int max = Integer.MIN_VALUE;</span><br><span class="line">for(int j = 1; j &lt;= i; j++)&#123;</span><br><span class="line">max = Math.max(max, prices[j] + prices[i - j]);</span><br><span class="line">&#125;</span><br><span class="line">dp[i] = max;</span><br><span class="line">&#125;</span><br><span class="line">return dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String args[])&#123;</span><br><span class="line">Solution s = new Solution();</span><br><span class="line">//System.out.println(s.solve(s.prices, 1));</span><br><span class="line">//System.out.println(s.solve(s.prices, 2));</span><br><span class="line">//System.out.println(s.solve(s.prices, 3));</span><br><span class="line">//System.out.println(s.solve(s.prices, 4));</span><br><span class="line">//System.out.println(s.solve(s.prices, 5));</span><br><span class="line">System.out.println(s.solveBottomToUp(s.prices, 1));</span><br><span class="line">System.out.println(s.solveBottomToUp(s.prices, 2));</span><br><span class="line">System.out.println(s.solveBottomToUp(s.prices, 3));</span><br><span class="line">System.out.println(s.solveBottomToUp(s.prices, 4));</span><br><span class="line">System.out.println(s.solveBottomToUp(s.prices, 5));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归 运算量比较大 O(2^N)</p><h3 id="递归，dp，分治的区别"><a href="#递归，dp，分治的区别" class="headerlink" title="递归，dp，分治的区别"></a>递归，dp，分治的区别</h3><p>递归只是一种编程的思想，只要自己调用自己，就算是递归。</p><p>分治，有三步，先分，再各自处理，最后整合。这里也涉及了子问题，这里的子问题是不重叠的，每一个只被处理一次，因此不需要memo。</p><p>dp，可以使用递归，而且dp的子问题是重复的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经-概率论算法</title>
      <link href="/2018/08/16/%E9%9D%A2%E7%BB%8F-%E6%A6%82%E7%8E%87%E8%AE%BA%E7%AE%97%E6%B3%95/"/>
      <url>/2018/08/16/%E9%9D%A2%E7%BB%8F-%E6%A6%82%E7%8E%87%E8%AE%BA%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p><img width="800" height="800" src="http://ph04wnm2q.bkt.clouddn.com/bg/magazine-unlock-01-2.3.971-_c98a796eb65a419dbcfa164bbb6563e7.jpg"></p><a id="more"></a><h3 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h3><p>100人坐飞机，第一个乘客在座位中随便选一个坐下，第100人正确坐到自己坐位的概率是？</p><h3 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h3><p>给定三个随机变量X,Y,Z，已知X和Y的相关系数(correlation)为0.8，X和Z的相关系数为0.8。问Y和Z的相关系数最大／最小为多少？</p><p>答：</p><p>|1|0.8|0.8|<br>|0.8|1|a|<br>|0.8|a|1|</p><h3 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h3><p>几何分布:<br>一个国家重男轻女，只要生了女孩就继续生，直到生出男孩为止，问这个国家的男女比例？</p><p>答：</p><p>1比1</p><p>因为只要生了女孩就继续生，直到生出男孩为止，影响的是家庭男女孩的比例，国家总人数比例还是1比1</p><h3 id="Q4"><a href="#Q4" class="headerlink" title="Q4"></a>Q4</h3><p>有50个红球，50个蓝球，如何放入两个盒子中使得拿到红球的概率最大</p><p>如果要拿两个红的，一个盒子放一个红球，一个盒子放49红，50蓝，取两个红球概率49/99</p><h3 id="Q5"><a href="#Q5" class="headerlink" title="Q5"></a>Q5</h3><p>一根木棍随机折成三段，能组成三角形的概率多大？</p><p>答：任意两边之和大于第三边<br>p=[(1/8)a^2]/[(1/2)a^2]=1/4=0.25  </p><h3 id="Q6"><a href="#Q6" class="headerlink" title="Q6"></a>Q6</h3><h3 id="Q7"><a href="#Q7" class="headerlink" title="Q7"></a>Q7</h3><h3 id="Q8"><a href="#Q8" class="headerlink" title="Q8"></a>Q8</h3><h3 id="Q9"><a href="#Q9" class="headerlink" title="Q9"></a>Q9</h3><h3 id="Q10"><a href="#Q10" class="headerlink" title="Q10"></a>Q10</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 笔面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经—机器学习</title>
      <link href="/2018/08/15/%E9%9D%A2%E7%BB%8F%E2%80%94%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/08/15/%E9%9D%A2%E7%BB%8F%E2%80%94%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>面经—机器学习</p><a id="more"></a><h2 id="CVTE面经"><a href="#CVTE面经" class="headerlink" title="CVTE面经"></a>CVTE面经</h2><p>作者：一一后<br>链接：<a href="https://www.nowcoder.com/discuss/88069" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/88069</a><br>来源：牛客网</p><p>1.解释方差</p><p>2.PCA的实现过程；推导PCA</p><p>3.传统的图像特征有哪些</p><p>4.Sift特征为什么能实现尺度不变性（讲sift原理到一半，我发现完全解释不了为啥尺度不变，就停了，尴尬）<br>[参考](<a href="https://blog.csdn.net/u014485485/article/details/78681086?locationNum=1&amp;fps=1）" target="_blank" rel="noopener">https://blog.csdn.net/u014485485/article/details/78681086?locationNum=1&amp;fps=1）</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">尺度不变性：</span><br><span class="line">不管原图尺度是多少，在包含了所有尺度的尺度空间下都能找到那些稳定的极值点，这样就做到了尺度不变！</span><br><span class="line">高斯函数是唯一可行的尺度空间核</span><br></pre></td></tr></table></figure></p><p>5.Hough直线检测的原理</p><p>6.梯度下降和牛顿法的区别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">牛顿法的优缺点</span><br><span class="line">优点：二阶收敛，收敛速度快；</span><br><span class="line">缺点：牛顿法是一种迭代算法，每一步都需要求解目标函数的Hessian矩阵的逆矩阵，计算比较复杂。</span><br><span class="line"></span><br><span class="line">梯度下降法的优化思想是用当前位置负梯度方向作为搜索方向，因为该方向为当前位置的最快下降方向，所以也被称为是”最速下降法“。最速下降法越接近目标值，步长越小，前进越慢</span><br><span class="line">梯度下降法的缺点：</span><br><span class="line">靠近极小值时收敛速度减慢，；</span><br><span class="line">直线搜索时可能会产生一些问题；</span><br><span class="line">可能会“之字形”地下降。</span><br><span class="line"></span><br><span class="line">牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快</span><br></pre></td></tr></table></figure></p><p>7.SVM和Lr的共同点和不同点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LR和SVM都是分类算法</span><br><span class="line">LR和SVM都是线性分类算法</span><br><span class="line">LR和SVM都是监督学习算法</span><br><span class="line">LR和SVM都是判别模型</span><br><span class="line">LR和SVM在学术界和工业界都广为人知并且应用广泛</span><br><span class="line"></span><br><span class="line">不同：</span><br><span class="line">损失函数</span><br><span class="line">LR：逻辑回归方法基于概率理论</span><br><span class="line">逻辑回归考虑全局（远离的点对边界线的确定也起作用）</span><br><span class="line">对数据不做处理</span><br><span class="line">LR必须另外在损失函数上添加正则项</span><br><span class="line"></span><br><span class="line">SVM：几何间隔最大化原理</span><br><span class="line">支持向量机只考虑局部的边界线附近的点，线性SVM不直接依赖于数据分布</span><br><span class="line">线性SVM依赖数据表达的距离测度，所以需要对数据先做归一化</span><br><span class="line">SVM的损失函数就自带正则</span><br></pre></td></tr></table></figure></p><p>8.rf和Adaboost的异同(优秀的基于决策树的组合算法)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1，相同：二者都是bootsrap自助法选取样本。 </span><br><span class="line">2，相同：二者都是要训练很多棵决策树。 </span><br><span class="line">3，不同：adaboost后面树的训练，其在变量抽样选取的时候，对于上一棵树分错的样本，抽中的概率会加大。 </span><br><span class="line">4，不同：随机森林在训练每一棵树的时候，随机挑选了部分变量作为拆分变量，而不是所有的变量都去作为拆分变量。 </span><br><span class="line">5，不同：在预测新数据时，adaboost中所有的树加权投票来决定因变量的预测值，每棵树的权重和错误率有关；随机森林按照所有树中少数服从多数树的分类值来决定因变量的预测值。</span><br></pre></td></tr></table></figure></p><p>9.给出一堆大小不一的矩形框，快速求矩形框的灰度值之和（当时没理解，这不是肯定要遍历么…后来结束后我想这些矩形框可能是重叠的，估计是要问我关于Bing中快速求梯度的算法）</p><p>10.有什么要问他的</p><h3 id="作业帮提前批机器学习算法岗"><a href="#作业帮提前批机器学习算法岗" class="headerlink" title="作业帮提前批机器学习算法岗"></a>作业帮提前批机器学习算法岗</h3><p>作者：编程一头牛<br>链接：<a href="https://www.nowcoder.com/discuss/90245" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/90245</a><br>来源：牛客网</p><p>对数据预处理怎么填充的缺失值，哪些判定为异常值，对连续属性进行离散化有什么好处，Logistic回归能处理浮点数吗？多项式组合特征对哪个模型中效果提升最大。这个没答上来，问了面试官，面试官说是Logistic回归里面提升最大，而且组合起来的两个特征也是想出来的，没什么理论支撑。还问了模型的评价指标AUC是如何计算的，ROC曲线的横纵坐标代表了什么含义。XGBoost模型里面参数有哪些？如何发现过拟合。XGBoost模型中对数据进行采样的好处？</p><p>如何最快的找出两个集合中的交集，提出用哈希表的方法，问了这种方法的复杂度，然后又问如果这两个集合都特别大，不能再内存中构建哈希表该如何做？可能是想让我回答多线程相关的内容，但是我不会。如何设计哈希表？期间也问过有编过多线程多进程的代码吗</p><h3 id="深信服【机器学习】一面"><a href="#深信服【机器学习】一面" class="headerlink" title="深信服【机器学习】一面"></a>深信服【机器学习】一面</h3><p>作者：Rnanprince<br>链接：<a href="https://www.nowcoder.com/discuss/87283" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/87283</a><br>来源：牛客网</p><p>【机器学习】一面：<br>1.项目介绍，研究的最成功的地方，我以写的文章为例，涉及到的知识点就问<br>2.笔试的数组求和100怎么做的？<br>没抽到这个题，但是做过；接着我说做了查找重复字符串最大长度，深搜，过了就没想别的方法<br>一个数组，求最长的连续子序列的起始下标，当时没理解明白，其实有歧义，简单说了一下<br>3.自己的哪些方面的优点没有涉及到，介绍一下<br>提到了SVM和决策树，介绍一下什么情况下使用？<br>svm:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">这个模型的优势是什么？</span><br><span class="line"></span><br><span class="line">分类效果好；</span><br><span class="line">可以有效地处理高维空间的数据；</span><br><span class="line">可以有效地处理变量个数大于样本个数的数据；</span><br><span class="line">只是使用了一部分子集来进行训练模型，所以SVM模型不需要太大的内存；</span><br><span class="line">可以提高泛化能力；</span><br><span class="line">无局部极小值问题；</span><br><span class="line">他什么情况下表现最好？</span><br><span class="line"></span><br><span class="line">数据的维度较高；</span><br><span class="line">需要模型具有非常强的泛化能力；</span><br><span class="line">样本数据量较小时；</span><br><span class="line">解决非线性问题；</span><br><span class="line">这个模型的缺点是什么？</span><br><span class="line"></span><br><span class="line">无法处理大规模的数据集，因为该算法需要较长的训练时间；</span><br><span class="line">无法有效地处理包含噪声太多的数据集；</span><br><span class="line">SVM模型没有直接给出概率的估计值，而是利用交叉验证的方式估计，这种方式耗时较长；</span><br><span class="line">对缺失数据非常敏感；</span><br><span class="line">对于非线性问题，有时很难找到一个合适的核函数。</span><br><span class="line">什么条件下它表现很差？</span><br><span class="line"></span><br><span class="line">数据集的数据量过大；</span><br><span class="line">数据集中的含有噪声；</span><br><span class="line">数据集中的缺失较多的数据；</span><br><span class="line">对算法的训练效率要求较高；</span><br><span class="line">根据我们当前数据集的特点，为什么这个模型适合这个问题。 </span><br><span class="line">该项目所提供的样本数据相对较少；</span><br><span class="line">该问题是属于非线性问题；</span><br><span class="line">数据集经过“独热编码”后，维度较高</span><br></pre></td></tr></table></figure></p><p>决策树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">这个模型的优势是什么？</span><br><span class="line"></span><br><span class="line">决策树易于实现和理解；</span><br><span class="line">对于决策树，数据的准备工作一般比较简单；</span><br><span class="line">能够同时处理多种数据类型</span><br><span class="line">给定一个决策树模型，可以根据产生的决策树推出相应的逻辑表达式；</span><br><span class="line">通过静态测试来对模型的表现进行评价；</span><br><span class="line">在相对较短的时间内可以对大量的数据做出非常好的结果；</span><br><span class="line">决策树可以很好地扩展到大型数据中，同时决策树的大小独立于数据库的大小；</span><br><span class="line">计算复杂度相对较低，结果的输出易于理解，对部分的数据缺失不敏感。</span><br><span class="line">他什么情况下表现最好？</span><br><span class="line"></span><br><span class="line">实例是由“属性-值”对表示的；</span><br><span class="line">目标函数具有离散的输出值；</span><br><span class="line">训练数据集包含部分错误(决策树对错误有适应性)；</span><br><span class="line">训练数据缺少少量属性的实例。</span><br><span class="line">这个模型的缺点是什么？</span><br><span class="line"></span><br><span class="line">易于出现过拟合问题；</span><br><span class="line">忽略了数据集中属性之间的相关性；</span><br><span class="line">对于类比不一致的样本，决策树的信息增益倾向于那些数据值较多的特征</span><br><span class="line">什么条件下它表现很差？</span><br><span class="line"></span><br><span class="line">决策树匹配的数据过多时；</span><br><span class="line">分类的类别过于复杂；</span><br><span class="line">数据的属性之间具有非常强的关联。</span><br><span class="line">根据我们当前数据集的特点，为什么这个模型适合这个问题。</span><br><span class="line"></span><br><span class="line">不需要准备太多的训练数据，不需要对数据过多的处理如删除空白值等；</span><br><span class="line">易于编码；</span><br><span class="line">该问题是非线性问题，决策树能够很好地解决非线性问题；</span><br><span class="line">算法的执行效率高，对机器的要求较小。</span><br></pre></td></tr></table></figure></p><h3 id="360浏览器事业部-推荐算法工程师"><a href="#360浏览器事业部-推荐算法工程师" class="headerlink" title="360浏览器事业部 推荐算法工程师"></a>360浏览器事业部 推荐算法工程师</h3><p>作者：泡了个泡<br>链接：<a href="https://www.nowcoder.com/discuss/77924" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/77924</a><br>来源：牛客网</p><p>二面</p><p>1.项目</p><p>2.SVM原始问题为什么要转化为对偶问题，为什么对偶问题就好求解，原始问题不能求解么</p><p>3.K-means 中我想聚成100类 结果发现只能聚成98类，为什么</p><p>4.进程中的内存分段是怎样的</p><p>5.每个线程有哪些东西是自己独享的</p><p>6.一枚不均匀的硬币，我抛了100次，有70次朝上，那么第101次朝上的概率是多少</p><p>这个概率怎么样，公示是如何推导出来的</p><p>7.给你个字符串，字符串是个数字，怎么转换为int型，不用库函数的话</p><p>8.4个海盗，100个金币，每个人轮流提方案，如果你的方案有半数以上通过，那么久可以，否则就会被杀掉，如果你是第一个人，那么你怎么提方案比较好</p><p>9.你的优点是什么</p><h3 id="腾讯沈阳现场一面"><a href="#腾讯沈阳现场一面" class="headerlink" title="腾讯沈阳现场一面"></a>腾讯沈阳现场一面</h3><p>1.项目</p><p>2.特征选择方法都有用过哪些</p><p>3.随机森林怎么进行特征选择</p><p>4.用过哪些机器学习算法</p><p>5.加密方法知道哪些</p><p>6.MD5可逆么</p><p>7.word2vec用过么</p><p>8.极大似然估计是什么意思</p><p>9.上过哪些课</p><p>10.排序算法哪些时间复杂度比较低</p><p>11.计算机网络了解多少</p><h3 id="阿里-新零售-天猫-算法工程师-机器学习"><a href="#阿里-新零售-天猫-算法工程师-机器学习" class="headerlink" title="阿里 新零售 天猫 算法工程师-机器学习"></a>阿里 新零售 天猫 算法工程师-机器学习</h3><p>一面<br>先是一个简单的自我介绍；<br>1.然后介绍了项目的框架和主要创新点；</p><p>2.说一下随机森林和Adaboost，以及区别</p><p>3.说一下GBDT和Adaboost，以及区别</p><p>4.说一下LDA的原理</p><p>5.对于PCA，会有第一主成分、第二主成分，怎么为什么第一主成分是第一，原因是什么？</p><p>6.PCA的主成分是怎么得到的</p><p>3.面向对象的三要素</p><p>4.对深度学习了解多少</p><p>5.你觉得深度学习的方法和传统机器学习比，有什么大的优势</p><h3 id="腾讯提前批"><a href="#腾讯提前批" class="headerlink" title="腾讯提前批"></a>腾讯提前批</h3><p>作者：IamBright<br>链接：<a href="https://www.nowcoder.com/discuss/75166" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/75166</a><br>来源：牛客网</p><p>女朋友在广州又不想换工作的情况下，微信的机器学习算法工程师是最适合我实习的岗位了，因此最先让腾讯的同学内推了一波，在基本没有准备的情况下，接到了提前批电话一面二面，毫无意外的挂了。</p><p>电话一面<br>聊论文，但多数听我在说，没插话什么问题。最后问我第二篇论文里RNN实现的时候有什么trick。<br>问了问凸优化了解吗？传统机器学习了解吗？我答机器学习基本知识都学过，凸优化只了解和机器学习优化算法相关的。也没有继续问细节了。<br>编程题：打印所有子集，我用了迭代，但是写的比较蠢，好在不用调试运行<br>电话二面<br>聊论文，最后问了我跟什么算法做了对比，问我研究的实际意义，产业界现在的水平<br>编程题：打印螺旋矩阵，要我给一个可运行的结果。很简单的题，我一个符号错误调了很久都没发现，这里应该就印象很差了。<br>linux里查看端口被占用的命令，linux不熟，没答上。<br>AUC是什么？我说了是ROC曲线下面积，但是想不起来ROC是啥。我都是做序列数据，没做过二分类问题。<br>LR和SVM的区别。我说了损失函数不同，然后说了SVM通过核技巧可以更好的应对非线性，但是前面好差，这里也没好好组织语言了。<br>提前批挂的没什么话说，就是没准备，好久没做过算法题的情况下，突然出题做就很不顺手。而且机器学习的基础知识都有点忘了，像AUC这种没用过的，基本一问就懵逼。</p><p>之后跟工作的同学聊了一下，来牛客刷了刷面经，制定了简单的复习内容和刷题计划。花了一周时间，复习了一下西瓜书前11章和deep learning book前11章，刷了leetcode上三四十道medium的题吧（链表、字符串、迭代、dfs、堆、树、动态规划等每天刷一类题练练手），并且给自己做完2篇论文都准备了面试介绍版，又让同学推了阿里和网易，并进入腾讯笔试流程。</p><h3 id="算法、数据挖掘岗面经"><a href="#算法、数据挖掘岗面经" class="headerlink" title="算法、数据挖掘岗面经"></a>算法、数据挖掘岗面经</h3><p>作者：胖胖胖子<br>链接：<a href="https://www.nowcoder.com/discuss/81814" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/81814</a><br>来源：牛客网</p><p>1.华为<br>回国之后参加的第一次面试就是华为的留学生专场招聘，岗位是大数据开放（华为好像填什么岗位都没差吧~），一共只有两面<br>一面：介绍我的项目经历，我介绍完面试官尴尬的笑了笑说他不是做大数据方向的，也就没问我什么，聊了聊天愉快的过了<br>二面：可能会针对笔试提问，因为面试官问我为什么没参加笔试，然后就问了问职业规划，说大数据方向都在深圳工作，然后就一直问怎么看待华为的加班文化，怎么看待压力之类的<br>大概10天之后就直接把offer发到了邮箱里<br>2.第四范式（二面挂）<br>刚面完华为就参加了第四范式的面试，以为面试就是聊聊天，后来发现真是naive，第四范式的岗位是nlp研究员<br>一面：就写了两个代码，一个是逆时针打印矩阵，一个是leetcode原题count and say，虽然当时还没刷过题但写的都是easy难度，就过了<br>二面：二面面试官是牛津大学的phd，问我是不是distinction我说不是，就感受到了一股失望~讲了讲项目，问的很细，但是都在自己的项目范围内，问完之后又是写代码，一个字符串如何删除不匹配的括号然后输出括号匹配的字符串，比如（abc（），输出（abc）和abc（），哼哼唧唧没写出来就跪了<br>3.招银网络<br>招银网络面试岗位是算法工程师，一共两轮技术面，一轮hr面<br>一面：讲项目，问了决策树ID3，C4.5，CART的区别，讲了SVM的原理，然后写了找两个数的最小公倍数的代码<br>二面：讲项目，然后面试官说他是做C++开发的，问我会不会C++，我说学过但很久没用了，就聊了聊天愉快的过了<br>hr面：略（就谈人生谈理想接不接受调岗）</p><ol><li>平安科技<br>招银网络面试岗位是算法工程师，一共两轮技术面，一轮hr面<br>一面：讲项目，问了问当时爬虫有没有用什么框架，然后问为什么文本分类我选择了朴素贝叶斯，然后让我说了一下对word2vec的理解<br>二面：最痛的一次面试，三个面试官，一个问数据结构和数据库：问我知道的数据结构和使用场景，然后口述怎么把单链表变双向链表，讲了一下红黑树，以及红黑树的应用，数据的范式，索引失效的情况，如何优化数据库性能等等。第二个面试官问操作系统和计算机网络：TCP三次握手，四次挥手，第二次挥手和第三次挥手的时间间隔如何界定，TCP拥塞控制，OSI五层模型，每层有什么协议，TCP和UDP的区别，UDP的应用（这个问题我没太理解），ARP协议，python多线程，python3对python2是否有改进。第三个面试官问设计模式和算法：python闭包，bagging/boosting的区别，XGboost特点，tf-idf缺点，单例模式（设计模式我完全不会），怎样设计一个分布式的爬虫。<br>hr面：大概聊了聊对薪资的期望，和工作的部门<br>5.链家<br>链家是参加了牛客的留学生专场，感觉链家的面试官人真的好~岗位是机器学习/数据挖掘工程师，不过链家面试有点坎坷面完前两面才发现我面的大数据开发，其实我想去的是数据挖掘，然后就开始了第三轮面试<br>一面：先写了一个很简单的判断两个二叉树是不是一样的树，然后就说给一台机器内存有限制，然后10台服务器，每个服务器上有一个1G文件，假设文件里单词，如何给这些单词按频率排序，又问了求数据流的中位数，最后是智力题，给你两个一模一样的杯子，假设一共有10层楼，怎样找到杯子摔下来能不碎的最高楼层。<br>二面：面试官先问我职业规划，我说数据挖掘，他就比较懵说他们是大数据开发部门，问我考不考虑，我说还是倾向于做数据挖掘，就开始了面试，问了数据库索引的优缺点，索引失效的情况，然后复合索引如何引用会失效，然后问了ACID，剩下的记不清了，说我基础不错去给我联系数据挖掘的面试官<br>三面：手写LR损失函数，LR/SVM区别，手画word2vec网络结构，bagging，boosting，stacking的区别和联系，如果RF和GBDT达到同样的准确度哪个分裂的树更少为什么，随机梯度下降和梯度下降哪一个更快，XGBoost特点，XGBoost的L1和L2正则化怎么体现，特征工程相关的卡方统计和互信息计算公式，然后写了一个如何用最少的硬币找钱。<br>HR面：介绍了一下链家的福利和部门的发展。<br>6.快手<br>快手4.18的笔试，5.5面试大概是备胎池捞起来了，三轮技术面，一轮hr面<br>一面：介绍项目，边讲项目边提问，然后写了个代码，判断有向图中是否有环<br>二面：介绍项目，边讲项目边提问，问了文本分类问什么朴素贝叶斯比SVM，决策树效果更好，然后分类性能度量，precision，recall，F1 score和ROC AUC对比，写了一个leetcode的flatten nested list iterator<br>三面：只写代码，第一个AABB的字符串输出AB，第二个找数组的最长递增子序列，然后介绍了一下他们做的东西<br>HR面：谈了谈offer</li></ol><h3 id="顺丰提前批人工智能岗技术面面经"><a href="#顺丰提前批人工智能岗技术面面经" class="headerlink" title="顺丰提前批人工智能岗技术面面经"></a>顺丰提前批人工智能岗技术面面经</h3><p>作者：撒泼打滚求Offer<br>链接：<a href="https://www.nowcoder.com/discuss/92370" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/92370</a><br>来源：牛客网</p><ol><li>目标检测了解吗，（了解一点）Faster RCNN跟RCNN有什么区别</li><li>SPP， YOLO了解吗（不了解）（后悔没去看看= =）</li><li>梯度消失梯度爆炸怎么解决</li><li>RNN容易梯度消失，怎么解决（LSTM）</li><li>LSTM跟RNN有啥区别</li><li>传统的机器学习算法了解吗（不怎么了解，说了个KMeans）</li><li>KMeans讲讲，KMeans有什么缺点，K怎么确定（不会）</li><li>卷积层和池化层有什么区别（不是很懂这个问题的点）</li><li><p>防止过拟合有哪些方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、正则化，即在对模型的目标函数（objective function）或代价函数（cost function）加上正则项</span><br><span class="line">  随着模型训练的进行，模型的复杂度会增加，此时模型在训练数据集上的训练误差会逐渐减小，但是在模型的复杂度达到一定程度时，模型在验证集上的误差反而随着模型的复杂度增加而增大。此时便发生了过拟合，即模型的复杂度升高。</span><br><span class="line"></span><br><span class="line">1、early stopping、</span><br><span class="line">    迭代次数（epochs）截断的方法（常用 梯度下降法）；</span><br><span class="line">    训练数据一次遍历结束，计算指标，指标不增加，停止训练；</span><br><span class="line">    记录一个最好的指标，如果之后的10次，20次训练达到的指标都没有之前最好的高，则停止训练。</span><br><span class="line">2、数据增强（Data augmentation）、</span><br><span class="line">    从数据源采集更多数据 </span><br><span class="line">    复制原有数据并加上随机噪声 </span><br><span class="line">    重采样 </span><br><span class="line">    根据当前数据集估计数据分布参数，使用该分布产生更多数据等</span><br><span class="line">3、正则化（Regularization）、</span><br><span class="line">    正则化方法是指在进行目标函数或代价函数优化时，在目标函数或代价函数后面加上一个正则项，一般有L1正则与L2正则等。</span><br><span class="line">4、Dropout</span><br></pre></td></tr></table></figure></li><li><p>dropout咋回事讲讲</p></li><li>你有什么要问我的吗</li></ol><h3 id="联影医疗-Offer"><a href="#联影医疗-Offer" class="headerlink" title="联影医疗  Offer"></a>联影医疗  Offer</h3><p>作者：吃饭睡觉编论文<br>链接：<a href="https://www.nowcoder.com/discuss/52357" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/52357</a><br>来源：牛客网</p><p>联影医疗  Offer<br>一面<br>1、GBDT和xgboost的区别<br>2、GBDT和LR的区别<br>3、讲项目（为什么用GBDT LR？）<br>4、随便讲一个熟悉的传统图像处理中的特征提取和描述子（sift和sift描述子）<br>二面<br>1、写代码：实现统计图像灰度直方图的代码<br>2、熟悉的聚类算法、k-means原理、混合高斯模型原理<br>3、PCA原理、数学解释（应该是一个最优的线性子空间）<br>4、surf相比sift特征点的优化之处<br>5、写代码：dijkstra最短路径算法<br>6、SVM原理、过拟合怎么解决<br>7、霍夫变换检测直线和圆的原理<br>HR面<br>个人优缺点、拿到的offer、期望薪资、是不是独生子、对联影医疗的了解</p><h3 id="VIVO算法"><a href="#VIVO算法" class="headerlink" title="VIVO算法"></a>VIVO算法</h3><p>作者：MadCoder<br>链接：<a href="https://www.nowcoder.com/discuss/94110" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/94110</a><br>来源：牛客网</p><p>1.评估指标<br>2.在AUC值大时，Log损失也大。请问可能的原因<br>3.梯度消失，梯度爆炸原因及解决<br>4.概率题：8支球队循环赛，前四名晋级。求晋级可能性<br>5.Spark和hadoop实现K-MEANS，及优劣比较</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 笔面试 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git_update_error1</title>
      <link href="/2018/08/01/git_update_error1/"/>
      <url>/2018/08/01/git_update_error1/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>git 上传报错及解决<br><a id="more"></a></p><h2 id="failed-to-push-some-refs-to"><a href="#failed-to-push-some-refs-to" class="headerlink" title="failed to push some refs to"></a>failed to push some refs to</h2><p>报错内容，不能推送文件到github上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: failed to push some refs to github地址</span><br></pre></td></tr></table></figure></p><p>原因是github项目与本地文件夹一些关键文件的确实，比如.git，readme.md文件等等</p><h2 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h2><p>本地文件夹打开控制命令台 </p><p>1、添加本地文件夹，github项目更新到本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></p><p>2、再上传文件夹到github<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></p><h2 id="fatal-The-remote-end-hung-up-unexpectedly"><a href="#fatal-The-remote-end-hung-up-unexpectedly" class="headerlink" title="fatal: The remote end hung up unexpectedly"></a>fatal: The remote end hung up unexpectedly</h2><p>git推送项目时候出现 “fatal: The remote end hung up unexpectedly ” 原因是推送的文件太大。</p><p>上传网速过慢导致文件传输不完整</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>等一会，重新在push上传一遍 </p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用LaTex添加公式到Hexo博客里</title>
      <link href="/2018/07/23/hexo_LaTex1/"/>
      <url>/2018/07/23/hexo_LaTex1/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>使用LaTex添加公式到Hexo博客里</p><a id="more"></a><font color="blue">代码编辑器，强烈推荐使用微软的 VS code，相比Atom开启迅速，使用方便，扩展丰富</font><h2 id="第一步：-安装Kramed"><a href="#第一步：-安装Kramed" class="headerlink" title="第一步： 安装Kramed"></a>第一步： 安装Kramed</h2><p>hexo 默认的渲染引擎是 marked，但是 marked 不支持 mathjax。，所以需要更换Hexo的markdown渲染引擎为hexo-renderer-kramed引擎，后者支持mathjax公式输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.nos-eastchina1.126.net/hexo-math1.png" alt></p><h2 id="第二步：更改文件配置"><a href="#第二步：更改文件配置" class="headerlink" title="第二步：更改文件配置"></a>第二步：更改文件配置</h2><p>打开<code>/node_modules/hexo-renderer-kramed/lib/renderer.js</code>，更改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Change inline math rule</span><br><span class="line">function formatText(text) &#123;</span><br><span class="line">    // Fit kramed&apos;s rule: $$ + \1 + $$</span><br><span class="line">    return text.replace(/`\$(.*?)\$`/g, &apos;$$$$$1$$$$&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">为，直接返回text</span><br><span class="line"></span><br><span class="line">// Change inline math rule</span><br><span class="line">function formatText(text) &#123;</span><br><span class="line">    return text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.nos-eastchina1.126.net/hexo-math4.png" alt></p><h2 id="第三步-停止使用-hexo-math，并安装mathjax包"><a href="#第三步-停止使用-hexo-math，并安装mathjax包" class="headerlink" title="第三步: 停止使用 hexo-math，并安装mathjax包"></a>第三步: 停止使用 hexo-math，并安装mathjax包</h2><p>卸载hexo-math<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-math --save</span><br></pre></td></tr></table></figure></p><p>安装 hexo-renderer-mathjax 包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-mathjax --save</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.nos-eastchina1.126.net/hexo-math2.png" alt><br><img src="https://img-blog.nos-eastchina1.126.net/hexo-math3.png" alt></p><h2 id="第四步-更新-Mathjax-的-配置文件"><a href="#第四步-更新-Mathjax-的-配置文件" class="headerlink" title="第四步: 更新 Mathjax 的 配置文件"></a>第四步: 更新 Mathjax 的 配置文件</h2><p>打开<code>/node_modules/hexo-renderer-mathjax/mathjax.html</code><br>如图所示更改<code>&lt;script&gt;</code>为：<br>即注释掉<code>&lt;script&gt;</code>代码，并把以下代码复制到对应位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.nos-eastchina1.126.net/hexo-math5.png" alt></p><h2 id="第五步-更改默认转义规则"><a href="#第五步-更改默认转义规则" class="headerlink" title="第五步: 更改默认转义规则"></a>第五步: 更改默认转义规则</h2><p>因为LaTeX与markdown语法有语义冲突，所以 hexo 默认的转义规则会将一些字符进行转义，所以我们需要对默认的规则进行修改.<br> 打开<code>/node_modules\kramed\lib\rules\inline.js</code><br> 1、<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span><br></pre></td></tr></table></figure></p><p>更改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">escape: /^\\([`*\[\]()# +\-.!_&gt;])/,</span><br></pre></td></tr></table></figure></p><p>2、<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure></p><p>更改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.nos-eastchina1.126.net/hexo-math6.png" alt></p><h2 id="第六步-开启mathjax"><a href="#第六步-开启mathjax" class="headerlink" title="第六步: 开启mathjax"></a>第六步: 开启mathjax</h2><p>打开<code>/themes/yilia</code>主题目录下的<code>config.yml</code>文件<br>因为我用的<code>yilia</code>主题，所以路径是<code>/themes/yilia</code></p><p>我们需要在<code>config.yml</code>文件 中开启 Mathjax， 找到 mathjax 字段添加如下代码：(不同的主题配置方法略微有区别)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mathjax:</span><br><span class="line">    enable: true</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mathjax: true</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.nos-eastchina1.126.net/hexo-math7.png" alt></p><p><font color="red" size="2">注意的是：，无论是配置文件还是博客文件，配置项跟配置参数均有有一个空格，否则会配置失败</font><br><br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mathjax: true（mathjax:空格true）</span><br><span class="line">而不是</span><br><span class="line">mathjax:true（mathjax:true）</span><br></pre></td></tr></table></figure></p><p>写博客文件时，要开启 <code>Mathjax</code>选项，， 添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mathjax: true</span><br></pre></td></tr></table></figure><p>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 特征提取——局部特征</span><br><span class="line">date: 2018-07-16 09:39:40</span><br><span class="line">tags: [GitHub, Mysql]</span><br><span class="line">mathjax: true</span><br></pre></td></tr></table></figure></p><p>如下图所示</p><p><img src="https://img-blog.nos-eastchina1.126.net/hexo-math7.5.png" alt></p><p>通过以上步骤，我们就可以在 hexo 中使用 Mathjax 来书写数学公式。</p><p>效果展示：</p><p><img src="https://img-blog.nos-eastchina1.126.net/hexo-math8.png" alt></p><p><img src="https://img-blog.nos-eastchina1.126.net/hexo-math9.png" alt></p><p><a href="https://blog.csdn.net/crazy_scott/article/details/79293576" target="_blank" rel="noopener">参考文章1</a><br><a href="https://www.jianshu.com/p/a0aa94ef8ab2" target="_blank" rel="noopener">参考文章2</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_最优化_损失函数</title>
      <link href="/2018/07/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%9C%80%E4%BC%98%E5%8C%96_%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
      <url>/2018/07/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%9C%80%E4%BC%98%E5%8C%96_%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>机器学习<em>最优化</em>损失函数</p><a id="more"></a><p>通常机器学习每一个算法中都会有一个目标函数，算法的求解过程是通过对这个目标函数优化的过程。</p><p>在分类或者回归问题中，通常使用<strong>损失函数（代价函数）</strong>作为其目标函数。损失函数用来评价模型的预测值和真实值不一样的程度，损失函数越好，通常模型的性能越好。不同的算法使用的损失函数不一样。 </p><blockquote><p>损失函数分为经验风险损失函数和结构风险损失函数</p></blockquote><div class="table-container"><table><thead><tr><th>损失函数</th><th>概念</th></tr></thead><tbody><tr><td>经验风险损失函数</td><td>预测结果和实际结果的差别</td></tr><tr><td>结构风险损失函数</td><td>经验风险损失函数+正则项</td></tr></tbody></table></div><script type="math/tex; mode=display">θ^∗=argmin(1/N)\sum_i=1^n\L(y_i,f(x_i;θ_i))\+λ\phi(\theta)</script><h3 id="0-1损失函数和绝对值损失函数"><a href="#0-1损失函数和绝对值损失函数" class="headerlink" title="0-1损失函数和绝对值损失函数"></a>0-1损失函数和绝对值损失函数</h3><p>原理：预测值和目标值不相等为1，否则为0。<br>绝对值损失函数为：<br></p><script type="math/tex; mode=display">L(Y,f(X))=1, if Y≠f(X)</script><script type="math/tex; mode=display">L(Y,f(X))=0, if Y=f(X)</script><p>感知机就是用的这种损失函数<br><br>改进：Y-f(X)&lt;阈值T判断相等<br>绝对值损失函数为： </p><script type="math/tex; mode=display">L(Y,f(X)=|Y−f(X)|</script><h3 id="log对数损失函数"><a href="#log对数损失函数" class="headerlink" title="log对数损失函数"></a>log对数损失函数</h3><p>原理：假设样本服从伯努利分布（0-1）分布，然后求得满足该分布的似然函数，接着用对数求极值。<br><br>log损失函数的标准形式： <br></p><script type="math/tex; mode=display">L(Y,P(Y|X))=−logP(Y|X)</script><h3 id="平方损失函数"><a href="#平方损失函数" class="headerlink" title="平方损失函数"></a>平方损失函数</h3><p>最小二乘法是线性回归的一种方法，它将回归的问题转化为了凸优化的问题。最小二乘法的基本原则是：最优拟合曲线应该使得所有点到回归直线的距离和最小。通常用欧几里得距离进行距离的度量。<br>平方损失的损失函数为： <br></p><script type="math/tex; mode=display">L(Y|f(X))=∑N(Y−f(X))^2</script><h3 id="指数损失函数"><a href="#指数损失函数" class="headerlink" title="指数损失函数"></a>指数损失函数</h3><p>AdaBoost就是一指数损失函数为损失函数的。<br>指数损失函数的标准形式： <br></p><script type="math/tex; mode=display">L(Y|f(X))=exp[−yf(x)]</script><h3 id="Hinge损失函数"><a href="#Hinge损失函数" class="headerlink" title="Hinge损失函数"></a>Hinge损失函数</h3><p>Hinge损失函数和SVM是息息相关的。在线性支持向量机中，最优化问题可以等价于<br> </p><p><script type="math/tex">1/m\sum_i=1^m\l(wx_i+by_i)+||w||^2</script><br><br>其中<script type="math/tex">l(wx_i+by_i)</script> 就是hinge损失函数，后面相当于L2正则项。 </p><p>Hinge函数的标准形式： <br></p><p><script type="math/tex">L(y)=max(0,1−ty)</script><br></p><blockquote><p>y的值在-1和+1之间就可以了,使分类器可以更专注于整体的分类误差</p></blockquote><p><a href="https://blog.csdn.net/weixin_37933986/article/details/68488339" target="_blank" rel="noopener">参考文章</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 最优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_分类_adaboost</title>
      <link href="/2018/07/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_adaboost/"/>
      <url>/2018/07/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_adaboost/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>机器学习_分类_adaboost</p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Boosting, 也称为增强学习或提升法，是一种重要的集成学习技术， 能够将预测精度仅比随机猜度略高的弱学习器增强为预测精度高的强学习器。</p><blockquote><p>AdaBoost是英文”Adaptive Boosting”（自适应增强）的缩写</p></blockquote><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）首先，是初始化训练数据的权值分布D1。假设有N个训练样本数据，则每一个训练样本最开始时，都被赋予相同的权值：w1=1/N。</span><br><span class="line">2）然后，训练弱分类器hi。具体训练过程中是：如果某个训练样本点，被弱分类器hi准确地分类，那么在构造下一个训练集中，它对应的权值要减小；相反，如果某个训练样本点被错误分类，那么它的权值就应该增大。权值更新过的样本集被用于训练下一个分类器，整个训练过程如此迭代地进行下去。</span><br><span class="line">3）最后，将各个训练得到的弱分类器组合成一个强分类器。各个弱分类器的训练过程结束后，加大分类误差率小的弱分类器的权重，使其在最终的分类函数中起着较大的决定作用，而降低分类误差率大的弱分类器的权重，使其在最终的分类函数中起着较小的决定作用。</span><br></pre></td></tr></table></figure><blockquote><p>误差率低的弱分类器在最终分类器中占的权重较大，否则较小。</p></blockquote><p>alpha值是基于每个弱分类器的错误率进行计算,计算出alpha值之后，可以对权重向量进行更新，以使得那些正确分类的样本的权重降低而错分样本的权重升高，直到错误率为0或者弱分类器的数目达到用户的指定值为止</p><h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/adaboost_liucheng1.png" alt></p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/adaboost_liucheng2.png" alt></p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/adaboost_liucheng3.png" alt></p><p><a href="https://blog.csdn.net/guyuealian/article/details/70995333" target="_blank" rel="noopener">参考文章地址</a></p><p><a href="https://blog.csdn.net/v_july_v/article/details/40718799" target="_blank" rel="noopener">参考文章</a></p><p>数据分类模型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;opencv2/core/core.hpp&quot;  </span><br><span class="line">#include &quot;opencv2/highgui/highgui.hpp&quot;  </span><br><span class="line">#include &quot;opencv2/imgproc/imgproc.hpp&quot;  </span><br><span class="line">#include &quot;opencv2/ml/ml.hpp&quot;  </span><br><span class="line">  </span><br><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">using namespace cv;  </span><br><span class="line">using namespace std;  </span><br><span class="line">  </span><br><span class="line">int main( int argc, char** argv )  </span><br><span class="line">&#123;     </span><br><span class="line">    //训练样本  </span><br><span class="line">    float trainingData[42][2]=&#123; &#123;40, 55&#125;,&#123;35, 35&#125;,&#123;55, 15&#125;,&#123;45, 25&#125;,&#123;10, 10&#125;,&#123;15, 15&#125;,&#123;40, 10&#125;,  </span><br><span class="line">                            &#123;30, 15&#125;,&#123;30, 50&#125;,&#123;100, 20&#125;,&#123;45, 65&#125;,&#123;20, 35&#125;,&#123;80, 20&#125;,&#123;90, 5&#125;,  </span><br><span class="line">                            &#123;95, 35&#125;,&#123;80, 65&#125;,&#123;15, 55&#125;,&#123;25, 65&#125;,&#123;85, 35&#125;,&#123;85, 55&#125;,&#123;95, 70&#125;,  </span><br><span class="line">                            &#123;105, 50&#125;,&#123;115, 65&#125;,&#123;110, 25&#125;,&#123;120, 45&#125;,&#123;15, 45&#125;,  </span><br><span class="line">                            &#123;55, 30&#125;,&#123;60, 65&#125;,&#123;95, 60&#125;,&#123;25, 40&#125;,&#123;75, 45&#125;,&#123;105, 35&#125;,&#123;65, 10&#125;,  </span><br><span class="line">                            &#123;50, 50&#125;,&#123;40, 35&#125;,&#123;70, 55&#125;,&#123;80, 30&#125;,&#123;95, 45&#125;,&#123;60, 20&#125;,&#123;70, 30&#125;,  </span><br><span class="line">                            &#123;65, 45&#125;,&#123;85, 40&#125;   &#125;;  </span><br><span class="line">    Mat trainingDataMat(42, 2, CV_32FC1, trainingData);   </span><br><span class="line">    //训练样本的响应值  </span><br><span class="line">    float responses[42] = &#123;&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,  </span><br><span class="line">                            &apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,  </span><br><span class="line">                        &apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos; &#125;;  </span><br><span class="line">    Mat responsesMat(42, 1, CV_32FC1, responses);  </span><br><span class="line">  </span><br><span class="line">    float priors[2] = &#123;1, 1&#125;;    //先验概率  </span><br><span class="line">  </span><br><span class="line">    CvBoostParams params( CvBoost::REAL, // boost_type    </span><br><span class="line">                          10, // weak_count    </span><br><span class="line">                          0.95, // weight_trim_rate    </span><br><span class="line">                          15, // max_depth    </span><br><span class="line">                          false, // use_surrogates    </span><br><span class="line">                          priors // priors   </span><br><span class="line">                          );    </span><br><span class="line">  </span><br><span class="line">    CvBoost boost;  </span><br><span class="line">    boost.train (   trainingDataMat,   </span><br><span class="line">                    CV_ROW_SAMPLE,   </span><br><span class="line">                    responsesMat,  </span><br><span class="line">                    Mat(),    </span><br><span class="line">                    Mat(),  </span><br><span class="line">                    Mat(),  </span><br><span class="line">                    Mat(),    </span><br><span class="line">                    params  </span><br><span class="line">                    );    </span><br><span class="line">    //预测样本  </span><br><span class="line">    float myData[2] = &#123;55, 25&#125;;  </span><br><span class="line">    Mat myDataMat(2, 1, CV_32FC1, myData);  </span><br><span class="line">    double r = boost.predict( myDataMat );  </span><br><span class="line">  </span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;&quot;result:  &quot;&lt;&lt;(char)r&lt;&lt;endl;  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>基于的OpenCV的检测Demo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;opencv/highgui.h&gt;</span><br><span class="line">#include &lt;opencv/cv.h&gt;</span><br><span class="line">#include &lt;opencv2/imgproc/imgproc_c.h&gt;</span><br><span class="line">#include &lt;opencv2/objdetect/objdetect.hpp&gt;</span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    CascadeClassifier stFaceCascade;</span><br><span class="line">    IplImage *pstImage = NULL;</span><br><span class="line">    std::vector&lt;Rect&gt; faceRects;</span><br><span class="line"></span><br><span class="line">    if( !stFaceCascade.load(&quot;D:\\ProgramFiles\\develop\\opencv2.4.8\\sources\\data\\lbpcascades\\lbpcascade_frontalface.xml&quot;) )</span><br><span class="line">    &#123; </span><br><span class="line">        printf(&quot;Loading cascade error\n&quot;); </span><br><span class="line">        return -1; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pstImage = cvLoadImage(&quot;D:\\test.jpg&quot;, CV_LOAD_IMAGE_COLOR);</span><br><span class="line"></span><br><span class="line">    stFaceCascade.detectMultiScale(pstImage, </span><br><span class="line">        faceRects,            //检出结果</span><br><span class="line">        1.1,                  //缩放步长</span><br><span class="line">        2,                    //框融合时的最小检出个数</span><br><span class="line">        0|CV_HAAR_SCALE_IMAGE,//标志 |CV_HAAR_FIND_BIGGEST_OBJECT|CV_HAAR_DO_ROUGH_SEARCH|CV_HAAR_DO_CANNY_PRUNING</span><br><span class="line">        Size(30, 30),         //最小人脸尺寸</span><br><span class="line">        Size(300, 300) );     //最大人脸尺寸</span><br><span class="line">    printf(&quot;Face Num[%d]\n&quot;, faceRects.size());</span><br><span class="line"></span><br><span class="line">    for( unsigned int j = 0; j &lt; faceRects.size(); j++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cvRectangle(pstImage, </span><br><span class="line">            cvPoint(faceRects[j].x, faceRects[j].y), </span><br><span class="line">            cvPoint(faceRects[j].x + faceRects[j].width, faceRects[j].y + faceRects[j].height),</span><br><span class="line">            cvScalar(0,255,0),</span><br><span class="line">            2,8,0);</span><br><span class="line">    &#125;</span><br><span class="line">    cvShowImage(&quot;FDWin&quot;, pstImage);</span><br><span class="line">    cvWaitKey(0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cvReleaseImage(&amp;pstImage);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_分类_SVM</title>
      <link href="/2018/07/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_SVM/"/>
      <url>/2018/07/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_SVM/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>机器学习_分类_SVM</p><a id="more"></a><h3 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h3><p>（Support Vector Machine, SVM）的基本模型是在特征空间上找到最佳的<code>分离超平面</code>使得训练集上正负样本间隔最大。</p><p>二分类问题的有监督学习算法，引入了核方法之后SVM也可以用来解决非线性问题<br>一般SVM有下面三种：</p><blockquote><p>1、硬间隔支持向量机（线性可分支持向量机）：当训练数据线性可分时，可通过硬间隔最大化学得一个线性可分支持向量机。<br><br>2、软间隔支持向量机：当训练数据近似线性可分时，可通过软间隔最大化学得一个线性支持向量机。<br><br>3、非线性支持向量机：当训练数据线性不可分时，可通过核方法以及软间隔最大化学得一个非线性支持向量机。</p></blockquote><p><img src="https://pic2.zhimg.com/80/v2-d2b03cf98869849d1d6a4d91a05d6571_hd.jpg" alt="SVM"></p><p>SVM算法认为图1中的分类器A在性能上优于分类器B，其依据是A的分类间隔比B要大</p><blockquote><p>这两条平行虚线正中间的分界线就是在保持当前决策面方向不变的前提下的最优决策面。两条虚线之间的垂直距离就是这个最优决策面对应的<code>分类间隔</code>。<br></p><p>那个具有“最大间隔”的决策面就是SVM要寻找的最优解,而这个真正的最优解对应的两侧虚线所穿过的样本点，就是SVM中的支持样本点，称为<code>支持向量</code>。<br></p><p>对于图1中的数据，A决策面就是SVM寻找的最优解，而相应的三个位于虚线上的样本点在坐标系中对应的向量就叫做<code>支持向量</code>。</p></blockquote><h3 id="基于最大间隔分割数据"><a href="#基于最大间隔分割数据" class="headerlink" title="基于最大间隔分割数据"></a>基于最大间隔分割数据</h3><p>优点，错误率低，计算开销不大，结果容易解释<br>缺点，对参数调节敏感，原始分类器不加修改只能解决二类问题。</p><p><script type="math/tex">w^{t}x+b</script>为分类函数<br><br>输人数据给分类器会输出一个类别标签,单位阶跃函数）的函数对<script type="math/tex">w^{t}x+b</script>作用得到<script type="math/tex">f(w^{t}x+b)</script>,其中当u&lt;0时输出-1, 反之则输出+1。这是由于-1和+1仅仅相差一个符号，方便数学上的处理。</p><p>如果数据点处于正方向（即+1类 ）并且离<strong>分隔超平面</strong>很远的位置时，<script type="math/tex">w^{t}x+b</script>会是一个很大的正数，同时<script type="math/tex">label*(w^{t}x+b)</script>也会是一个很大的正数。而如果数据点处于负方向（-1类 ）并且离<strong>分隔超平面</strong>远的位置时，此时由于类别标签为-1，则<script type="math/tex">label*(w^{t}x+b)</script>仍然是一个很大的正数。</p><p>目标：找到分类器定义中的w和b。找到具有最小间隔的数据点即<strong>支持向量</strong>。找到支持向量，对间隔最大化。</p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/svm_1.png" alt="svm"></p><p>SVM的目标函数：<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/svm_2.png" alt="svm"><br>分离超平面分类函数为0，支持向量的分类函数为+-1,为了优化目标函数，固定一个优化另外一个，该问题是一个带约束条件的优化问题。这里的约束条件就是<script type="math/tex">label*(w^{t}x+b)=1</script>。<br><br>注：<script type="math/tex">label*(w^{t}x+b)</script>被称为点到分隔面的函数间隔，<script type="math/tex">label*(w^{t}x+b)*(1/w)</script>称为点到分隔面的几何间隔。<br><br>求解这个问题需要经过一系列的转换。具体如下：<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/svm_3.png" alt="svm"></p><p>求$ 1/W$的最大值相当于求$0.5w^2$的最小值，一个凸二次规划问题<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/svm_4.png" alt="svm"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注：新目标函数约束条件：</span><br><span class="line">alpha&gt;=0,所有的aplha*lable=0</span><br><span class="line">但是数据未必100%线性可分，引人所谓松弛变量C</span><br><span class="line">新目标函数约束条件为：</span><br><span class="line">C&gt;alpha&gt;=0,所有的aplha*lable=0</span><br></pre></td></tr></table></figure><p>SVM中的主要工作就是求解这些alpha。<br><br>SMO算法(序列最小优<br>化（SequentialMinimalOptimization ))<br>的目标是求出一系列alpha和b，一旦求出了这些alpha，就很容易计算出权重向量w，并得到分隔超平面。</p><blockquote><p>SMO的工作原理是：每次循环中选择两个alpha进行优化处理，一旦找到一对合适的alpha，那么就增大其中一个，同时减小另一个。选择的alpha要满足在间隔边界之外的条件，而且还没有进行过区间化处理或者不再边界上。</p></blockquote><h3 id="核函数："><a href="#核函数：" class="headerlink" title="核函数："></a>核函数：</h3><p>大部分时候数据并不是线性可分的，这个时候满足这样条件的超平面就根本不存在。在上文中，我们已经了解到了SVM处理线性可分的情况，那对于非线性的数据SVM咋处理呢？对于非线性的情况，SVM 的处理方法是选择一个核函数，通过将数据映射到高维空间，来解决在原始空间中线性不可分的问题。</p><p>这是原始数据和原始空间，明显有红蓝两类：<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/svm_he_tu1.jpg" alt><br>通过核函数，将样本数据映射到更高维的空间（在这里，是二维映射到三维）：<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/svm_he_tu2.jpg" alt><br>而后进行分离超平面：<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/svm_he_tu3.jpg" alt><br>再将分割的超平面映射回去：<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/svm_he_tu4.jpg" alt><br>效果图：<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/svm_he_tu5.jpg" alt></p><blockquote><p>核函数的选择变成了支持向量机的最大变数（如果必须得用上核函数，即核化），因此选用什么样的核函数会影响最后的结果。而最常用的核函数有：线性核、多项式核、高斯核、拉普拉斯核、sigmoid核、通过核函数之间的线性组合或直积等运算得出的新核函数。</p></blockquote><p>Opencv代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;opencv2/core/core.hpp&gt;  </span><br><span class="line">#include &lt;opencv2/highgui/highgui.hpp&gt;  </span><br><span class="line">#include &lt;opencv2/ml/ml.hpp&gt;  </span><br><span class="line">  </span><br><span class="line">using namespace cv;  </span><br><span class="line">  </span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    // Data for visual representation  </span><br><span class="line">    int width = 512, height = 512;  </span><br><span class="line">    Mat image = Mat::zeros(height, width, CV_8UC3);  </span><br><span class="line">  </span><br><span class="line">    // Set up training data  </span><br><span class="line">    float labels[5] = &#123;1.0, -1.0, -1.0, -1.0,1.0&#125;;  </span><br><span class="line">    Mat labelsMat(5, 1, CV_32FC1, labels);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    float trainingData[5][2] = &#123; &#123;501, 10&#125;, &#123;255, 10&#125;, &#123;501, 255&#125;, &#123;10, 501&#125;,&#123;501,128&#125; &#125;;  </span><br><span class="line">    Mat trainingDataMat(5, 2, CV_32FC1, trainingData);  </span><br><span class="line">  </span><br><span class="line">    //设置支持向量机的参数  </span><br><span class="line">    CvSVMParams params;  </span><br><span class="line">    params.svm_type    = CvSVM::C_SVC;//SVM类型：使用C支持向量机  </span><br><span class="line">    params.kernel_type = CvSVM::LINEAR;//核函数类型：线性  </span><br><span class="line">    params.term_crit   = cvTermCriteria(CV_TERMCRIT_ITER, 100, 1e-6);//终止准则函数：当迭代次数达到最大值时终止  </span><br><span class="line">  </span><br><span class="line">    //训练SVM  </span><br><span class="line">    //建立一个SVM类的实例  </span><br><span class="line">    CvSVM SVM;  </span><br><span class="line">    //训练模型，参数为：输入数据、响应、XX、XX、参数（前面设置过）  </span><br><span class="line">    SVM.train(trainingDataMat, labelsMat, Mat(), Mat(), params);  </span><br><span class="line">      </span><br><span class="line">    Vec3b green(0,255,0), blue (255,0,0);  </span><br><span class="line">    //显示判决域  </span><br><span class="line">    for (int i = 0; i &lt; image.rows; ++i)  </span><br><span class="line">        for (int j = 0; j &lt; image.cols; ++j)  </span><br><span class="line">        &#123;  </span><br><span class="line">                        Mat sampleMat = (Mat_&lt;float&gt;(1,2) &lt;&lt; i,j);  </span><br><span class="line">            //predict是用来预测的，参数为：样本、返回值类型（如果值为ture而且是一个2类问题则返回判决函数值，否则返回类标签）、  </span><br><span class="line">            float response = SVM.predict(sampleMat);  </span><br><span class="line">  </span><br><span class="line">            if (response == 1)  </span><br><span class="line">                image.at&lt;Vec3b&gt;(j, i)  = green;  </span><br><span class="line">            else if (response == -1)   </span><br><span class="line">                 image.at&lt;Vec3b&gt;(j, i)  = blue;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    //画出训练数据  </span><br><span class="line">    int thickness = -1;  </span><br><span class="line">    int lineType = 8;  </span><br><span class="line">    circle( image, Point(501,  10), 5, Scalar(  0,   0,   0), thickness, lineType);//画圆  </span><br><span class="line">    circle( image, Point(255,  10), 5, Scalar(255, 255, 255), thickness, lineType);  </span><br><span class="line">    circle( image, Point(501, 255), 5, Scalar(255, 255, 255), thickness, lineType);  </span><br><span class="line">    circle( image, Point( 10, 501), 5, Scalar(255, 255, 255), thickness, lineType);  </span><br><span class="line">    circle(image, Point( 501, 128), 5, Scalar(0, 0, 0), thickness, lineType);  </span><br><span class="line">  </span><br><span class="line">    //显示支持向量  </span><br><span class="line">    thickness = 2;  </span><br><span class="line">    lineType  = 8;  </span><br><span class="line">    //获取支持向量的个数  </span><br><span class="line">    int c     = SVM.get_support_vector_count();  </span><br><span class="line">  </span><br><span class="line">    for (int i = 0; i &lt; c; ++i)  </span><br><span class="line">    &#123;  </span><br><span class="line">        //获取第i个支持向量  </span><br><span class="line">        const float* v = SVM.get_support_vector(i);  </span><br><span class="line">        //支持向量用到的样本点，用灰色进行标注  </span><br><span class="line">        circle( image,  Point( (int) v[0], (int) v[1]),   6,  Scalar(128, 128, 128), thickness, lineType);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    imwrite(&quot;result.png&quot;, image);        // save the image   </span><br><span class="line">  </span><br><span class="line">    imshow(&quot;SVM Simple Example&quot;, image); // show it to the user  </span><br><span class="line">    waitKey(0);  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++图像处理程序</title>
      <link href="/2018/07/19/CImageProcess1/"/>
      <url>/2018/07/19/CImageProcess1/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>C++图像处理程序</p><a id="more"></a><p>C++开源项目：</p><blockquote><p>Boost.GIL：通用图像库<br>CImg ：用于图像处理的小型开源C++工具包<br>CxImage ：用于加载，保存，显示和转换的图像处理和转换库，可以处理的图片格式包括 BMP, JPEG, GIF, PNG, TIFF, MNG, ICO, PCX, TGA, WMF, WBMP, JBG, J2K。<br>FreeImage ：开源库，支持现在多媒体应用所需的通用图片格式和其他格式。<br>GDCM：Grassroots DICOM 库<br>ITK：跨平台的开源图像分析系统<br>Magick++：ImageMagick程序的C++接口<br>MagickWnd：ImageMagick程序的C++接口<br>OpenCV ： 开源计算机视觉类库<br>tesseract-ocr：OCR引擎<br>VIGRA ：用于图像分析通用C++计算机视觉库<br>VTK ：用于3D计算机图形学，图像处理和可视化的开源免费软件系统。</p></blockquote><h2 id="MakegGray-彩色转灰度"><a href="#MakegGray-彩色转灰度" class="headerlink" title="MakegGray 彩色转灰度"></a>MakegGray 彩色转灰度</h2><p>函数名称：MakegGray()<br>函数类型：void<br>功能：真彩色转化成256色灰度图像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::MakegGray()    //灰度变化</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();   //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line"> for(int j=0;j&lt;height;j++) // 每行</span><br><span class="line">  for(int i=0;i&lt;DibWidth;i+=3) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">   BYTE* pbyBlue = p_data++;   //得到蓝色值</span><br><span class="line">   BYTE* pbyGreen = p_data++;  //得到绿色值</span><br><span class="line">   BYTE* pbyRed = p_data++;    //得到红色值</span><br><span class="line">   BYTE r = *pbyRed;</span><br><span class="line">   BYTE g = *pbyGreen;</span><br><span class="line">   BYTE b = *pbyBlue;</span><br><span class="line">   //取到原r,g,b中的最大值作为像素三分量值的新值</span><br><span class="line">   int gray=0;</span><br><span class="line">   if(r&gt;g)</span><br><span class="line">    gray=r;</span><br><span class="line">   else </span><br><span class="line">    gray=g;</span><br><span class="line">   if(gray&lt;b)</span><br><span class="line">    gray=b;   </span><br><span class="line">         *pbyBlue = gray;     //将取到的最大值赋给像素的蓝分量</span><br><span class="line">   *pbyGreen = gray;    //将取到的最大值赋给像素的绿分量</span><br><span class="line">   *pbyRed = gray;      //将取到的最大值赋给像素的红分量</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="LightAlter-亮度调整"><a href="#LightAlter-亮度调整" class="headerlink" title="LightAlter 亮度调整"></a>LightAlter 亮度调整</h2><p>函数名称：LightAlter(int m_Light)<br>函数类型：void<br>参数：int m_Light，用户给定的阈值<br>功能：对图像使用阈值法进行亮度调整</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::LightAlter(int m_Light)    //亮度调整</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();    //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line"> for(int j=0;j&lt;height;j++) // 每行</span><br><span class="line"> for(int i=0;i&lt;DibWidth;i++) // 每列</span><br><span class="line"> &#123;   </span><br><span class="line">  int a=0;</span><br><span class="line">  a=int(*p_data*m_Light/100);   //调整当前点的亮度</span><br><span class="line">  *p_data=a;</span><br><span class="line">  //判断范围，取得合理的值</span><br><span class="line">  if(a&lt;0) </span><br><span class="line">   *p_data=0;  </span><br><span class="line">     if(a&gt;255)</span><br><span class="line">   *p_data=255;</span><br><span class="line">        p_data++;   //指向下一指针</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="LightReverse-亮度取反"><a href="#LightReverse-亮度取反" class="headerlink" title="LightReverse 亮度取反"></a>LightReverse 亮度取反</h2><p>函数名称：LightReverse()<br>函数类型：void<br>功能：图像的亮度取反。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::LightReverse()    //亮度取反</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line"> for(int j=0;j&lt;height;j++) // 每行</span><br><span class="line">  for(int i=0;i&lt;DibWidth;i++) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">   int a=*p_data;   //取得当前点的值</span><br><span class="line">   *p_data=255-a;    //取反</span><br><span class="line">   p_data++;  //指向下一指针  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ContrastAlter-调整对比度（阈值法）"><a href="#ContrastAlter-调整对比度（阈值法）" class="headerlink" title="ContrastAlter 调整对比度（阈值法）"></a>ContrastAlter 调整对比度（阈值法）</h2><p>函数名称：ContrastAlter(int m_Increment)<br>函数类型：void<br>参数：int m_Increment，用户给定的阈值<br>功能：对图像使用阈值法调整对比度处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::ContrastAlter(int m_Increment)   ///对比度处理</span><br><span class="line">&#123;</span><br><span class="line"> int nHigh = 255 - m_Increment;</span><br><span class="line"> //对于极端情况加以处理</span><br><span class="line"> if(nHigh &lt; m_Increment)</span><br><span class="line"> &#123;</span><br><span class="line">  nHigh = 127;</span><br><span class="line">  m_Increment = 120;</span><br><span class="line"> &#125;</span><br><span class="line"> if(m_Increment &lt; -127)</span><br><span class="line">  m_Increment = -120;</span><br><span class="line"> //扩展或压缩区间的长度</span><br><span class="line"> int nStretch = 255;</span><br><span class="line"> if(m_Increment &gt;= 0)</span><br><span class="line">  nStretch = 255 - 2 * m_Increment;</span><br><span class="line"> else</span><br><span class="line">  nStretch = 255 + 2 * m_Increment;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line"> if(m_Increment &gt;= 0)   // m_Increment&gt;=0时</span><br><span class="line"> &#123;</span><br><span class="line">  for(int j=0;j&lt;height;j++) // 每行</span><br><span class="line">   for(int i=0;i&lt;DibWidth-3;i+=3) // 每列</span><br><span class="line">   &#123;   </span><br><span class="line">    //取得当前点（蓝色）的值，调整</span><br><span class="line">    BYTE* pbyBlue = p_data++;    </span><br><span class="line">    if(*pbyBlue&lt;=m_Increment)</span><br><span class="line">     *pbyBlue=0;</span><br><span class="line">    else if(*pbyBlue&gt;nHigh)</span><br><span class="line">     *pbyBlue=255;</span><br><span class="line">    else</span><br><span class="line">     *pbyBlue=(BYTE)((((int)*pbyBlue - m_Increment) * 255) / nStretch );</span><br><span class="line">    //取得当前点（绿色）的值，调整</span><br><span class="line">    BYTE* pbyGreen = p_data++;</span><br><span class="line">    if(*pbyGreen&lt;=m_Increment)</span><br><span class="line">     *pbyGreen=0;</span><br><span class="line">    else if(*pbyGreen&gt;nHigh)</span><br><span class="line">     *pbyGreen=255;</span><br><span class="line">    else</span><br><span class="line">     *pbyGreen=(BYTE)((((int)*pbyGreen - m_Increment) * 255) / nStretch );</span><br><span class="line">    //取得当前点（红色）的值，调整</span><br><span class="line">    BYTE* pbyRed = p_data++;</span><br><span class="line">    if(*pbyRed&lt;=m_Increment)</span><br><span class="line">     *pbyRed=0;</span><br><span class="line">    else if(*pbyRed&gt;nHigh)</span><br><span class="line">     *pbyRed=255;</span><br><span class="line">    else</span><br><span class="line">     *pbyRed=(BYTE)((((int)*pbyRed - m_Increment) * 255) / nStretch );</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"> &#125;</span><br><span class="line"> else  // m_Increment &lt; 0 时</span><br><span class="line"> &#123;</span><br><span class="line">  for(int j=0;j&lt;height;j++)</span><br><span class="line">   for(int i=0;i&lt;DibWidth-3;i+=3)</span><br><span class="line">   &#123; //取得当前点（蓝色）的值，调整</span><br><span class="line">    BYTE* pbyBlue = p_data++;</span><br><span class="line">    *pbyBlue = (BYTE)((((int)(*pbyBlue) * nStretch) / 255) - m_Increment);</span><br><span class="line">    //取得当前点（红色）的值，调整</span><br><span class="line">    BYTE* pbyGreen = p_data++;</span><br><span class="line">    *pbyGreen = (BYTE)((((int)(*pbyGreen) * nStretch) / 255) - m_Increment);</span><br><span class="line">    //取得当前点（红色）的值，调整</span><br><span class="line">    BYTE* pbyRed = p_data++;</span><br><span class="line">    *pbyRed = (BYTE)((((int)(*pbyRed) * nStretch) / 255) - m_Increment);    </span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Exposal-曝光处理"><a href="#Exposal-曝光处理" class="headerlink" title="Exposal 曝光处理"></a>Exposal 曝光处理</h2><p>函数名称：Exposal()<br>函数类型：void<br>功能：图像曝光处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::Exposal() //曝光处理</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line"> for(int j=0;j&lt;height;j++) // 每行</span><br><span class="line">  for(int i=0;i&lt;DibWidth;i++) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">   BYTE* pbydata = p_data++;  //取得当前点的值</span><br><span class="line">   BYTE a=*pbydata;   //传给临时变量</span><br><span class="line">   *pbydata=(a&gt;128)?a:(255-a);   //调整</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="PaintColor-着色处理（阈值法）"><a href="#PaintColor-着色处理（阈值法）" class="headerlink" title="PaintColor 着色处理（阈值法）"></a>PaintColor 着色处理（阈值法）</h2><p>函数名称：PaintColor(int m_Red,int m_Green,int m_Blue)<br>函数类型：void<br>参数：int m_Red、m_Green、m_Blue，用户给定的红绿蓝值<br>功能：对图像使用阈值法进行着色处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::PaintColor(int m_Red,int m_Green,int m_Blue) //着色处理</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line"> for(int j=0;j&lt;height;j++) // 每行</span><br><span class="line">  for(int i=0;i&lt;DibWidth;i+=3) // 每列</span><br><span class="line">  &#123;   </span><br><span class="line">   BYTE* pbyBlue = p_data++; //取得当前点（蓝色）的值     </span><br><span class="line">   BYTE* pbyGreen = p_data++;  //取得当前点（绿色）的值</span><br><span class="line">   BYTE* pbyRed = p_data++;    //取得当前点（红色）的值</span><br><span class="line">   BYTE r = *pbyRed;</span><br><span class="line">   BYTE g = *pbyGreen;</span><br><span class="line">   BYTE b = *pbyBlue;</span><br><span class="line">      BYTE gray=(BYTE)(((WORD)r * 59 + (WORD)g * 30 + (WORD)b * 11) / 100);</span><br><span class="line">   *pbyBlue = (BYTE)((m_Blue * gray) / 255);  </span><br><span class="line">   *pbyGreen = (BYTE)((m_Green * gray) / 255);</span><br><span class="line">   *pbyRed = (BYTE)((m_Red * gray) / 255);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="NeonLight-霓虹处理"><a href="#NeonLight-霓虹处理" class="headerlink" title="NeonLight 霓虹处理"></a>NeonLight 霓虹处理</h2><p>函数名称：NeonLight()<br>函数类型：void<br>功能：使图像产生霓虹处理效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::NeonLight()   //霓虹处理</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line">    BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像</span><br><span class="line"> for(int j=0;j&lt;height-4;j++) // 每行</span><br><span class="line"> &#123;</span><br><span class="line">  for(int i=0;i&lt;DibWidth-1;i++) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">    int pby_pt=0;</span><br><span class="line">    //对像素执行算法</span><br><span class="line">    pby_pt=(*(p_data+(height-j-1)*DibWidth+i)-*(p_data+(height-j-1)*DibWidth+i+3))</span><br><span class="line">       *(*(p_data+(height-j-1)*DibWidth+i)-*(p_data+(height-j-1)*DibWidth+i+3))</span><br><span class="line">       +(*(p_data+(height-j-1)*DibWidth+i)-*(p_data+(height-j-2)*DibWidth+i))</span><br><span class="line">       *(*(p_data+(height-j-1)*DibWidth+i)-*(p_data+(height-j-2)*DibWidth+i));</span><br><span class="line">   *(p_temp+(height-j-1)*DibWidth+i)=2*int(sqrt(pby_pt));</span><br><span class="line">   //判断合法性</span><br><span class="line">   if(*(p_temp+(height-j-1)*DibWidth+i)&lt;0)</span><br><span class="line">     *(p_temp+(height-j-1)*DibWidth+i)=0;</span><br><span class="line">   if(*(p_temp+(height-j-1)*DibWidth+i)&gt;255)</span><br><span class="line">     *(p_temp+(height-j-1)*DibWidth+i)=255;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    memcpy(p_data,p_temp,height*DibWidth);  // 复制处理后的图像</span><br><span class="line">    delete []p_temp;   //删除暂时分配内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Smoothness-平滑处理"><a href="#Smoothness-平滑处理" class="headerlink" title="Smoothness 平滑处理"></a>Smoothness 平滑处理</h2><p>函数名称：Smoothness()<br>函数类型：void<br>功能：使图像平滑处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::Smoothness()   //平滑处理</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line">    int h[3][3];////定义(3x3)矩阵</span><br><span class="line"> h[0][0] = 1;  h[0][1] = 1; h[0][2] = 1;</span><br><span class="line"> h[1][0] = 1;  h[1][1] = 1; h[1][2] = 1;</span><br><span class="line"> h[2][0] = 1;  h[2][1] = 1; h[2][2] = 1;</span><br><span class="line">    BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像</span><br><span class="line"> for(int j=0;j&lt;height-2;j++) // 每行</span><br><span class="line"> &#123;</span><br><span class="line">  for(int i=0;i&lt;DibWidth-8;i++) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">         double pby_pt=0;</span><br><span class="line">                    //对应的第0行的值乘以矩阵对应值，再相加</span><br><span class="line">       pby_pt= h[0][0]*(*(p_data+(height-j-1)*DibWidth+i))</span><br><span class="line">        +h[0][1]*(*(p_data+(height-j-1)*DibWidth+i+3))</span><br><span class="line">        +h[0][2]*(*(p_data+(height-j-1)*DibWidth+i+6))</span><br><span class="line">                    //对应的第1行的值乘以矩阵对应值，再相加</span><br><span class="line">        +h[1][0]*(*(p_data+(height-j-2)*DibWidth+i))</span><br><span class="line">        +h[1][1]*(*(p_data+(height-j-2)*DibWidth+i+3))</span><br><span class="line">        +h[1][2]*(*(p_data+(height-j-2)*DibWidth+i+6))</span><br><span class="line">                    //对应的第2行的值乘以矩阵对应值，再相加</span><br><span class="line">              +h[2][0]*(*(p_data+(height-j-3)*DibWidth+i))</span><br><span class="line">     +h[2][1]*(*(p_data+(height-j-3)*DibWidth+i+3))</span><br><span class="line">     +h[2][2]*(*(p_data+(height-j-3)*DibWidth+i+6));</span><br><span class="line">   *(p_temp+(height-j-2)*DibWidth+i+3)=abs(int(pby_pt/9));//取总和的的平均值</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    memcpy(p_data,p_temp,height*DibWidth);  // 复制处理后的图像</span><br><span class="line">    delete []p_temp;//删除暂时分配内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Embossment-浮雕处理"><a href="#Embossment-浮雕处理" class="headerlink" title="Embossment 浮雕处理"></a>Embossment 浮雕处理</h2><p>函数名称：Embossment()<br>函数类型：void<br>功能：产生图像浮雕处理效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::Embossment()   //浮雕处理</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line">    BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像</span><br><span class="line"> for(int j=0;j&lt;height;j++) // 每行</span><br><span class="line"> &#123;</span><br><span class="line">  for(int i=0;i&lt;DibWidth-4;i++) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">    int pby_pt=0;</span><br><span class="line">    //对像素得每个分量执行算法</span><br><span class="line">    pby_pt=*(p_data+(height-j-1)*DibWidth+i)</span><br><span class="line">       -*(p_data+(height-j-1)*DibWidth+i+3)+128;</span><br><span class="line">    *(p_temp+(height-j-1)*DibWidth+i+3)=pby_pt;</span><br><span class="line">   //检验合法性</span><br><span class="line">   if(*(p_temp+(height-j-1)*DibWidth+i+3)&lt;0)</span><br><span class="line">    *(p_temp+(height-j-1)*DibWidth+i+3)=0;</span><br><span class="line">   else if(*(p_temp+(height-j-1)*DibWidth+i+3)&gt;255)</span><br><span class="line">    *(p_temp+(height-j-1)*DibWidth+i+3)=255;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    memcpy(p_data,p_temp,height*DibWidth);  // 复制处理后的图像</span><br><span class="line">    delete []p_temp;   //删除暂时分配内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Spread-图像扩散"><a href="#Spread-图像扩散" class="headerlink" title="Spread 图像扩散"></a>Spread 图像扩散</h2><p>函数名称：Spread()<br>函数类型：void<br>功能：图像扩散处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::Spread()   //扩散处理</span><br><span class="line">&#123; </span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line">    BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像</span><br><span class="line"> for(int j=0;j&lt;height-4;j++) // 每行</span><br><span class="line"> &#123;</span><br><span class="line">  for(int i=0;i&lt;DibWidth-14;i++) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">    int m=0,n=0;</span><br><span class="line">    m=rand()%5; //取得行随机数</span><br><span class="line">    n=rand()%5; //取得列随机数</span><br><span class="line">    int pby_pt=0; </span><br><span class="line">    pby_pt=*(p_data+(height-j-1-m)*DibWidth+i+3*n);//得到对应随机像素值</span><br><span class="line">    *(p_temp+(height-j-3)*DibWidth+i+6)=pby_pt;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    memcpy(p_data,p_temp,height*DibWidth);  // 复制处理后的图像</span><br><span class="line">    delete []p_temp;   //删除暂时分配内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Sharp-锐化"><a href="#Sharp-锐化" class="headerlink" title="Sharp 锐化"></a>Sharp 锐化</h2><p>函数名称：Sharp()<br>函数类型：void<br>功能：图像锐化处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::Sharp()   //图像锐化</span><br><span class="line">&#123;</span><br><span class="line">  BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line">    BYTE *p_temp=new BYTE[height*DibWidth];</span><br><span class="line"> for(int j=0;j&lt;height-1;j++) // 每行</span><br><span class="line"> &#123;</span><br><span class="line">  for(int i=0;i&lt;DibWidth-5;i++) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">         int pby_pt=0; </span><br><span class="line">   pby_pt= *(p_data+(height-j-2)*DibWidth+i+3)</span><br><span class="line">          -*(p_data+(height-j-1)*DibWidth+i);</span><br><span class="line">   *(p_temp+(height-j-2)*DibWidth+i+3)=*(p_data+(height-j-2)*DibWidth+i+3)</span><br><span class="line">                                     +abs(int(pby_pt/4));</span><br><span class="line">   if(*(p_temp+(height-j-2)*DibWidth+i+3)&gt;255)</span><br><span class="line">      *(p_temp+(height-j-2)*DibWidth+i+3)=255;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    memcpy(p_data,p_temp,height*DibWidth);  // 复制处理后的图像</span><br><span class="line">    delete []p_temp;  //删除暂时分配内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="HighLVBO-阈值法进行高通滤波"><a href="#HighLVBO-阈值法进行高通滤波" class="headerlink" title="HighLVBO 阈值法进行高通滤波"></a>HighLVBO 阈值法进行高通滤波</h2><p>函数名称：HighLVBO(int m_GaoTong)<br>函数类型：void<br>参数：int m_GaoTong，用户给定的阈值来选择矩阵<br>功能：对图像使用阈值法进行高通滤波。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::HighLVBO(int m_GaoTong)   //高通滤波</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line"> int h[3][3];  ////定义(3x3)矩阵</span><br><span class="line"> if(m_GaoTong==1)</span><br><span class="line"> &#123;   //矩阵1（基本高通）</span><br><span class="line">  h[0][0] =1;   h[0][1] =-2;  h[0][2] =1;</span><br><span class="line">  h[1][0] =-2;  h[1][1] =5;   h[1][2] =-2;</span><br><span class="line">  h[2][0] =1;   h[2][1] =-2;  h[2][2] =1;</span><br><span class="line"> &#125;</span><br><span class="line"> else if(m_GaoTong==2)</span><br><span class="line"> &#123;   //矩阵2（中等高通）</span><br><span class="line">  h[0][0] = 0;   h[0][1] = -1; h[0][2] = 0;</span><br><span class="line">  h[1][0] = -1;  h[1][1] =  5; h[1][2] = -1;</span><br><span class="line">  h[2][0] = 0;   h[2][1] = -1; h[2][2] = 0;</span><br><span class="line"> &#125;</span><br><span class="line"> else</span><br><span class="line"> &#123;   //矩阵3（过量高通）</span><br><span class="line">  h[0][0] = -1;  h[0][1] = -1; h[0][2] = -1;</span><br><span class="line">  h[1][0] = -1;  h[1][1] =  9; h[1][2] = -1;</span><br><span class="line">  h[2][0] = -1;  h[2][1] = -1; h[2][2] = -1;</span><br><span class="line"> &#125;</span><br><span class="line">    BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像</span><br><span class="line"> for(int j=0;j&lt;height-2;j++) // 每行</span><br><span class="line"> &#123;</span><br><span class="line">  for(int i=0;i&lt;DibWidth-8;i++) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">   int pby_pt=0;</span><br><span class="line">   //对应的第0行的值乘以矩阵对应值，再相加</span><br><span class="line">   pby_pt=  h[0][0]*(*(p_data+(height-j-1)*DibWidth+i))</span><br><span class="line">    +h[0][1]*(*(p_data+(height-j-1)*DibWidth+i+3))</span><br><span class="line">    +h[0][2]*(*(p_data+(height-j-1)*DibWidth+i+6))</span><br><span class="line">    //对应的第1行的值乘以矩阵对应值，再相加</span><br><span class="line">    +h[1][0]*(*(p_data+(height-j-2)*DibWidth+i))</span><br><span class="line">    +h[1][1]*(*(p_data+(height-j-2)*DibWidth+i+3))</span><br><span class="line">    +h[1][2]*(*(p_data+(height-j-2)*DibWidth+i+6))</span><br><span class="line">    //对应的第2行的值乘以矩阵对应值，再相加</span><br><span class="line">    +h[2][0]*(*(p_data+(height-j-3)*DibWidth+i))</span><br><span class="line">    +h[2][1]*(*(p_data+(height-j-3)*DibWidth+i+3))</span><br><span class="line">    +h[2][2]*(*(p_data+(height-j-3)*DibWidth+i+6));</span><br><span class="line">   *(p_temp+(height-j-2)*DibWidth+i+3)=abs(pby_pt);</span><br><span class="line">   if(pby_pt&gt;255) //判断是否越界</span><br><span class="line">    *(p_temp+(height-j-2)*DibWidth+i+3)=255;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    memcpy(p_data,p_temp,height*DibWidth);  // 复制处理后的图像</span><br><span class="line">    delete []p_temp;  //删除暂时分配内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="LowLVBO-图像低通滤波"><a href="#LowLVBO-图像低通滤波" class="headerlink" title="LowLVBO 图像低通滤波"></a>LowLVBO 图像低通滤波</h2><p>函数名称：LowLVBO()<br>函数类型：void<br>功能：实现图像低通滤波(3x3)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::LowLVBO()   //低通滤波(3x3)</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line">    double h[3][3];////定义(3x3)矩阵</span><br><span class="line"> h[0][0] = 0.1;  h[0][1] = 0.1; h[0][2] = 0.1;</span><br><span class="line"> h[1][0] = 0.1;  h[1][1] = 0.2; h[1][2] = 0.1;</span><br><span class="line"> h[2][0] = 0.1;  h[2][1] = 0.1; h[2][2] = 0.1;</span><br><span class="line"> BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像</span><br><span class="line"> for(int j=0;j&lt;height-2;j++) // 每行</span><br><span class="line"> &#123;</span><br><span class="line">  for(int i=0;i&lt;DibWidth-8;i++) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">   double pby_pt=0;</span><br><span class="line">            //对应的第0行的值乘以矩阵对应值，再相加 </span><br><span class="line">   pby_pt=  h[0][0]*(*(p_data+(height-j-1)*DibWidth+i))</span><br><span class="line">    +h[0][1]*(*(p_data+(height-j-1)*DibWidth+i+3))</span><br><span class="line">    +h[0][2]*(*(p_data+(height-j-1)*DibWidth+i+6))</span><br><span class="line">    //对应的第0行的值乘以矩阵对应值，再相加</span><br><span class="line">    +h[1][0]*(*(p_data+(height-j-2)*DibWidth+i))</span><br><span class="line">    +h[1][1]*(*(p_data+(height-j-2)*DibWidth+i+3))</span><br><span class="line">    +h[1][2]*(*(p_data+(height-j-2)*DibWidth+i+6))</span><br><span class="line">    //对应的第0行的值乘以矩阵对应值，再相加</span><br><span class="line">    +h[2][0]*(*(p_data+(height-j-3)*DibWidth+i))</span><br><span class="line">    +h[2][1]*(*(p_data+(height-j-3)*DibWidth+i+3))</span><br><span class="line">    +h[2][2]*(*(p_data+(height-j-3)*DibWidth+i+6));</span><br><span class="line">   *(p_temp+(height-j-2)*DibWidth+i+3)=abs(int(pby_pt));</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> memcpy(p_data,p_temp,height*DibWidth);  // 复制处理后的图像</span><br><span class="line"> delete []p_temp;  //删除暂时分配内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="LowVBObig-低通滤波"><a href="#LowVBObig-低通滤波" class="headerlink" title="LowVBObig 低通滤波"></a>LowVBObig 低通滤波</h2><p>函数名称：LowVBObig()<br> 函数类型：void<br> 功能：实现函数低通滤波(5*5)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::LowLVBObig()   //低通滤波(5x5)</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line"> int h[5][5];//定义(5x5)矩阵</span><br><span class="line"> h[0][0] = 1;  h[0][1] = 1; h[0][2] = 1; h[0][3] = 1; h[0][4] = 1;</span><br><span class="line"> h[1][0] = 1;  h[1][1] = 2; h[1][2] = 2; h[1][3] = 2; h[1][4] = 1;</span><br><span class="line"> h[2][0] = 1;  h[2][1] = 2; h[2][2] = 3; h[2][3] = 2; h[2][4] = 1;</span><br><span class="line"> h[3][0] = 1;  h[3][1] = 2; h[3][2] = 2; h[3][3] = 2; h[3][4] = 1;</span><br><span class="line"> h[4][0] = 1;  h[4][1] = 1; h[4][2] = 1; h[4][3] = 1; h[4][4] = 1;</span><br><span class="line"> BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像</span><br><span class="line"> for(int j=0;j&lt;height-4;j++) // 每行</span><br><span class="line"> &#123;</span><br><span class="line">  for(int i=0;i&lt;DibWidth-14;i++) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">         int pby_pt=0;</span><br><span class="line">         //对应的第0行的值乘以矩阵对应值，再相加</span><br><span class="line">   pby_pt=h[0][0]*(*(p_data+(height-j-1)*DibWidth+i))</span><br><span class="line">      +h[0][1]*(*(p_data+(height-j-1)*DibWidth+i+3))</span><br><span class="line">      +h[0][2]*(*(p_data+(height-j-1)*DibWidth+i+6))</span><br><span class="line">         +h[0][3]*(*(p_data+(height-j-1)*DibWidth+i+9))</span><br><span class="line">      +h[0][4]*(*(p_data+(height-j-1)*DibWidth+i+12))</span><br><span class="line">                  //对应的第1行的值乘以矩阵对应值，再相加</span><br><span class="line">         +h[1][0]*(*(p_data+(height-j-2)*DibWidth+i))</span><br><span class="line">         +h[1][1]*(*(p_data+(height-j-2)*DibWidth+i+3))</span><br><span class="line">      +h[1][2]*(*(p_data+(height-j-2)*DibWidth+i+6))</span><br><span class="line">      +h[1][3]*(*(p_data+(height-j-2)*DibWidth+i+9))</span><br><span class="line">      +h[1][4]*(*(p_data+(height-j-2)*DibWidth+i+12))</span><br><span class="line">                  //对应的第2行的值乘以矩阵对应值，再相加</span><br><span class="line">         +h[2][0]*(*(p_data+(height-j-3)*DibWidth+i))</span><br><span class="line">      +h[2][1]*(*(p_data+(height-j-3)*DibWidth+i+3))</span><br><span class="line">      +h[2][2]*(*(p_data+(height-j-3)*DibWidth+i+6))</span><br><span class="line">      +h[2][3]*(*(p_data+(height-j-3)*DibWidth+i+9))</span><br><span class="line">      +h[2][4]*(*(p_data+(height-j-3)*DibWidth+i+12))</span><br><span class="line">                  //对应的第3行的值乘以矩阵对应值，再相加</span><br><span class="line">         +h[3][0]*(*(p_data+(height-j-4)*DibWidth+i))</span><br><span class="line">         +h[3][1]*(*(p_data+(height-j-4)*DibWidth+i+3))</span><br><span class="line">      +h[3][2]*(*(p_data+(height-j-4)*DibWidth+i+6))</span><br><span class="line">      +h[3][3]*(*(p_data+(height-j-4)*DibWidth+i+9))</span><br><span class="line">      +h[3][4]*(*(p_data+(height-j-4)*DibWidth+i+12))</span><br><span class="line">                  //对应的第4行的值乘以矩阵对应值，再相加</span><br><span class="line">         +h[4][0]*(*(p_data+(height-j-5)*DibWidth+i))</span><br><span class="line">      +h[4][1]*(*(p_data+(height-j-5)*DibWidth+i+3))</span><br><span class="line">      +h[4][2]*(*(p_data+(height-j-5)*DibWidth+i+6))</span><br><span class="line">      +h[4][3]*(*(p_data+(height-j-5)*DibWidth+i+9))</span><br><span class="line">      +h[4][4]*(*(p_data+(height-j-5)*DibWidth+i+12));</span><br><span class="line">                  //为了计算方便我们把除以35（矩阵权和）放在求总和之后</span><br><span class="line">   *(p_temp+(height-j-3)*DibWidth+i+6)=abs(int(pby_pt/35));</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> memcpy(p_data,p_temp,height*DibWidth);  // 复制处理后的图像</span><br><span class="line"> delete []p_temp;  //删除暂时分配内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ShuiPingGROW-水平增强"><a href="#ShuiPingGROW-水平增强" class="headerlink" title="ShuiPingGROW 水平增强"></a>ShuiPingGROW 水平增强</h2><p>函数名称：ShuiPingGROW()<br>函数类型：void<br>功能：使图像水平增强。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::ShuiPingGROW()   //水平增强</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line"> int h[3][1];//定义(3x1)矩阵</span><br><span class="line"> h[0][0] = -1;  </span><br><span class="line"> h[1][0] = 2; </span><br><span class="line"> h[2][0] = -1;</span><br><span class="line"> BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像</span><br><span class="line"> for(int j=0;j&lt;height-2;j++) // 每行</span><br><span class="line"> &#123;</span><br><span class="line">  for(int i=0;i&lt;DibWidth-8;i++) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">   int pby_pt=0;</span><br><span class="line">   //对应的3行的值乘分别以矩阵对应值，再相加</span><br><span class="line">   pby_pt= h[0][0]*(*(p_data+(height-j-1)*DibWidth+i))</span><br><span class="line">    +h[1][0]*(*(p_data+(height-j-2)*DibWidth+i))</span><br><span class="line">    +h[2][0]*(*(p_data+(height-j-3)*DibWidth+i));</span><br><span class="line">   if(pby_pt&gt;20)</span><br><span class="line">    *(p_temp+(height-j-2)*DibWidth+i)=abs(pby_pt)+100;</span><br><span class="line">   else</span><br><span class="line">    *(p_temp+(height-j-2)*DibWidth+i)=abs(pby_pt);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> memcpy(p_data,p_temp,height*DibWidth);  // 复制处理后的图像</span><br><span class="line">    delete []p_temp;  //删除暂时分配内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ChuiZhiGROW-垂直增强"><a href="#ChuiZhiGROW-垂直增强" class="headerlink" title="ChuiZhiGROW 垂直增强"></a>ChuiZhiGROW 垂直增强</h2><p>函数名称：ChuiZhiGROW()<br>函数类型：void<br>功能：使图像垂直增强。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::ChuiZhiGROW()   //垂直增强</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line"> int h[1][3];//定义(1x3)矩阵</span><br><span class="line"> h[0][0] = -1; </span><br><span class="line"> h[0][1] = 2;</span><br><span class="line"> h[0][2] = -1;</span><br><span class="line"> BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像</span><br><span class="line"> for(int j=0;j&lt;height-2;j++) // 每行</span><br><span class="line"> &#123;</span><br><span class="line">  for(int i=0;i&lt;DibWidth-8;i++) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">   int pby_pt=0;</span><br><span class="line">   //对应的第0行的值乘以矩阵对应值，再相加</span><br><span class="line">   pby_pt= h[0][0]*(*(p_data+(height-j-1)*DibWidth+i))</span><br><span class="line">    +h[0][1]*(*(p_data+(height-j-1)*DibWidth+i+3))</span><br><span class="line">    +h[0][2]*(*(p_data+(height-j-1)*DibWidth+i+6));</span><br><span class="line">   if(pby_pt&gt;20)</span><br><span class="line">    *(p_temp+(height-j-2)*DibWidth+i)=abs(pby_pt)+100;</span><br><span class="line">   else</span><br><span class="line">    *(p_temp+(height-j-2)*DibWidth+i)=abs(pby_pt);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> memcpy(p_data,p_temp,height*DibWidth);  // 复制处理后的图像</span><br><span class="line"> delete []p_temp;  //删除暂时分配内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ShuangXiangGROW-双向增强"><a href="#ShuangXiangGROW-双向增强" class="headerlink" title="ShuangXiangGROW 双向增强"></a>ShuangXiangGROW 双向增强</h2><p>函数名称：ShuangXiangGROW()<br>函数类型：void<br>功能：使图像双向增强。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::ShuangXiangGROW()    //双向增强</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line"> int h[3][3];//定义(3x3)矩阵</span><br><span class="line"> h[0][0] = -1;  h[0][1] = -1; h[0][2] = -1;</span><br><span class="line"> h[1][0] = -1;  h[1][1] =  8; h[1][2] = -1;</span><br><span class="line"> h[2][0] = -1;  h[2][1] = -1; h[2][2] = -1; </span><br><span class="line"> BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像</span><br><span class="line"> for(int j=0;j&lt;height-2;j++) // 每行</span><br><span class="line"> &#123; </span><br><span class="line">  for(int i=0;i&lt;DibWidth-8;i++) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">   int pby_pt=0;</span><br><span class="line">   //对应的第0行的值乘以矩阵对应值，再相加</span><br><span class="line">   pby_pt= h[0][0]*(*(p_data+(height-j-1)*DibWidth+i))</span><br><span class="line">    +h[0][1]*(*(p_data+(height-j-1)*DibWidth+i+3))</span><br><span class="line">    +h[0][2]*(*(p_data+(height-j-1)*DibWidth+i+6))</span><br><span class="line">    //对应的第1行的值乘以矩阵对应值，再相加</span><br><span class="line">    +h[1][0]*(*(p_data+(height-j-2)*DibWidth+i))</span><br><span class="line">    +h[1][1]*(*(p_data+(height-j-2)*DibWidth+i+3))</span><br><span class="line">    +h[1][2]*(*(p_data+(height-j-2)*DibWidth+i+6))</span><br><span class="line">    //对应的第2行的值乘以矩阵对应值，再相加</span><br><span class="line">    +h[2][0]*(*(p_data+(height-j-3)*DibWidth+i))</span><br><span class="line">    +h[2][1]*(*(p_data+(height-j-3)*DibWidth+i+3))</span><br><span class="line">    +h[2][2]*(*(p_data+(height-j-3)*DibWidth+i+6));</span><br><span class="line">   if(pby_pt&gt;20)</span><br><span class="line">    *(p_temp+(height-j-2)*DibWidth+i)=abs(pby_pt)+100;</span><br><span class="line">   else</span><br><span class="line">    *(p_temp+(height-j-2)*DibWidth+i)=abs(pby_pt);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125; </span><br><span class="line"> memcpy(p_data,p_temp,height*DibWidth);  // 复制处理后的图像</span><br><span class="line"> delete []p_temp;  //删除暂时分配内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Mosaic-马塞克"><a href="#Mosaic-马塞克" class="headerlink" title="Mosaic 马塞克"></a>Mosaic 马塞克</h2><p>函数名称：Mosaic()<br>函数类型：void<br>功能：使图像产生马赛克效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::Mosaic()    //马赛克</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line"> BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像</span><br><span class="line"> for(int j=0;j&lt;height-4;j+=5) // 每行</span><br><span class="line"> &#123; </span><br><span class="line">     for(int i=0;i&lt;DibWidth-14;i+=15) // 每列</span><br><span class="line">  &#123;   //对应周围(5x5)矩阵蓝色值求和平均</span><br><span class="line">   int pby_pt=0;</span><br><span class="line">   for(int m=0;m&lt;5;m++)</span><br><span class="line">    for(int n=0;n&lt;15;n+=3)</span><br><span class="line">    &#123;   </span><br><span class="line">     pby_pt+=*(p_data+(height-j-1-m)*DibWidth+i+n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   for(m=0;m&lt;5;m++)</span><br><span class="line">    for(int n=0;n&lt;14;n+=3)</span><br><span class="line">    &#123;</span><br><span class="line">     *(p_temp+(height-j-1-m)*DibWidth+i+n)=int(pby_pt/25);</span><br><span class="line">    &#125; </span><br><span class="line">            //对应周围(5x5)矩阵绿色值求和平均</span><br><span class="line">   pby_pt=0;</span><br><span class="line">   for(m=0;m&lt;5;m++)</span><br><span class="line">    for(int n=0;n&lt;15;n+=3)</span><br><span class="line">    &#123;</span><br><span class="line">     pby_pt+=*(p_data+(height-j-1-m)*DibWidth+i+n+1);</span><br><span class="line">    &#125;</span><br><span class="line">   for(m=0;m&lt;5;m++)</span><br><span class="line">    for(int n=0;n&lt;14;n+=3)</span><br><span class="line">    &#123;</span><br><span class="line">     *(p_temp+(height-j-1-m)*DibWidth+i+n+1)=int(pby_pt/25);</span><br><span class="line">    &#125;</span><br><span class="line">            //对应周围(5x5)矩阵红色值求和平均</span><br><span class="line">   pby_pt=0;</span><br><span class="line">   for(m=0;m&lt;5;m++)</span><br><span class="line">    for(int n=0;n&lt;15;n+=3)</span><br><span class="line">    &#123;</span><br><span class="line">     pby_pt+=*(p_data+(height-j-1-m)*DibWidth+i+n+2);</span><br><span class="line">    &#125;</span><br><span class="line">   for(m=0;m&lt;5;m++)</span><br><span class="line">    for(int n=0;n&lt;14;n+=3)</span><br><span class="line">    &#123;</span><br><span class="line">     *(p_temp+(height-j-1-m)*DibWidth+i+n+2)=int(pby_pt/25);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;   </span><br><span class="line"> &#125;</span><br><span class="line"> memcpy(p_data,p_temp,height*DibWidth);  // 复制处理后的图像</span><br><span class="line"> delete []p_temp;  //删除暂时分配内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++入门</title>
      <link href="/2018/07/19/C++%E5%85%A5%E9%97%A8/"/>
      <url>/2018/07/19/C++%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>C++入门</p><a id="more"></a><h3 id="指针入门"><a href="#指针入门" class="headerlink" title="指针入门"></a>指针入门</h3><blockquote><p>指针作用：  引用类型，传递地址，减少内存消耗<br>案例<br>int p &gt;定义变量p<br>int* p &gt;定义指针变量p<br>使用指针，先要定义指针变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int *p;     //int* p &gt;定义指针变量p</span><br><span class="line">    int a=3; </span><br><span class="line">    p=&amp;a;   //&amp;a是把a的地址赋给指针p，&amp;：取址符a</span><br><span class="line">    printf(&quot;%d\n&quot;,*p)   //输出为3</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp; 取变量的地址 &amp;(变量名)</span><br><span class="line">* 指针运算符（取值运算） *(变量名)</span><br><span class="line">&amp; *互为逆运算 *(&amp;(int i =6))=6</span><br></pre></td></tr></table></figure><p>指针变量是存储地址的变量，随机分配<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int *p1;</span><br><span class="line">char *name</span><br><span class="line"></span><br><span class="line">int x;int *p; p=&amp;x;</span><br><span class="line">答：*P=3;</span><br><span class="line">p是x的地址，*p是x的值</span><br></pre></td></tr></table></figure></p><p>常用错误：<br>1、指针不能直接复制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">错误：</span><br><span class="line">int *p; </span><br><span class="line">p =100;//错误</span><br><span class="line"></span><br><span class="line">正确：</span><br><span class="line">int i, *p, *t;</span><br><span class="line">p=&amp;i;</span><br><span class="line">t=p;</span><br><span class="line">*p *t是指针，把i的地址赋给pt指针（元素地址）</span><br></pre></td></tr></table></figure></p><p>2、不能直接给指针赋值(不能直接变量取值)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x= 20;</span><br><span class="line">printf(&quot;%d,&amp;(*x));</span><br></pre></td></tr></table></figure></p><p>Scanf函数:函数后的参数应该传入指针，不应该是值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int score;</span><br><span class="line">printf(&quot;shuru :\n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,score);</span><br></pre></td></tr></table></figure></p><p>Swap函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void swap(int *x, int *y)</span><br><span class="line">&#123;</span><br><span class="line">    int temp;//中间变量</span><br><span class="line">    temp=*x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = temp;</span><br><span class="line"></span><br><span class="line">    printf(&quot;x=%d, y=%d \n&quot;, *x, *y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    int i =13, j =45;</span><br><span class="line">    swap(&amp;i, &amp;j);</span><br><span class="line">    printf(&quot;i=%d, j=%d\n&quot;,i ,j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出： x=45,y=13    i=45,j=13</span><br></pre></td></tr></table></figure></p><h3 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h3><blockquote><p>C语言的参数传递都是值传递，当传传递一个指针给函数的时，其实质上还是值传递，除非使用双指针。<br>只有一个<em>号的时候，我们叫它一级指针。*</em> 两个星号的叫二级指针。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void  </span><br><span class="line">swap ( int *a, int *b )&#123;  </span><br><span class="line">    int c;  </span><br><span class="line">    c = *a;  </span><br><span class="line">    *a = *b;  </span><br><span class="line">    *b = c;  </span><br><span class="line">&#125;  </span><br><span class="line">int  </span><br><span class="line">main(int argc, char **argv)&#123;  </span><br><span class="line">    int a,b;  </span><br><span class="line">    a = 16;  </span><br><span class="line">    b = 32;  </span><br><span class="line">    swap( &amp;a, &amp;b);  </span><br><span class="line">    return ( a - b );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>段代码编译成汇编语言之后，除了会有代码段，数据段，堆栈，那么在调用的时候，会把main函数的参数变量压入main函数的栈帧，然后接着会压入swap函数的局部变量和参数</p><p><img src="http://hi.csdn.net/attachment/201002/9/4758664_12657012034TT4.jpg" alt></p><p>我们申明 **a之后，其实双指针变量a其实已经存在,内存效果如下<br><img src="http://hi.csdn.net/attachment/201002/9/4758664_1265703222WluB.jpg" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p中放的是中间桥梁bridge的地址&amp;bridge</span><br><span class="line">*p就是中间桥梁bridge的内容(即是目标操作数的地址&amp;income)，</span><br><span class="line">**p就是目标操作数</span><br><span class="line"></span><br><span class="line">中间的bridge是桥梁，中间件使用的，过度吧</span><br></pre></td></tr></table></figure></p><blockquote><p>双指针主要用在但我们想向一个A函数传递参数的时候，但是我们希望在A内部对参数做任何修改都能保存起来，那么就是用双指针吧。</p></blockquote><h3 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h3><p>IO库：<br>|头文件|类型|||<br>|-|-|-|-|<br>|iostream|istream,wistream 从流读取数据|ostream, wostream向流写入数据|iostream. wiostream读写流|<br>|fstream|ifstream, wifstream从文件读取数据|ofstream, wofstream向文件写入数据|fstream, wfstream读写文件|<br>|sstream|istringstream. wistringstream string 读取数据|ostringstream, wostringstream string 写入数据|stringstream, wstringstream string 读写string|</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型ifsream和istringstream都继承自istream;</span><br><span class="line">类型ofsream和ostringstream都继承自ostream;</span><br><span class="line">类型fsream和stringstream都继承自iostream;</span><br></pre></td></tr></table></figure><p>1、创建使用文件流对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ifstream in(ifile);//构造一个ifstream并打开给定文件</span><br><span class="line">ofstream out;//构造输出文件流，未关联任何文件</span><br><span class="line"></span><br><span class="line">in.close();//关闭文件</span><br><span class="line">in.open(ifile + &quot;2&quot;);//打开另一个文件</span><br></pre></td></tr></table></figure></p><p>ifstream,ofstream和fstream是实现文件读写操作的类型</p><p>案例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                                                                                                                                </span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">   char buffer[256];</span><br><span class="line">   ifstream in(&quot;input.txt&quot;);//文件不存在会返回错误</span><br><span class="line">   if (! in.is_open())&#123;</span><br><span class="line">       cout &lt;&lt; &quot;Error opening file&quot;&lt;&lt;endl;</span><br><span class="line">       exit (1);</span><br><span class="line">   &#125;</span><br><span class="line">   vector&lt;string&gt; a;</span><br><span class="line">   while (!in.eof())&#123;</span><br><span class="line">       in.getline (buffer,100);</span><br><span class="line">       //cout &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">       a.push_back(buffer);</span><br><span class="line">    &#125;   </span><br><span class="line">   for(unsigned int i=0;i&lt;a.size();i++)</span><br><span class="line">       cout&lt;&lt;a[i]&lt;&lt;endl;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="resize-reserve"><a href="#resize-reserve" class="headerlink" title="resize(),reserve()"></a>resize(),reserve()</h3><p>resize()，设置大小（size）;<br>reserve()，设置容量（capacity）;<br>size()是分配容器的内存大小，而capacity()只是设置容器容量大小，但并没有真正分配内存。</p><h3 id="ifstream"><a href="#ifstream" class="headerlink" title="ifstream"></a>ifstream</h3><p><a href="https://blog.csdn.net/kingstar158/article/details/6859379" target="_blank" rel="noopener">cankao</a><br><br>1、文件打开<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifstream infile(fname,ios::in);</span><br></pre></td></tr></table></figure></p><p>定义ifstream的对象infile,打开文件faname,ios::in是读取</p><div class="table-container"><table><thead><tr><th>打开文件的方式在ios类(所以流式I/O的基类)中定义</th><th></th></tr></thead><tbody><tr><td>IO流的定义</td><td>含义</td></tr><tr><td>ios::in</td><td>为输入(读)而打开文件</td></tr><tr><td>ios::out</td><td>为输出(写)而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>所有输出附加在文件末尾</td></tr><tr><td>ios::trunc</td><td>如果文件已存在则先删除该文件</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table></div><p>2、关闭文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infile.close</span><br></pre></td></tr></table></figure></p><p>3、文本文件的读写</p><p>类ofstream, ifstream 和fstream 是分别从ostream, istream 和iostream 中引申而来的。这就是为什么 fstream 的对象可以使用其父类的成员来访问数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">写入内容：</span><br><span class="line">#include &lt;fiostream.h&gt;</span><br><span class="line">    int main () &#123;</span><br><span class="line">        ofstream out(&quot;out.txt&quot;);</span><br><span class="line">        if (out.is_open()) </span><br><span class="line">       &#123;</span><br><span class="line">            out &lt;&lt; &quot;This is a line.\n&quot;;</span><br><span class="line">            out &lt;&lt; &quot;This is another line.\n&quot;;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">   //结果: 在out.txt中写入：</span><br><span class="line">   This is a line.</span><br><span class="line">   This is another line</span><br><span class="line"></span><br><span class="line">读取内容：</span><br><span class="line">// reading a text file</span><br><span class="line">    #include &lt;iostream.h&gt;</span><br><span class="line">    #include &lt;fstream.h&gt;</span><br><span class="line">    #include &lt;stdlib.h&gt;</span><br><span class="line">    </span><br><span class="line">    int main () &#123;</span><br><span class="line">        char buffer[256];</span><br><span class="line">        ifstream in(&quot;test.txt&quot;);</span><br><span class="line">        if (! in.is_open())</span><br><span class="line">        &#123; cout &lt;&lt; &quot;Error opening file&quot;; exit (1); &#125;</span><br><span class="line">        while (!in.eof() )</span><br><span class="line">        &#123;</span><br><span class="line">            in.getline (buffer,100);</span><br><span class="line">            cout &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    //结果 在屏幕上输出</span><br><span class="line">     This is a line.</span><br><span class="line">     This is another line</span><br><span class="line">```</span><br><span class="line">状态标识符</span><br></pre></td></tr></table></figure></p><p>bad()<br>如果在读写过程中出错，返回 true 。例如：当我们要对一个不是打开为写状态的文件进行写入时，或者我们要写入的设备没有剩余空间的时候。</p><p>fail()<br>除了与bad() 同样的情况下会返回 true 以外，加上格式错误时也返回true ，例如当想要读入一个整数，而获得了一个字母的时候。</p><p>eof()<br>如果读文件到达文件末尾，返回true。</p><p>good()<br>这是最通用的：如果调用以上任何一个函数返回true 的话，此函数返回 false 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">要想重置以上成员函数所检查的状态标志，你可以使用成员函数clear()，没有参数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### sizeof</span><br><span class="line">sizeof 求对象或者类型的大小`sizeof(array)`&lt;br&gt;</span><br><span class="line">[cankao](https://blog.csdn.net/tao20dage/article/details/52372604)</span><br></pre></td></tr></table></figure></p><p>特性0：sizeof是运算符，不是函数<br>特性1：sizeof不能求得void类型的长度<br>特性2：sizeof能求得void类型的指针的长度<br>特性3：sizeof能求得静态分配内存的数组的长度!<br>特性4：sizeof不能求得动态分配的内存的大小!<br>特性5：sizeof不能对不完整的数组求长度！<br>特性6：当表达式作为sizeof的操作数时，它返回表达式的计算结果的类型大小，但是它不对表达式求值！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### new(std::nothrow)</span><br><span class="line"> 顾名思义，即不抛出异常，当new一个对象失败时，默认设置该对象为NULL，这样可以方便的通过if(p == NULL) 来判断new操作是否成功</span><br><span class="line"> 建议在c++代码中，凡是涉及到new操作，都采用new(std::nothrow)，然后if(p==NULL)的方式进行判断</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">### vector</span><br><span class="line">[cankao](https://blog.csdn.net/duan19920101/article/details/50617190/)&lt;br&gt;</span><br><span class="line">在c++中，vector是一个十分有用的容器。</span><br><span class="line">作用：它能够像容器一样存放各种类型的对象，简单地说，vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。&lt;br&gt;</span><br><span class="line">&gt;1、如果你要表示的向量长度较长（需要为向量内部保存很多数），容易导致内存泄漏，而且效率会很低；&lt;br&gt;</span><br><span class="line">2、Vector作为函数的参数或者返回值时，需要注意它的写法：</span><br><span class="line">   double Distance(vector&lt;int&gt;&amp;a, vector&lt;int&gt;&amp;b) 其中的“&amp;”绝对不能少！！！</span><br><span class="line"></span><br><span class="line">   c++基本操作</span><br></pre></td></tr></table></figure></p><p>   1 、基本操作</p><p>(1)头文件#include<vector>.<br>(2)创建vector对象，vector<int> vec;<br>(3)尾部插入数字：vec.push_back(a);<br>(4)使用下标访问元素，cout&lt;<vec[0]<<endl;记住下标是从0开始的。 (5)使用迭代器访问元素. vector<int>::iterator it;<br>for(it=vec.begin();it!=vec.end();it++)<br>    cout&lt;&lt;*it&lt;<endl; (6)插入元素： vec.insert(vec.begin()+i,a);在第i+1个元素前面插入a; (7)删除元素： vec.erase(vec.begin()+2);删除第3个元素 vec.erase(vec.begin()+i,vec.end()+j);删除区间[i,j-1];区间从0开始 (8)向量大小:vec.size(); (9)清空:vec.clear(); <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### 二维数组</span><br></pre></td></tr></table></endl;></vec[0]<<endl;记住下标是从0开始的。></int></vector></p><h1 id="include-“stdafx-h”"><a href="#include-“stdafx-h”" class="headerlink" title="include “stdafx.h”"></a>include “stdafx.h”</h1><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <cv.h></cv.h></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <vector></vector></h1><h1 id="include-2"><a href="#include-2" class="headerlink" title="include "></a>include <iostream></iostream></h1><p>using namespace std;<br>int main()<br>{<br>    using namespace std;<br>    int out[3][2] = { 1, 2,<br>             3, 4,<br>            5, 6 };<br>    vector <int*> v1;</int*></p><pre><code>v1.push_back(out[0]);v1.push_back(out[1]);v1.push_back(out[2]);cout &lt;&lt; v1[0][0] &lt;&lt; endl;//1cout &lt;&lt; v1[0][1] &lt;&lt; endl;//2cout &lt;&lt; v1[1][0] &lt;&lt; endl;//3cout &lt;&lt; v1[1][1] &lt;&lt; endl;//4cout &lt;&lt; v1[2][0] &lt;&lt; endl;//5cout &lt;&lt; v1[2][1] &lt;&lt; endl;//6return 0;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 随机数</span><br><span class="line">RAND_MAX是C中stdlib.h中宏定义的一个字符常量：</span><br><span class="line">`#define RAND_MAX Ox7FFF`</span><br><span class="line">其值最小为32767,最大为2147483647</span><br></pre></td></tr></table></figure><p>(double)rand() / RAND_MAX;//生成随机数<br>```</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv图像分割</title>
      <link href="/2018/07/19/opencv_imgseg/"/>
      <url>/2018/07/19/opencv_imgseg/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Opencv图像分割</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *</span><br><span class="line"> * 功能：通过灰度图做简单的图像分割,再使用findContours去掉多余的轮廓</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"> </span><br><span class="line">#include &lt;opencv2/core/core.hpp&gt;</span><br><span class="line">#include &lt;opencv2/highgui/highgui.hpp&gt;</span><br><span class="line">#include &lt;opencv2/imgproc/imgproc.hpp&gt;</span><br><span class="line"> </span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">void contours();</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    contours();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void contours()</span><br><span class="line">&#123;</span><br><span class="line">    //--1.读入图片</span><br><span class="line">    Mat image = imread(&quot;horse_hw.jpg&quot;);</span><br><span class="line"> </span><br><span class="line">    Mat gray;//mat类型数据存放图片，opencv特有</span><br><span class="line">  </span><br><span class="line">    cvtColor(image,gray,CV_RGB2GRAY);</span><br><span class="line"> </span><br><span class="line">    Mat binary;</span><br><span class="line">    threshold(gray,binary,60,255,THRESH_BINARY_INV);</span><br><span class="line"> </span><br><span class="line">    vector&lt;vector&lt;Point&gt; &gt; contours;</span><br><span class="line">    Mat binary_copy; //因为findcontours函数会改变输入的图像，所以复制一个图像作为函数的输入</span><br><span class="line">    binary.copyTo(binary_copy);</span><br><span class="line">    findContours(binary_copy,contours,CV_RETR_EXTERNAL/*获取外轮廓*/,CV_CHAIN_APPROX_NONE/*获取每个轮廓的每个像素*/);</span><br><span class="line"> </span><br><span class="line">    //遍历每一个轮廓，把多余的轮廓去掉</span><br><span class="line">    vector&lt;vector&lt;Point&gt; &gt;::const_iterator it=contours.begin();</span><br><span class="line">    while(it!=contours.end())</span><br><span class="line">    &#123;</span><br><span class="line">        if(it-&gt;size()&lt;500)</span><br><span class="line">            it = contours.erase(it);</span><br><span class="line">        else</span><br><span class="line">            ++it;</span><br><span class="line">    &#125;</span><br><span class="line">    Mat dst(image.size(),CV_8U,Scalar(0));</span><br><span class="line">    drawContours(dst,contours,-1/*绘制所有轮廓*/,Scalar(255)/*绘制为白色*/,CV_FILLED/*轮廓全部填充*/);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    //--4.显示结果(原图和结果图显示在一起)</span><br><span class="line">    const int width  = image.cols;</span><br><span class="line">    const int height = image.rows;</span><br><span class="line">    Mat show_image(Size(3*width,height),CV_8UC3);</span><br><span class="line">    //将image拷贝到显示图片指定位置</span><br><span class="line">    image.copyTo(show_image(Rect(0,0,width,height)));</span><br><span class="line">    //将binary,dst转换为3通道，使得show_image和dst通道数一致，或者使用convertTo()函数做操作</span><br><span class="line">    cvtColor(binary,binary,CV_GRAY2RGB);</span><br><span class="line">    cvtColor(dst,dst,CV_GRAY2RGB);</span><br><span class="line">    //将binary,dst拷贝image指定位置</span><br><span class="line">    binary.copyTo(show_image(Rect(width,0,width,height)));</span><br><span class="line">    dst.copyTo(show_image(Rect(2*width,0,width,height)));</span><br><span class="line">    //显示</span><br><span class="line">    imshow(&quot;show&quot;,show_image);</span><br><span class="line">    waitKey(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> Opencv </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构_二叉树</title>
      <link href="/2018/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2018/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>数据结构_二叉树</p><a id="more"></a><p>树的遍历顺序大体分为三种：前序遍历（先根遍历、先序遍历），中序遍历（中根遍历），后序遍历（后根遍历）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">二叉树：</span><br><span class="line">      A</span><br><span class="line">     /  \</span><br><span class="line">   B     C</span><br><span class="line">  /\    /</span><br><span class="line"> D  E  F</span><br></pre></td></tr></table></figure><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>前序遍历可以记为根左右。<br><br>前序遍历的规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）访问根节点</span><br><span class="line">（2）前序遍历左子树</span><br><span class="line">（3）前序遍历右子树</span><br></pre></td></tr></table></figure></p><p>前序遍历的输出结果：ABDECF</p><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>中序遍历可以记为左根右<br><br>中序遍历的规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）中序遍历左子树</span><br><span class="line">（2）访问根节点</span><br><span class="line">（3）中序遍历右子树</span><br></pre></td></tr></table></figure></p><p>中序遍历的输出结果：DBEAFC</p><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>后序遍历可以记为左右根<br><br>后序遍历二叉树的规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）后序遍历左子树</span><br><span class="line">（2）后序遍历右子树</span><br><span class="line">（3）访问根节点</span><br></pre></td></tr></table></figure></p><p>后序遍历的输出顺序：DEBFCA</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-线性回归</title>
      <link href="/2018/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
      <url>/2018/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>机器学习-线性回归 </p><a id="more"></a><h3 id="LR模型"><a href="#LR模型" class="headerlink" title="LR模型"></a>LR模型</h3><p>每个特征变量可以首先映射到⼀一个函数，然后再参与线性计算,模型如下：</p><script type="math/tex; mode=display">y = \theta_0 + \theta_1x_1 + \theta_2x_2 + · · · + \theta_nx_n</script><p>其中$ x_1,x_2,…,x_n$表示自变量（特征分量），$y$表示因变量，$\theta$是权重，$\theta_0$是偏移项（截距）;$\theta_i$越大，说明$x_i$对$y$结果的影响越⼤<br>输入空间映射到特征空间(映射函数$\phi(x)$)，建模.为</p><script type="math/tex; mode=display">h_\theta(x)=\theta^T\phi(x)</script><p>特征映射相关技术，包括特征哈希、特征学习、Kernel等</p><h3 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h3><p>预测值$ h_\theta(x)$与真实值$y$之差越小越好，加入损失函数(<strong>平方损失函数</strong>):</p><script type="math/tex; mode=display">J(\theta)={0.5}\sum_{i=1}^{n}{(h_\theta(x^i)-y^i)^2}</script><p>求$min{J(\theta)}$<br>损失函数就是$x^i$的预测值$h_\theta(x^i)$与真实值$y^i$之差的平方和</p><blockquote><p>回归模型（尤其是线性回归类）的⽬目标函数通常⽤用平⽅方损失函数来作为优化的⽬目标函数<br></p></blockquote><p>为什么用<strong>误差平方和</strong>作为目标函数：</p><blockquote><p>根据中⼼心极限定理理，把那些对结果影响⽐比较⼩小的变量量（假设独⽴立同分布）之和认为服从正态分布是合理理的</p></blockquote><p>如果数据是<strong>高斯分布</strong>的，输入值$x^i$，预测值$\theta^Tx^i$，真实值$y^i$，误差$\epsilon^{i}$，线性模型为，</p><script type="math/tex; mode=display">y^i=\theta^Tx^i+\epsilon^{i}</script><p>根据中心极限定理，认为变量之和服从高斯分布,即</p><script type="math/tex; mode=display">e^{i} = y^i-\theta^Tx^i</script><p>则，x,y的条件概率为</p><script type="math/tex; mode=display">p(y^i|x^i;\theta) = \frac{1}{\sqrt{2\pi}\sigma}exp(-\frac{(y^i-\theta^Tx^i)^2}{2\sigma^2})</script><p>$p(y^i|x^i;\theta)$越大，证明越接近真实值，还要考虑拟合过度以及模型的泛化能力问题</p><p>优化目标函数：使目标函数最小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">最小二乘法</span><br><span class="line">梯度下降法</span><br><span class="line">    批量梯度下降法</span><br><span class="line">    随机梯度下降法</span><br><span class="line">拉格朗日乘子法</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.nos-eastchina1.126.net/min2cheng.png" alt></p><p>例子</p><script type="math/tex; mode=display">\begin{bmatrix}{a_{11}}&{a_{12}}&{\cdots}&{a_{1n}}\\{a_{21}}&{a_{22}}&{\cdots}&{a_{2n}}\\{\vdots}&{\vdots}&{\ddots}&{\vdots}\\{a_{m1}}&{a_{m2}}&{\cdots}&{a_{mn}}\\\end{bmatrix}</script>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-正则化-L1L2</title>
      <link href="/2018/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%AD%A3%E5%88%99%E5%8C%96-L1L2/"/>
      <url>/2018/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%AD%A3%E5%88%99%E5%8C%96-L1L2/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>机器学习-正则化-L1L2</p><a id="more"></a><p>样本数据量大：经验⻛风险最⼩小化</p><p>样本数据量小：结构⻛风险最⼩小化==正则化</p><p>经验风险最⼩小化（empirical risk minimization）认为经验⻛风险最⼩小的模型是最优的模型，即求解最优化问题</p><script type="math/tex; mode=display">minf ∈ F(1/N)\sum_{i=1}^NL(y_i,f(x_i))</script><p>样本容量量⾜足够⼤大的时候，经验⻛风险最⼩小化学习效果良好</p><p>结构⻛风险=经验⻛风险+模型复杂度的正则化项（regularizer）或罚项（penalty term）</p><script type="math/tex; mode=display">minf ∈ F(1/N)\sum_{i=1}^NL(y_i,f(x_i))+\lambda{J(f)}</script><p>$J(f)$是模型的复杂度，模型$f$越复杂，复杂度$J(f)$越大。<br>$\lambda ≥ 0$是系数，⽤用以权衡经验⻛风险和模型复杂度。</p><blockquote><p>结构风险⼩需要1、经验风险和2、模型复杂度同时⼩</p></blockquote><h3 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h3><p>因为非负性：可以做损失函数，正则项</p><blockquote><p>损失函数通常是⼀个有下确界的函数</p></blockquote><p>常用范数：<br>L0</p><p>L1:绝对值</p><script type="math/tex; mode=display">||x||=\sum_{i=1}^{d}{|x_i|}</script><p>L2；平方再开根号</p><script type="math/tex; mode=display">||x||_2=(\sum_{i=1}^{d}{|x_i^2|})^{1/2}</script><p>Lp</p><script type="math/tex; mode=display">||x||_2=(\sum_{i=1}^{d}{|x_i^p|})^{1/p}</script><p>p=1,曼哈顿距离，L1范数，表示某个向量量中所有元素绝对值的和<br><br>p=2,欧式距离，L2范数</p><p>使用L1正则项，倾向于使参数稀疏化，使用L2正则项，使参数稠密的接近于0。<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/L1L21.png" alt><br>L1正则是菱形，参数的交点都落在坐标轴上，实现稀疏化。<br>L2是圆形，</p><blockquote><p>正则项是为了降低模型的复杂度，从而避免模型区过分拟合训练数据，包括噪声与异常点（outliers）。从另一个角度上来讲，正则化即是假设模型参数服从先验概率，即为模型参数添加先验，只是不同的正则化方式的先验分布是不一样的。这样就规定了参数的分布，使得模型的复杂度降低（试想一下，限定条件多了，是不是模型的复杂度降低了呢），这样模型对于噪声与异常点的抗干扰性的能力增强，从而提高模型的泛化能力。还有个解释便是，从贝叶斯学派来看：加了先验，在数据少的时候，先验知识可以防止过拟合；从频率学派来看：正则项限定了参数的取值，从而提高了模型的稳定性，而稳定性强的模型不会过拟合，即控制模型空间。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_分类_KNN_EM</title>
      <link href="/2018/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_KNN_EM/"/>
      <url>/2018/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_KNN_EM/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>机器学习_分类_KNN_EM</p><a id="more"></a><h3 id="K最近邻-kNN，k-NearestNeighbor-分类算法"><a href="#K最近邻-kNN，k-NearestNeighbor-分类算法" class="headerlink" title="K最近邻(kNN，k-NearestNeighbor)分类算法"></a>K最近邻(kNN，k-NearestNeighbor)分类算法</h3><p>在KNN中，通过计算对象间距离来作为各个对象之间的非相似性指标，避免了对象之间的匹配问题，在这里距离一般使用欧氏距离或曼哈顿距离：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">步骤：</span><br><span class="line">其算法的描述为：</span><br><span class="line"></span><br><span class="line">1）计算测试数据与各个训练数据之间的距离；</span><br><span class="line"></span><br><span class="line">2）按照距离的递增关系进行排序；</span><br><span class="line"></span><br><span class="line">3）选取距离最小的K个点；</span><br><span class="line"></span><br><span class="line">4）确定前K个点所在类别的出现频率；</span><br><span class="line"></span><br><span class="line">5）返回前K个点中出现频率最高的类别作为测试数据的预测分类。</span><br></pre></td></tr></table></figure><p>KNN算法的优点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1）简单、有效。 </span><br><span class="line">2）重新训练的代价较低（类别体系的变化和训练集的变化，在Web环境和电子商务应用中是很常见的）。 </span><br><span class="line">3）计算时间和空间线性于训练集的规模（在一些场合不算太大）。 </span><br><span class="line">4）由于KNN方法主要靠周围有限的邻近的样本，而不是靠判别类域的方法来确定所属类别的，因此对于类域的交叉或重叠较多的待分样本集来说，KNN方法较其他方法更为适合。 </span><br><span class="line">5）该算法比较适用于样本容量比较大的类域的自动分类，而那些样本容量较小的类域采用这种算法比较容易产生误分。</span><br></pre></td></tr></table></figure></p><p>KNN算法缺点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1）KNN算法是懒散学习方法（lazy learning,基本上不学习），一些积极学习的算法要快很多。 </span><br><span class="line">2）类别评分不是规格化的（不像概率评分）。 </span><br><span class="line">3）输出的可解释性不强，例如决策树的可解释性较强。 </span><br><span class="line">4）该算法在分类时有个主要的不足是，当样本不平衡时，如一个类的样本容量很大，而其他类样本容量很小时，有可能导致当输入一个新样本时，该样本的K个邻居中大容量类的样本占多数。该算法只计算“最近的”邻居样本，某一类的样本数量很大，那么或者这类样本并不接近目标样本，或者这类样本很靠近目标样本。无论怎样，数量并不能影响运行结果。可以采用权值的方法（和该样本距离小的邻居权值大）来改进。 </span><br><span class="line">5）计算量较大。目前常用的解决方法是事先对已知样本点进行剪辑，事先去除对分类作用不大的样本。</span><br></pre></td></tr></table></figure><h3 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h3><p>EM的策略就是先随便给一个条件概率p1(x1|thera)，然后找到一个l(thera)的下界函数r(x1|thera),求r的最大值p2(x2|thera)，再找到经过p2点的下界函数r2(x2|thera)，重复该过程直到收敛到局部最大值。</p><p>灰度图分割：<a href="https://blog.csdn.net/u014612806/article/details/65442061" target="_blank" rel="noopener">参考</a></p><p>point.h文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#ifndef POINT_H</span><br><span class="line">#define POINT_H</span><br><span class="line">//point结构主要用来存储图像中节点的横坐标，纵坐标以及灰度值</span><br><span class="line">struct point</span><br><span class="line">&#123;</span><br><span class="line">    int row;</span><br><span class="line">    int col;</span><br><span class="line">    double pixVal;</span><br><span class="line">    point(int row, int col, double pixVal) :row(row),col(col),pixVal(pixVal) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>keams.h头文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line">#ifndef KMEANS_H</span><br><span class="line">#define KMEANS_H</span><br><span class="line"></span><br><span class="line">#include&lt;opencv2\opencv.hpp&gt;</span><br><span class="line">#include&lt;random&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&quot;point.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Kmeans&#123;</span><br><span class="line">private:</span><br><span class="line">    //存储所有点</span><br><span class="line">    vector&lt;point&gt; points;</span><br><span class="line">    //存储簇的中心点</span><br><span class="line">    vector&lt;point&gt; centers;</span><br><span class="line">    //存储每个点到相应的簇</span><br><span class="line">    vector&lt;point&gt;* clusters;</span><br><span class="line">    //向量的维数</span><br><span class="line">    int dimension;</span><br><span class="line">    //簇的个数</span><br><span class="line">    int k;</span><br><span class="line">public:</span><br><span class="line">    //构造函数</span><br><span class="line">    Kmeans(vector&lt;point&gt; points, vector&lt;point&gt; centers, int k, int dimension)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;points = points;</span><br><span class="line">        this-&gt;centers = centers;</span><br><span class="line">        this-&gt;dimension = dimension;</span><br><span class="line">        this-&gt;k = k;</span><br><span class="line">        clusters = new vector&lt;point&gt;[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //析构函数</span><br><span class="line">    ~Kmeans()</span><br><span class="line">    &#123;</span><br><span class="line">        delete clusters;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取簇</span><br><span class="line">    vector&lt;point&gt;* getClusters()</span><br><span class="line">    &#123;</span><br><span class="line">        return this-&gt;clusters;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //计算两个向量之间的欧式距离</span><br><span class="line">    double getDistanceBetweenTwoPoints(const point&amp; point1, const point&amp; point2)</span><br><span class="line">    &#123;</span><br><span class="line">        double sum = 0;</span><br><span class="line">        //double tmp;</span><br><span class="line">        //for (int i = 0; i &lt; dimension; i++)</span><br><span class="line">        //&#123;</span><br><span class="line">        //tmp = pow(point1.pixVal - point2.pixVal,2);</span><br><span class="line">        //sum += tmp;</span><br><span class="line">        //&#125;</span><br><span class="line">        sum = pow(point1.pixVal - point2.pixVal, 2);</span><br><span class="line">        return sqrt(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //计算每个点到离它最近的簇中心点，结果保存到vector中</span><br><span class="line">    vector&lt;int&gt; getClosetClusterCenterLabel()</span><br><span class="line">    &#123;</span><br><span class="line">        double min;</span><br><span class="line">        int label;</span><br><span class="line">        vector&lt;int&gt; labels;</span><br><span class="line">        for (int i = 0; i &lt; points.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            label = 0;</span><br><span class="line">            min = getDistanceBetweenTwoPoints(points[i], centers[0]);</span><br><span class="line">            for (int j = 1; j &lt; centers.size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                double tmp = getDistanceBetweenTwoPoints(points[i], centers[j]);</span><br><span class="line">                if (tmp &lt; min)</span><br><span class="line">                &#123;</span><br><span class="line">                    min = tmp;</span><br><span class="line">                    label = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            labels.push_back(label);</span><br><span class="line">        &#125;</span><br><span class="line">        return labels;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将每个点放入它离的最近的中心点对应的簇中</span><br><span class="line">    void computeClusters(const vector&lt;int&gt;&amp; labels)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            clusters[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; labels.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int label = labels[i];</span><br><span class="line">            clusters[label].push_back(points[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //重新计算所有簇的中心点的灰度值</span><br><span class="line">    void computeCenters()</span><br><span class="line">    &#123;</span><br><span class="line">        centers.clear();</span><br><span class="line">        for (int i = 0; i &lt; k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            double sum = 0;</span><br><span class="line">            for (int j = 0; j &lt; clusters[i].size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += clusters[i][j].pixVal;</span><br><span class="line">            &#125;</span><br><span class="line">            double meanVal = sum / clusters[i].size();</span><br><span class="line">            point cp(-1, -1, meanVal);</span><br><span class="line">            centers.push_back(cp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //确定新的中心点后重新计算一次cost</span><br><span class="line">    double computeCost()</span><br><span class="line">    &#123;</span><br><span class="line">        double sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;point&gt; tmpVec=clusters[i];</span><br><span class="line">            for (int j = 0; j &lt; tmpVec.size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += getDistanceBetweenTwoPoints(tmpVec[j], centers[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum / points.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //迭代执行k-means算法的步骤</span><br><span class="line">    void kmeans()</span><br><span class="line">    &#123;</span><br><span class="line">        double oldCost, newCost;</span><br><span class="line">        vector&lt;int&gt; labels=getClosetClusterCenterLabel();</span><br><span class="line">        computeClusters(labels);</span><br><span class="line">        newCost = computeCost();</span><br><span class="line"></span><br><span class="line">        computeCenters();</span><br><span class="line">        labels = getClosetClusterCenterLabel();</span><br><span class="line">        computeClusters(labels);</span><br><span class="line">        oldCost = newCost;</span><br><span class="line">        newCost = computeCost();</span><br><span class="line"></span><br><span class="line">        while (oldCost != newCost)</span><br><span class="line">        &#123;</span><br><span class="line">            oldCost = newCost;</span><br><span class="line">            computeCenters();</span><br><span class="line">            labels = getClosetClusterCenterLabel();</span><br><span class="line">            computeClusters(labels);</span><br><span class="line">            newCost = computeCost();</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt;&quot;Final Cost: &quot;&lt;&lt; newCost &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>测试的kmeans.cpp文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;kmeans.h&quot;</span><br><span class="line">//图片的存放位置</span><br><span class="line">const String imageFolder = &quot;F:\\&quot;;</span><br><span class="line">//簇的个数（即k的大小，根据自己需要调整）</span><br><span class="line">const int numOfCluster =4;</span><br><span class="line">//最大像素值</span><br><span class="line">const int MAX_PIX_VALUE = 255;</span><br><span class="line">//存放所有点</span><br><span class="line">vector&lt;point&gt; points;</span><br><span class="line">//存放所有簇中心</span><br><span class="line">vector&lt;point&gt; centers;</span><br><span class="line">//存放所有点颜色特征(i,j)-&gt;i*rows+j</span><br><span class="line">vector&lt;double&gt; pixVec;</span><br><span class="line"></span><br><span class="line">//读取图像</span><br><span class="line">Mat readImage(String imageName)</span><br><span class="line">&#123;</span><br><span class="line">    String imageLoc = imageFolder + imageName;</span><br><span class="line">    Mat image=imread(imageLoc);</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//初始化k-means聚类中心</span><br><span class="line">void initializeCenters(const Mat&amp; img)</span><br><span class="line">&#123;</span><br><span class="line">    srand((unsigned)time(NULL));</span><br><span class="line">    for (int i = 0; i &lt; numOfCluster; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int randomX = rand() % img.rows;</span><br><span class="line">        int randomY = rand() % img.cols;</span><br><span class="line">        uchar pixVal = img.at&lt;uchar&gt;(randomX, randomY);</span><br><span class="line">        point cp(randomX, randomY, (double)pixVal);</span><br><span class="line">        centers.push_back(cp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将图像中的所有点装入points中</span><br><span class="line">void initializePoints(const Mat&amp; img)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; img.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        const uchar* data = img.ptr&lt;uchar&gt;(i);</span><br><span class="line">        for (int j = 0; j &lt; img.cols; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            uchar pixVal = data[j];</span><br><span class="line">            point p(i,j, (double)pixVal);</span><br><span class="line">            points.push_back(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    String imageName = &quot;lena.jpg&quot;;</span><br><span class="line">    Mat img = readImage(imageName);</span><br><span class="line">    cvtColor(img, img, CV_RGB2GRAY);//转化为灰度图像</span><br><span class="line">    namedWindow(imageName,WINDOW_NORMAL);</span><br><span class="line">    imshow(imageName, img);</span><br><span class="line">    waitKey(0);</span><br><span class="line">    int rows = img.rows;</span><br><span class="line">    int cols = img.cols;</span><br><span class="line">    initializeCenters(img);</span><br><span class="line">    initializePoints(img);</span><br><span class="line">    Kmeans* km=new Kmeans(points, centers, numOfCluster, 1);</span><br><span class="line">    cout &lt;&lt; &quot;---------------k-means start-------------&quot; &lt;&lt; endl;</span><br><span class="line">    km-&gt;kmeans();</span><br><span class="line">    cout &lt;&lt; &quot;---------------k-means end---------------&quot; &lt;&lt;endl;</span><br><span class="line">    vector&lt;point&gt;* clusters = km-&gt;getClusters();</span><br><span class="line">    Mat res(img.rows,img.cols,img.type());</span><br><span class="line">    double div = MAX_PIX_VALUE / numOfCluster;</span><br><span class="line">    for (int i = 0; i &lt; numOfCluster; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;point&gt; tmpVec = clusters[i];</span><br><span class="line">        for (int j = 0; j &lt; tmpVec.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.at&lt;uchar&gt;(tmpVec[j].row, tmpVec[j].col) = i*div;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    namedWindow(&quot;kmeansResult&quot;,WINDOW_NORMAL);</span><br><span class="line">    imshow(&quot;kmeansResult&quot;, res);</span><br><span class="line">    waitKey(0);</span><br><span class="line">    imwrite(&quot;./segment_lena.jpg&quot;, res);</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>彩色图像分割：<a href="https://blog.csdn.net/owen7500/article/details/51604906" target="_blank" rel="noopener">参考</a></p><p>主函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;clusterImagePixels.hpp&quot;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Mat testImage = imread(&quot;E:\\testImage\\board.jpg&quot;);</span><br><span class="line">if (testImage.empty())</span><br><span class="line">&#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ClusterPixels clusterPix(testImage,3);</span><br><span class="line"> </span><br><span class="line">Mat colorResults = clusterPix.clusterColorImageByKmeans();</span><br><span class="line">Mat grayResult = clusterPix.clusterGrayImageByKmeans();</span><br><span class="line"> </span><br><span class="line">if (!colorResults.empty())</span><br><span class="line">&#123;</span><br><span class="line">hconcat(testImage, colorResults, colorResults);</span><br><span class="line">imshow(&quot;clusterImage&quot;, colorResults);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">if (!grayResult.empty())</span><br><span class="line">&#123;</span><br><span class="line">hconcat(testImage, grayResult, grayResult);</span><br><span class="line">imshow(&quot;grayCluster&quot;, grayResult);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">if (waitKey() == 27)</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;opencv.hpp&gt;</span><br><span class="line">using namespace cv;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Scalar colorTab[] =     //10个颜色</span><br><span class="line">&#123;</span><br><span class="line">Scalar(0, 0, 255),</span><br><span class="line">Scalar(0, 255, 0),</span><br><span class="line">Scalar(255, 100, 100),</span><br><span class="line">Scalar(255, 0, 255),</span><br><span class="line">Scalar(0, 255, 255),</span><br><span class="line">Scalar(255, 0, 0),</span><br><span class="line">Scalar(255, 255, 0),</span><br><span class="line">Scalar(255, 0, 100),</span><br><span class="line">Scalar(100, 100, 100),</span><br><span class="line">Scalar(50, 125, 125)</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">class ClusterPixels</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">Mat image;//待聚类图像</span><br><span class="line">Mat labels;//聚类后的标签</span><br><span class="line">int clusterCounts;//分类数,不得大于10，只是颜色定义只有10类，并不是算法限制</span><br><span class="line"> </span><br><span class="line">public:</span><br><span class="line">ClusterPixels() :clusterCounts(0)&#123;&#125;</span><br><span class="line">ClusterPixels(const Mat&amp; src, int clusters = 5) :clusterCounts(clusters)&#123; image = src.clone(); &#125;</span><br><span class="line"> </span><br><span class="line">void setImage(const Mat&amp; src)&#123; image = src.clone(); &#125;;</span><br><span class="line">void setClusters(int clusters)&#123; clusterCounts = clusters; &#125;</span><br><span class="line"> </span><br><span class="line">Mat getLabels()&#123;return labels;&#125;;//返回聚类后的标签</span><br><span class="line"> </span><br><span class="line">Mat clusterGrayImageByKmeans()</span><br><span class="line">&#123;</span><br><span class="line">//转换成灰度图</span><br><span class="line">if (image.channels() != 1)</span><br><span class="line">cvtColor(image, image, COLOR_BGR2GRAY);</span><br><span class="line"> </span><br><span class="line">int rows = image.rows;</span><br><span class="line">int cols = image.cols;</span><br><span class="line"></span><br><span class="line">//保存聚类后的图片</span><br><span class="line">Mat clusteredMat(rows, cols, CV_8UC3);</span><br><span class="line">clusteredMat.setTo(Scalar::all(0));</span><br><span class="line"> </span><br><span class="line">Mat pixels(rows*cols, 1, CV_32FC1);//pixels用于保存所有的灰度像素</span><br><span class="line"> </span><br><span class="line">for (int i = 0; i &lt; rows;++i)</span><br><span class="line">&#123;</span><br><span class="line">const uchar *idata = image.ptr&lt;uchar&gt;(i);</span><br><span class="line">float *pdata = pixels.ptr&lt;float&gt;(0);</span><br><span class="line">for (int j = 0; j &lt; cols;++j)</span><br><span class="line">&#123;</span><br><span class="line">pdata[i*cols + j] = idata[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">kmeans(pixels, clusterCounts, labels, TermCriteria(TermCriteria::EPS + TermCriteria::MAX_ITER, 10, 0), 5, KMEANS_PP_CENTERS);</span><br><span class="line"> </span><br><span class="line">for (int i = 0; i &lt; rows;++i)</span><br><span class="line">&#123;</span><br><span class="line">for (int j = 0; j &lt; cols;++j)</span><br><span class="line">&#123;</span><br><span class="line">circle(clusteredMat, Point(j,i), 1, colorTab[labels.at&lt;int&gt;(i*cols + j)]);//标记像素点的类别，颜色区分</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">return clusteredMat;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Mat clusterColorImageByKmeans()</span><br><span class="line">&#123;</span><br><span class="line">assert(image.channels() != 1);</span><br><span class="line"> </span><br><span class="line">int rows = image.rows;</span><br><span class="line">int cols = image.cols;</span><br><span class="line">int channels = image.channels();</span><br><span class="line"> </span><br><span class="line">//保存聚类后的图片</span><br><span class="line">Mat clusteredMat(rows, cols, CV_8UC3);</span><br><span class="line">clusteredMat.setTo(Scalar::all(0));</span><br><span class="line"> </span><br><span class="line">Mat pixels(rows*cols, 1, CV_32FC3);//pixels用于保存所有的灰度像素</span><br><span class="line">pixels.setTo(Scalar::all(0));</span><br><span class="line"> </span><br><span class="line">for (int i = 0; i &lt; rows; ++i)</span><br><span class="line">&#123;</span><br><span class="line">const uchar *idata = image.ptr&lt;uchar&gt;(i);</span><br><span class="line">float *pdata = pixels.ptr&lt;float&gt;(0);</span><br><span class="line"> </span><br><span class="line">for (int j = 0; j &lt; cols*channels; ++j)</span><br><span class="line">&#123;</span><br><span class="line">pdata[i*cols*channels + j] = saturate_cast&lt;float&gt;(idata[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">kmeans(pixels, clusterCounts, labels, TermCriteria(CV_TERMCRIT_EPS + CV_TERMCRIT_ITER, 10, 0), 5, KMEANS_PP_CENTERS);</span><br><span class="line"> </span><br><span class="line">for (int i = 0; i &lt; rows; ++i)</span><br><span class="line">&#123;</span><br><span class="line">for (int j = 0; j &lt; cols*channels; j += channels)</span><br><span class="line">&#123;</span><br><span class="line">circle(clusteredMat, Point(j/channels,i), 1, colorTab[labels.at&lt;int&gt;(i*cols + (j/channels))]);//标记像素点的类别，颜色区分</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">return clusteredMat;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>opencv3代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;opencv2\opencv.hpp&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace cv::ml;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Mat img = imread(&quot;E:/opencv/opencv/sources/samples/data/digits.png&quot;);</span><br><span class="line">    Mat gray;</span><br><span class="line">    cvtColor(img, gray, CV_BGR2GRAY);</span><br><span class="line">    int b = 20;</span><br><span class="line">    int m = gray.rows / b;   //原图为1000*2000</span><br><span class="line">    int n = gray.cols / b;   //裁剪为5000个20*20的小图块</span><br><span class="line">    Mat data,labels;   //特征矩阵</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int offsetCol = i*b; //列上的偏移量</span><br><span class="line">        for (int j = 0; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            int offsetRow = j*b;  //行上的偏移量</span><br><span class="line">            //截取20*20的小块</span><br><span class="line">            Mat tmp;</span><br><span class="line">            gray(Range(offsetRow, offsetRow + b), Range(offsetCol, offsetCol + b)).copyTo(tmp);</span><br><span class="line">            data.push_back(tmp.reshape(0,1));  //序列化后放入特征矩阵</span><br><span class="line">            labels.push_back((int)j / 5);  //对应的标注</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    data.convertTo(data, CV_32F); //uchar型转换为cv_32f</span><br><span class="line">    int samplesNum = data.rows;</span><br><span class="line">    int trainNum = 3000;</span><br><span class="line">    Mat trainData, trainLabels;</span><br><span class="line">    trainData = data(Range(0, trainNum), Range::all());   //前3000个样本为训练数据</span><br><span class="line">    trainLabels = labels(Range(0, trainNum), Range::all());</span><br><span class="line"></span><br><span class="line">    //使用KNN算法</span><br><span class="line">    int K = 5;</span><br><span class="line">    Ptr&lt;TrainData&gt; tData = TrainData::create(trainData, ROW_SAMPLE, trainLabels);</span><br><span class="line">    Ptr&lt;KNearest&gt; model = KNearest::create();</span><br><span class="line">    model-&gt;setDefaultK(K);</span><br><span class="line">    model-&gt;setIsClassifier(true);</span><br><span class="line">    model-&gt;train(tData);</span><br><span class="line"></span><br><span class="line">    //预测分类</span><br><span class="line">    double train_hr = 0, test_hr = 0;</span><br><span class="line">    Mat response;</span><br><span class="line">    // compute prediction error on train and test data</span><br><span class="line">    for (int i = 0; i &lt; samplesNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Mat sample = data.row(i);</span><br><span class="line">        float r = model-&gt;predict(sample);   //对所有行进行预测</span><br><span class="line">        //预测结果与原结果相比，相等为1，不等为0</span><br><span class="line">        r = std::abs(r - labels.at&lt;int&gt;(i)) &lt;= FLT_EPSILON ? 1.f : 0.f;          </span><br><span class="line"></span><br><span class="line">        if (i &lt; trainNum)</span><br><span class="line">            train_hr += r;  //累积正确数</span><br><span class="line">        else</span><br><span class="line">            test_hr += r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    test_hr /= samplesNum - trainNum;</span><br><span class="line">    train_hr = trainNum &gt; 0 ? train_hr / trainNum : 1.;</span><br><span class="line"></span><br><span class="line">    printf(&quot;accuracy: train = %.1f%%, test = %.1f%%\n&quot;,</span><br><span class="line">        train_hr*100., test_hr*100.);</span><br><span class="line">    waitKey(0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大佬终极面经</title>
      <link href="/2018/07/19/%E5%A4%A7%E4%BD%AC%E7%BB%88%E6%9E%81%E9%9D%A2%E7%BB%8F/"/>
      <url>/2018/07/19/%E5%A4%A7%E4%BD%AC%E7%BB%88%E6%9E%81%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>大佬终极面经</p><a id="more"></a><p>作者：非理性的猫<br>链接：<a href="https://www.nowcoder.com/discuss/92930" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/92930</a><br>来源：牛客网</p><p>去年秋招在准备求职算法岗的过程中，经过一整个秋招的努力，拿了蚂蚁金服、滴滴、宜信大数据、美图几个厂的算法offer，这中间我参考了牛客网很多大神的经验，自己总结了一些经验，写成这篇文章。</p><p>一个完整的机器学习工程师的面试过程主要有以下这些环节：自我介绍、项目介绍、算法推导和解释、数据结构与算法题（写代码）。</p><p>关于自我介绍，主要就是简单介绍下自己的教育背景，在校期间的研究方向和所做的项目以及在项目中所充当的角色等等，为之后的面试做个铺垫，让面试官从中捕捉点来问。</p><p>项目介绍是最为重要的，这也是体现你综合实力的地方，对项目背景、项目实现的方案，项目所实现的东西都要了如指掌，做机器学习的，必然需要准备一到两个重点的机器学习项目，可以是比赛，也可以是实验室项目，关键是项目中间的技术细节都要了如指掌，比如你用了树模型，就得知道所有树模型相关的推导和原理，决不能含糊，一旦你说不太清楚，面试官就会对项目的真实性存疑。参加比赛应该是没有实验室项目的同学最佳的积累经验的途径，比较好的比赛平台有Kaggle、天池大数据、datacastle等</p><p>接下来就是机器学习算法原理和推导，这也是要重点去准备的，在面试前得达到，给你一张白纸，你可以把推导的每一步写的清清楚楚的，推导的话面试常考逻辑回归和SVM的推导，关于原理面试官常会问你几个树模型之间的对比等等等，其他的算法比如LR、SVM、EM、Adaboost、PageRank、 FFM、决策树，随机森林， GBDT ， XGBoost 、推荐算法、聚类、CNN、RNN、LSTM、Word2Vec等等，以及他们的适用场景，再如一些机器学习的理论，非平衡问题、过拟合问题，交叉验证问题，模型选择问题，模型融合问题。这一部分我会在文末贴出一个问题集锦，大家按照这个去准备就行。还有必看的书李航的《统计学习方法》、周志华的《机器学习》、项亮的《推荐系统实践》</p><p>最后就是写代码了，很多非计算机出身的大都会栽在这个地方，代码写得少，训练不到位，就会导致当场思路不清晰，不知从哪写起，但目前市面上已经有很多专门为这块总结的一些书籍，推荐使用《剑指offer》、《王道程序员求职宝典》等等，有时间的话再刷一下leetcode。排序算法、查找算法、二叉树遍历这些最基本的一定要很顺溜的写下来，其他的就看自己去拓展了，同样的，我也总结了一些笔记供大家参考，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">机器学习</span><br><span class="line">机器学习算法系列（40）：机器学习中的数据清洗与特征处理综述</span><br><span class="line">机器学习算法系列（39）：实例详解机器学习如何解决问题</span><br><span class="line">机器学习算法系列（38）：外卖订单量预测异常报警模型实践</span><br><span class="line">机器学习算法系列（37）：外卖O2O的用户画像实践</span><br><span class="line">机器学习算法系列（36）：GBDT算法原理深入解析</span><br><span class="line">机器学习算法系列（35）：使用Sklearn进行集成学习（实践）</span><br><span class="line">机器学习算法系列（34）：使用Sklearn进行集成学习（理论）</span><br><span class="line">机器学习算法系列（33）：特征处理（Feature Processing）</span><br><span class="line">机器学习算法系列（32）：MapReduce执行流程详解</span><br><span class="line">机器学习算法系列（31）：在线最优化求解（online Optimization）</span><br><span class="line">机器学习算法系列（30）：Scikit-Learn总结</span><br><span class="line">机器学习算法系列（29）：Sparsity and Some Basics of L1 Regularization</span><br><span class="line">机器学习算法系列（28）：L1、L2正则化</span><br><span class="line">机器学习算法系列（27）：Isolation Forest</span><br><span class="line">机器学习算法系列（26）：因子分解机（FM）与场感知分解机（FFM）</span><br><span class="line">机器学习算法系列（24）：机器学习中的损失函数</span><br><span class="line">机器学习算法系列（25）：最速下降法、牛顿法、拟牛顿法</span><br><span class="line">机器学习算法系列（23）：TF-IDF与余弦相似度</span><br><span class="line">机器学习算法系列（22）：主成分分析</span><br><span class="line">机器学习算法系列（21）：SVD</span><br><span class="line">机器学习算法系列（20）：机器学习模型优化四要素</span><br><span class="line">机器学习算法系列（19）：机器学习性能评价指标</span><br><span class="line">机器学习算法系列（18）：方差偏差权衡（Bias-Variance Tradeoff）</span><br><span class="line">机器学习算法系列（17）：非平衡数据处理</span><br><span class="line">机器学习算法系列（16）：统计学习概论</span><br><span class="line">机器学习算法系列（15）：EM算法</span><br><span class="line">机器学习算法系列（14）：关联分析</span><br><span class="line">机器学习算法系列（13）：推荐系统（3）—矩阵分解技术</span><br><span class="line">机器学习算法系列（13）：推荐系统（2）—基于领域的协同过滤</span><br><span class="line">机器学习算法系列（13）：推荐系统（1）—简介</span><br><span class="line">机器学习算法系列（12）：SVM（4）—SMO</span><br><span class="line">机器学习算法系列（12）：SVM（3）—非线性支持向量机</span><br><span class="line">机器学习算法系列（12）：SVM（2）—线性支持向量机</span><br><span class="line">机器学习算法系列（12）：SVM（1）—线性可分支持向量机</span><br><span class="line">机器学习算法系列（11）：聚类（4）—密度最大值聚类</span><br><span class="line">机器学习算法系列（11）：聚类（3）—DBSCAN</span><br><span class="line">机器学习算法系列（11）：聚类（2）—Kmeans</span><br><span class="line">机器学习算法系列（11）：聚类（1）—简介</span><br><span class="line">机器学习算法系列（10）：朴素贝叶斯</span><br><span class="line">机器学习算法系列（9）：感知机</span><br><span class="line">机器学习算法系列（8）：XgBoost</span><br><span class="line">机器学习算法系列（7）：GBDT</span><br><span class="line">机器学习算法系列（6）：AdaBoost</span><br><span class="line">机器学习算法系列（5）：随机森林</span><br><span class="line">机器学习算法系列（4）：决策树</span><br><span class="line">机器学习算法系列（3）：逻辑斯谛回归</span><br><span class="line">机器学习算法系列（2）：线性回归</span><br><span class="line">机器学习算法系列（1）：K近邻</span><br><span class="line"></span><br><span class="line">自然语言处理</span><br><span class="line">自然语言处理系列（10）：自然语言处理的发展与趋势</span><br><span class="line">自然语言处理系列（9）：DCNN</span><br><span class="line">自然语言处理系列（8）：RCNN</span><br><span class="line">自然语言处理系列（7）：TextCNN调参技巧</span><br><span class="line">自然语言处理系列（6）：TextCNN</span><br><span class="line">自然语言处理系列（5）：FastText</span><br><span class="line">自然语言处理系列（4）：深度学习解决大规模文本分类问题</span><br><span class="line">自然语言处理系列（3）：中文维基语料词向量训练</span><br><span class="line">自然语言处理系列（2）：Word2Vec</span><br><span class="line">自然语言处理系列（1）：词向量和语言模型</span><br><span class="line"></span><br><span class="line">深度学习</span><br><span class="line">深度学习系列（12）：pytorch实现卷积神经网络</span><br><span class="line">深度学习系列（11）：神经网络防止过拟合的方法</span><br><span class="line">深度学习系列（10）：DMC—卷积神经网络分享</span><br><span class="line">深度学习系列（9）：Batch Normalization</span><br><span class="line">深度学习系列（8）：激活函数</span><br><span class="line">深度学习系列（7）：神经网络的优化方法</span><br><span class="line">深度学习系列（6）：递归神经网络</span><br><span class="line">深度学习系列（5）：长短时记忆网络（LSTM）</span><br><span class="line">深度学习系列（4）：循环神经网络（RNN）</span><br><span class="line">深度学习系列（3）：卷积神经网络（CNN）</span><br><span class="line">深度学习系列（2）：神经网络MNIST实战</span><br><span class="line">深度学习系列（1）：神经网络与反向传播算法</span><br><span class="line"></span><br><span class="line">数据结构与算法</span><br><span class="line">数据结构与算法题解（11）：最长回文子串</span><br><span class="line">数据结构与算法题解（10）：0-1背包问题与部分背包问题</span><br><span class="line">数据结构与算法题解（9）：最长公共子序列和最长公共子串</span><br><span class="line">数据结构与算法题解（8）：KMP算法</span><br><span class="line">数据结构与算法题解（7）：最短编辑距离</span><br><span class="line">数据结构与算法题解（6）：重点掌握</span><br><span class="line">数据结构与算法题解（5）：剑指offer解题报告</span><br><span class="line">数据结构与算法题解（4）：二叉树题解</span><br><span class="line">数据结构与算法题解（3）：字符串题解</span><br><span class="line">数据结构与算法题解（2）：数组题解</span><br><span class="line">数据结构与算法题解（1）：链表题解</span><br><span class="line"></span><br><span class="line">数据结构与算法（19）：海量数据处理</span><br><span class="line">数据结构与算法（18）：倒排索引</span><br><span class="line">数据结构与算法（17）：simhash</span><br><span class="line">数据结构与算法（16）：一致性哈希</span><br><span class="line">数据结构与算法（15）：布隆过滤器</span><br><span class="line">数据结构与算法（14）：最短路算法</span><br><span class="line">数据结构与算法（13）：深度优先搜索和广度优先搜索</span><br><span class="line">数据结构与算法（12）：排序</span><br><span class="line">数据结构与算法（11）：哈希表</span><br><span class="line">数据结构与算法（10）：查找</span><br><span class="line">数据结构与算法（9）：Trie树</span><br><span class="line">数据结构与算法（8）：红黑树</span><br><span class="line">数据结构与算法（7）：数据库索引原理及优化</span><br><span class="line">数据结构与算法（6）：B树、B+树</span><br><span class="line">数据结构与算法（5）：AVL树</span><br><span class="line">数据结构与算法（4）：二叉查找树</span><br><span class="line">数据结构与算法（3）：二叉树</span><br><span class="line">数据结构与算法（2）：栈与队列</span><br><span class="line">数据结构与算法（1）：数组与链表</span><br><span class="line"></span><br><span class="line">Java</span><br><span class="line">Java学习笔记（12）：单例模式</span><br><span class="line">Java学习笔记（11）：进程与线程</span><br><span class="line">Java学习笔记（10）：QA</span><br><span class="line">Java学习笔记（9）：内部类、抽象类、接口</span><br><span class="line">Java学习笔记（8）：常用库类、向量与哈希</span><br><span class="line">Java学习笔记（7）：深入理解java异常处理机制</span><br><span class="line">Java学习笔记（6）：异常处理</span><br><span class="line">Java学习笔记（5）：static、final关键字和Object类</span><br><span class="line">Java学习笔记（4）：多态</span><br><span class="line">Java学习笔记（3）：继承、覆盖、重载</span><br><span class="line">Java学习笔记（2）：类与对象</span><br><span class="line">Java学习笔记（1）：语法基础</span><br><span class="line"></span><br><span class="line">Java集合学习手册（11）：Java HashMap源码全剖析</span><br><span class="line">Java集合学习手册（10）：hashCode方法与equal方法</span><br><span class="line">Java集合学习手册（9）：Java 集合对比</span><br><span class="line">Java集合学习手册（8）：Java 集合框架</span><br><span class="line">Java集合学习手册（7）：Java LinkedList</span><br><span class="line">Java集合学习手册（6）：Java ArrayList</span><br><span class="line">Java集合学习手册（5）：Java LinkedHashSet</span><br><span class="line">Java集合学习手册（4）：Java LinkedHashMap</span><br><span class="line">Java集合学习手册（3）：Java HashTable</span><br><span class="line">Java集合学习手册（2）：Java HashSet</span><br><span class="line">Java集合学习手册（1）：Java HashMap</span><br></pre></td></tr></table></figure><p>以下是我总结的机器学习提问集锦，大家可以在把所有算法过了一遍的基础上把一个个问题都仔细揣摩一遍，加强对算法的理解和延伸。</p><h3 id="SVM："><a href="#SVM：" class="headerlink" title="SVM："></a>SVM：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">简单介绍SVM（详细原理）：从分类平面，到求两类间的最大间隔，到转化为求间隔分之一，等优化问题，然后就是优化问题的解决办法，首先是用拉格拉日乘子把约束优化转化为无约束优化，对各个变量求导令其为零，得到的式子带入拉格朗日式子从而转化为对偶问题， 最后再利用SMO（序列最小优化）来解决这个对偶问题。svm里面的c有啥用</span><br><span class="line">SVM的推导，解释原问题和对偶问题，SVM原问题和对偶问题的关系，KKT限制条件，KKT条件用哪些，完整描述；软间隔问题，解释支持向量、核函数（哪个地方引入、画图解释高维映射，高斯核可以升到多少维，如何选择核函数），引入拉格朗日的优化方法的原因，最大的特点，损失函数解释，</span><br><span class="line">SVM与LR最大区别，LR和SVM对于outlier的敏感程度分析，逻辑回归与SVM的区别</span><br><span class="line">为什么要把原问题转换为对偶问题？因为原问题是凸二次规划问题，转换为对偶问题更加高效。为什么求解对偶问题更加高效？因为只用求解alpha系数，而alpha系数只有支持向量才非0，其他全部为0.alpha系数有多少个？样本点的个数</span><br><span class="line">加大训练数据量一定能提高SVM准确率吗？</span><br><span class="line">与感知器的联系和优缺点比较</span><br><span class="line">如何解决多分类问题、可以做回归吗，怎么做</span><br><span class="line">它与其他分类器对比的优缺点，它的速度</span><br><span class="line">机器学习有很多关于核函数的说法，核函数的定义和作用是什么？https://www.zhihu.com/question/24627666</span><br><span class="line">支持向量机(SVM)是否适合大规模数据？https://www.zhihu.com/question/19591450</span><br><span class="line">SVM和逻辑斯特回归对同一样本A进行训练，如果某类中增加一些数据点，那么原来的决策边界分别会怎么变化？https://www.zhihu.com/question/30123068</span><br><span class="line">各种机器学习的应用场景分别是什么？例如，k近邻,贝叶斯，决策树，svm，逻辑斯蒂回归和最大熵模型。https://www.zhihu.com/question/26726794</span><br><span class="line">Linear SVM 和 LR 有什么异同？https://www.zhihu.com/question/26768865</span><br></pre></td></tr></table></figure><h3 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LR推导（伯努利过程，极大似然，损失函数，梯度下降）有没有最优解？</span><br><span class="line">LR可以用核么？可以怎么用？l1和l2正则项是啥？lr加l1还是l2好？加哪个可以用核（加l2正则项，和svm类似，加l2正则项可以用核方便处理）</span><br><span class="line">LR可以用来处理非线性问题么？（还是lr啊 只不过是加了核的lr 这里加核是显式地把特征映射到高维 然后再做lr）怎么做？可以像SVM那样么？为什么？</span><br><span class="line">为什么LR需要归一化或者取对数，为什么LR把特征离散化后效果更好，为什么把特征组合之后还能提升，反正这些基本都是增强了特征的表达能力，或者说更容易线性可分吧</span><br><span class="line">美团技术团队《Logistic Regression 模型简介》https://tech.meituan.com/intro_to_logistic_regression.html</span><br><span class="line">SVM和logistic回归分别在什么情况下使用？https://www.zhihu.com/question/21704547</span><br><span class="line">逻辑斯蒂回归能否解决非线性分类问题？https://www.zhihu.com/question/29385169</span><br><span class="line">为什么LR可以用来做CTR预估？https://www.zhihu.com/question/23652394</span><br><span class="line">逻辑回归估计参数时的目标函数 （就是极大似然估计那部分），逻辑回归估计参数时的目标函数 （呵呵，第二次） 逻辑回归估计参数时的目标函数 如果加上一个先验的服从高斯分布的假设，会是什么样（天啦。我不知道，其实就是在后面乘一个东西，取log后就变成加一个东西，实际就变成一个正则项）</span><br><span class="line">逻辑回归估计参数时的目标函数逻辑回归的值表示概率吗？（值越大可能性越高，但不能说是概率）</span><br><span class="line">手推逻辑回归目标函数，正类是1，反类是-1，这里挖了个小坑，一般都是正例是1，反例是0的，他写的时候我就注意到这个坑了，然而写的太快又给忘了，衰，后来他提醒了一下，改了过来，就是极大似然函数的指数不一样，然后说我这里的面试就到这了。</span><br><span class="line">看没看过scikit-learn源码LR的实现？（回头看了一下是调用的liblinear，囧）</span><br><span class="line">为什么LR需要归一化或者取对数，为什么LR把特征离散化后效果更好，为什么把特征组合之后还能提升，反正这些基本都是增强了特征的表达能力，或者说更容易线性可分吧</span><br><span class="line">naive bayes和logistic regression的区别http://m.blog.csdn.net/blog/muye5/19409615</span><br><span class="line">LR为什么用sigmoid函数。这个函数有什么优点和缺点？为什么不用其他函数？sigmoid函数由那个指数族分布，加上二项分布导出来的。损失函数是由最大似然估计求出的。</span><br><span class="line">了解其他的分类模型吗，问LR缺点，LR怎么推导（当时我真没准备好，写不出来）写LR目标函数，目标函数怎么求最优解（也不会）讲讲LR的梯度下降，梯度下降有哪几种，逻辑函数是啥</span><br></pre></td></tr></table></figure><h3 id="L1和L2"><a href="#L1和L2" class="headerlink" title="L1和L2"></a>L1和L2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">L2正则化，为什么L2正则化可以防止过拟合？L1正则化是啥？</span><br><span class="line">深度学习里面怎么防止过拟合？（data aug；dropout；multi-task learning）如何防止过拟合，我跟他列举了4中主要防止过拟合方法：Early Stopping、数据集扩充、正则化法以及dropout，还详细跟他说了每种方法原理及使用的场景，并解释我在哪些项目里具体用到了这些方法，</span><br><span class="line">机器学习中使用「正则化来防止过拟合」到底是一个什么原理？为什么正则化项就可以防止过拟合？https://www.zhihu.com/question/20700829</span><br><span class="line">机器学习中常常提到的正则化到底是什么意思？https://www.zhihu.com/question/20924039</span><br><span class="line">什么是正则项，L1范式，L2范式区别是什么，各自用在什么地方？L1 与 L2 的区别以及如何解决 L1 求导困难；</span><br><span class="line">L1正则为什么能让系数变为0？L1正则怎么处理0点不可导的情形？（这个谁会？近端梯度下降）</span><br><span class="line">L0，L1，L2正则化(如果能推导绝对是加分项，一般人最多能画个等高线，L0是NP问题)其实上面的这些问题基本都能在《李航：统计学习方法》《周志华：机器学习》里面找到，能翻个4，5遍基本就无压力了</span><br><span class="line">避免过拟合策略、如何提高模型泛化能力、L1与L2正则区别，优缺点、生成式，判别式模型、深度学习这块了解多少、</span><br><span class="line">如何克服过拟合，欠拟合</span><br><span class="line">L1 与 L2 的区别以及如何解决 L1 求导困难；</span><br><span class="line">L1正则为什么可以把系数压缩成0，坐标下降法的具体实现细节</span><br><span class="line">为什么L1正则可以实现参数稀疏，而L2正则不可以？为什么L1很多系数可以被压缩为0，L2是被压缩至接近于0？</span><br><span class="line">树模型</span><br></pre></td></tr></table></figure><h3 id="决策树："><a href="#决策树：" class="headerlink" title="决策树："></a>决策树：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">rf ， gbdt 的区别； gbdt ， xgboost 的区别（烂大街的问题最好从底层原理去分析回答）</span><br><span class="line">介绍决策树，谈了3种决策树及其区别和适应场景</span><br><span class="line">决策树处理连续值的方法；简单介绍决策树几种算法，有什么区别？</span><br><span class="line">决策树基本模型介绍？决策树算法中缺失值怎么处理？决策树算法在应用中有什么值得注意的地方。SVM、LR、决策树的对比？GBDT 和 决策森林 的区别？决策树的特性？（3 ）决策树处理连续值的方法；</span><br><span class="line">解释下随机森林和gbdt的区别。gbdt的boosting体现在哪里。解释下随机森林节点的分裂策略，以及它和gbdt做分类有什么区别？哪个效果更好些？为什么？哪个更容易过拟合？为什么？ 问了随机森林的损失函数，和lr的优缺点对比， adaboost和随机森林的比较，为了防止随机森林过拟合可以怎么做，是否用过随机森林，怎么用的。</span><br><span class="line">随机森林和GBDT的区别？CART（回归树用平方误差最小化准则，分类树用基尼指数最小化准则）</span><br><span class="line">GBDT（利用损失函数的负梯度在当前模型的值作为回归问题提升树算法中的残差的近似值，拟合一个回归树）</span><br><span class="line">随机森林（Bagging+CART）</span><br><span class="line">SVM与随机森林比较</span><br><span class="line">改变随机森林的训练样本数据量，是否会影响到随机森林学习到的模型的复杂度</span><br><span class="line">Logistics与随机森林比较</span><br><span class="line">GBDT与随机森林比较随机森林的学习过程；随机森林中的每一棵树是如何学习的；随机森林学习算法中CART树的基尼指数是什么？</span><br><span class="line">RF 与 GBDT 区别，原理优缺点适用场景分析，哪个具备交叉验证功能等</span><br><span class="line">接着写一下信息增益的公式。之后就是问机器学习相关算法，说了一下bagging跟boosting，之后问了GBDT（没做过，只能说说大体思路）。（2 ） rf ， gbdt 的区别； gbdt ， xgboost 的区别；</span><br><span class="line">说说xgboost、gbdt区别、Tree-based Model如何处理连续型特征。</span><br><span class="line">让我把一个完整的数据挖掘流程讲一下，从预处理，特征工程，到模型融合。介绍常用的算法，gbdt和xgboost区别，具体怎么做预处理，特征工程，模型融合常用方式，融合一定会提升吗？</span><br><span class="line">gbdt树根据什么分裂（瞎扯的梯度近似残差、梯度下降方向，其实还是信息增益这种东西）</span><br><span class="line">gbdt怎么并发（特征选择层面，树层面不能并发）</span><br><span class="line">介绍LR、RF、GBDT ，分析它们的优缺点，是否写过它们的分布式代码</span><br><span class="line">XGB和GBDT区别与联系也会经常问到：https://www.zhihu.com/question/41354392/answer/128008021?group_id=773629156532445184</span><br><span class="line">CART（回归树用平方误差最小化准则，分类树用基尼指数最小化准则）、Logistics（推导）、GBDT（利用损失函数的负梯度在当前模型的值作为回归问题提升树算法中的残差的近似值，拟合一个回归树）</span><br><span class="line">在面试过程中主动引导面试官提问，比如面试官让你讲解 gbdt 原理时，这会你可以跟他说，一般说起 gbdt ，我们都会跟 rf 以及 xgboost 一块讲，然后你就可以主动地向面试官输出你的知识；面试并不是死板地你问我答，而是一种沟通交流，所以尽可能地把面试转化成聊天式的对话，多输出自己一些有价值的观点而不是仅仅为了回答面试官的问题；</span><br><span class="line">几种树模型的原理和对比，</span><br><span class="line">特征选取怎么选？ 为什么信息增益可以用来选特征？</span><br><span class="line">信息熵和基尼指数的关系(信息熵在x=1处一阶泰勒展开就是基尼指数)</span><br><span class="line">介绍xgboost一下。写下xgboost目标函数。（因为我提到xgboost在目标函数里显式地加入了正则项..血雪崩）怎么调整XGB参数；xgboost原理</span><br></pre></td></tr></table></figure><h3 id="K-means"><a href="#K-means" class="headerlink" title="K-means"></a>K-means</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">k-means 聚类的原理以及缺点及对应的改进；kmeans 算法的优缺点。。。。</span><br><span class="line">kmeans 的原理，优缺点以及改进；</span><br><span class="line">em 与 kmeans 的关系；</span><br><span class="line">kmeans 代码；</span><br><span class="line">说说 Kmeans 算法， Kmeans 算法 K 怎么设置、适用什么样数据集、怎么评价 Kmeans 聚类结果、 Kmeans 有什么优缺点？你的项目中使用 Kmeans 遇到哪些问题，怎么解决的 ?</span><br><span class="line">用 EM 算法推导解释 Kmeans。</span><br><span class="line">KMeans的算法伪代码</span><br><span class="line">如何判断自己实现的 LR、Kmeans 算法是否正确？</span><br><span class="line">如何优化kmeans算法</span><br><span class="line">如何用hadoop实现k-means</span><br><span class="line">手写k-means的伪代码（就6行）</span><br></pre></td></tr></table></figure><h3 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bagging和boosting是怎么做的和他们的比较</span><br><span class="line">详细讨论了样本采样和bagging的问题</span><br><span class="line">聊的比较多的是如何知道一个特征的重要性，如何做ensemble哪些方法比较好。聊了聊计算广告方面FM，embedding。</span><br><span class="line">常见融合框架原理，优缺点，bagging，stacking，boosting，为什么融合能提升效果</span><br><span class="line">是否了解线性加权、bagging、boosting、cascade等模型融合方式</span><br><span class="line">K-means起始点http://www.cnki.com.cn/Article/CJFDTotal-DNZS200832067.htm</span><br></pre></td></tr></table></figure><h3 id="贝叶斯"><a href="#贝叶斯" class="headerlink" title="贝叶斯"></a>贝叶斯</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">朴素贝叶斯分类器原理以及公式，出现估计概率值为 0 怎么处理（拉普拉斯平滑），缺点；</span><br><span class="line">解释贝叶斯公式和朴素贝叶斯分类。</span><br><span class="line">贝叶斯分类，这是一类分类方法，主要代表是朴素贝叶斯，朴素贝叶斯的原理，重点在假设各个属性类条件独立。然后能根据贝叶斯公式具体推导。考察给你一个问题，如何利用朴素贝叶斯分类去分类，比如：给你一个人的特征，判断是男是女，比如身高，体重，头发长度等特征的的数据，那么你要能推到这个过程。给出最后的分类器公式。</span><br><span class="line">那你说说贝叶斯怎么分类啊？比如说看看今天天气怎么样？我：blabla，，，利用天气的历史数据，可以知道天气类型的先验分布，以及每种类型下特征数据（比如天气数据的特征：温度啊，湿度啊）的条件分布，这样我们根据贝叶斯公式就能求得天气类型的后验分布了。。。。面试官：en（估计也比较满意吧）那你了解关于求解模型的优化方法吗？一般用什么优化方法来解？</span><br><span class="line">贝叶斯分类器的优化和特殊情况的处理</span><br></pre></td></tr></table></figure><h3 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">解释一下CNN、介绍CNN、卷积公式，以及特点，假设面试官什么都不懂，详细解释 CNN 的原理；问CNN的细节特点，哪些特点使得CNN这么好用，哪些场景用CNN可以，抽象一下这些场景的特征，可以降采样但仍能保持主要信息；局部连接可以保证获取局部信息；权值共享保证高效，DNN和CNN相比有哪些区别，用过RNN么？画一下RNN的图，你在深度学习过程中遇到过哪些问题？如果出现过拟合你怎么办？dropout是什么？它有什么用？你会怎么用它？当全连接跟dropout连着用需要注意什么？你之前过拟合怎么解决的？如果本身training loss就很大你怎么办？如果数据不变，怎么调整网络结构解决这个问题？（batch normalization）梯度消失知道么？为什么会出现梯度消失？dnn和rnn中的梯度消失原理一样么？dnn中是哪个部分导致梯度消失？（激活层如sigmoid）rnn中怎么解决梯度消失问题？（lstm的结构相对普通RNN多了加和，为避免梯度消散提供了可能。线性自连接的memory是关键。）讲一下CNN吧，有哪些重要的特点？CNN可以处理哪些场景？为什么CNN要用权值共享？（每个卷积核相当于一个特征提取器，它的任务是匹配局部图像中的特征，权值共享后，匹配的特征方式都是一样的，提取若干特征后就知道学习的是啥了）CNN里面哪些层？讲一下卷积。卷积的形式是啥样？给定一个输入，算输出的feature map大小。卷积有啥用？池化有啥用？有哪些池化方式？池化除了降采样还有啥用？（就不知道了）还有哪些层你用过？讲讲dropout。dropout内部是怎么实现只让部分信号通过并不更新其余部分对于输入的权值的？讲讲BN（BatchNormalization）为什么好？全连接有什么用处？知道RNN么？讲讲RNN大致的实现思路。知道梯度消失么？为什么会出现梯度消失？RNN里的梯度消失一般怎么处理？细讲下lstm的结构，这样设计为什么好？（门关闭，当前信息不需要，只有历史依赖；门打开，历史和当前加权平均）你觉得梯度消失靠引入一些新的激活层可以完全解决么？为什么？</span><br><span class="line">问了做的比赛里面使用tensorflow的细节，LSTM里调参的细节</span><br><span class="line">用过哪些库或者工具，mkl，cuda这些会用吗？</span><br><span class="line">有一个弱分类器和大量未被标记过的图像数据，如何人工标记图像来对分类器进行提升</span><br><span class="line">介绍下RNN和它的优缺点</span><br><span class="line">让我推导BP反向传播、随机梯度下降法权重更新公式</span><br><span class="line">卷积神经网络结构特点、各参数对模型结果影响、项目进展遇到的难题、推导BP神经网络参数更新方式、随机梯度下降法（SGD）优化函数存在的缺点以及拟牛顿法在优化函数使用上更有优势、修改Caffe开源框架、开源社区代码贡献量就跟我聊了很多行业发展趋势及问题，知道目前深度学习的一个趋势，也了解到最新行业发展动态，改进相机智能化程度，也聊到了美颜相机美颜效果以及小米相机人脸分类、年龄检测等等不足之处，了解到新兴行业大佬商汤科技和旷视科技（face++脸草）在研究的热门方向</span><br><span class="line">看到有deep learning相关的项目，就问了deep learning 相关问题：如何减少参数（权值共享、VGG的感受野、GoogLeNet的inception ），激活函数的选择（sigmoid-&gt;ReLu-&gt;LReLU-&gt;PReLU ），为什么之前没有深度网络出现（数据量不够+机器性能），由数据引申到数据不平衡怎么处理（10W正例，1W负例，牛客上有原题），</span><br><span class="line">后面问了下DNN原理，应用，瞎扯一通……</span><br><span class="line">你了解神经网络吗？我：了解一些，讲感知机，然后是BP网络。简单讲了一下原理。</span><br><span class="line">图像处理题：如何找相似图片。我说用感知哈希算法，计算汉明距离，他说这种方法精度不行；我说那就用SIFT算法吧，他说SIFT效果还可以，但计算有点繁重，有没有轻量级的方法？我想起来去年在美图秀秀实习时，曾经做过一种图像滤波算法，有一步是把像素点用K-means聚类。我就说先把图片灰度化，然后用K-means聚类，把聚类后的各个中心点作为一张图片的特征向量如果两张图片的特征向量相近则说明这两张图片相似。貌似我这个答案有点出乎他的意料，他意味深长地说了个“行吧~~~~”（个人觉得颜色直方图匹配是个他期待的常规回答）</span><br><span class="line">介绍卷积神经网络，和 DBN 有什么区别？</span><br><span class="line">Deep CNN, Deep RNN, RBM的典型应用与局限，看Hinton讲义和Paper去吧</span><br><span class="line">神经网络,plsi的推导</span><br><span class="line">验证码图片的去噪和提取字符</span><br><span class="line">有限状态自动机,然后要我画状态转移图.</span><br></pre></td></tr></table></figure><h3 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用过哪些聚类算法，解释密度聚类算法。</span><br><span class="line">聚类算法中的距离度量有哪些？</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">梯度下降的优缺点；主要问最优化方面的知识，梯度下降法的原理以及各个变种（批量梯度下降，随机梯度下降法， mini 梯度下降法），以及这几个方法会不会有局部最优问题，牛顿法原理和适用场景，有什么缺点，如何改进（拟牛顿法）</span><br><span class="line">常用优化算法：1.梯度下降法：又有随机梯度下降和负梯度下降，2.牛顿法 主要是问了各自的优缺点，速度，能不能得到全局最优解，牛顿法的二次收敛等</span><br><span class="line">问你如果有若干个极小值点，如何避免陷入局部最优解。</span><br><span class="line">它们间的牛顿学习法、SGD如何训练，</span><br><span class="line">如何判断函数凸或非凸？</span><br><span class="line">线性回归的梯度下降和牛顿法求解公式的推导</span><br><span class="line">最速下降法和共轭梯度法 wolfe条件 最速下降法和共轭梯度法的收敛速度如何判断</span><br><span class="line">深刻理解常用的优化方法：梯度下降、牛顿法、各种随机搜索算法（基因、蚁群等等），深刻理解的意思是你要知道梯度下降是用平面来逼近局部，牛顿法是用曲面逼近局部等等。</span><br></pre></td></tr></table></figure><h3 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">介绍SVD、SVD++</span><br><span class="line">推荐系统的冷启动问题如何解决</span><br><span class="line">深度学习在推荐系统上可能有怎样的发挥？</span><br><span class="line">推荐系统的算法中最近邻和矩阵分解各自适用场景</span><br><span class="line">白板写SVD/SVD++公式，SGD迭代更新p，q矩阵公式，SVD/SVD++优化方法</span><br><span class="line">对推荐算法的未来看法；</span><br><span class="line">用过什么算法？最好是在项目/实习的大数据场景里用过，比如推荐里用过 CF、LR，</span><br><span class="line">我面的推荐，问了各类协同过滤的好与坏。</span><br><span class="line">问了一个很有意思的问题，现实应用中的Top-N推荐问题和学术研究中的评分预测问题之间有什么不同。问我ItemCF的工程实现，面对大数据如何实现，又追问了有没有什么工程优化算法。这个问题我没答好，一开始我说了一个MapReduce模型，他问能不能更快一点，我就卡那了。。。最后面试官告诉我，不能只从算法角度分析，要从系统设计分析，利用内存来减小MapReduce的吞吐量。（当然也许从MapReduce那一刻开始我就输了也不一定）</span><br><span class="line">推荐系统的算法中最近邻和矩阵分解各自适用场景http://www.doc88.com/p-3961053026557.html</span><br></pre></td></tr></table></figure><h3 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">那你对pca了解吗？我：了解啊，面试官：那讲一下pca是用来干嘛的？我：pca啊，可以用来分析主方向啊，降维啊，特征筛选啊，具体方法是用svd分解得到特征值矩阵和特征向量矩阵，然后根据不同的任务对选择特征值或向量进行计算。</span><br></pre></td></tr></table></figure><p>EM<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">采用 EM 算法求解的模型有哪些，为什么不用牛顿法或梯度下降法？</span><br></pre></td></tr></table></figure></p><h3 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用过哪些 NLP 算法项目中用过哪些机器学习算法。</span><br><span class="line">海量的 item 算文本相似度的优化方法；</span><br><span class="line">解释 word2vec 的原理以及哈夫曼树的改进；word2vec的原理</span><br><span class="line">二面面试官主要跟我聊简历上的几个项目，他好像不能理解词向量的形式，反复解释了很多遍，问的问题都比较简单，有TF-IDF,余弦相似度，分词工具等等。</span><br><span class="line">然后我说我做过LDA，问我，Dirichlet Distribution的定义和性质，并问我，为什么它和multinomial distribution是共轭的，顺便问了我啥叫共轭分布。</span><br></pre></td></tr></table></figure><h3 id="关联分析："><a href="#关联分析：" class="headerlink" title="关联分析："></a>关联分析：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目中涉及到频繁模式挖掘，于是问了一下如何实现的？ 用的是 Apriori算法，描述他的原理过程，关键字眼：支持度，支持度计数，k项候选频繁项集，怎么从k项到k+1项等，连接剪枝过程。</span><br></pre></td></tr></table></figure><h3 id="hadoop"><a href="#hadoop" class="headerlink" title="hadoop"></a>hadoop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">简单介绍 MapReduce 原理，有没有看过源码，说说 Map 阶段怎么实现的,</span><br><span class="line">MapReduce 实现统计出现次数最多的前 100 个访问 IP.</span><br><span class="line">MapReduce 实现统计不重复用户 ID,MapReduce 实现两个数据集求交集。</span><br><span class="line">HBase 行健怎么设计,spark 性能一般优化方法,spark streaming 和 storm 区别.给了一张笔试题， 10 道选择，一道大题。选择题是 java 基础知识，大题一个有三问：根据场景写出 Hive 建表语句； Hsql 从表中查询；</span><br><span class="line">用MapReduce写好友推荐，在一堆单词里面找出现次数最多的k个</span><br><span class="line">用分布式的方法做采样怎么保证采样结果完全符合预期？</span><br><span class="line">后面又问了Hadoop,Spark,storm下面的产品，原理，适用场景，</span><br><span class="line">写一个 Hadoop 版本的 wordcount。</span><br></pre></td></tr></table></figure><h3 id="HMM"><a href="#HMM" class="headerlink" title="HMM"></a>HMM</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">实现 hmm 的状态转移代码；</span><br><span class="line">机器学习理论</span><br><span class="line">讲机器学习中常用的损失函数有哪些？交叉熵有什么好处？（凸优化问题）</span><br><span class="line">判别模型与生成模型的本质区别是什么</span><br><span class="line">分类模型和回归模型的区别，分类模型可以做回归分析吗？反过来可以吗？（我回答是分类不可以做回归，回归倒是可以做分类，不知道对不对）</span><br><span class="line">k折交叉验证 中k取值多少有什么关系 （我不知道，随便答，然后面试官后面问我知道bias和variance吗？估计是和这两个东西有关， 知乎上有个问题讨论了k值大小与bias和variance的关系）</span><br><span class="line">解释局部相关性</span><br><span class="line">特征选择的方法；</span><br><span class="line">在模型的训练迭代中，怎么评估效果；</span><br><span class="line">特征选择方法有哪些(能说出来10种以上加分)，之后和面试官仔细聊了一下特征选择的问题，我介绍了了解的几种基本的特征选择思路（错误率选择、基于熵的选择、类内类间距离的选择）；</span><br><span class="line">有没有接触过机器学习的前沿，深度学习看过paper没有？（并没有）</span><br><span class="line">如何用尽可能少的样本训练模型同时又保证模型的性能；</span><br><span class="line">你读哪些期刊会议的论文？你遇到的比较有意思的算法？</span><br><span class="line">生成模型，判别模型</span><br><span class="line">线性分类和非线性分类各有哪些模型</span><br><span class="line">比较各个模型的Loss function，</span><br><span class="line">设计一个结构存取稀疏矩阵 （面试官最后告诉我了一个极度压缩的存法，相同行或列存偏差，我当时没听懂，还不懂装懂，最后还是没记住）</span><br><span class="line">PageRank原理，怎么用模型来查找异常用户，我讲了一大堆我的理解，然后面试官一句你怎么不用规则把我噎到了……</span><br><span class="line">无监督和有监督算法的区别？</span><br><span class="line">经典算法推导(加分项)，原理，各个损失函数之间区别，使用场景，如何并行化，有哪些关键参数</span><br><span class="line">什么叫判别模型什么叫生成模型。</span><br><span class="line">先针对项目十分细致地询问了各种细节，然后就问我如何处理数据中的噪声点、数据清洗算法（正好自己做了一个算法）、如何选择特征等。</span><br><span class="line">校招TST内推，面过了2面，还是跟之前那个有点类似的游戏开发的安全部门，因为我也玩LOL，又问到怎么来判断玩家有没有作弊之类的问题，这次我小心翼翼的说用模型怎么做，用规则怎么做，感觉这次聊的都挺开心的。</span><br><span class="line">是否了解A/B Test以及A/B Test结果的置信度特征工程经验是否了解mutual infomation、chi-square、LR前后向、树模型等特征选择方式</span><br><span class="line">深刻理解各种算法对应采用的数据结构和对应的搜索方法。比如KNN对应的KD树、如何给图结构设计数据结构？如何将算法map-red化</span><br><span class="line">矩阵的各种变换，尤其是特征值相关的知识。分布式的矩阵向量乘的算法</span><br><span class="line">线性分类器与非线性分类器的区别及优劣；特征比数据量还大时，选择什么样的分类器？对于维度很高的特征，你是选择线性还是非线性分类器？对于维度极低的特征，你是选择线性还是非线性分类器？如何解决过拟合问题？L1和L2正则的区别，如何选择L1和L2正则？</span><br><span class="line">项目中的数据是否会归一化处理，哪个机器学习算法不需要归一化处理</span><br><span class="line">并行计算、压缩算法LDA http://www.doc88.com/p-1621945750499.html</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 笔面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习推荐书</title>
      <link href="/2018/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8E%A8%E8%8D%90%E4%B9%A6/"/>
      <url>/2018/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8E%A8%E8%8D%90%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>机器学习推荐书</p><a id="more"></a><p>5本深度学习书籍资源推荐</p><p>深度学习（Deep Learning）byIan Goodfellow and Yoshua Bengio and Aaron Courville</p><p>中文版下载地址：<a href="https://github.com/exacity/deeplearningbook-chinese" target="_blank" rel="noopener">https://github.com/exacity/deeplearningbook-chinese</a></p><p>R语言深度学习实践指南（Deep Learning Made Easy with R）by Dr. N.D. Lewis</p><p>下载地址：<a href="http://download.csdn.net/detail/oscer2016/9829915" target="_blank" rel="noopener">http://download.csdn.net/detail/oscer2016/9829915</a></p><p>深度学习基础（Fundamentals of Deep Learning）by Nikhil Buduma</p><p>下载地址：<a href="http://www.taodocs.com/p-32598980.html" target="_blank" rel="noopener">http://www.taodocs.com/p-32598980.html</a></p><p>神经网络和统计学习（Neural networks and statistical learning） by K.-L. Du and M.N.s. Swamy</p><p>下载地址：<a href="http://download.csdn.net/detail/oscer2016/9829919" target="_blank" rel="noopener">http://download.csdn.net/detail/oscer2016/9829919</a></p><p>神经网络和深度学习（Neural Networks and Deep Learning） by Michael Niels</p><p>下载地址：<a href="http://download.csdn.net/download/newhotter/9651111" target="_blank" rel="noopener">http://download.csdn.net/download/newhotter/9651111</a></p><p>10本机器学习书籍资源推荐</p><p>机器学习、神经网络和统计分类（Machine Learning, Neural Networks, and Statistical Classification）by</p><p>D. Michie, D.J. Spiegelhalter, C.C. Taylor</p><p>下载地址：<a href="http://www1.maths.leeds.ac.uk/~charles/statlog/" target="_blank" rel="noopener">http://www1.maths.leeds.ac.uk/~charles/statlog/</a></p><p>贝叶斯推理和机器学习（Bayesian Reasoning and Machine Learning）by David Barber</p><p>下载地址：<a href="http://web4.cs.ucl.ac.uk/staff/D.Barber/pmwiki/pmwiki.php?n=Brml.Online" target="_blank" rel="noopener">http://web4.cs.ucl.ac.uk/staff/D.Barber/pmwiki/pmwiki.php?n=Brml.Online</a></p><p>机器学习的高斯过程（Gaussian Processes for Machine Learning） by Carl Edward Rasmussen and Christopher K. I. Williams，The MIT Press</p><p>下载地址：<a href="http://www.gaussianprocess.org/gpml/" target="_blank" rel="noopener">http://www.gaussianprocess.org/gpml/</a></p><p>信息理论、推理和学习算法（Information Theory, Inference, and Learning Algorithms） by David J.C. MacKay</p><p>下载地址：<a href="http://www.inference.phy.cam.ac.uk/mackay/itprnn/book.html" target="_blank" rel="noopener">http://www.inference.phy.cam.ac.uk/mackay/itprnn/book.html</a></p><p>统计学习元素（The Elements of Statistical Learning）by Trevor Hastie, Robert Tibshirani, Jerome Friedman</p><p>下载地址：<a href="http://statweb.stanford.edu/~tibs/ElemStatLearn/printings/ESLII_print10.pdf" target="_blank" rel="noopener">http://statweb.stanford.edu/~tibs/ElemStatLearn/printings/ESLII_print10.pdf</a></p><p>机器学习课程（A Course in Machine Learning）by Hal Daumé III</p><p>下载地址：<a href="http://ciml.info/" target="_blank" rel="noopener">http://ciml.info/</a></p><p>机器学习导论（Introduction to Machine Learning）by Amnon Shashua，Cornell University</p><p>下载地址：<a href="https://arxiv.org/abs/0904.3664v1" target="_blank" rel="noopener">https://arxiv.org/abs/0904.3664v1</a></p><p>强化学习（Reinforcement Learning）</p><p>下载地址：<a href="https://www.intechopen.com/books/reinforcement_learning" target="_blank" rel="noopener">https://www.intechopen.com/books/reinforcement_learning</a></p><p>机器学习导论（Introduction to Machine Learning）- By Nils Nilsson</p><p>下载地址：<a href="http://ai.stanford.edu/~nilsson/mlbook.html" target="_blank" rel="noopener">http://ai.stanford.edu/~nilsson/mlbook.html</a></p><p>强化学习（Reinforcement Learning）- MIT Press</p><p>下载地址：<a href="http://webdocs.cs.ualberta.ca/~sutton/book/the-book.html" target="_blank" rel="noopener">http://webdocs.cs.ualberta.ca/~sutton/book/the-book.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习常见算法总结</title>
      <link href="/2018/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2018/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>机器学习常见算法总结</p><a id="more"></a><div class="table-container"><table><thead><tr><th>学习方式</th><th>概念</th></tr></thead><tbody><tr><td>监督式学习</td><td>从给定的训练数据集中学习出一个函数，当新的数据到来时，可以根据此函数预测结果。训练数据集中的目标由人标注的。常见的算法有回归分析和统计分类</td></tr><tr><td>非监督式学习</td><td>与监督式学习相比，训练集没有人为标注的结果，常见的算法有聚类</td></tr><tr><td>半监督式学习</td><td>训练集部分被标识，部分没有被标识。常见的算法有SVM</td></tr><tr><td>强化学习</td><td>输入数据作为模型的反馈，模型对此作出调整。常见的算法有时间差学习</td></tr></tbody></table></div><p><br><br><br>|机器学习算法分类|概念|<br>|—————-|—-|<br>|决策树算法|根据数据属性，采用树状结构建立决策模型。常用来解决分类和回归问题。<br>常见算法：CART(Classification And Regression Tree)，ID3，C4.5，随机森林等|<br>|回归算法|对连续值预测，如逻辑回归LR等|<br>|分类算法|对离散值预测，事前已经知道分类，如k-近邻算法|<br>|聚类算法|对离散值预测，事前对分类未知，如k-means算法|<br>|神经网络|模拟生物神经网络，可以用来解决分类和回归问题<br>感知器神经网络(Perceptron Neural Network) ，反向传递(Back Propagation)和深度学习（DL）|<br>|集成算法 |集成几种学习模型进行学习，将最终预测结果进行汇总<br>Boosting、Bagging、AdaBoost、随机森林 (Random Forest) 等|</p><h3 id="机器学习算法分类"><a href="#机器学习算法分类" class="headerlink" title="机器学习算法分类"></a>机器学习算法分类</h3><p>决策树算法<br>根据数据属性，采用树状结构建立决策模型。常用来解决分类和回归问题。<br>常见算法：CART(Classification And Regression Tree)，ID3，C4.5，随机森林等<br>回归算法<br>对连续值预测，如逻辑回归LR等<br>分类算法<br>对离散值预测，事前已经知道分类，如k-近邻算法<br>聚类算法<br>对离散值预测，事前对分类未知，如k-means算法<br>神经网络<br>模拟生物神经网络，可以用来解决分类和回归问题<br>感知器神经网络(Perceptron Neural Network) ，反向传递(Back Propagation)和深度学习（DL）<br>集成算法<br>集成几种学习模型进行学习，将最终预测结果进行汇总<br>Boosting、Bagging、AdaBoost、随机森林 (Random Forest) 等</p><h3 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h3><p>1、SVM不太容易过拟合：松弛因子+损失函数形式</p><p>SVM的求解方法叫拉格朗日乘子法</p><p><img src="https://upload-images.jianshu.io/upload_images/1996593-3c55ea30ea545a2f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/678" alt></p><p>有时候如果你非要很明确地分类，那么结果就会像右边的一样 —— 过拟合。明显左边的两个都比过拟合好多了，可是这样就要求允许一些样本不在正确的类上.</p><blockquote><p>目标：找出总损失值最小并且能大概分类的超平面</p></blockquote><p>2、方法选择<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、如果Feature的数量很大，跟样本数量差不多，这时候选用LR或者是Linear Kernel的SVM</span><br><span class="line">2、如果Feature的数量比较小，样本数量一般，不算大也不算小，选用SVM+Gaussian Kernel</span><br><span class="line">3、如果Feature的数量比较小，而样本数量很多，需要手工添加一些feature变成第一种情况</span><br></pre></td></tr></table></figure></p><p>3、数据维度<br>如果数据特征维度高，svm要使用<strong>核函数</strong>来求解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Note：拉格朗日对偶没有改变最优解，但改变了算法复杂度：原问题—样本维度；对偶问题–样本数量。</span><br><span class="line">线性分类            样本维度&lt;样本数量：原问题求解（liblinear默认）； </span><br><span class="line">非线性–升维—一般导致 样本维度&gt;样本数量：对偶问题求解</span><br></pre></td></tr></table></figure></p><h3 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h3><p>朴素贝叶斯的优点：<br>对小规模的数据表现很好，适合多分类任务，适合增量式训练。<br>缺点：<br>对输入数据的表达形式很敏感（离散、连续，值极大极小之类的）</p><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><p>线性回归试图学得一个线性模型以尽可能准确地预测实值输出标记。均方误差是回归任务中最常用的性能度量，基于均方误差最小化来进行模型求解的方法成为最小二乘法。在线性回归中，最小二乘法就是试图找到一条直线，使得所有样本到直线上的欧式距离之和最小。这个想法和分类问题是正好相反的，分类问题是找到一个分界面离所有样本尽可能远。</p><p>优化方法</p><p>当x矩阵是列满秩的时候，可以用最小二乘法，但是求矩阵的逆比较慢</p><h2 id="机器学习算法选择"><a href="#机器学习算法选择" class="headerlink" title="机器学习算法选择"></a>机器学习算法选择</h2><blockquote><p>没有最好的分类器，只有最合适的分类器。</p></blockquote><p>数据维度越高，随机森林就比AdaBoost强越多，但是整体不及SVM。</p><p>数据量越大，神经网络就越强。</p><h3 id="1、K近邻"><a href="#1、K近邻" class="headerlink" title="1、K近邻"></a>1、K近邻</h3><p>典型KNN，它的思路就是——对于待判断的点，找到离它最近的几个数据点，根据它们的类型决定待判断点的类型。<br>它的特点是完全跟着数据走，没有数学模型可言。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">适用情景：</span><br><span class="line">需要一个特别容易解释的模型的时候。</span><br><span class="line">比如需要向用户解释原因的推荐算法。</span><br></pre></td></tr></table></figure></p><h3 id="2、贝叶斯"><a href="#2、贝叶斯" class="headerlink" title="2、贝叶斯"></a>2、贝叶斯</h3><p>典型的例子是Naive Bayes，核心思路是根据条件概率计算待判断点的类型。是相对容易理解的一个模型，至今依然被垃圾邮件过滤器使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">适用情景：</span><br><span class="line"></span><br><span class="line">需要一个比较容易解释，而且不同维度之间相关性较小的模型的时候。</span><br><span class="line"></span><br><span class="line">可以高效处理高维数据，虽然结果可能不尽如人意。</span><br></pre></td></tr></table></figure></p><h3 id="3、决策树-Decision-tree"><a href="#3、决策树-Decision-tree" class="headerlink" title="3、决策树 (Decision tree)"></a>3、决策树 (Decision tree)</h3><p>决策树的特点是它总是在沿着特征做切分。随着层层递进，这个划分会越来越细。<br>举个简单的例子，当我们预测一个孩子的身高的时候，决策树的第一层可能是这个孩子的性别。男生走左边的树进行进一步预测，女生则走右边的树。这就说明性别对身高有很强的影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">适用情景：</span><br><span class="line">同时它也是相对容易被攻击的分类器。这里的攻击是指人为的改变一些特征，使得分类器判断错误。常见于垃圾邮件躲避检测中。因为决策树最终在底层判断是基于单个条件的，攻击者往往只需要改变很少的特征就可以逃过监测。受限于它的简单性，决策树更大的用处是作为一些更有用的算法的基石。</span><br></pre></td></tr></table></figure><h4 id="随机森林-Random-forest"><a href="#随机森林-Random-forest" class="headerlink" title="随机森林 (Random forest)"></a>随机森林 (Random forest)</h4><p>随机森林其实算是一种集成算法。它首先随机选取不同的特征(feature)和训练样本(training sample)，生成大量的决策树，然后综合这些决策树的结果来进行最终的分类。</p><p>它相对于决策树，在准确性上有了很大的提升，同时一定程度上改善了决策树容易被攻击的特点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">适用情景：</span><br><span class="line"></span><br><span class="line">数据维度相对低（几十维），同时对准确性有较高要求时。</span><br><span class="line"></span><br><span class="line">因为不需要很多参数调整就可以达到不错的效果，基本上不知道用什么方法的时候都可以先试一下随机森林。</span><br></pre></td></tr></table></figure><h3 id="优化问题的求解方法"><a href="#优化问题的求解方法" class="headerlink" title="优化问题的求解方法"></a>优化问题的求解方法</h3><p>大部分的机器学习算法的本质都是建立优化模型，通过最优化方法对目标函数（或损失函数）进行优化，从而训练出最好的模型。常见的最优化方法有梯度下降法、牛顿法和拟牛顿法、共轭梯度法等等。</p><p>1、梯度下降法</p><p>优化思想<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当目标函数是凸函数时，梯度下降法的解是全局解。一般情况下，其解不保证是全局最优解，梯度下降法的速度也未必是最快的。梯度下降法的优化思想是用当前位置负梯度方向作为搜索方向，因为该方向为当前位置的最快下降方向，所以也被称为是”最速下降法“。最速下降法越接近目标值，步长越小，前进越慢。</span><br></pre></td></tr></table></figure></p><p>缺点<br>梯度下降法的最大问题就是会陷入局部最优，靠近极小值时收敛速度减慢。</p><p>2、批量梯度下降法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最小化所有训练样本的损失函数，使得最终求解的是全局的最优解，即求解的参数是使得风险函数最小，但是对于大规模样本问题效率低下。</span><br></pre></td></tr></table></figure></p><p>3、随机梯度下降法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最小化每条样本的损失函数，虽然不是每次迭代得到的损失函数都向着全局最优方向， 但是大的整体的方向是向全局最优解的，最终的结果往往是在全局最优解附近，适用于大规模训练样本情况。</span><br></pre></td></tr></table></figure></p><p>随机梯度下降是通过每个样本来迭代更新一次，如果样本量很大的情况（例如几十万），那么可能只用其中几万条或者几千条的样本，就已经将theta迭代到最优解了，对比上面的批量梯度下降，迭代一次需要用到十几万训练样本，一次迭代不可能最优，如果迭代10次的话就需要遍历训练样本10次。但是，SGD伴随的一个问题是噪音较BGD要多，使得SGD并不是每次迭代都向着整体最优化方向。</p><p>4、牛顿法</p><p>牛顿法是一种在实数域和复数域上近似求解方程的方法。方法使用函数f (x)的泰勒级数的前面几项来寻找方程f (x) = 0的根。牛顿法最大的特点就在于它的收敛速度很快。</p><p>牛顿法比梯度下降法快</p><p>牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快。如果更通俗地说的话，比如你想找一条最短的路径走到一个盆地的最底部，梯度下降法每次只从你当前所处位置选一个坡度最大的方向走一步，牛顿法在选择方向时，不仅会考虑坡度是否够大，还会考虑你走了一步之后，坡度是否会变得更大。所以，可以说牛顿法比梯度下降法看得更远一点，能更快地走到最底部。</p><p>但是牛顿法要算hessian矩阵的逆，比较费时间。</p><p>5、拟牛顿法</p><p>拟牛顿法的本质思想是改善牛顿法每次需要求解复杂的Hessian矩阵的逆矩阵的缺陷，它使用正定矩阵来近似Hessian矩阵的逆，从而简化了运算的复杂度。拟牛顿法和最速下降法一样只要求每一步迭代时知道目标函数的梯度。通过测量梯度的变化，构造一个目标函数的模型使之足以产生超线性收敛性。这类方法大大优于最速下降法，尤其对于困难的问题。另外，因为拟牛顿法不需要二阶导数的信息，所以有时比牛顿法更为有效。</p><p>6、拉格朗日法</p><p>拉格朗日乘数法</p><p>拉格朗日乘子法主要用于解决约束优化问题，它的基本思想就是通过引入拉格朗日乘子来将含有n个变量和k个约束条件的约束优化问题转化为含有（n+k）个变量的无约束优化问题。拉格朗日乘子背后的数学意义是其为约束方程梯度线性组合中每个向量的系数。</p><p>通过引入拉格朗日乘子建立极值条件，对n个变量分别求偏导对应了n个方程，然后加上k个约束条件（对应k个拉格朗日乘子）一起构成包含了（n+k）变量的（n+k）个方程的方程组问题，这样就能根据求方程组的方法对其进行求解</p><p>过拟合：</p><blockquote><p>如果一味的去提高训练数据的预测能力，所选模型的复杂度往往会很高，这种现象称为过拟合。所表现的就是模型训练时候的误差很小，但在测试的时候误差很大。</p></blockquote><p>训练模型很好用，测试时候误差较大</p><p><a href="http://kubicode.me/2015/08/16/Machine%20Learning/Algorithm-Summary-for-Interview/#" target="_blank" rel="noopener">参考</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特征提取_图像矩阵变换</title>
      <link href="/2018/07/19/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E5%9B%BE%E5%83%8F%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2/"/>
      <url>/2018/07/19/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E5%9B%BE%E5%83%8F%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>特征提取_图像矩阵变换</p><a id="more"></a><p>基本的二维变换可包括缩放、旋转、扭曲，和平移四种<br></p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/juzhen_1.png" alt></p><p>几何运算则可以转换为一些基本的矩阵运算<br></p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/juzhen_2.png" alt></p><p>平移运算不是线性的,使用矩阵乘法再使用矩阵加法来完成此操作<br><br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/juzhen_3.png" alt></p><p>综合这几种基本运算，数学家们将其统一为一个3*3矩阵，存储形式<br><br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/juzhen_4.png" alt></p><p>仿射变换的矩阵的第三列总是（0，0，1），在存储矩阵的时候，大多只存成一个2*3的数组。</p><blockquote><p>复合变换是有顺序的，一般说来，先旋转、再缩放、然后平移</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 特征提取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_分类_决策树</title>
      <link href="/2018/07/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_%E5%86%B3%E7%AD%96%E6%A0%91/"/>
      <url>/2018/07/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_%E5%86%B3%E7%AD%96%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>机器学习<em>分类</em>决策树</p><a id="more"></a><p>决策树算法是借助于树的分支结构实现分类。</p><p>叶子节点：存放决策结果<br>非叶子节点：特征属性，及其对应输出，按照输出选择分支<br>决策过程：从根节点出发，根据数据的各个属性，计算结果，选择对应的输出分支，直到到达叶子节点，得到结果</p><p>决策树使用自顶向下递归分治法，并采用不回溯的贪心策略。分裂属性的选择算法很多，这里介绍3种常用的算法：信息增益（Information gain）、增益比率（gain ratio）、基尼指数（Gini index）。<br></p><blockquote><p>我们通过<strong>基尼不纯度</strong>或者<strong>熵</strong>来对一个集合进行的有序程度进行量化，然后引入<strong>信息增益</strong>概念对一次拆分进行量化评价</p></blockquote><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/tree_1.png" alt></p><h3 id="基尼不纯度"><a href="#基尼不纯度" class="headerlink" title="基尼不纯度"></a>基尼不纯度</h3><p>基尼不纯度是指将来自集合中的某种结果随机应用于集合中某一数据项的预期误差率。该值越高，说明拆分的越不理想，如果该值为 0，说明完美拆分。</p><script type="math/tex; mode=display">Gini(D)=1−∑_i=(1^m)p_i^2</script><h3 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h3><p>用来表示集合的无序程度，熵越大表示集合越混乱<br></p><script type="math/tex; mode=display">E = -P * log2P</script><blockquote><p>基尼不纯度与熵对比<br><br>两者主要区别在于，熵到达峰值的过程相对慢一些。因此熵对混乱集合的「判罚」往往更重一些。通常情况下，熵的使用更加频繁。</p></blockquote><h3 id="信息增益（Information-Gain）"><a href="#信息增益（Information-Gain）" class="headerlink" title="信息增益（Information Gain）"></a>信息增益（Information Gain）</h3><p>基于香浓的信息论，<strong>信息熵</strong>表示不确定度，均匀分布时，不确定度最大，此时熵就最大。<br>当选择某个特征对数据集进行分类时，数据集分类后的信息熵会比分类前的小，其差值即为信息增益。<br><strong>信息增益</strong>可以衡量某个特征对分类结果的影响大小，<strong>越大越好</strong>。</p><blockquote><p>信息增益=abs(信息熵（分类后）-信息熵（分类前）)</p><script type="math/tex; mode=display">Gain(R)=Info(D)−InfoR(D)</script></blockquote><h3 id="决策树降剪枝"><a href="#决策树降剪枝" class="headerlink" title="决策树降剪枝"></a>决策树降剪枝</h3><blockquote><p>为什么要剪枝<br>训练出得决策树存在过度拟合现象——决策树过于针对训练的数据，专门针对训练集创建出来的分支，其熵值可能会比真实情况有所降低。</p><p>如何剪枝<br>人工设置一个信息增益的阀值，自下而上遍历决策树，将信息增益低于该阀值的拆分进行合并</p></blockquote><h3 id="处理缺失数据"><a href="#处理缺失数据" class="headerlink" title="处理缺失数据"></a>处理缺失数据</h3><blockquote><p>决策树模型还有一个很大的优势，就是可以容忍缺失数据。如果决策树中某个条件缺失，可以按一定的权重分配继续往以后的分支走，最终的结果可能有多个，每个结果又一定的概率，即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最终结果=某个分支的结果 x 该分支的权重(该分支下的结果数/总结果数)</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="生成算法：ID3和C4-5。"><a href="#生成算法：ID3和C4-5。" class="headerlink" title="生成算法：ID3和C4.5。"></a>生成算法：ID3和C4.5。</h3><h4 id="1、ID3算法"><a href="#1、ID3算法" class="headerlink" title="1、ID3算法"></a>1、ID3算法</h4><p>ID3算法可用于划分标称型数据集，没有剪枝的过程，为了去除过度数据匹配的问题，可通过裁剪合并相邻的无法产生大量信息增益的叶子节点（例如设置信息增益阀值）。<br>考虑某个特征后，信息熵减小的多，这个特征就是好的特征(在每层分裂时，选择使得Gain(R)最大的属性作为分裂属性)<br>ID3算法中根据信息增益评估和选择特征，每次选择信息增益最大的特征作为判断模块建立子结点</p><blockquote><p>缺点：1、此公式偏向数据量多的属性，如果样本分布不均，则会导致过拟合。<br>2、不能处理连续分布的数据特征</p></blockquote><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/tree_ID3.png" alt></p><h4 id="2、C4-5算法"><a href="#2、C4-5算法" class="headerlink" title="2、C4.5算法"></a>2、C4.5算法</h4><p>C4.5算法用<strong>信息增益率</strong>来选择属性，继承了ID3算法的优点<br>优点：</p><blockquote><p>1、克服了用信息增益选择属性时偏向选择取值多的属性的不足；<br>2、在树构造过程中进行剪枝；<br>3、能够完成对连续属性的离散化处理；<br>4、能够对不完整数据进行处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C4.5算法产生的分类规则易于理解、准确率较高；但效率低，因树构造过程中，需要对数据集进行多次的顺序扫描和排序C4.5算法在结构与递归上与ID3完全相同，区别只在于选取决决策特征时的决策依据不同，二者都有贪心性质：即通过局部最优构造全局最优</span><br></pre></td></tr></table></figure></p></blockquote><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/tree_C4.5.png" alt></p><p>svm:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">模型在真实世界中也应用场景 </span><br><span class="line">支撑向量机用于文本和超文本的分类；</span><br><span class="line">用于图像分类；</span><br><span class="line">用于手写体识别；</span><br><span class="line"></span><br><span class="line">这个模型的优势是什么？</span><br><span class="line"></span><br><span class="line">分类效果好；</span><br><span class="line">可以有效地处理高维空间的数据；</span><br><span class="line">可以有效地处理变量个数大于样本个数的数据；</span><br><span class="line">只是使用了一部分子集来进行训练模型，所以SVM模型不需要太大的内存；</span><br><span class="line">可以提高泛化能力；</span><br><span class="line">无局部极小值问题；</span><br><span class="line">他什么情况下表现最好？</span><br><span class="line"></span><br><span class="line">数据的维度较高；</span><br><span class="line">需要模型具有非常强的泛化能力；</span><br><span class="line">样本数据量较小时；</span><br><span class="line">解决非线性问题；</span><br><span class="line">这个模型的缺点是什么？</span><br><span class="line"></span><br><span class="line">无法处理大规模的数据集，因为该算法需要较长的训练时间；</span><br><span class="line">无法有效地处理包含噪声太多的数据集；</span><br><span class="line">SVM模型没有直接给出概率的估计值，而是利用交叉验证的方式估计，这种方式耗时较长；</span><br><span class="line">对缺失数据非常敏感；</span><br><span class="line">对于非线性问题，有时很难找到一个合适的核函数。</span><br><span class="line">什么条件下它表现很差？</span><br><span class="line"></span><br><span class="line">数据集的数据量过大；</span><br><span class="line">数据集中的含有噪声；</span><br><span class="line">数据集中的缺失较多的数据；</span><br><span class="line">对算法的训练效率要求较高；</span><br><span class="line">根据我们当前数据集的特点，为什么这个模型适合这个问题。 </span><br><span class="line">该项目所提供的样本数据相对较少；</span><br><span class="line">该问题是属于非线性问题；</span><br><span class="line">数据集经过“独热编码”后，维度较高</span><br></pre></td></tr></table></figure></p><p>决策树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">这个模型的优势是什么？</span><br><span class="line"></span><br><span class="line">决策树易于实现和理解；</span><br><span class="line">对于决策树，数据的准备工作一般比较简单；</span><br><span class="line">能够同时处理多种数据类型</span><br><span class="line">给定一个决策树模型，可以根据产生的决策树推出相应的逻辑表达式；</span><br><span class="line">通过静态测试来对模型的表现进行评价；</span><br><span class="line">在相对较短的时间内可以对大量的数据做出非常好的结果；</span><br><span class="line">决策树可以很好地扩展到大型数据中，同时决策树的大小独立于数据库的大小；</span><br><span class="line">计算复杂度相对较低，结果的输出易于理解，对部分的数据缺失不敏感。</span><br><span class="line">他什么情况下表现最好？</span><br><span class="line"></span><br><span class="line">实例是由“属性-值”对表示的；</span><br><span class="line">目标函数具有离散的输出值；</span><br><span class="line">训练数据集包含部分错误(决策树对错误有适应性)；</span><br><span class="line">训练数据缺少少量属性的实例。</span><br><span class="line">这个模型的缺点是什么？</span><br><span class="line"></span><br><span class="line">易于出现过拟合问题；</span><br><span class="line">忽略了数据集中属性之间的相关性；</span><br><span class="line">对于类比不一致的样本，决策树的信息增益倾向于那些数据值较多的特征</span><br><span class="line">什么条件下它表现很差？</span><br><span class="line"></span><br><span class="line">决策树匹配的数据过多时；</span><br><span class="line">分类的类别过于复杂；</span><br><span class="line">数据的属性之间具有非常强的关联。</span><br><span class="line">根据我们当前数据集的特点，为什么这个模型适合这个问题。</span><br><span class="line"></span><br><span class="line">不需要准备太多的训练数据，不需要对数据过多的处理如删除空白值等；</span><br><span class="line">易于编码；</span><br><span class="line">该问题是非线性问题，决策树能够很好地解决非线性问题；</span><br><span class="line">算法的执行效率高，对机器的要求较小。</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv_ocr</title>
      <link href="/2018/07/16/opencv_ocr/"/>
      <url>/2018/07/16/opencv_ocr/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>opencv_ocr</p><a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv_斑点检测</title>
      <link href="/2018/07/16/opencv_%E6%96%91%E7%82%B9%E6%A3%80%E6%B5%8B/"/>
      <url>/2018/07/16/opencv_%E6%96%91%E7%82%B9%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Opencv_斑点检测</p><a id="more"></a><h3 id="opencv中检测Blobs的类为SimpleBlobDetector"><a href="#opencv中检测Blobs的类为SimpleBlobDetector" class="headerlink" title="opencv中检测Blobs的类为SimpleBlobDetector"></a>opencv中检测Blobs的类为SimpleBlobDetector</h3><p>这个类在opencv中的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class SimpleBlobDetector : public FeatureDetector</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">struct Params</span><br><span class="line">&#123;</span><br><span class="line">    Params();</span><br><span class="line">    float thresholdStep;</span><br><span class="line">    float minThreshold;</span><br><span class="line">    float maxThreshold;</span><br><span class="line">    size_t minRepeatability;</span><br><span class="line">    float minDistBetweenBlobs;</span><br><span class="line"></span><br><span class="line">    bool filterByColor;</span><br><span class="line">    uchar blobColor;</span><br><span class="line"></span><br><span class="line">    bool filterByArea;</span><br><span class="line">    float minArea, maxArea;</span><br><span class="line"></span><br><span class="line">    bool filterByCircularity;</span><br><span class="line">    float minCircularity, maxCircularity;</span><br><span class="line"></span><br><span class="line">    bool filterByInertia;</span><br><span class="line">    float minInertiaRatio, maxInertiaRatio;</span><br><span class="line"></span><br><span class="line">    bool filterByConvexity;</span><br><span class="line">    float minConvexity, maxConvexity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SimpleBlobDetector(const SimpleBlobDetector::Params &amp;parameters = SimpleBlobDetector::Params());</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>算法的大致步骤如下：</p><p>对[minThreshold,maxThreshold)区间，以thresholdStep为间隔，做多次二值化。<br>对每张二值图片，使用findContours()提取连通域并计算每一个连通域的中心。<br>根据2得到的中心，全部放在一起。一些很接近的点［由theminDistBetweenBlobs控制多少才算接近］被归为一个group,对应一个bolb特征..<br>从3得到的那些点,估计最后的blob特征和相应半径，并以key points返回。<br>同时该支持提取特征的方法，一共有5个选项，这里就不多加描述了，默认是提取黑色圆形的Blob特征。下面是一个示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char** argv) </span><br><span class="line">&#123; </span><br><span class="line">    Mat image = imread(argv[1]); </span><br><span class="line">    vector&lt;KeyPoint&gt; keyPoints; </span><br><span class="line">    SimpleBlobDetector::Params params;</span><br><span class="line"></span><br><span class="line">    SimpleBlobDetector blobDetect(params); </span><br><span class="line">    blobDetect.create(&quot;SimpleBlob&quot;); </span><br><span class="line">    blobDetect.detect(image, keyPoints); </span><br><span class="line">    cout &lt;&lt; keyPoints.size() &lt;&lt; endl; </span><br><span class="line">    drawKeypoints(image, keyPoints, image, Scalar(255,0,0));</span><br><span class="line"></span><br><span class="line">    namedWindow(&quot;blobs&quot;); </span><br><span class="line">    imshow(&quot;blobs&quot;, image); </span><br><span class="line">    waitKey(); </span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总体来说，OpenCV的斑点检测效果还算不错，但是在有些图像的效果上明显不如LOG算子检测的检测效果</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> Opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像分割-大津法</title>
      <link href="/2018/07/16/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2_%E5%A4%A7%E6%B4%A5%E6%B3%95/"/>
      <url>/2018/07/16/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2_%E5%A4%A7%E6%B4%A5%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>图像分割-大津法</p><a id="more"></a><h3 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h3><p>最大类间方差法是1979年由日本学者大津提出的，是一种自适应阈值确定的方法，又叫大津法，简称OTSU</p><p>算法公式</p><h3 id="代码-Opencv249-vs2010"><a href="#代码-Opencv249-vs2010" class="headerlink" title="代码 Opencv249 + vs2010"></a>代码 Opencv249 + vs2010</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;cv.h&quot;</span><br><span class="line">#include &quot;highgui.h&quot;</span><br><span class="line">#include &quot;Math.h&quot;</span><br><span class="line"></span><br><span class="line">int Otsu(IplImage* src);</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    IplImage* img = cvLoadImage(&quot;lena.jpg&quot;,0); //获取灰度图像img</span><br><span class="line">    IplImage* dst = cvCreateImage(cvGetSize(img), 8, 1);</span><br><span class="line">    int threshold = Otsu(img); //调用大津法求出最佳阈值</span><br><span class="line">    printf(&quot;otsu threshold = %d\n&quot;, threshold);</span><br><span class="line">    cvThreshold(img, dst, threshold, 255, CV_THRESH_BINARY); //用otsu的阈值二值化</span><br><span class="line"></span><br><span class="line">    cvNamedWindow( &quot;img&quot;, 1 );</span><br><span class="line">    cvNamedWindow( &quot;dst&quot;, 1 );</span><br><span class="line">    cvShowImage(&quot;img&quot;, img);</span><br><span class="line">    cvShowImage(&quot;dst&quot;, dst);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cvWaitKey(-1);</span><br><span class="line"></span><br><span class="line">    cvReleaseImage(&amp;img);</span><br><span class="line">    cvReleaseImage(&amp;dst);</span><br><span class="line"></span><br><span class="line">    cvDestroyWindow( &quot;img&quot; );</span><br><span class="line">    cvDestroyWindow( &quot;dst&quot; );</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Otsu(IplImage* src)  </span><br><span class="line">&#123;  </span><br><span class="line">    int height=src-&gt;height;  </span><br><span class="line">    int width=src-&gt;width;      </span><br><span class="line"></span><br><span class="line">    //histogram  </span><br><span class="line">    float histogram[256] = &#123;0&#125;;  </span><br><span class="line">    for(int i=0; i &lt; height; i++)</span><br><span class="line">    &#123;  </span><br><span class="line">        unsigned char* p=(unsigned char*)src-&gt;imageData + src-&gt;widthStep * i;  </span><br><span class="line">        for(int j = 0; j &lt; width; j++) </span><br><span class="line">        &#123;  </span><br><span class="line">            histogram[*p++]++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    //normalize histogram &amp; average pixel value </span><br><span class="line">    int size = height * width;  </span><br><span class="line">    float u =0;</span><br><span class="line">    for(int i = 0; i &lt; 256; i++)</span><br><span class="line">    &#123;  </span><br><span class="line">        histogram[i] = histogram[i] / size;  </span><br><span class="line">        u += i * histogram[i];  //整幅图像的平均灰度</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    int threshold;    </span><br><span class="line">    float maxVariance=0;  </span><br><span class="line">    float w0 = 0, avgValue  = 0;</span><br><span class="line">    for(int i = 0; i &lt; 256; i++) </span><br><span class="line">    &#123;  </span><br><span class="line">        w0 += histogram[i];  //假设当前灰度i为阈值, 0~i 灰度像素所占整幅图像的比例即前景比例</span><br><span class="line">        avgValue  += i * histogram[i]; //avgValue/w0 = u0</span><br><span class="line"></span><br><span class="line">        float t = avgValue/w0 - u;  //t=u0-u</span><br><span class="line">        float variance = t * t * w0 /(1 - w0);  </span><br><span class="line">        if(variance &gt; maxVariance) </span><br><span class="line">        &#123;  </span><br><span class="line">            maxVariance = variance;  </span><br><span class="line">            threshold = i;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    return threshold;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;opencv2/opencv.hpp&gt;  </span><br><span class="line">#include &lt;cv.h&gt;</span><br><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line">#include &lt;cxcore.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">using namespace cv;</span><br><span class="line"></span><br><span class="line">Mat otsuGray(const Mat src) &#123;</span><br><span class="line">    Mat img = src;</span><br><span class="line">    int c = img.cols; //图像列数</span><br><span class="line">    int r = img.rows; //图像行数</span><br><span class="line">    int T = 0; //阈值</span><br><span class="line">    uchar* data = img.data; //数据指针</span><br><span class="line">    int ftNum = 0; //前景像素个数</span><br><span class="line">    int bgNum = 0; //背景像素个数</span><br><span class="line">    int N = c*r; //总像素个数</span><br><span class="line">    int ftSum = 0; //前景总灰度值</span><br><span class="line">    int bgSum = 0; //背景总灰度值</span><br><span class="line">    int graySum = 0;</span><br><span class="line">    double w0 = 0; //前景像素个数占比</span><br><span class="line">    double w1 = 0; //背景像素个数占比</span><br><span class="line">    double u0 = 0; //前景平均灰度</span><br><span class="line">    double u1 = 0; //背景平均灰度</span><br><span class="line">    double Histogram[256] = &#123;0&#125;; //灰度直方图</span><br><span class="line">    double temp = 0; //临时类间方差</span><br><span class="line">    double g = 0; //类间方差</span><br><span class="line"></span><br><span class="line">    //灰度直方图</span><br><span class="line">    for(int i = 0; i &lt; r ; i ++) &#123;</span><br><span class="line">        for(int j = 0; j &lt;c; j ++) &#123;</span><br><span class="line">            Histogram[img.at&lt;uchar&gt;(i,j)]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //求总灰度值</span><br><span class="line">    for(int i = 0; i &lt; 256; i ++) &#123;</span><br><span class="line">        graySum += Histogram[i]*i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; 256; i ++) &#123;</span><br><span class="line">        ftNum += Histogram[i];  //阈值为i时前景个数</span><br><span class="line">        bgNum = N - ftNum;      //阈值为i时背景个数</span><br><span class="line">        w0 = (double)ftNum/N; //前景像素占总数比</span><br><span class="line">        w1 = (double)bgNum/N; //背景像素占总数比</span><br><span class="line">        if(ftNum == 0) continue;</span><br><span class="line">        if(bgNum == 0) break;</span><br><span class="line">        //前景平均灰度</span><br><span class="line">        ftSum += i*Histogram[i];</span><br><span class="line">        u0 = ftSum/ftNum;</span><br><span class="line"></span><br><span class="line">        //背景平均灰度</span><br><span class="line">        bgSum = graySum - ftSum;</span><br><span class="line">        u1 = bgSum/bgNum;</span><br><span class="line"></span><br><span class="line">        g = w0*w1*(u0-u1)*(u0-u1);</span><br><span class="line">        if(g &gt; temp) &#123;</span><br><span class="line">            temp = g;</span><br><span class="line">            T = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0; i&lt;img.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=0; j&lt;img.cols; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if((int)img.at&lt;uchar&gt;(i,j)&gt;T)</span><br><span class="line">                img.at&lt;uchar&gt;(i,j) = 255;</span><br><span class="line">            else</span><br><span class="line">                img.at&lt;uchar&gt;(i,j) = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return img;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理-图像去雾</title>
      <link href="/2018/07/16/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE/"/>
      <url>/2018/07/16/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>图像处理-图像去雾</p><a id="more"></a><h3 id="雾图模型"><a href="#雾图模型" class="headerlink" title="雾图模型"></a>雾图模型</h3><script type="math/tex; mode=display">I(x)=J(x)t(x)+A(1-t(x))</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I(x) ——待去雾的图像</span><br><span class="line">J(x)——无雾图像</span><br><span class="line">A——全球大气光成分</span><br><span class="line">t——折射率（大气传递系数）</span><br></pre></td></tr></table></figure><h3 id="暗通道先验"><a href="#暗通道先验" class="headerlink" title="暗通道先验"></a>暗通道先验</h3><p>在无雾图像中，每一个局部区域都很有可能会有阴影，或者是纯颜色的东西，又或者是黑色的东西。因此，每一个局部区域都很有可能有至少一个颜色通道会有很低的值。把这个统计规律叫做Dark Channel Prior。</p><blockquote><p>实际生活中造成暗原色中低通道值主要有三个因素：a)汽车、建筑物和城市中玻璃窗户的阴影，或者是树叶、树与岩石等自然景观的投影；b)色彩鲜艳的物体或表面，在RGB的三个通道中有些通道的值很低（比如绿色的草地／树／植物，红色或黄色的花朵／叶子，或者蓝色的水面）；c)颜色较暗的物体或者表面，例如灰暗色的树干和石头。总之，自然景物中到处都是阴影或者彩色，这些景物的图像的暗原色总是很灰暗的。</p></blockquote><p><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_fog.png" alt></p><p>首先求出每个像素RGB分量中的最小值，存入一副和原始图像大小相同的灰度图中，然后再对这幅灰度图进行最小值滤波(邻域中取最小值)<br><img src="https://img-blog.nos-eastchina1.126.net/blog/blog_fog1.png" alt></p><p>验证了暗通道先验理论的普遍性</p><h3 id="计算折射率"><a href="#计算折射率" class="headerlink" title="计算折射率"></a>计算折射率</h3><script type="math/tex; mode=display">t(x)=1-wmin(minI(y)/A)</script><p>估计大气光<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.选取暗通道图像暗通道最亮的0.1%的像素（一般来说，这些像素表示雾浓度最大的地方）</span><br><span class="line">2.取输入图像里面这些像素对应的像素里面最亮的作为大气光</span><br><span class="line">（暗图像最亮的0.1%的像素对应的原图最亮的为大气光）</span><br></pre></td></tr></table></figure></p><p>注：选中的像素未必是全图最亮的，而且要比选取全图最亮的方式鲁棒性更好。</p><h3 id="去雾"><a href="#去雾" class="headerlink" title="去雾"></a>去雾</h3><script type="math/tex; mode=display">J(x)=I(x)-A/max(t(x),t0) +A</script><p>t0=0.1</p><p>流程：<br>1.求图像暗通道</p><p>2.利用暗通道计算出折射率</p><p>3.利用暗通道估计大气光</p><p>4.代回雾图公式去雾</p><p><a href="https://github.com/AomanHao/Matlab-Image-Dehazing" target="_blank" rel="noopener">我的代码-图像去雾算法Matlab实现</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理_图像增强</title>
      <link href="/2018/07/16/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/"/>
      <url>/2018/07/16/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>图像处理_图像增强</p><a id="more"></a><h2 id="图像增强前期知识"><a href="#图像增强前期知识" class="headerlink" title="图像增强前期知识"></a>图像增强前期知识</h2><p>图像增强是图像模式识别中非常重要的图像预处理过程。<br>图像增强的目的是通过对图像中的信息进行处理，使得有利于模式识别的信息得到增强，不利于模式识别的信息被抑制，扩大图像中不同物体特征之间的差别，为图像的信息提取及其识别奠定良好的基础。图像增强按实现方法不同可分为点增强、空域增强和频域增强。</p><p>1、点增强<br>点增强主要指图像灰度变换和几何变换。图像的灰度变换也称为点运算、对比度增强或对比度拉伸，它是图像数字化软件和图像显示软件的重要组成部分。灰度变换是一种既简单又重要的技术，它能让用户改变图像数据占据的灰度范围。一幅输入图像经过灰度变换后将产生一幅新的输出图像，由输入像素点的灰度值决定相应的输出像素点的灰度值。灰度变换不会改变图像内的空间关系。图像的几何变换是图像处理中的另一种基本变换。它通常包括图像的平移、图像的镜像变换、图像的缩放和图像的旋转。通过图像的几何变换可以实现图像的最基本的坐标变换及缩放功能。</p><p>2、空域增强<br>图像的空间信息可以反映图像中物体的位置 、形状、大小等特征，而这些特征可以通过一定的物理模式来描述。例如，物体的边缘轮廓由于灰度值变化剧烈一般出现高频率特征，而一个比较平滑的物体内部由于灰度值比较均一则呈现低频率特征。因此，根据需要可以分别增强图像的高频和低频特征。对图像的高频增强可以突出物体的边缘轮廓，从而起到锐化图像的作用。例如，对于人脸的比对查询，就需要通过高频增强技术来突出五宫的轮廓。相应地，对图像的低频部分进行增强可以对图像进行平滑处理，一般用于图像的噪声消除。</p><p>3、频域增强<br>图像的空域增强一般只是对数字图像进行局部增强，而图像的频域增强可以对图像进行全局增强。频域增强技术是在数字图像的频率域空间对图像进行滤波，因此需要将图像从空间域变换到频率域，一般通过傅里叶变换实现。在频率域空间的滤波与空域滤波一样可以通过卷积实现，因此傅里叶变换和和卷积理论是频域滤波技术的基础。</p><h3 id="图像增强的方法分类："><a href="#图像增强的方法分类：" class="headerlink" title="图像增强的方法分类："></a>图像增强的方法分类：</h3><div class="table-container"><table><thead><tr><th>图像增强方法</th><th>实现方法</th></tr></thead><tbody><tr><td>处理对象</td><td>灰度图</td></tr><tr><td></td><td>（伪）彩色图</td></tr><tr><td>-</td><td>-</td></tr><tr><td>处理策略</td><td>全局处理</td></tr><tr><td></td><td>局部处理（ROI ROI，Region of Interest Interest）</td></tr><tr><td>-</td><td>-</td></tr><tr><td>处理方法</td><td>空间域（点域运算，即灰度变换）</td></tr><tr><td></td><td>空间域（邻域方法，即空域滤波）</td></tr><tr><td></td><td>频域方法</td></tr><tr><td>-</td><td>-</td></tr><tr><td>处理目的</td><td>图像锐化</td></tr><tr><td></td><td>平滑去噪</td></tr><tr><td></td><td>灰度调整（对比度增强）</td></tr></tbody></table></div><h3 id="图像增强的方法之对比度增强"><a href="#图像增强的方法之对比度增强" class="headerlink" title="图像增强的方法之对比度增强"></a>图像增强的方法之对比度增强</h3><div class="table-container"><table><thead><tr><th>图像增强方法</th><th>实现方法</th></tr></thead><tbody><tr><td>灰度变换法</td><td>线性变换（已实现）</td></tr><tr><td></td><td>对数变换（已实现）</td></tr><tr><td></td><td>指数变换（已实现）</td></tr><tr><td>-</td><td>-</td></tr><tr><td>直方图调整法</td><td>直方图均衡化（已实现）</td></tr><tr><td></td><td>直方图匹配（未实现）</td></tr></tbody></table></div><p>图像对比度增强</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>图像对比度增强</td><td>直接</td><td></td></tr><tr><td></td><td>间接</td><td>直方图拉伸</td></tr><tr><td></td><td></td><td>直方图均衡化</td></tr><tr><td></td><td></td></tr></tbody></table></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">直方图拉伸</span><br><span class="line">    是通过对比度拉伸对直方图进行调整，从而“扩大”前景和背景灰度的差别，以达到增强对比度的目的，这种方法可以利用线性或非线性的方法来实现;直方图均衡化则通过使用累积函数对灰度值进行“调整”以实现对比度的增强。</span><br><span class="line">直方图均衡化处理</span><br><span class="line">    “中心思想”是把原始图像的灰度直方图从比较集中的某个灰度区间变成在全部灰度范围内的均匀分布。直方图均衡化就是对图像进行非线性拉伸，重新分配图像像素值，使一定灰度范围内的像素数量大致相同。直方图均衡化就是把给定图像的直方图分布改变成“均匀”分布直方图分布。</span><br></pre></td></tr></table></figure><h2 id="常用图像增强"><a href="#常用图像增强" class="headerlink" title="常用图像增强"></a>常用图像增强</h2><h3 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h3><div class="table-container"><table><thead><tr><th>直方图均衡化</th><th></th></tr></thead><tbody><tr><td>优点</td><td>处理过亮过暗图像很有效(曝光过度或者曝光不足),刻画更多细节</td></tr><tr><td></td><td>是一个相当直观的技术并且是可逆操作，如果已知均衡化函数，那么就可以恢复原始的直方图，并且计算量也不大</td></tr><tr><td>-</td><td>-</td></tr><tr><td>缺点</td><td>处理数据随机，可能会降低信噪比(会增加背景噪声对比度，降低有用信号对比度)</td></tr></tbody></table></div><p>c语言代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;fftw3.h&quot;</span><br><span class="line">#include &quot;string&quot;</span><br><span class="line">#include &quot;vector&quot;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;opencv2/legacy/legacy.hpp&gt;</span><br><span class="line">#include &lt;opencv2/nonfree/nonfree.hpp&gt;//opencv_nonfree模块：包含一些拥有专利的算法，如SIFT、SURF函数源码。 </span><br><span class="line">#include &quot;opencv2/core/core.hpp&quot;</span><br><span class="line">#include &quot;opencv2/features2d/features2d.hpp&quot;</span><br><span class="line">#include &quot;opencv2/highgui/highgui.hpp&quot;</span><br><span class="line">#include &lt;opencv2/nonfree/features2d.hpp&gt;</span><br><span class="line"> </span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">class hisEqt</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">hisEqt::hisEqt();</span><br><span class="line">hisEqt::~hisEqt();</span><br><span class="line">public:</span><br><span class="line">int w;</span><br><span class="line">int h;</span><br><span class="line">int nlen;</span><br><span class="line"> </span><br><span class="line">int *pHis;</span><br><span class="line">float *pdf;</span><br><span class="line"> </span><br><span class="line">//=====求像素分布概率密度====  </span><br><span class="line">void  getPdf();</span><br><span class="line"> </span><br><span class="line">//======统计像素个数=======  </span><br><span class="line">void getHis(unsigned char*imgdata);</span><br><span class="line"> </span><br><span class="line">//==========画统计分布直方图===============  </span><br><span class="line">void drawHistogram(const float*pdf,Mat &amp;hist1);  </span><br><span class="line"> </span><br><span class="line">//===========直方图均衡化==========  </span><br><span class="line">void hisBal();</span><br><span class="line"> </span><br><span class="line">//====直方图均衡化后的图像===  </span><br><span class="line">void imgBal(unsigned char* img);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">hisEqt::hisEqt() :nlen(0)&#123;</span><br><span class="line">pHis = new int[256 * sizeof(int)];</span><br><span class="line">memset(pHis, 0, 256 * sizeof(int));</span><br><span class="line">pdf = new float[255 * sizeof(float)];</span><br><span class="line">memset(pdf, 0, 255 * sizeof(float));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">hisEqt::~hisEqt()&#123;</span><br><span class="line">delete[]pHis;</span><br><span class="line">delete[]pdf;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//======统计像素个数=======  </span><br><span class="line">void hisEqt::getHis(unsigned char*imgdata)&#123;</span><br><span class="line">for (int i = 0; i&lt;nlen; i++)</span><br><span class="line">&#123;</span><br><span class="line">pHis[imgdata[i]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//=====求像素分布概率密度====  </span><br><span class="line">void hisEqt::getPdf()&#123;</span><br><span class="line">for (int k = 0; k&lt;256; k++)</span><br><span class="line">&#123;</span><br><span class="line">pdf[k] = pHis[k] / float(nlen);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//===========直方图均衡化==========  </span><br><span class="line">void hisEqt::hisBal()&#123;</span><br><span class="line">for (int k = 1; k&lt;256; k++)</span><br><span class="line">&#123;</span><br><span class="line">pdf[k] += pdf[k - 1];</span><br><span class="line">&#125;</span><br><span class="line">for (int k = 0; k&lt;256; k++)</span><br><span class="line">&#123;</span><br><span class="line">pHis[k] = 255 * pdf[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//====直方图均衡化  </span><br><span class="line">void hisEqt::imgBal(unsigned char* img)&#123;</span><br><span class="line">for (int i = 0; i&lt;nlen; i++)</span><br><span class="line">&#123;</span><br><span class="line">img[i] = pHis[img[i]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void hisEqt::drawHistogram(const float *pdf, Mat&amp; hist1)&#123;</span><br><span class="line">for (int k = 0; k&lt;256; k++)</span><br><span class="line">&#123;</span><br><span class="line">if (k % 2 == 0)</span><br><span class="line">&#123;</span><br><span class="line">Point a(k, 255), b(k, 255 - pdf[k] * 2550);</span><br><span class="line">line(hist1,</span><br><span class="line">a,</span><br><span class="line">b,</span><br><span class="line">Scalar(0, 0, 255),</span><br><span class="line">1);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">Point a(k, 255), b(k, 255 - pdf[k] * 2550);</span><br><span class="line">line(hist1,</span><br><span class="line">a,</span><br><span class="line">b,</span><br><span class="line">Scalar(0, 255, 0),</span><br><span class="line">1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Mat image = imread(&quot;Fig0651(a)(flower_no_compression).tif&quot;);</span><br><span class="line">if (!image.data)</span><br><span class="line">return -1;</span><br><span class="line"> </span><br><span class="line">Mat hist2(256, 256, CV_8UC3, Scalar(0, 0, 0));</span><br><span class="line">Mat hist1(256, 256, CV_8UC3, Scalar(0, 0, 0));</span><br><span class="line"> </span><br><span class="line">Mat imgOut = Mat(image.rows, image.cols, CV_8UC3, Scalar(0, 0, 0));</span><br><span class="line">vector&lt;Mat&gt; planes;</span><br><span class="line">int chn = image.channels();</span><br><span class="line">if (chn == 3)</span><br><span class="line">&#123;</span><br><span class="line">split(image, planes);</span><br><span class="line">&#125;</span><br><span class="line">while (chn)</span><br><span class="line">&#123;</span><br><span class="line">chn--;</span><br><span class="line">unsigned char* imageData = new unsigned char[sizeof(unsigned char)*(image.cols*image.rows)];</span><br><span class="line">memcpy(imageData, planes[chn].data, planes[chn].cols*planes[chn].rows);</span><br><span class="line">hisEqt his;//自定义的类</span><br><span class="line">his.nlen = image.rows*image.cols;</span><br><span class="line">his.getHis(imageData);</span><br><span class="line">his.getPdf();</span><br><span class="line"> </span><br><span class="line">//  //======画原图直方图并保存============  </span><br><span class="line">his.drawHistogram(his.pdf, hist1);</span><br><span class="line">string pic_name = &quot;hisline&quot;;</span><br><span class="line">pic_name = pic_name + to_string(chn);</span><br><span class="line">pic_name=pic_name+&quot;.jpg&quot;;</span><br><span class="line">imwrite(pic_name, hist1);</span><br><span class="line"> </span><br><span class="line">his.hisBal();</span><br><span class="line">his.getPdf();</span><br><span class="line">//  //======画均衡化后直方图并保存============  </span><br><span class="line">his.drawHistogram(his.pdf, hist2);</span><br><span class="line">string pic_name0 = &quot;his_balanceline&quot;;</span><br><span class="line">pic_name0 = pic_name0 + to_string(chn);</span><br><span class="line">pic_name0 = pic_name0 + &quot;.jpg&quot;;</span><br><span class="line">imwrite(pic_name0, hist2);</span><br><span class="line"> </span><br><span class="line">//  //=====图像均衡化===  </span><br><span class="line">his.imgBal(imageData);</span><br><span class="line">memcpy(planes[chn].data, imageData, planes[chn].cols*planes[chn].rows);</span><br><span class="line">delete[] imageData;</span><br><span class="line">imageData = NULL;</span><br><span class="line">&#125;</span><br><span class="line">merge(planes, imgOut);//单通道合并</span><br><span class="line">imwrite(&quot;result.jpg&quot;, imgOut);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="指数变换"><a href="#指数变换" class="headerlink" title="指数变换"></a>指数变换</h3><blockquote><p>先做归一化，再指数变换，最后反归一化</p></blockquote><script type="math/tex; mode=display">S=c*R^r</script><p>通过合理的选择c和r可以压缩灰度范围，算法以c=1.0/255.0, r=2实现</p><p><img src="https://img-blog.csdn.net/20161229163907449?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRWJvd1Rhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><p>Opencv代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void ExpEnhance(IplImage* img, IplImage* dst)</span><br><span class="line">&#123;</span><br><span class="line">// 由于oldPixel:[1,256],则可以先保存一个查找表</span><br><span class="line">uchar lut[256] =&#123;0&#125;;</span><br><span class="line"> </span><br><span class="line">double temp = 1.0/255.0;</span><br><span class="line"> </span><br><span class="line">for ( int i =0; i&lt;255; i++)</span><br><span class="line">&#123;</span><br><span class="line">lut[i] = (uchar)(temp*i*i+0.5);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">for( int row =0; row &lt;img-&gt;height; row++)</span><br><span class="line">&#123;</span><br><span class="line">uchar *data = (uchar*)img-&gt;imageData+ row* img-&gt;widthStep;</span><br><span class="line">uchar *dstData = (uchar*)dst-&gt;imageData+ row* dst-&gt;widthStep;</span><br><span class="line"> </span><br><span class="line">for ( int col = 0; col&lt;img-&gt;width; col++)</span><br><span class="line">&#123;</span><br><span class="line">for( int k=0; k&lt;img-&gt;nChannels; k++)</span><br><span class="line">&#123;</span><br><span class="line">uchar t1 = data[col*img-&gt;nChannels+k];</span><br><span class="line">dstData[col*img-&gt;nChannels+k] = lut[t1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="对数变换"><a href="#对数变换" class="headerlink" title="对数变换"></a>对数变换</h3><blockquote><p>低灰度值部分扩展，高灰度值部分压缩,来强调图像低灰度部分</p></blockquote><script type="math/tex; mode=display">s=c*log_{v+1}(1+v*r)</script><p>底数为（v+1），实际输入范围为归一化的【0-1】，其输出也为【0-1】。底数越大，对低灰度部分的强调就越强，对高灰度部分的压缩也就越强</p><p><img src="https://img-blog.csdn.net/20131014153326875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGhuaDE2OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><p>matlab代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function dst_img=myLogEnhance(src_img,v)   </span><br><span class="line">c=1.0;  </span><br><span class="line">src_img = mat2gray(src_img,[0 255]);  </span><br><span class="line">g =c*log2(1 + v*src_img)/log2(v+1);  </span><br><span class="line">%反归一化  </span><br><span class="line">max=255;  </span><br><span class="line">min=0;  </span><br><span class="line">dst_img=uint8(g*(max-min)+min);</span><br></pre></td></tr></table></figure></p><h3 id="灰度拉伸"><a href="#灰度拉伸" class="headerlink" title="灰度拉伸"></a>灰度拉伸</h3><blockquote><p>灰度拉升可以改善图像的动态范围</p></blockquote><script type="math/tex; mode=display">s=\frac{1}{1+\frac{m}{r+eps}^E}</script><p>输入r为【0-1】，其输出s也为【0-1】</p><h3 id="线性拉伸"><a href="#线性拉伸" class="headerlink" title="线性拉伸"></a>线性拉伸</h3><p>三段线性变换</p><blockquote><p>突出感兴趣的目标或者灰度区间，相对抑制那些不感兴趣的灰度区域</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">范围吧</span><br><span class="line">%横轴</span><br><span class="line">fa=20; fb=80;</span><br><span class="line">%纵轴</span><br><span class="line">ga=50; gb=230;</span><br><span class="line"></span><br><span class="line">function dst_img=myLinearEnhance(src_img,fa,fb,ga,gb)  </span><br><span class="line"> </span><br><span class="line">[height,width] = size(src_img);</span><br><span class="line">dst_img=uint8(zeros(height,width));</span><br><span class="line"> </span><br><span class="line">src_img=double(src_img);</span><br><span class="line"> </span><br><span class="line">%三段斜率</span><br><span class="line">k1=ga/fa; </span><br><span class="line">k2=(gb- ga)/(fb- fa);</span><br><span class="line">k3=(255- gb)/(255- fb);</span><br><span class="line">for i=1:height</span><br><span class="line">    for j=1:width</span><br><span class="line">            if src_img(i,j) &lt;= fa</span><br><span class="line">                dst_img(i,j)= k1*src_img(i,j);</span><br><span class="line">            elseif fa &lt; src_img(i,j) &amp;&amp; src_img(i,j) &lt;= fb</span><br><span class="line">                dst_img(i,j)= k2*( src_img(i,j)- fa)+ ga;</span><br><span class="line">            else</span><br><span class="line">                dst_img(i,j)= k3*( src_img(i,j)- fb)+ gb;</span><br><span class="line">            end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">dst_img=uint8(dst_img);</span><br></pre></td></tr></table></figure><h2 id="频率域图像增强"><a href="#频率域图像增强" class="headerlink" title="频率域图像增强"></a>频率域图像增强</h2><blockquote><p>傅里叶变换提供了一种从空间域到频域的转换手段，且用傅里叶反变换可以实现从频域到空间域的无损转换，不丢失任何信息</p></blockquote><div class="table-container"><table><thead><tr><th>频域图像增强</th><th>类型</th></tr></thead><tbody><tr><td>高通滤波器</td><td>突出图像的边界</td></tr><tr><td>低通滤波器</td><td>抑制图像噪声，改善图像质量</td></tr></tbody></table></div><h3 id="分析频谱图"><a href="#分析频谱图" class="headerlink" title="分析频谱图"></a>分析频谱图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">clc;  %清空命令行</span><br><span class="line">clear;%清空变量</span><br><span class="line"> </span><br><span class="line">I1=imread(&apos;beauty.jpg&apos;);</span><br><span class="line">subplot(1,2,1);</span><br><span class="line">imshow(I1);</span><br><span class="line">title(&apos;beauty.jpg&apos;);</span><br><span class="line"> </span><br><span class="line">I2=fft2(I1);%计算二维FFT</span><br><span class="line">spectrum =fftshift(I2);%将零点移到中心</span><br><span class="line">temp= log(1+ abs(spectrum) ); %对幅值做 对数变换 以压缩动态范围</span><br><span class="line">subplot(1,2,2);</span><br><span class="line">imshow(temp,[]);</span><br><span class="line">title(&apos;FFT&apos;);</span><br></pre></td></tr></table></figure><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/img_fft.png" alt></p><blockquote><p>低频分量:主要对整副图像的强度的综合度量.灰度变化缓慢的特性<br>高频分量:主要是对图像边缘和轮廓的度量.灰度变化快的特性</p></blockquote><p>幅度图，看图像的频率分布，哪里亮那里暗，低频一般在图像中央<br>如果只保留图像的中心点，则图像的细节会丢失，大致轮廓还在，不同区域好友不同的灰度<br>如果保留远离中心的点，而去掉中心的幅度，则保留着图像的细节，而不同区域的灰度一样</p><h3 id="频域低通滤波"><a href="#频域低通滤波" class="headerlink" title="频域低通滤波"></a>频域低通滤波</h3><h4 id="理想低通滤波器"><a href="#理想低通滤波器" class="headerlink" title="理想低通滤波器"></a>理想低通滤波器</h4><p>理想低通滤波器并不能很好的兼顾 滤除噪声 与 保留细节 这两个方面</p><p>理想低通滤波器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">% 频域低通滤波器 imidealflpf.m</span><br><span class="line">%&#123;</span><br><span class="line">函数：    function ff=imidealflpf(I,freq)</span><br><span class="line">函数说明：构造理想的频域低通滤波器（即 滤镜）</span><br><span class="line">参数说明：I：为输入原图像</span><br><span class="line">         freq:为截止频率</span><br><span class="line">返回值： 与I等大的频域滤镜</span><br><span class="line"> %&#125;</span><br><span class="line"> </span><br><span class="line"> function ff=imidealflpf(I,freq)</span><br><span class="line"> </span><br><span class="line"> [M,N]=size(I);</span><br><span class="line"> ff=ones(M,N);</span><br><span class="line"> for i=1:M</span><br><span class="line">     for j=1:N</span><br><span class="line">         if (sqrt ((i-M/2)^2+ (j-N/2)^2 ) &gt;freq)  ff(i,j)=0; %高于截止频率 设为0</span><br><span class="line">         end</span><br><span class="line">     end</span><br><span class="line"> end</span><br></pre></td></tr></table></figure></p><p>不同截止频率的滤波结果：<br><img src="https://img-blog.csdn.net/20180515114639532?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI2Nzk3MDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><h4 id="高斯低通滤波器"><a href="#高斯低通滤波器" class="headerlink" title="高斯低通滤波器"></a>高斯低通滤波器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">%高斯低通滤波器滤镜 imgaussflpf.m</span><br><span class="line">%&#123;</span><br><span class="line">函数： function ff=imgaussflpf(I,sigma)</span><br><span class="line">函数说明：构造高斯低通滤镜</span><br><span class="line">参数说明：I：输入图像</span><br><span class="line">         sigma：标准差</span><br><span class="line">返回值：与原图像等大的高斯低通滤镜</span><br><span class="line"> </span><br><span class="line">%&#125;</span><br><span class="line">  </span><br><span class="line">function ff=imgaussflpf(I,sigma)</span><br><span class="line">[M,N]=size(I);</span><br><span class="line"> ff=ones(M,N);</span><br><span class="line"> for i=1:M</span><br><span class="line">     for j=1:N</span><br><span class="line">         ff(i,j)= exp( -((i-M/2)^2+(j-N/2)^2) /2/(sigma^2) ); %高斯函数</span><br><span class="line">        </span><br><span class="line">     end</span><br><span class="line"> end</span><br></pre></td></tr></table></figure><p>高斯滤波结果：<br><img src="https://img-blog.csdn.net/20180515114758843?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI2Nzk3MDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><blockquote><p>高斯相比于低通滤波，在有效抑制噪声的同时，图像的模糊程度更低</p></blockquote><p><a href="https://blog.csdn.net/u012679707/article/details/78236474" target="_blank" rel="noopener">cankao</a></p><h3 id="频域高通滤波器"><a href="#频域高通滤波器" class="headerlink" title="频域高通滤波器"></a>频域高通滤波器</h3><blockquote><p>图像锐化可以通过衰减频域中的低频信号来实现</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">%高斯高通滤波器滤镜 imgaussfhpf.m</span><br><span class="line">%&#123;</span><br><span class="line">函数： function ff=imgaussfhpf(I,sigma)</span><br><span class="line">函数说明：构造高斯高通滤镜</span><br><span class="line">参数说明：I：输入图像</span><br><span class="line">         sigma：标准差</span><br><span class="line">返回值：与原图像等大的高斯高通滤镜</span><br><span class="line"> </span><br><span class="line">%&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">function ff=imgaussfhpf(I,sigma)</span><br><span class="line">[M,N]=size(I);</span><br><span class="line"> ff=ones(M,N);</span><br><span class="line"> for i=1:M</span><br><span class="line">     for j=1:N</span><br><span class="line">         ff(i,j)= 1-exp( -((i-M/2)^2+(j-N/2)^2) /2/(sigma^2) ); %  1-(gauss)</span><br><span class="line">        </span><br><span class="line">     end</span><br><span class="line"> end</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180515114917692?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI2Nzk3MDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><blockquote><p>1、高斯高通滤波器可以较好的提取边缘信息；<br>2、sigma越小，Gauss高通的截止频率越低，通过的低频成分越多，边缘提取越不精确，会包含更多的非边缘信息；（要求太低，多了浑水摸鱼者）<br>3、sigma越大，边缘提取越精确，但可能包含不完整的边缘信息。（要求太高，有了漏网之鱼）</p></blockquote><h3 id="拉普拉斯滤波器"><a href="#拉普拉斯滤波器" class="headerlink" title="拉普拉斯滤波器"></a>拉普拉斯滤波器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">%laplace滤波器滤镜 imlapf.m</span><br><span class="line">%&#123;</span><br><span class="line">函数： function ff=imlapf(I)</span><br><span class="line">函数说明：构造laplace滤镜</span><br><span class="line">参数说明：I：输入图像</span><br><span class="line">       </span><br><span class="line">返回值：与原图像等大的laplace滤镜</span><br><span class="line"> </span><br><span class="line">%&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">function ff=imlapf(I)</span><br><span class="line">[M,N]=size(I);</span><br><span class="line"> ff=ones(M,N);</span><br><span class="line"> for i=1:M</span><br><span class="line">     for j=1:N</span><br><span class="line">         ff(i,j)= -((i-M/2)^2+(j-N/2)^2)  % </span><br><span class="line">        </span><br><span class="line">     end</span><br><span class="line"> end</span><br></pre></td></tr></table></figure><h2 id="图像处理评价指标"><a href="#图像处理评价指标" class="headerlink" title="图像处理评价指标"></a>图像处理评价指标</h2><h3 id="基于误差灵敏度评价算法："><a href="#基于误差灵敏度评价算法：" class="headerlink" title="基于误差灵敏度评价算法："></a>基于误差灵敏度评价算法：</h3><p>最简单的质量评价算法就是均方差(Mean Squared Error, MSE)和峰值信噪比(Peak Signal- Noise Ratio, PSNR)。MSE 和 PSNR 计算复杂度小，易于实现，在图像处理领域中广泛应用。但缺点是它们给出的数值与图像的感知质量之间没有必然联系。</p><h4 id="峰值信噪比-PSNR"><a href="#峰值信噪比-PSNR" class="headerlink" title="峰值信噪比-PSNR"></a>峰值信噪比-PSNR</h4><p>图像压缩等领域信号重建质量的评价</p><p><img src="https://img-blog.csdn.net/20171029101506855?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcGlhb3h1ZXpob25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p><p>MSE为当前图像 X 和参考图像 Y 的均方误差,H、W 分别表示图像的高和宽；n为每像素的比特数，一般取8，即像素灰阶数为256。PSNR的单位是dB，数值越大表示失真越小。</p><p>matlab代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function pnsr_result = psnr(img_ref,img_in)       </span><br><span class="line">    %   img_ref is a high reference quality image   </span><br><span class="line">    %   img_in is the denoise image    </span><br><span class="line">    %   pnsr_result is the PSNR of the denoise image    </span><br><span class="line">    width = size(img_ref,2);    </span><br><span class="line">    heigh = size(img_ref,1);    </span><br><span class="line">    if( width ~= size(img_in,2) || heigh ~= size(img_in,1) )    </span><br><span class="line">        disp(&apos;Please check whether the input image and reference image have same size&apos;);    </span><br><span class="line">        return    </span><br><span class="line">    end    </span><br><span class="line">    [a,b]=size(img_ref);      </span><br><span class="line">    XX=double(img_ref) - double(img_in);      </span><br><span class="line">    mse_value = sum(sum( XX.^2 ))/(a*b);      </span><br><span class="line">    pnsr_result = 10*log10( 255*255 / mse_value );   </span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><h4 id="SSIM"><a href="#SSIM" class="headerlink" title="SSIM"></a>SSIM</h4><h4 id="信噪比（SNR）"><a href="#信噪比（SNR）" class="headerlink" title="信噪比（SNR）"></a>信噪比（SNR）</h4><p>信噪比就是有用信号与噪声信号的比值</p><script type="math/tex; mode=display">snr=10*log_{10}\frac{sigma(I2)}{sigma(I2-I1)}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function snr=SNR2(I,In)</span><br><span class="line">% 计算噪声比</span><br><span class="line">% I :original signal</span><br><span class="line">% In:noisy signal</span><br><span class="line">% snr=10*log10(sigma2(I2)/sigma2(I2-I1))</span><br><span class="line"> </span><br><span class="line">[~,~,nchannel]=size(I);</span><br><span class="line">snr=0;</span><br><span class="line">I=double(I);</span><br><span class="line">In=double(In);</span><br><span class="line">if nchannel==1</span><br><span class="line">    Ps=sum(sum((I-mean(mean(I))).^2));%signal power</span><br><span class="line">    Pn=sum(sum((I-In).^2));%noise power</span><br><span class="line">    snr=10*log10(Ps/Pn);</span><br><span class="line">elseif nchannel==3</span><br><span class="line">    for i=1:3</span><br><span class="line">        Ps=sum(sum((I(:,:,i)-mean(mean(I(:,:,i)))).^2));%signal power</span><br><span class="line">        Pn=sum(sum((I(:,:,i)-In(:,:,i)).^2));%noise power</span><br><span class="line">        snr=snr+10*log10(Ps/Pn);</span><br><span class="line">    end</span><br><span class="line">    snr=snr/3;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="基于结构相似度评价算法"><a href="#基于结构相似度评价算法" class="headerlink" title="基于结构相似度评价算法"></a>基于结构相似度评价算法</h3><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="曝光过度问题处理"><a href="#曝光过度问题处理" class="headerlink" title="曝光过度问题处理"></a>曝光过度问题处理</h3><p>计算当前图像的反相（255-image)，然后取当前图像和反相图像的较小者为当前像素位置的值。</p><script type="math/tex; mode=display">min(image,(255-image))</script><h3 id="加Masaic算法"><a href="#加Masaic算法" class="headerlink" title="加Masaic算法"></a>加Masaic算法</h3><p>原理：用中心像素来表示邻域像素<br>Opencv代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">uchar getPixel( IplImage* img, int row, int col, int k)</span><br><span class="line">&#123;</span><br><span class="line">return ((uchar*)img-&gt;imageData + row* img-&gt;widthStep)[col*img-&gt;nChannels +k];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void setPixel( IplImage* img, int row, int col, int k, uchar val)</span><br><span class="line">&#123;</span><br><span class="line">((uchar*)img-&gt;imageData + row* img-&gt;widthStep)[col*img-&gt;nChannels +k] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line"></span><br><span class="line">// nSize:为尺寸大小，奇数</span><br><span class="line">// 将邻域的值用中心像素的值替换</span><br><span class="line">void Masic(IplImage* img, IplImage* dst, int nSize)</span><br><span class="line">&#123;</span><br><span class="line">int offset = (nSize-1)/2;</span><br><span class="line">for ( int row = offset; row &lt;img-&gt;height - offset; row= row+offset)</span><br><span class="line">&#123;</span><br><span class="line">for( int col= offset; col&lt;img-&gt;width - offset; col = col+offset)</span><br><span class="line">&#123;</span><br><span class="line">int val0 = getPixel(img, row, col, 0);</span><br><span class="line">int val1 = getPixel(img, row, col, 1);</span><br><span class="line">int val2 = getPixel(img, row, col, 2);</span><br><span class="line">for ( int m= -offset; m&lt;offset; m++)</span><br><span class="line">&#123;</span><br><span class="line">for ( int n=-offset; n&lt;offset; n++)</span><br><span class="line">&#123;</span><br><span class="line">setPixel(dst, row+m, col+n, 0, val0);</span><br><span class="line">setPixel(dst, row+m, col+n, 1, val1);</span><br><span class="line">setPixel(dst, row+m, col+n, 2, val2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理_图像滤波</title>
      <link href="/2018/07/16/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2/"/>
      <url>/2018/07/16/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>图像滤波</p><a id="more"></a><h2 id="噪声"><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h2><p>加性噪声一般指热噪声、散弹噪声等，它们与信号的关系是相加，不管有没有信号，噪声都存在。 </p><blockquote><p>高斯白噪声包括热噪声和散粒噪声。在通信信道测试和建模中，高斯噪声被用作加性白噪声以产生加性白高斯噪声。</p><p>加性高斯白噪声只是白噪声的一种，另有泊松白噪声等,加性高斯白噪声在通信领域中指的是一种各频谱分量服从均匀分布（即白噪声），且幅度服从高斯分布的噪声信号。因其可加性、幅度服从高斯分布且为白噪声的一种而得名。</p></blockquote><p>而乘性噪声一般由信道不理想引起，它们与信号的关系是相乘，信号在它在，信号不在他也就不在。 </p><p>一般通信中把加性随机性看成是系统的背景噪声； </p><p>而乘性随机性看成系统的时变性（如衰落或者多普勒）或者非线性所造成的。</p><h2 id="空域滤波"><a href="#空域滤波" class="headerlink" title="空域滤波"></a>空域滤波</h2><p>空域滤波可以用于非线性滤波，但是频域滤波不能用于非线性滤波</p><div class="table-container"><table><thead><tr><th>图像滤波</th><th></th><th></th></tr></thead><tbody><tr><td>空域</td><td>线性滤波</td><td>均值滤波</td></tr><tr><td>-</td><td>-</td><td>-</td></tr><tr><td></td><td>非线性滤波</td><td>中值滤波</td></tr><tr><td></td><td></td><td>双边滤波</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table></div><h3 id="滤波模板"><a href="#滤波模板" class="headerlink" title="滤波模板"></a>滤波模板</h3><p>图像滤波 模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">线性平均滤波：</span><br><span class="line">1|0 1 0 |</span><br><span class="line">-|1 1 1 |</span><br><span class="line">5|0 1 0 |</span><br></pre></td></tr></table></figure></p><p>图像锐化 模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">锐化滤波：图像锐化一般是通过微分运算来实现的</span><br><span class="line"></span><br><span class="line">|-1  0  1|</span><br><span class="line">|-1  0  1|</span><br><span class="line">|-1  0  1|</span><br><span class="line"></span><br><span class="line">| 1  1  1|</span><br><span class="line">| 0  0  0|</span><br><span class="line">|-1 -1 -1|</span><br></pre></td></tr></table></figure></p><p>方向滤波器-sobel算子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x轴：</span><br><span class="line">|-1  0  1|</span><br><span class="line">|-2  0  2|</span><br><span class="line">|-1  0  1|</span><br><span class="line"></span><br><span class="line">y轴：</span><br><span class="line">|-1 -2 -1|</span><br><span class="line">| 0  0  0|</span><br><span class="line">| 1  2  1|</span><br></pre></td></tr></table></figure></p><p>Scharr算子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x轴：</span><br><span class="line">|-3  0  3|</span><br><span class="line">|-10 0 10|</span><br><span class="line">|-3  0  3|</span><br><span class="line"></span><br><span class="line">y轴：</span><br><span class="line">|-3 -10 -3|</span><br><span class="line">| 0  0   0|</span><br><span class="line">| 3  10  3|</span><br></pre></td></tr></table></figure></p><h3 id="线性空域滤波"><a href="#线性空域滤波" class="headerlink" title="线性空域滤波"></a>线性空域滤波</h3><p><code>线性空域滤波</code>指的是像素的输出值是计算该像素邻域内像素值的线性组合<br>线性滤波中滤波模板也称为<code>卷积模板</code></p><h4 id="模板卷积"><a href="#模板卷积" class="headerlink" title="模板卷积"></a>模板卷积</h4><p>模板卷积的主要步骤包括如下几个步骤，</p><p>1) 将模板在图像中进行遍历，将模板中心和各个像素位置重合；</p><p>2) 将模板的各个系数与模板对应像素值进行相乘；</p><p>3) 将所有的乘积相加，并将求和结果赋值于模板中心对应的像素</p><h4 id="延拓"><a href="#延拓" class="headerlink" title="延拓"></a>延拓</h4><p>模板的行或列就会超出图像之外，因此常常采用延拓的方式解决外边界问题。常用的方法有四种，分别是<code>补零</code>、<code>重复</code>、<code>对称</code>和<code>循环</code>方式。</p><blockquote><p>补零是指通过在图像边界外围补零来扩展图像；<br>重复是指在图像边界外围通过复制外边界的值来扩展图像；<br>对称是指在图像边界外围通过镜像反射外边界的值来扩展图像；<br>循环是在图像边界外围指将图像看成二维周期函数的一个周期来扩展。</p></blockquote><h4 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h4><h4 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h4><p>高斯滤波器宽度(决定着平滑程度)是由参数σ表征的，而且σ和平滑程度的关系是非常简单的．σ越大，高斯滤波器的频带就越宽，平滑程度就越好．通过调节平滑程度参数σ</p><p>高斯分布：$h(x,y)=e^-(\frac{x^2+y^2}{2a^2})$</p><h4 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h4><p>一种非线性的滤波方法，是结合图像的<code>空间邻近度</code>和<code>像素相似度</code>的的一种折中处理。它是一种<code>保持边缘</code>的非迭代平滑滤波方法。中心像素的距离和灰度差值的增大，邻域像素的权系数逐渐减小</p><blockquote><p>优点：保持边缘性能良好，对低频信息滤波良好<br>缺点：不能处理高频信息</p></blockquote><p>假设高斯函数表达式如下：</p><script type="math/tex; mode=display">W_ij=\frac{1}{K_i}e^-\frac{(x_j-x_i)^2}{σ^2_G}</script><p>K是归一化的常量，W是权重，权重只跟像素之间的空间距离有关系。</p><p>双边滤波器:</p><script type="math/tex; mode=display">W_ij=\frac{1}{K_i}e^-\frac{(x_j-x_i)^2}{σ^2_G}e^-\frac{(I_j-I_i)^2}{σ^2_r}</script><h4 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h4><p>中值滤波是统计排序滤波的一种，中值滤波对椒盐噪声效果好；滤波图像边缘信息好，边缘清晰<br>|统计排序滤波|||<br>|-|-|-|<br>|最大值滤波|有效地滤除椒噪声(黑色)|寻找最亮点，亮化图片|<br>|最小值滤波|有效地滤除盐噪声(白色)|寻找最暗点，暗化图片|<br>|自适应中值滤波|有效地滤除椒盐噪声|钝化图像、去除噪音|</p><p>操作步骤：</p><p>1) 将模板在图像中遍历</p><p>2) 将模板对应的邻域内像素的灰度值排序</p><p>3) 查找中间值，将其赋于模板中心对应的像素</p><h3 id="Matlab函数"><a href="#Matlab函数" class="headerlink" title="Matlab函数"></a>Matlab函数</h3><p>Matlab滤波相关函数主要有<code>imfilter()</code>和<code>fspecial()</code>。</p><blockquote><p><code>imfilter()</code>是滤波操作<br><code>fspecial()</code>是构建自定义的二维滤波器，供<code>imfilter()</code>函数使用</p></blockquote><h4 id="imfilter-函数"><a href="#imfilter-函数" class="headerlink" title="imfilter()函数"></a>imfilter()函数</h4><p>定义 <code>g = imfilter(f, w, option1, option2, ...)</code></p><blockquote><p>其中：<br>f:待滤波图像<br>w:滤波模板<br>option1, option2:可选项</p></blockquote><p>可选项分为：</p><p>（1） 边界项：遍历处理边界元素时，需要提前在图像边界周围补充元素<br>     参数：<code>X</code>—表示具体的数字，默认用<code>0</code>补充<br>      <code>symmetric</code>—镜像边界元素<br>      <code>replicate</code>—重复边界像素<br>      <code>circular</code>—周期性填充边界内容</p><p>（2） 尺寸项：处理图像前扩充了边界，比原图大一圈，此项输出图像大小<br>参数: <code>same</code>—输出图像输入图像尺寸相同<br><code>full</code>—输出图像与扩充边界的图像尺寸相同，即比原图大一圈<br>（3） 模式项：滤波过程选择<br>参数：<code>corr</code>—相关滤波过程<br><code>conv</code>—卷积相关过程<br>（4）</p><h4 id="fspecial-函数"><a href="#fspecial-函数" class="headerlink" title="fspecial()函数"></a>fspecial()函数</h4><p>定义 <code>h = fspecial(type, parameters)</code></p><blockquote><p>其中：<br>type:滤波类型</p></blockquote><p>参数：<code>average</code>—平均模板<br><code>disk</code>—圆形邻域平均模板<br><code>guassian</code>—高斯模板<br><code>laplacian</code>—拉普拉斯模板<br><code>log</code>—高斯-拉普拉斯模板<br><code>prewitt</code>—prewitt水平边缘检测算子<br><code>sobel</code>—Sobel水平边缘检测算子</p><hr><h2 id="频域滤波"><a href="#频域滤波" class="headerlink" title="频域滤波"></a>频域滤波</h2><p>可以用图像增强，首先把图像通过傅里叶变换将图像从空间域转换到频率域，频域处理，反傅里叶变换转到空间域</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></div><h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h3><h3 id="均值滤波-1"><a href="#均值滤波-1" class="headerlink" title="均值滤波"></a>均值滤波</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void meanFilter (unsigned char* corrupted, unsigned char* smooth, int width, int height)  </span><br><span class="line">&#123;  </span><br><span class="line">      </span><br><span class="line">    memcpy ( smooth, corrupted, width*height*sizeof(unsigned char) );  </span><br><span class="line">      </span><br><span class="line">    for (int j=1;j&lt;height-1;j++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        for (int i=1;i&lt;width-1;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            smooth [ j*width+i ] = (    corrupted [ (j-1)*width+(i-1) ] + corrupted [ (j-1)*width+i] + corrupted [ (j-1)*width+(i+1) ] +  </span><br><span class="line">                                        corrupted [ j*width+(i-1) ]     + corrupted [ j*width+i]     + corrupted [ j*width+(i+1) ] +  </span><br><span class="line">                                        corrupted [ (j+1)*width+(i-1) ] + corrupted [ (j+1)*width+i] + corrupted [ (j+1)*width+(i+1) ] ) / 9;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中值滤波-1"><a href="#中值滤波-1" class="headerlink" title="中值滤波"></a>中值滤波</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void medianFilter (unsigned char* corrupted, unsigned char* smooth, int width, int height)  </span><br><span class="line">&#123;  </span><br><span class="line">      </span><br><span class="line">    memcpy ( smooth, corrupted, width*height*sizeof(unsigned char) );  </span><br><span class="line">    for (int j=1;j&lt;height-1;j++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        for (int i=1;i&lt;width-1;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            int k = 0;  </span><br><span class="line">            unsigned char window[9];  </span><br><span class="line">            for (int jj = j - 1; jj &lt; j + 2; ++jj)  </span><br><span class="line">                for (int ii = i - 1; ii &lt; i + 2; ++ii)  </span><br><span class="line">                    window[k++] = corrupted[jj * width + ii];  </span><br><span class="line">            //   Order elements (only half of them)  </span><br><span class="line">            for (int m = 0; m &lt; 5; ++m)  </span><br><span class="line">            &#123;  </span><br><span class="line">                int min = m;  </span><br><span class="line">                for (int n = m + 1; n &lt; 9; ++n)  </span><br><span class="line">                    if (window[n] &lt; window[min])  </span><br><span class="line">                        min = n;  </span><br><span class="line">                //   Put found minimum element in its place  </span><br><span class="line">                unsigned char temp = window[m];  </span><br><span class="line">                window[m] = window[min];  </span><br><span class="line">                window[min] = temp;  </span><br><span class="line">            &#125;  </span><br><span class="line">            smooth[ j*width+i ] = window[4];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形态学滤波</title>
      <link href="/2018/07/16/%E5%BD%A2%E6%80%81%E5%AD%A6%E6%BB%A4%E6%B3%A2_leitao%E8%AE%BA%E6%96%87/"/>
      <url>/2018/07/16/%E5%BD%A2%E6%80%81%E5%AD%A6%E6%BB%A4%E6%B3%A2_leitao%E8%AE%BA%E6%96%87/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>形态学滤波</p><a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_分类_随机森林</title>
      <link href="/2018/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/"/>
      <url>/2018/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>机器学习<em>分类</em>随机森林</p><a id="more"></a><p>它也是最常用的算法之一，随机森林建立了多个决策树，并将它们合并在一起以获得更准确和稳定的预测。随机森林的一大优势在于它既可用于分类，也可用于回归问题</p><p>随机森林的主要限制在于使用大量的树会使算法变得很慢，并且无法做到实时预测。一般而言，这些算法训练速度很快，预测十分缓慢。越准确的预测需要越多的树，这将导致模型越慢。在大多数现实世界的应用中，随机森林算法已经足够快，但肯定会遇到实时性要求很高的情况，那就只能首选其他方法。</p><h3 id="随机森林和Adaboost，以及区别："><a href="#随机森林和Adaboost，以及区别：" class="headerlink" title="随机森林和Adaboost，以及区别："></a>随机森林和Adaboost，以及区别：</h3><p>bagging 随机森林，不同的分类器是通过串行训练而获得的，每个新分<br>类器都根据已训练出的分类器的性能来进行训练<br>分类器权重相等.</p><p>boost ：— §是通过集中关注被已有分类器错分的那些数据来获得新的分类器。<br>匕0081丨明分类的结果是基于所有分类器的加权求和结果的，分类器权重并不相等，每个权重代表的是其对应分类器在上一轮迭代中的成功度</p><p>说一下GBDT和Adaboost，以及区别</p><p>Bagging + 决策树 = 随机森林</p><p>2）AdaBoost + 决策树 = 提升树</p><p>3）Gradient Boosting + 决策树 = GBDT</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_最优化_数学</title>
      <link href="/2018/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%9C%80%E4%BC%98%E5%8C%96_%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%9C%80%E4%BC%98%E5%8C%96_%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>机器学习<em>最优化</em>数学</p><a id="more"></a><h3 id="泰勒展开式"><a href="#泰勒展开式" class="headerlink" title="泰勒展开式"></a>泰勒展开式</h3><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/taylor1.png" alt></p><h3 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h3><p>概率加权下的平均值<br>离散型：$E(x)=\sum<em>ix_ip_i$<br><br>连续型：$E(x)=\int</em>{-\infty}^{\infty}xf(x)dx$</p><h3 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h3><p>取对数：$lnL(\theta<em>1,\theta_2,…,\theta_k=\sum</em>{i=1}^nlnf(x,\theta_1,\theta_2,…,\theta_k))$<br>求驻点：$\partial{lnL(\theta)}/\partial{\theta_i}=0,i=1,2,…k$</p><h1 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h1><h4 id="中心极限定理："><a href="#中心极限定理：" class="headerlink" title="中心极限定理："></a>中心极限定理：</h4><p>设n个随机变量$X_1,X_2,…,X_n$相互独立，均具有相同的数学期望与方差，即<br>$E(X_i)=\mu;D(X_i)=\sigma^2$,</p><script type="math/tex; mode=display">Y_n=X_1+X_2+...+X_n</script><script type="math/tex; mode=display">Z_n=\frac{Y_n-E(Y_n)}{\sqrt{D(Y_n)}}=\frac{Y_n-n\mu}{\sqrt{n}\sigma}→N(0,1)</script><p>随机变量$Z_n$为n个随机变量$X_1,X_2,…,X_n$的规范和<br>设从均值为$\mu$、方差为$\sigma^2$（有限）的任意一个总体中抽取样本量为$n$的样本，当$n$充分⼤大时，样本均值的抽样分布$\frac{Y_n}{n}$近似服从于均值为$\mu$、方差为$\sigma^2$的正态分布。</p><blockquote><p>中心极限定理，把那些对结果影响⽐比较小的变量（假设独⽴立同分布）之和认为服从正态分布是合理理的。</p></blockquote><h4 id="高斯分布"><a href="#高斯分布" class="headerlink" title="高斯分布"></a>高斯分布</h4><p>输入值$x^i$，预测值$\theta^Tx^i$，真实值$y^i$，误差$\epsilon^{i}$</p><script type="math/tex; mode=display">y^i=\theta^Tx^i+\epsilon^{i}</script><p>根据中心极限定理，认为变量之和服从高斯分布,即</p><script type="math/tex; mode=display">\epsilon^{i} = y^i-\theta^Tx^i</script><p>则，x,y的条件概率为</p><script type="math/tex; mode=display">p(y^i|x^i;\theta) = \frac{1}{\sqrt{2\pi}\sigma}exp(-\frac{(y^i-\theta^Tx^i)^2}{2\sigma^2})</script><h1 id="矩阵论"><a href="#矩阵论" class="headerlink" title="矩阵论"></a>矩阵论</h1><h1 id="最优化"><a href="#最优化" class="headerlink" title="最优化"></a>最优化</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 最优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_概率论_数学基础</title>
      <link href="/2018/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%A6%82%E7%8E%87%E8%AE%BA_%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%A6%82%E7%8E%87%E8%AE%BA_%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>机器学习_概率论</p><a id="more"></a><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>先验概率：<br><br>A的边缘概率表示为P(A)，B的边缘概率表示为P(B)</p><p>联合概率:<br><br>表示两个事件共同发生的概率。A与B的联合概率表示为P(A∩B)或者P(A,B)。</p><p>条件概率（又称后验概率）：<br><br>事件A在另外一个事件B已经发生条件下的发生概率。条件概率表示为P(A|B)，读作“在B条件下A的概率”,。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">考虑一个问题：P(A|B)是在B发生的情况下A发生的可能性。</span><br><span class="line"></span><br><span class="line">首先，事件B发生之前，我们对事件A的发生有一个基本的概率判断，称为A的先验概率，用P(A)表示；</span><br><span class="line"></span><br><span class="line">其次，事件B发生之后，我们对事件A的发生概率重新评估，称为A的后验概率，用P(A|B)表示；</span><br><span class="line"></span><br><span class="line">类似的，事件A发生之前，我们对事件B的发生有一个基本的概率判断，称为B的先验概率，用P(B)表示；</span><br><span class="line"></span><br><span class="line">同样，事件A发生之后，我们对事件B的发生概率重新评估，称为B的后验概率，用P(B|A)表示。</span><br></pre></td></tr></table></figure><h3 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h3><p>贝叶斯定理</p><script type="math/tex; mode=display">P(B_i|A) = \frac{P(B_i)P(A|B_i)}{\sum_{j=1}^n{P(B_j)}{P(A|B_j)}}</script><p>贝叶斯公式</p><script type="math/tex; mode=display">P(A|B)=\frac{P(B|A)P(A)}{P(B)}</script><p>因为联合概率$P(A,B)$</p><script type="math/tex; mode=display">P(A,B)=P(A|B)*P(B)=P(B|A)*P(A)</script><p>假设B事件是由A1、A2事件导致的</p><script type="math/tex; mode=display">P(B)=P(B|A1)P(A1)+P(B|A2)P(A2)</script><p>理解：<br>P(规律|现象)=P(现象|规律)P(规律)/P(现象)</p><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p>假设有两个班级其中1班有男生30人，女生20人；2班有男生25人、女生25人。体育老师抓到一个抽烟的男生，该男生打死也不告诉体育老师是那个班的。问题来了体育老师怎么判断该男生来自那个班？</p><p>先将1班和2班标记为事件A1和事件A2，男生标记为事件B</p><p>那么我们所求的就是P(A1丨B)和P(A2丨B)</p><p>因为只有2个班那么我们先验概率P(A1)=P(A2)=50%；来自1班男生的概率P(B丨A1)=3/5：来自2班男生的概率P(B丨A2)=1/2</p><p>那么我们求出P(B)就可以代入公式得到结果:</p><p>P(B)=P(B丨A1)P(A1) P(B丨A2)P(A2)=0.55</p><p>P(A1丨B)=P(B丨A1)P(A1)/P(B)=0.6*0.5/0.55=55%</p><p>P(A2丨B)=P(B丨A2)P(A2)/P(B)=0.5*0.5/0.55=45%</p><p>由结果我们可以得出：该男生来自1班的概率从50%（先验概率）上升到55%（后验概率）</p><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p>一种癌症，得了这个癌症的人被检测出为阳性的几率为90%，未得这种癌症的人被检测出阴性的几率为90%，而人群中得这种癌症的几率为1%，一个人被检测出阳性，问这个人得癌症的几率为多少？</p><p>我们用 A 表示事件 “测出为阳性”, 用 $B_1$ 表示“得癌症”,  $B_2$ 表示“未得癌症”。</p><p>得到以下信息:<br>$P(A|B_1)=0.9$得癌症的人检测阳性 0.9<br>$P(A|B_2)=0.1$得癌症的人检测阴性 0.1<br>$P(B_1)=0.01$得癌症的概率       0.01<br>$P(B_2)=0.99$未得癌症的概率    0.99</p><p>计算：<br>人群中检测为阳性且得癌症的几率$P(B_1,A)$，联合概率</p><script type="math/tex; mode=display">P(B_1,A)=P(B_1)*P(A|B_1)=0.01*0.9=0.009</script><p>检测阳性并且未得癌症概率$P(B_2,A)$，联合概率</p><script type="math/tex; mode=display">P(B_2,A)=P(B_2)*P(A|B_2)=0.99*0.1=0.099</script><p>目前状态是已经检测除阳性，求患癌症概率$P(B_1|A)$<br>$P(B_1|A)=\frac{0.009}{0.099+0.009}=0.083$<br>未患癌症概率$P(B_2|A)$<br>$P(B_2|A)=\frac{0.099}{0.099+0.009}=0.917$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_最优化</title>
      <link href="/2018/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%9C%80%E4%BC%98%E5%8C%96/"/>
      <url>/2018/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%9C%80%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>机器学习-最优化-梯度下降-牛顿法等(梯度消失爆炸))</p><a id="more"></a><h3 id="铺垫"><a href="#铺垫" class="headerlink" title="铺垫"></a>铺垫</h3><p>微分意义<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、函数图像中，某点的切线的斜率</span><br><span class="line">2、函数的变化率</span><br></pre></td></tr></table></figure></p><p>梯度意义<br></p><blockquote><p>梯度就是分别对每个变量进行微分，然后用逗号分割开，梯度是用&lt;&gt;包括起来，说明梯度其实一个向量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、在单变量的函数中，梯度其实就是函数的微分，代表着函数在某个给定点的切线的斜率</span><br><span class="line">2、在多变量函数中，梯度是一个向量，向量有方向，梯度的方向就指出了函数在给定点的上升最快的方向</span><br></pre></td></tr></table></figure></p><p>梯度的方向实际就是函数在此点上升最快的方向！而我们需要朝着下降最快的方向走，自然就是负的梯度的方向，所以此处需要加上负号</p></blockquote><h3 id="梯度下降法（Gradient-Descent）"><a href="#梯度下降法（Gradient-Descent）" class="headerlink" title="梯度下降法（Gradient Descent）"></a>梯度下降法（Gradient Descent）</h3><blockquote><p>梯度下降法的优化思想是用当前位置负梯度方向作为搜索方向，因为该方向为当前位置的最快下降方向，所以也被称为是”最速下降法“。最速下降法越接近目标值，步长越小，前进越慢</p></blockquote><p>梯度下降法的缺点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）靠近极小值时收敛速度减慢，；</span><br><span class="line"></span><br><span class="line">（2）直线搜索时可能会产生一些问题；</span><br><span class="line"></span><br><span class="line">（3）可能会“之字形”地下降。</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">\theta^1=\theta^0 - \alpha\nabla(j(\theta)</script><p>是关于Θ的一个函数，我们当前所处的位置为Θ0点，要从这个点走到J的最小值点<br>$\nabla$ 是梯度,$\alpha$是学习率或者步长</p><h4 id="批量梯度下降法"><a href="#批量梯度下降法" class="headerlink" title="批量梯度下降法"></a>批量梯度下降法</h4><p>将$j(\theta)$对$\theta$求偏导，得到每个$\theta$对应的的梯度：每个参数$\theta$的梯度负方向，来更新每个$\theta$</p><blockquote><p>优点：它得到的是一个全局最优解<br>缺点：数据量大，计算缓慢</p></blockquote><h4 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h4><p>随机梯度下降是通过每个样本来迭代更新一次，如果样本量很大的情况（例如几十万），那么可能只用其中几万条或者几千条的样本</p><blockquote><p>优点：只用部分数据继续优化，运算量小<br>缺点：损失一部分进度，增加迭代次数</p></blockquote><p>两者关系：</p><blockquote><p>随机梯度下降方法以损失很小的一部分精确度和增加一定数量的迭代次数为代价，换取了总体的优化效率的提升。增加的迭代次数远远小于样本的数量。</p></blockquote><p>总结：</p><blockquote><p><em>批量梯度下降</em>—最小化所有训练样本的损失函数，使得最终求解的是<strong>全局的最优解</strong>，即求解的参数是使得风险函数最小，但是对于大规模样本问题效率低下。</p><p><em>随机梯度下降</em>—最小化每条样本的损失函数，虽然不是每次迭代得到的损失函数都向着全局最优方向， 但是大的整体的方向是向全局最优解的，最终的结果往往是在全局最优解附近，适用于<strong>大规模训练样本</strong>情况。</p></blockquote><h3 id="牛顿法和拟牛顿法"><a href="#牛顿法和拟牛顿法" class="headerlink" title="牛顿法和拟牛顿法"></a>牛顿法和拟牛顿法</h3><p>牛顿法是一种在实数域和复数域上近似求解方程的方法。牛顿法最大的特点就在于它的<strong>收敛速度很快</strong>。</p><h4 id="单变量"><a href="#单变量" class="headerlink" title="单变量"></a>单变量</h4><p>例如：方法使用函数$f(x)$的泰勒级数的前面几项来寻找方程$f(x)= 0$的根。</p><p>1、选择一个接近函数$ f (x)$零点的 $x_0$，计算相应的$ f (x_0)$ 和切线斜率$f  ‘ (x_0)$（这里$f ‘ $表示函数$ f $ 的导数）。然后我们计算穿过点$(x_0,  f  (x_0))$ 并且斜率为$f ‘(x_0)$的直线和 $x $轴的交点的$x$坐标，也就是求如下方程的解：</p><script type="math/tex; mode=display">x*f'(x_0)+f(x_0)-x_0*f'(x_0)=0</script><p>求得新的$x$坐标$x_1$,$x_1$比$x_0$更加接近收敛值的解，也就是使得$f(x)=0$，单变量迭代公式：</p><script type="math/tex; mode=display">x_n+1=x_n-f(x_n)/f'(x_n)</script><blockquote><p>如果$f ‘$ 是连续的，牛顿法必定收敛</p></blockquote><h4 id="多变量的话，需要用到雅可比矩阵和海森矩阵。"><a href="#多变量的话，需要用到雅可比矩阵和海森矩阵。" class="headerlink" title="多变量的话，需要用到雅可比矩阵和海森矩阵。"></a>多变量的话，需要用到雅可比矩阵和海森矩阵。</h4><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/zyh_haise.png" alt="海森矩阵"></p><p>总结：</p><blockquote><p>牛顿法的优缺点<br>优点：二阶收敛，收敛速度快；<br>缺点：牛顿法是一种迭代算法，每一步都需要求解目标函数的Hessian矩阵的逆矩阵，计算比较复杂。</p></blockquote><h3 id="牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快"><a href="#牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快" class="headerlink" title="牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快"></a><font color="red">牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快</font></h3><blockquote><p>牛顿法就是用一个二次曲面去拟合你当前所处位置的局部曲面，而梯度下降法是用一个平面去拟合当前的局部曲面，通常情况下，二次曲面的拟合会比平面更好，所以牛顿法选择的下降路径会更符合真实的最优下降路径。</p><p>Hessian 矩阵非正定（非凸）导致无法收敛；<br>Hessian 矩阵维度过大带来巨大的计算量。</p></blockquote><h3 id="拟牛顿法（Quasi-Newton-Methods）"><a href="#拟牛顿法（Quasi-Newton-Methods）" class="headerlink" title="拟牛顿法（Quasi-Newton Methods）"></a>拟牛顿法（Quasi-Newton Methods）</h3><p>拟牛顿法是求解非线性优化问题最有效的方法之一。</p><p>拟牛顿法的本质思想是改善牛顿法每次需要求解复杂的Hessian矩阵的逆矩阵的缺陷，它使用<font color="red">正定矩阵来近似Hessian矩阵的逆</font>，从而简化了运算的复杂度。只需要用到一阶导数，不需要计算Hessian矩阵 以及逆矩阵，因此能够更快收敛</p><p>正定矩阵：<br>如果$X^TAX&gt;0$<br>判定定理1：对称阵A为正定的充分必要条件是：A的特征值全为正。 　<br>判定定理2：对称阵A为正定的充分必要条件是：A的各阶顺序主子式都为正。 　<br>判定定理3：任意阵A为正定的充分必要条件是：A合同于单位阵。</p><h3 id="拉格朗日乘子法"><a href="#拉格朗日乘子法" class="headerlink" title="拉格朗日乘子法"></a>拉格朗日乘子法</h3><p>作为一种优化算法，拉格朗日乘子法主要用于解决约束优化问题，它的基本思想就是通过引入拉格朗日乘子来将含有n个变量和k个约束条件的约束优化问题转化为含有（n+k）个变量的无约束优化问题。拉格朗日乘子背后的数学意义是其为约束方程梯度线性组合中每个向量的系数。</p><p>典型：<br>求函数$z=f(x,y)$在满足$b(x,y)=0$下的条件极值<br><br>转化为函数$F(x,y,\alpha)=f(x,y)+\alpha b(x,y)$的无条件极值问题</p><p>列题：<br>给定椭球：$x^2/a^2+y^2/b^2+z^2/c^2=1$(约束条件),求内接长方体最大体积，求极值问题，求$f(x,y,z)=8xyz$的最大值<br>用拉格朗日乘子法：转化为</p><script type="math/tex; mode=display">F(x,y,z,\alpha)=f(x,y,z)+\alpha b(x,y,z)</script><script type="math/tex; mode=display">=8xyz+\alpha(x^2/a^2+y^2/b^2+z^2/c^2-1)</script><p>对<script type="math/tex">F(x,y,z,\alpha)</script>求偏导得<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/lagelangri1.png" alt><br>然后联立三个方程的$bx=ay,az=cx$，带入第四个方程解<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/lagelangri2png.png" alt><br>解为：<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/lagelangri3.png" alt></p><h3 id="共轭梯度法"><a href="#共轭梯度法" class="headerlink" title="共轭梯度法"></a>共轭梯度法</h3><p>共轭梯度法是介于最速下降法与牛顿法之间的一个方法，它仅需利用一阶导数信息，但克服了最速下降法收敛慢的缺点，又避免了牛顿法需要存储和计算Hesse矩阵并求逆的缺点，共轭梯度法不仅是解决大型线性方程组最有用的方法之一，也是解大型非线性最优化最有效的算法之一。 在各种优化算法中，共轭梯度法是非常重要的一种。其优点是所需存储量小，具有步收敛性，稳定性高，而且不需要任何外来参数。</p><p><a href="http://www.cnblogs.com/maybe2030/p/4946256.html" target="_blank" rel="noopener">参考文章</a><br><a href="https://www.cnblogs.com/shixiangwan/p/7532830.html" target="_blank" rel="noopener">参考文章</a></p><h3 id="梯度不稳定"><a href="#梯度不稳定" class="headerlink" title="梯度不稳定"></a>梯度不稳定</h3><p>什么是梯度不稳定问题：深度神经网络中的梯度不稳定性，前面层中的梯度或会消失，或会爆炸。</p><p>原因：前面层上的梯度是来自于后面层上梯度的乘乘积。当存在过多的层次时，就出现了内在本质上的不稳定场景，如梯度消失和梯度爆炸。</p><p>后果：训练很难进行，不收敛了<br>1、loss过早地不再下降<br>2、精确度过早地不在提高</p><h4 id="梯度消失"><a href="#梯度消失" class="headerlink" title="梯度消失"></a>梯度消失</h4><p>梯度消失：<br>一是在深层网络中；<br>二是采用了不合适的损失函数，比如sigmoid。sigmoid导数最大为1/4，故只有当abs(w)&gt;4时才可能出现。先前传递误差就很小，前端网络w几乎没什么变化，等于这一层没能学习什么东西，网络层数越多就浪费了</p><p>解决方法：<br>1、初始化一个合适的w<br>2、选合适的激励函数</p><blockquote><p>relu、leakrelu、elu等激活函数</p></blockquote><p>relu函数：目前使用最多的激活函数</p><script type="math/tex; mode=display">Relu(x)=max(x,0)</script><p>函数图像：<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/imgrelu.png" alt></p><blockquote><p>relu的主要贡献在于：<br><br>优点：<br><br>1、— 解决了梯度消失、爆炸的问题<br><br>2、— 计算方便，计算速度快<br><br>3、— 加速了网络的训练<br><br>缺点：<br><br>1、由于负数部分恒为0，会导致一些神经元无法激活（可通过设置小学习率部分解决）<br><br>2、输出不是以0为中心的<br></p></blockquote><p>leakrelu:leakrelu就是为了解决relu的0区间带来的影响</p><script type="math/tex; mode=display">leakrelu=max(k*x,x)</script><p>函数图像：<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/imgrelu_leak.png" alt></p><h4 id="爆炸问题"><a href="#爆炸问题" class="headerlink" title="爆炸问题"></a>爆炸问题</h4><p>梯度爆炸：<br><br>一般出现在深层网络和权值初始化值太大的情况下。当权值过大，前面层比后面层梯度变化更快，会引起梯度爆炸问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 最优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_分类_数据聚类</title>
      <link href="/2018/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_%E6%95%B0%E6%8D%AE%E8%81%9A%E7%B1%BB/"/>
      <url>/2018/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_%E6%95%B0%E6%8D%AE%E8%81%9A%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>机器学习<em>分类</em>数据聚类</p><a id="more"></a><h3 id="K-Means（k-平均或k-均值）"><a href="#K-Means（k-平均或k-均值）" class="headerlink" title="K-Means（k-平均或k-均值）"></a>K-Means（k-平均或k-均值）</h3><p>可以称的上是知名度最高的一种聚类算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">首先，我们确定要几个的聚类（cluster，也称簇），并为它们随机初始化一个各自的聚类质心点（cluster centroids），它在上图中被表示为“X”。要确定聚类的数量，我们可以先快速看一看已有的数据点，并从中分辨出一些独特的数据。</span><br><span class="line">其次，我们计算每个数据点到质心的距离来进行分类，它跟哪个聚类的质心更近，它就被分类到该聚类。</span><br><span class="line">需要注意的是，初始质心并不是真正的质心，质心应满足聚类里每个点到它的欧式距离平方和最小这个条件。因此根据这些被初步分类完毕的数据点，我们再重新计算每一聚类中所有向量的平均值，并确定出新的质心。</span><br><span class="line">最后，重复上述步骤，进行一定次数的迭代，直到质心的位置不再发生太大变化。当然你也可以在第一步时多初始化几次，然后选取一个看起来更合理的点节约时间。</span><br><span class="line">K-Means的优点是速度非常快，因为我们所做的只是计算数据点和质心点之间的距离，涉及到的计算量非常少！因此它的算法时间复杂度只有O(n)。</span><br><span class="line"></span><br><span class="line">另一方面，K-Means有两个缺点。一是你必须一开始就决定数据集中包含多少个聚类。这个缺点并不总是微不足道的，理想情况下，我们的目标其实是用一种算法来分类这些数据，并从结果中观察出一些规律，而不是限制几个条件强行聚类。二是一开始质心点的选取是随机的，算法可能会初始化出差异巨大的点。这个缺点导致的结果是质心点的位置不可重复且缺乏一致性。</span><br><span class="line"></span><br><span class="line">K-Medians是与K-Means相关的另一种聚类算法，不同之处在于它使用簇的中值向量来重新计算质心点。该方法对异常值不敏感（因为使用中值），但在较大数据集上运行时速度会慢很多，因为每次计算中值向量，我们都要重新排序。</span><br></pre></td></tr></table></figure><h3 id="Mean-Shift聚类"><a href="#Mean-Shift聚类" class="headerlink" title="Mean-Shift聚类"></a>Mean-Shift聚类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Mean shift算法，又称均值漂移算法，这是一种基于核密度估计的爬山算法，可用于聚类、图像分割、跟踪等。它的工作原理基于质心，这意味着它的目标是定位每个簇/类的质心，即先算出当前点的偏移均值，将该点移动到此偏移均值，然后以此为新的起始点，继续移动，直到满足最终的条件（找出最密集的区域）。</span><br><span class="line"></span><br><span class="line">1、为了理解均值漂移，我们可以像上图一样想象二维空间中的一组数据点，然后先随机选择一个点C，以它为圆心画一个半径为r的圆开始移动。之前提到了，这是个爬山算法，它的核函数会随着迭代次数增加逐渐向高密度区域靠近。</span><br><span class="line">2、在每轮迭代中，算法会不断计算圆心到质心的偏移均值，然后整体向质心靠近。漂移圆圈内的密度与数据点数成正比。到达质心后，算法会更新质心位置，并继续让圆圈向更高密度的区域靠近。</span><br><span class="line">3、当圆圈到达目标质心后，它发现自己无论朝哪个方向漂移都找不到更多的数据点，这时我们就认为它已经处于最密集的区域。</span><br><span class="line">4、这时，算法满足了最终的条件，即退出。</span><br><span class="line"></span><br><span class="line">Mean-Shift不需要实现定义聚类数量，因为这些都可以在计算偏移均值时得出。这是一个巨大的优势。同时，算法推动聚类中心在向密度最大区域靠近的效果也非常令人满意，这一过程符合数据驱动型任务的需要，而且十分自然直观。如果要说Mean-Shift有什么缺点，那就是对高维球区域的半径r的定义，不同选择可能会产生高度不同的影响。</span><br></pre></td></tr></table></figure><h3 id="EM聚类"><a href="#EM聚类" class="headerlink" title="EM聚类"></a>EM聚类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">均值→质心，方差→椭圆聚类，权重→聚类大小。</span><br><span class="line">K-Means算法的主要缺点之一是它直接用了距离质心的平均值。</span><br><span class="line"></span><br><span class="line">1、首先，我们确定聚类的数量（如K-Means），并随机初始化每个聚类的高斯分布参数。你也可以尝试通过快速查看数据来为初始参数提供更好的猜测，但从上图可以看出，这其实不是很必要，因为算法会很快进行优化。</span><br><span class="line">2、其次，根据每个聚类的高斯分布，计算数据点属于特定聚类的概率。如果数据点越接近高斯质心，那它属于该聚类的概率就越高。这很直观，因为对于高斯分布，我们一般假设大部分数据更靠近聚类质心。</span><br><span class="line">3、在这些概率的基础上，我们为高斯分布计算一组新的参数，使聚类内数据点的概率最大化。我们用数据点位置的加权和来计算这些新参数，其中权重就是数据点属于聚类的概率。为了可视化这个过程，我们可以看看上面的图片，特别是黄色的聚类。第一次迭代中，它是随机的，大多数黄点都集中在该聚类的右侧。当我们按概率计算加权和后，虽然聚类的中部出现一些点，但右侧的比重依然很高。随着迭代次数增加，黄点在聚类中的位置也完成了“右下→左下”的移动。因此，标准差的变化调整着聚类的形状，以使它能更适合数据点的分布。</span><br><span class="line">4、迭代步骤2和步骤3，直至收敛。</span><br><span class="line"></span><br><span class="line">GMM有两个关键优势。首先它比K-Means更灵活，由于标准差的引入，最后聚类的形状不再局限于圆形，它还可以是大小形状不一的椭圆形——K均值实际上是GMM的一个特例，其中每个聚类的协方差在所有维上都接近0。其次，权重的引入为同一点属于多个聚类找到了解决方案。如果一个数据点位于两个聚类的重叠区域，那我们就可以简单为它定义一个聚类，或者计算它属于X聚类的百分比是多少，属于Y聚类的百分比是多少。简而言之，GMM支持混合“成员”。</span><br><span class="line"></span><br><span class="line">谈及缺点，和K-Means相比，GMM每一步迭代的计算量比较大。另外，它的求解办法基于EM算法，因此有可能陷入局部极值，需要经过多次迭代。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特征提取——颜色特征</title>
      <link href="/2018/07/16/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E9%A2%9C%E8%89%B2%E7%89%B9%E5%BE%81/"/>
      <url>/2018/07/16/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E9%A2%9C%E8%89%B2%E7%89%B9%E5%BE%81/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>特征提取——颜色特征<br><a id="more"></a></p><h3 id="颜色直方图"><a href="#颜色直方图" class="headerlink" title="颜色直方图"></a>颜色直方图</h3><p>OpenCV之颜色空间:</p><p>颜色空间RGB（Red 红色，Green 绿色，Blue 蓝色）</p><p>R的取值范围：0-255</p><p>G的取值范围：0-255</p><p>B的取值范围：0-255</p><p>颜色空间HSV （Hue 色相，Saturation 饱和度，intensity 亮度）</p><p>H的取值范围：0-179</p><p>S的取值范围：0-255</p><p>V的取值范围：0-255</p><p>颜色空间HLS (Hue 色相，lightness 亮度，Saturation 饱和度)</p><p>H的取值范围：0-179</p><p>L的取值范围：0-255</p><p>S的取值范围：0-255</p><h3 id="颜色矩"><a href="#颜色矩" class="headerlink" title="颜色矩"></a>颜色矩</h3><p>这种方法的数学基础在于图像中任何的颜色分布均可以用它的矩来表示。此外，由于颜色分布信息主要集中在低阶矩中，因此仅采用颜色的一阶矩（mean）、二阶矩（variance）和三阶矩（skewness）就足以表达图像的颜色分布。与颜色直方图相比，该方法的另一个好处在于无需对特征进行向量化。<br>图像的颜色矩一共只需要9个分量（3个颜色分量，每个分量上3个低阶矩）<br>颜色矩常和其它特征结合使用，而且一般在使用其它特征前起到过滤缩小范围（narrow down）的作用。 </p><p>一阶矩(均值,mean),反映图像明暗程度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u=(1/N)sum(Pij)</span><br></pre></td></tr></table></figure></p><p>二阶矩(方差,viarance),反映图像颜色分布范围<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=sqrt(((1/N)sum(Pij-u)^2),2)</span><br></pre></td></tr></table></figure></p><p>三阶矩(斜度,skewness),反映图像颜色分布对称性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=sqrt(((1/N)sum(Pij-u)^3),3)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> 特征提取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特征提取——局部特征</title>
      <link href="/2018/07/16/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E5%B1%80%E9%83%A8%E7%89%B9%E5%BE%81/"/>
      <url>/2018/07/16/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E5%B1%80%E9%83%A8%E7%89%B9%E5%BE%81/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>特征提取——局部特征</p><a id="more"></a><p>LOG,HOG,DOG微分算子在近圆的斑点检测方面效果很好</p><h3 id="HOG特征"><a href="#HOG特征" class="headerlink" title="HOG特征"></a>HOG特征</h3><p><a href="https://blog.csdn.net/coming_is_winter/article/details/72850511" target="_blank" rel="noopener">https://blog.csdn.net/coming_is_winter/article/details/72850511</a><br><a href="https://blog.csdn.net/zouxy09/article/details/7929348/" target="_blank" rel="noopener">https://blog.csdn.net/zouxy09/article/details/7929348/</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">总结：Dalal提出的Hog特征提取的过程：把样本图像分割为若干个像素的单元（cell），把梯度方向平均划分为9个区间（bin），在每个单元里面对所有像素的梯度方向在各个方向区间进行直方图统计，得到一个9维的特征向量，每相邻的4个单元构成一个块（block），把一个块内的特征向量联起来得到36维的特征向量，用块对样本图像进行扫描，扫描步长为一个单元。最后将所有块的特征串联起来，就得到了人体的特征。</span><br><span class="line"></span><br><span class="line">例如，对于64*128的图像而言，每16*16的像素组成一个cell，每2*2个cell组成一个块，因为每个cell有9个特征，所以每个块内有4*9=36个特征，以8个像素为步长，那么，水平方向将有7个扫描窗口，垂直方向将有15个扫描窗口。也就是说，64*128的图片，总共有36*7*15=3780个特征。</span><br><span class="line"></span><br><span class="line">特征总数： 一个cell有9个特征（9个梯度方向），每个特征cell块里有 num*9个特征，步长像素规格：（列像素数-步长）/步长*（行像素数-步长）/步长，</span><br><span class="line">总特征数:（列像素数-步长）/步长*（行像素数-步长）/步长*num*9</span><br></pre></td></tr></table></figure></p><h3 id="LOG特征"><a href="#LOG特征" class="headerlink" title="LOG特征"></a>LOG特征</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图像与某一个二维函数进行卷积运算实际就是求取图像与这一函数的相似性。同理，图像与高斯拉普拉斯函数的卷积实际就是求取图像与高斯拉普拉斯函数的相似性。当图像中的斑点尺寸与高斯拉普拉斯函数的形状趋近一致时，图像的拉普拉斯响应达到最大。</span><br></pre></td></tr></table></figure><p>Laplace可以用来检测图像中的局部极值点，但是对噪声敏感，所以在我们对图像进行Laplace卷积之前，我们用一个高斯低通滤波对图像进行卷积，目标是去除图像中的噪声点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">先对图像f(x,y)用方差为σ的高斯核进行高斯滤波，去除图像中的噪点。</span><br><span class="line"></span><br><span class="line">L(x,y;σ)=f(x,y)∗G(x,y;σ)</span><br><span class="line">G(x,y;σ)高斯核</span><br><span class="line">然后对图像的拉普拉斯图像则为：</span><br><span class="line"></span><br><span class="line">∇^2=(∂^2L/∂^x2)+(∂^2L/∂y^2)</span><br><span class="line">而实际上有下面等式：</span><br><span class="line"></span><br><span class="line">∇^2[G(x,y)∗f(x,y)]=∇^2[G(x,y)]∗f(x,y)</span><br><span class="line"></span><br><span class="line">我们可以先求高斯核的拉普拉斯算子，再对图像进行卷积</span><br></pre></td></tr></table></figure></p><blockquote><p>使用LoG虽然能较好的检测到图像中的特征点，但是其运算量过大，通常可使用DoG（差分高斯，Difference of Gaussina）来近似计算LoG</p></blockquote><h3 id="Haar特征"><a href="#Haar特征" class="headerlink" title="Haar特征"></a>Haar特征</h3><p>Haar特征分为三类：边缘特征、线性特征、中心特征和对角线特征，组合成特征模板。特征模板内有白色和黑色两种矩形，并定义该模板的特征值为</p><h3>白色矩形像素和减去黑色矩形像素和</h3><p></p><h3 id="Haar-like特征"><a href="#Haar-like特征" class="headerlink" title="Haar-like特征"></a>Haar-like特征</h3><p><a href="https://blog.csdn.net/zouxy09/article/details/7929570" target="_blank" rel="noopener">https://blog.csdn.net/zouxy09/article/details/7929570</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">积分图就是只遍历一次图像就可以求出图像中所有区域像素和的快速算法，大大的提高了图像特征值计算的效率。</span><br><span class="line"></span><br><span class="line">       积分图主要的思想是将图像从起点开始到各个点所形成的矩形区域像素之和作为一个数组的元素保存在内存中，当要计算某个区域的像素和时可以直接索引数组的元素，不用重新计算这个区域的像素和，从而加快了计算（这有个相应的称呼，叫做动态规划算法）。积分图能够在多种尺度下，使用相同的时间（常数时间）来计算不同的特征，因此大大提高了检测速度。</span><br><span class="line"></span><br><span class="line">       我们来看看它是怎么做到的。</span><br><span class="line"></span><br><span class="line">       积分图是一种能够描述全局信息的矩阵表示方法。积分图的构造方式是位置（i,j）处的值ii(i,j)是原图像(i,j)左上角方向所有像素的和：</span><br></pre></td></tr></table></figure><p>归一化图像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i¯(x,y)=(i(x,y)−μ)/cσ</span><br><span class="line">公式中i¯(x,y)表示归一化之后的图像，而i(x,y)表示原始的图像，其中μ表示图像的均值，而σ表示图像的标准差</span><br><span class="line">σ2=(1/N)∑x2−μ2   2是平方</span><br></pre></td></tr></table></figure></p><h3 id="SIFT特征"><a href="#SIFT特征" class="headerlink" title="SIFT特征"></a>SIFT特征</h3><p>SIFT的全称是Scale Invariant Feature Transform，尺度不变特征变换(物体怎么转，人都能识别)。SIFT特征对旋转、尺度缩放、亮度变化等保持不变性，是一种非常稳定的局部特征。</p><p>有4个主要步骤</p><p>1、尺度空间的极值检测 搜索所有尺度空间上的图像，通过高斯微分函数来识别潜在的对尺度和选择不变的兴趣点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$$$L(x,y,σ)=G(x,y,σ)∗I(x,y)$</span><br><span class="line"></span><br><span class="line">为了有效的在尺度空间检测到稳定的关键点，提出了高斯差分尺度空间（DOG scale-space）。利用不同尺度的高斯差分核与图像卷积生成。构造高斯差分尺度空间(DOG scale-space): </span><br><span class="line">$$D(x,y,σ)=(G(x,y,kσ)−G(x,y,σ))∗I(x,y)=L(x,y,kσ)−L(x,y,σ)$$</span><br><span class="line"></span><br><span class="line">σ 是尺度坐标。σ大小决定图像的平滑程度，大尺度对应图像的概貌特征，小尺度对应图像的细节特征。大的σ值对应粗糙尺度(低分辨率)，反之，对应精细尺度(高分辨率)。</span><br><span class="line"></span><br><span class="line">对于一幅图像I，建立其在不同尺度(scale)的图像,后面每个采样都是原图的1/4倍。</span><br><span class="line"></span><br><span class="line">每个点都要与邻域的点，上下相邻尺度的点做比较（9+8+9）26个点作比较（以确保在尺度空间和二维图像空间都检测到极值点）。一个点如果在DOG尺度空间本层以及上下两层的26个领域中是最大或最小值时，就认为该点是图像在该尺度下的一个特征点</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.csdn.net/20160411162902180" alt></p><p>2、特征点定位 在每个候选的位置上，通过一个拟合精细模型来确定位置尺度，关键点的选取依据他们的稳定程度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">拟和三维二次函数以精确确定关键点的位置和尺度，同时去除低对比度的关键点和不稳定的边缘响应点(因为DoG算子会产生较强的边缘响应)，以增强匹配稳定性、提高抗噪声能力</span><br></pre></td></tr></table></figure></p><p>用Harris Corner检测<br><a href="https://blog.csdn.net/ws_20100/article/details/51122322" target="_blank" rel="noopener">参考文章</a></p><p>3、特征方向赋值 基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向，后续的所有操作都是对于关键点的方向、尺度和位置进行变换，从而提供这些特征的不变性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个特征点计算一个方向，依照这个方向做进一步的计算， *利用关键点邻域像素的梯度方向分布特性为每个关键点指定方向参数，使算子具备旋转不变性。</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">m(x,y)=(L(x+1,y)−L(x−1,y))2+(L(x,y+1)−L(x,y−1))2</script><script type="math/tex; mode=display">√θ(x,y)=atan2(L(x,y+1)−L(x,y−1)L(x+1,y)−L(x−1,y)</script><p>每个关键点有三个信息：位置、所处尺度、方向。由此可以确定一个SIFT特征区域。<br><img src="https://img-blog.csdn.net/20160413110610471" alt="直方图"><br>4、特征点描述 在每个特征点周围的邻域内，在选定的尺度上测量图像的局部梯度，这些梯度被变换成一种表示，这种表示允许比较大的局部形状的变形和光照变换。</p><blockquote><p>高斯函数是唯一可行的尺度空间核</p></blockquote><h3 id="尺度空间"><a href="#尺度空间" class="headerlink" title="尺度空间"></a>尺度空间</h3><p>多分辨率图像金字塔:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、对原始图像进行平滑</span><br><span class="line">2、对处理后的图像进行降采样（通常是水平、垂直方向的1/2）降采样后得到一系列不断尺寸缩小的图像。显然，一个传统的金字塔中，每一层的图像是其上一层图像长、高的各一半。多分辨率的图像金字塔虽然生成简单，但其本质是降采样，图像的局部特征则难以保持，也就是无法保持特征的尺度不变性。</span><br></pre></td></tr></table></figure></p><p>高斯尺度空间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">图像的模糊程度来模拟人在距离物体由远到近时物体在视网膜上成像过程，距离物体越近其尺寸越大图像也越模糊，这就是高斯尺度空间，使用不同的参数模糊图像（分辨率不变）</span><br><span class="line"></span><br><span class="line">图像和高斯函数进行卷积运算，图像模糊，使用不同的“高斯核”可得到不同模糊程度的图像</span><br><span class="line"></span><br><span class="line">L(x,y,σ)=G(x,y,σ)∗I(x,y)</span><br><span class="line"></span><br><span class="line">其中G(x,y,σ)是高斯核函数</span><br><span class="line">G(x,y,σ)=（1/2Πσ^2）e^((x^2+y^2)/(2σ^2))</span><br></pre></td></tr></table></figure></p><p>构建尺度空间的目的是为了检测出在不同的尺度下都存在的特征点，而检测特征点较好的算子是Δ^2G(高斯拉普拉斯,LoG）</p><h3 id="DoG特征"><a href="#DoG特征" class="headerlink" title="DoG特征"></a>DoG特征</h3><p>使用LoG虽然能较好的检测到图像中的特征点，但是其运算量过大，通常可使用DoG（差分高斯，Difference of Gaussina）来近似计算LoG。</p><p>DOG可以看作为LOG的一个近似，但是它比LOG的效率更高。<br>设k为相邻两个高斯尺度空间的比例因子，则DoG的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D(x,y,σ)=[G(x,y,kσ)−G(x,y,σ)]∗I(x,y)=L(x,y,kσ)−L(x,y,σ)</span><br></pre></td></tr></table></figure><p>L(x,y,σ) 是图像的高斯尺度空间<br>将相邻的两个高斯空间的图像相减就得到了DoG的响应图像</p><h3 id="Harris角点特征提取"><a href="#Harris角点特征提取" class="headerlink" title="Harris角点特征提取"></a>Harris角点特征提取</h3><font color="red">Harris角点检测是一种基于图像灰度的一阶导数矩阵检测方法。检测器的主要思想是局部自相似性/自相关性，即在某个局部窗口内图像块与在各个方向微小移动后的窗口内图像块的相似性。</font><blockquote><p>1、角点可以是两个边缘的角点；&lt;/br&gt;<br>2、角点是邻域内具有两个主方向的特征点；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">人眼对角点的识别通常是在一个局部的小区域或小窗口完成的。如果在各个方向上移动这个特征的小窗口，窗口内区域的灰度发生了较大的变化，那么就认为在窗口内遇到了角点。如果这个特定的窗口在图像各个方向上移动时，窗口内图像的灰度没有发生变化，那么窗口内就不存在角点；如果窗口在某一个方向移动时，窗口内图像的灰度发生了较大的变化，而在另一些方向上没有发生变化，那么，窗口内的图像可能就是一条直线的线段。</span><br></pre></td></tr></table></figure></p></blockquote><script type="math/tex; mode=display">x^{y^z}=(1+{\rm e}^x)^{-2xy^w}</script><script type="math/tex; mode=display">sqrt()</script><blockquote><p>结论：1、增大α的值，将减小角点响应值R，降低角点检测的灵性，减少被检测角点的数量；减小α值，将增大角点响应值R，增加角点检测的灵敏性，增加被检测角点的数量。&lt;/br&gt;<br>2、Harris角点检测算子对亮度和对比度的变化不敏感&lt;/br&gt;<br>3、Harris角点检测算子具有旋转不变性&lt;/br&gt;<br>4、Harris角点检测算子不具有尺度不变性&lt;/br&gt;</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> 特征提取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特征提取——纹理特征</title>
      <link href="/2018/07/16/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E7%BA%B9%E7%90%86%E7%89%B9%E5%BE%81/"/>
      <url>/2018/07/16/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E7%BA%B9%E7%90%86%E7%89%B9%E5%BE%81/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>特征提取——纹理特征<br><a id="more"></a></p><h3 id="LBP图像特征"><a href="#LBP图像特征" class="headerlink" title="LBP图像特征"></a>LBP图像特征</h3><p>图像处理之特征提取（二）之LBP特征简单梳理<br><br><a href="https://blog.csdn.net/coming_is_winter/article/details/72859957" target="_blank" rel="noopener">https://blog.csdn.net/coming_is_winter/article/details/72859957</a><br><br><a href="https://blog.csdn.net/zouxy09/article/details/7929531" target="_blank" rel="noopener">https://blog.csdn.net/zouxy09/article/details/7929531</a><br><br>LBP特征理解。<br><br><a href="http://blog.csdn.net/hqh45/article/details/24501097" target="_blank" rel="noopener">http://blog.csdn.net/hqh45/article/details/24501097</a><br>LBP（Local Binary Pattern，局部二值模式）是一种用来描述图像局部纹理特征的算子；它具有旋转不变性和灰度不变性等显著的优点。它是首先由T. Ojala, M.Pietikäinen, 和 D. Harwood 在1994年提出，用于纹理特征提取。而且，提取的特征是图像的局部的纹理特征；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lbp理论：</span><br><span class="line">原始的LBP算子定义为在3*3的窗口内，以窗口中心像素为阈值，将相邻的8个像素的灰度值与其进行比较，若周围像素值大于中心像素值，则该像素点的位置被标记为1，否则为0。这样，3*3邻域内的8个点经比较可产生8位二进制数（通常转换为十进制数即LBP码，共256种），即得到该窗口中心像素点的LBP值，并用这个值来反映该区域的纹理信息。</span><br></pre></td></tr></table></figure></p><p>圆形LBP算子： 半径为R<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本的 LBP算子的最大缺陷在于它只覆盖了一个固定半径范围内的小区域，这显然不能满足不同尺寸和频率纹理的需要。为了适应不同尺度的纹理特征，并达到灰度和旋转不变性的要求，Ojala等对 LBP 算子进行了改进，将 3×3邻域扩展到任意邻域，并用圆形邻域代替了正方形邻域，改进后的 LBP 算子允许在半径为 R 的圆形邻域内有任意多个像素点。从而得到了诸如半径为R的圆形区域内含有P个采样点的LBP算子；</span><br></pre></td></tr></table></figure></p><p>即不断旋转圆形邻域得到一系列初始定义的 LBP值，取其最小值作为该邻域的 LBP 值。</p><h3 id="灰度共生矩阵（GLCM，Gray-Level-Co-occurrence-Matrix）"><a href="#灰度共生矩阵（GLCM，Gray-Level-Co-occurrence-Matrix）" class="headerlink" title="灰度共生矩阵（GLCM，Gray-Level Co-occurrence Matrix）"></a>灰度共生矩阵（GLCM，Gray-Level Co-occurrence Matrix）</h3><p>概念：</p><blockquote><p>灰度共生矩阵是涉及像素距离和角度的矩阵函数，它通过计算图像中一定距离和一定方向的两点灰度之间的相关性，来反映图像在<font color="red">方向、间隔、变化幅度及快慢</font>上的综合信息。<br><br>灰度直方图是对图像上单个像素具有某个灰度进行统计的结果，而<font color="red">灰度共生矩阵是对图像上保持某距离的两像素分别具有某灰度的状况进行统计得到的。</font></p></blockquote><p>含义：<br>以（1，1）点为例，GLCM（1，1）值为1说明左侧原图只有一对灰度为1的像素水平相邻。GLCM（1，2）值为2，是因为原图有两对灰度为1和2的像素水平相邻。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">矩阵</span><br><span class="line">|1 2 1|</span><br><span class="line">|2 2 2| </span><br><span class="line">|1 2 2|</span><br><span class="line">对应GLMC矩阵（最大是2，所以是2*2矩阵）</span><br><span class="line"></span><br><span class="line">GLCM矩阵:</span><br><span class="line">  1 2</span><br><span class="line">1|0 2| </span><br><span class="line">2|1 6|</span><br><span class="line">0(1,1)相邻， 2(1,2)水平相邻， 2(2,1)垂直相邻， 6(2,2)相邻</span><br></pre></td></tr></table></figure><p>灰度共生矩阵的特征</p><p>1) 角二阶矩（Angular Second Moment, ASM)<br><br>公式：$ASM = sum(p(i,j)^2)$，其中  $p(i,j) $表示归一后的灰度共生矩阵<br>意义：角二阶矩是图像灰度分布均匀程度和纹理粗细的一个度量，当图像纹理绞细致、灰度分布均匀时，能量值较大，反之，较小。<br></p><font color="red">结论：值大，灰度分布均匀</font><p>2) 熵（Entropy, ENT)<br><br>公式：$ENT=sum[-p(i,j)log(p(i,j))] $<br>意义：描述图像具有的信息量的度量，表明图像的复杂程度，当复杂程度高时，熵值较大，反之则较小。<br></p><font color="red">结论：值大，复杂程度高</font><p>3) 反差分矩阵（Inverse Differential Moment, IDM)<br>公式：$IDM=sum[p(i,j)/(1+(i-j)^2)]$<br>意义：反映了纹理的清晰程度和规则程度，纹理清晰、规律性较强、易于描述的，值较大；杂乱无章的，难于描述的，值较小。</p><font color="red">结论：值大，纹理清晰、规律性较强</font><h3 id="Gabor小波"><a href="#Gabor小波" class="headerlink" title="Gabor小波"></a>Gabor小波</h3><p>Gabor函数是一个用于边缘提取的线性滤波器</p><p>作用：<br>Gabor小波可以方便的提取图像在<font color="red">各个尺度和方向上的纹理信息</font>，同时在一定程度上降低了图像中光照变化和噪声的影响。<br>提取目标的<font color="red">局部空间和频率域信息</font>方面具有良好的特性。<br><br>特点：<br>1、Gabor小波对于图像的边缘敏感<br>2、对光照不敏感<br>3、对图像旋转有一定适应性</p><h5 id="灰度共生矩阵opencv代码："><a href="#灰度共生矩阵opencv代码：" class="headerlink" title="灰度共生矩阵opencv代码："></a>灰度共生矩阵opencv代码：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">// 0°灰度共生矩阵</span><br><span class="line">void getGLCM0(Mat&amp; src, Mat&amp; dst, int gray_level)// 0度灰度共生矩阵</span><br><span class="line">&#123;</span><br><span class="line">CV_Assert(1 == src.channels());</span><br><span class="line"> </span><br><span class="line">int height = src.rows;</span><br><span class="line">int width = src.cols;</span><br><span class="line"> </span><br><span class="line">dst.create(gray_level, gray_level, CV_32SC1);</span><br><span class="line">dst = Scalar::all(0);</span><br><span class="line"> </span><br><span class="line">for (int i = 0; i &lt; height; i++)</span><br><span class="line">&#123;</span><br><span class="line">int*srcdata = src.ptr&lt;int&gt;(i);</span><br><span class="line">for (int j = 0; j &lt; width - 1; j++)</span><br><span class="line">&#123;</span><br><span class="line">// 同样的像素对，水平相邻</span><br><span class="line">int rows = srcdata[j];</span><br><span class="line">int cols = srcdata[j + 1];</span><br><span class="line">dst.ptr&lt;int&gt;(rows)[cols]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 90°灰度共生矩阵</span><br><span class="line">void getGLCM90(Mat&amp; src, Mat&amp; dst, int gray_level)</span><br><span class="line">&#123;</span><br><span class="line">CV_Assert(1 == src.channels());</span><br><span class="line"> </span><br><span class="line">int height = src.rows;</span><br><span class="line">int width = src.cols;</span><br><span class="line"> </span><br><span class="line">dst = Mat(gray_level, gray_level, CV_32SC1, Scalar(0));</span><br><span class="line"> </span><br><span class="line">for (int i = 0; i &lt; height - 1; i++)</span><br><span class="line">&#123;</span><br><span class="line">int*srcdata = src.ptr&lt;int&gt;(i);</span><br><span class="line">int*srcdata1 = src.ptr&lt;int&gt;(i + 1);</span><br><span class="line">for (int j = 0; j &lt; width; j++)</span><br><span class="line">&#123;</span><br><span class="line">// 同样的像素对，垂直相邻</span><br><span class="line">int rows = srcdata[j];</span><br><span class="line">int cols = srcdata1[j];</span><br><span class="line">dst.ptr&lt;int&gt;(rows)[cols]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 45°灰度共生矩阵</span><br><span class="line">void getGLCM45(Mat&amp; src, Mat&amp; dst, int gray_level)</span><br><span class="line">&#123;</span><br><span class="line">CV_Assert(1 == src.channels());</span><br><span class="line"> </span><br><span class="line">int height = src.rows;</span><br><span class="line">int width = src.cols;</span><br><span class="line"> </span><br><span class="line">dst = Mat(gray_level, gray_level, CV_32SC1, Scalar(0));</span><br><span class="line"> </span><br><span class="line">for (int i = 0; i &lt; height - 1; i++)</span><br><span class="line">&#123;</span><br><span class="line">int*srcdata = src.ptr&lt;int&gt;(i);</span><br><span class="line">int*srcdata1 = src.ptr&lt;int&gt;(i + 1);</span><br><span class="line">for (int j = 0; j &lt; width - 1; j++)</span><br><span class="line">&#123;</span><br><span class="line">// 同样的像素对，45°相邻</span><br><span class="line">int rows = srcdata[j];</span><br><span class="line">int cols = srcdata1[j + 1];</span><br><span class="line">dst.ptr&lt;int&gt;(rows)[cols]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 135°灰度共生矩阵</span><br><span class="line">void getGLCM135(Mat&amp; src, Mat&amp; dst, int gray_level)</span><br><span class="line">&#123;</span><br><span class="line">CV_Assert(1 == src.channels());</span><br><span class="line"> </span><br><span class="line">int height = src.rows;</span><br><span class="line">int width = src.cols;</span><br><span class="line"> </span><br><span class="line">dst = Mat(gray_level, gray_level, CV_32SC1, Scalar(0));</span><br><span class="line"> </span><br><span class="line">for (int i = 0; i &lt; height - 1; i++)</span><br><span class="line">&#123;</span><br><span class="line">int*srcdata = src.ptr&lt;int&gt;(i);</span><br><span class="line">int*srcdata1 = src.ptr&lt;int&gt;(i + 1);</span><br><span class="line">for (int j = 1; j &lt; width; j++)</span><br><span class="line">&#123;</span><br><span class="line">// 同样的像素对，135°相邻</span><br><span class="line">int rows = srcdata[j];</span><br><span class="line">int cols = srcdata1[j - 1];</span><br><span class="line">dst.ptr&lt;int&gt;(rows)[cols]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 计算特征值</span><br><span class="line">void featureGLCM(Mat&amp;src, double&amp; Asm, double&amp; Ent, double&amp; Con, double&amp; Idm)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">CV_Assert(src.channels() == 1);</span><br><span class="line"></span><br><span class="line">int height = src.rows;</span><br><span class="line">int width = src.cols;</span><br><span class="line">int total = 0;</span><br><span class="line"> </span><br><span class="line">//求图像所有像素的灰度值的和</span><br><span class="line">for (int i = 0; i &lt; height; i++)</span><br><span class="line">&#123;</span><br><span class="line">int*srcdata = src.ptr&lt;int&gt;(i);</span><br><span class="line">for (int j = 0; j &lt; width; j++)</span><br><span class="line">&#123;</span><br><span class="line">total += srcdata[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//图像每一个像素的的值除以像素总和</span><br><span class="line">Mat mean;</span><br><span class="line">mean.create(height, width, CV_64FC1);</span><br><span class="line">for (int i = 0; i &lt; height; i++)</span><br><span class="line">&#123;</span><br><span class="line">int*srcdata = src.ptr&lt;int&gt;(i);</span><br><span class="line">double*copydata = mean.ptr&lt;double&gt;(i);</span><br><span class="line">for (int j = 0; j &lt; width; j++)</span><br><span class="line">&#123;</span><br><span class="line">copydata[j] = (double)srcdata[j] / (double)total;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">for (int i = 0; i &lt; height; i++)</span><br><span class="line">&#123;</span><br><span class="line">double*srcdata = mean.ptr&lt;double&gt;(i);</span><br><span class="line">for (int j = 0; j &lt; width; j++)</span><br><span class="line">&#123;</span><br><span class="line">// 能量</span><br><span class="line">Asm += srcdata[j] * srcdata[j];</span><br><span class="line"> </span><br><span class="line">// 熵(Entropy) </span><br><span class="line">if (srcdata[j]&gt;0)</span><br><span class="line">Ent -= srcdata[j] * log(srcdata[j]);</span><br><span class="line"> </span><br><span class="line">// 对比度</span><br><span class="line">Con += (double)(i - j)*(double)(i - j)*srcdata[j];</span><br><span class="line"> </span><br><span class="line">// 逆差矩</span><br><span class="line">Idm += srcdata[j] / (1 + (double)(i - j)*(double)(i - j));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> 特征提取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特征提取——局部特征-SIFT算法尺度不变性的理解</title>
      <link href="/2018/07/16/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E5%B1%80%E9%83%A8%E7%89%B9%E5%BE%81_SIFT/"/>
      <url>/2018/07/16/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E5%B1%80%E9%83%A8%E7%89%B9%E5%BE%81_SIFT/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>特征提取——局部特征</p><a id="more"></a><p><a href="https://blog.csdn.net/ws_20100/article/details/51122322" target="_blank" rel="noopener">参考这个就完事了</a></p><h3 id="局部特征"><a href="#局部特征" class="headerlink" title="局部特征"></a>局部特征</h3><p>不管原图尺度是多少，在包含了所有尺度的尺度空间下都能找到那些稳定的极值点，这样就做到了尺度不变！</p><blockquote><p>高斯函数是唯一可行的尺度空间核<br>比如说一张美女图片，想要框出帽子的信息，图像尺寸小时框要这么大，图像尺寸大时，框也要相应调大：</p></blockquote><p>尺度不变性：</p><script type="math/tex; mode=display">L(x,y,σ)=G(x,y,σ)*I(x,y)</script><p>为了有效的在尺度空间检测到稳定的关键点，提出了高斯差分尺度空间（DOG scale-space）。利用不同尺度的高斯差分核与图像卷积生成。构造高斯差分尺度空间(DOG scale-space): </p><script type="math/tex; mode=display">D(x,y,σ)=(G(x,y,kσ)-G(x,y,σ))*I(x,y)=L(x,y,kσ)-L(x,y,σ)</script><p>σ 是尺度坐标。σ大小决定图像的平滑程度，大尺度对应图像的概貌特征，小尺度对应图像的细节特征。大的σ值对应粗糙尺度(低分辨率)，反之，对应精细尺度(高分辨率)。</p><p>旋转不变性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lowe采用的方法是在生成描述子前将图片旋转到一个特定的方向上，这个方向是根据图片内容得到的，具体就是用在某个半径大小的圆内的像素的梯度信息。</span><br><span class="line">sigma取的是1.5*&lt;scale of key point&gt;,r取3*sigma</span><br><span class="line">将图片先旋转到主方向，这个方向由于是用相同的信息得到的，所以总是指向同一方。</span><br></pre></td></tr></table></figure></p><p>抵抗噪声：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DoG得到极值点后，去除低对比度的点的点舍弃,在确定主方向和生成描述子时都将梯度模值加进行加权，即是噪声影响了部分点，经过加权统计会抑制变化，不会对全局造成太大影响</span><br></pre></td></tr></table></figure></p><p><a href="https://blog.csdn.net/u014485485/article/details/78681086?locationNum=1&amp;fps=1" target="_blank" rel="noopener">参考文章</a></p><h3 id="OpenCV代码"><a href="#OpenCV代码" class="headerlink" title="OpenCV代码"></a>OpenCV代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">// opencv_empty_proj.cpp : 定义控制台应用程序的入口点。</span><br><span class="line">//</span><br><span class="line"> </span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &lt;opencv2/opencv.hpp&gt;</span><br><span class="line">#include &lt;opencv2/features2d/features2d.hpp&gt;</span><br><span class="line">#include&lt;opencv2/nonfree/nonfree.hpp&gt;</span><br><span class="line">#include&lt;opencv2/legacy/legacy.hpp&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using namespace cv;</span><br><span class="line"> </span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    const char* imagename = &quot;img.jpg&quot;;</span><br><span class="line">  </span><br><span class="line">    //从文件中读入图像</span><br><span class="line">    Mat img = imread(imagename);</span><br><span class="line">    Mat img2=imread(&quot;img2.jpg&quot;);</span><br><span class="line"> </span><br><span class="line">    //如果读入图像失败</span><br><span class="line">    if(img.empty())</span><br><span class="line">    &#123;</span><br><span class="line">            fprintf(stderr, &quot;Can not load image %s\n&quot;, imagename);</span><br><span class="line">            return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(img2.empty())</span><br><span class="line">    &#123;</span><br><span class="line">            fprintf(stderr, &quot;Can not load image %s\n&quot;, imagename);</span><br><span class="line">            return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    //显示图像</span><br><span class="line">    imshow(&quot;image before&quot;, img);</span><br><span class="line">    imshow(&quot;image2 before&quot;,img2);</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    //sift特征检测</span><br><span class="line">    SiftFeatureDetector  siftdtc;</span><br><span class="line">    vector&lt;KeyPoint&gt;kp1,kp2;</span><br><span class="line"> </span><br><span class="line">    siftdtc.detect(img,kp1);</span><br><span class="line">    Mat outimg1;</span><br><span class="line">    drawKeypoints(img,kp1,outimg1);</span><br><span class="line">    imshow(&quot;image1 keypoints&quot;,outimg1);</span><br><span class="line">    KeyPoint kp;</span><br><span class="line"> </span><br><span class="line">    vector&lt;KeyPoint&gt;::iterator itvc;</span><br><span class="line">    for(itvc=kp1.begin();itvc!=kp1.end();itvc++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;angle:&quot;&lt;&lt;itvc-&gt;angle&lt;&lt;&quot;\t&quot;&lt;&lt;itvc-&gt;class_id&lt;&lt;&quot;\t&quot;&lt;&lt;itvc-&gt;octave&lt;&lt;&quot;\t&quot;&lt;&lt;itvc-&gt;pt&lt;&lt;&quot;\t&quot;&lt;&lt;itvc-&gt;response&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    siftdtc.detect(img2,kp2);</span><br><span class="line">    Mat outimg2;</span><br><span class="line">    drawKeypoints(img2,kp2,outimg2);</span><br><span class="line">    imshow(&quot;image2 keypoints&quot;,outimg2);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    SiftDescriptorExtractor extractor;</span><br><span class="line">    Mat descriptor1,descriptor2;</span><br><span class="line">    BruteForceMatcher&lt;L2&lt;float&gt;&gt; matcher;</span><br><span class="line">    vector&lt;DMatch&gt; matches;</span><br><span class="line">    Mat img_matches;</span><br><span class="line">    extractor.compute(img,kp1,descriptor1);</span><br><span class="line">    extractor.compute(img2,kp2,descriptor2);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    imshow(&quot;desc&quot;,descriptor1);</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;descriptor1&lt;&lt;endl;</span><br><span class="line">    matcher.match(descriptor1,descriptor2,matches);</span><br><span class="line"> </span><br><span class="line">    drawMatches(img,kp1,img2,kp2,matches,img_matches);</span><br><span class="line">    imshow(&quot;matches&quot;,img_matches);</span><br><span class="line"> </span><br><span class="line">    //此函数等待按键，按键盘任意键就返回</span><br><span class="line">    waitKey();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理_边缘检测</title>
      <link href="/2018/07/16/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/"/>
      <url>/2018/07/16/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>图像处理_边缘检测</p><a id="more"></a><p>边缘检测：<br><a href="https://blog.csdn.net/tigerda/article/details/61192943" target="_blank" rel="noopener">https://blog.csdn.net/tigerda/article/details/61192943</a></p><p>常见边缘检测算子：Roberts 、Sobel 、Prewitt、Laplacian、Log/Marr、Canny、Kirsch、Nevitia&lt;/br&gt;</p><p>一阶微分算子：Roberts 、Sobel 、Prewitt&lt;/br&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">模板：</span><br><span class="line">Roberts  </span><br><span class="line">|1, 0|</span><br><span class="line">|0,-1|</span><br><span class="line"></span><br><span class="line">sobel算子</span><br><span class="line">|1, 0 , 1|</span><br><span class="line">|1, 0 , 1|</span><br><span class="line">|1, 0 , 1|</span><br><span class="line"></span><br><span class="line">prewitt算子</span><br><span class="line">|1, 0 , 1|</span><br><span class="line">|1, 0 , 1|</span><br><span class="line">|1, 0 , 1|</span><br><span class="line"></span><br><span class="line">Sobel各向同性算子:</span><br><span class="line"></span><br><span class="line">   |-1  ,0,  1|     |-1,-跟2,-1|</span><br><span class="line">Gx=|-跟2,0,跟2| ,Gx=| 0,   0, 0|</span><br><span class="line">   |-1  ,0,  1|     | 1, 跟2, 1|</span><br></pre></td></tr></table></figure></p><p>Sobel各向同性算子的权值比普通Sobel算子的权值更准确。为什么？模板的权值是离中心位置越远则权值（看绝对值）影响越小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">计算边缘幅值与方向？以Sobel算子为例。3*3Sobel两个方向的算子在图像上滑动，模板与其覆盖的图像3*3区域9个像素进行卷积，求和后得到此方向的边缘检测幅值。</span><br><span class="line"></span><br><span class="line">   |-1,0,1|            |-1,-2,-1|</span><br><span class="line">Gx=|-2,0,2|*f(x,y) ,Gx=| 0, 0, 0|*f(x,y)</span><br><span class="line">   |-1,0,1|            | 1, 2, 1|</span><br><span class="line"></span><br><span class="line">G^2=Gx^2+Gy^2</span><br><span class="line"></span><br><span class="line">P=arctan(Gx/Gy)</span><br><span class="line"></span><br><span class="line">f(x,y)为图像，Gx和Gy分别是水平和竖直方向算子的卷积结果，G则是最终得到的边缘幅值，θ值则是边缘方向。当然G的计算有时简化为</span><br><span class="line">G=|Gx|+|Gy| 或者 G=max(|Gx|,|Gy|)</span><br></pre></td></tr></table></figure></p><p>二阶微分算子：Laplacian、Log/Marr<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Laplacian算子</span><br><span class="line">   |-1,-1,-1|      </span><br><span class="line">Gx=|-1, 8,-1|</span><br><span class="line">   |-1,-1,-1|</span><br><span class="line"></span><br><span class="line">   | 0,-1, 0|      </span><br><span class="line">Gx=|-1, 4,-1|</span><br><span class="line">   | 0,-1, 0|</span><br><span class="line"></span><br><span class="line">   |-2,-4,-4,-4,-2|</span><br><span class="line">   |-4, 0, 8, 0,-4|      </span><br><span class="line">Gx=|-4, 8,24, 8,-4|</span><br><span class="line">   |-4, 0, 8, 0,-4|</span><br><span class="line">   |-2,-4,-4,-4,-2|</span><br><span class="line">Log边缘检测则是先进行高斯滤波再进行拉普拉斯算子检测</span><br></pre></td></tr></table></figure></p><p>非微分边缘检测算子：Canny</p><div class="table-container"><table><thead><tr><th>算 子</th><th>优缺点比较</th></tr></thead><tbody><tr><td>Roberts</td><td>对具有陡峭的低噪声的图像处理效果较好，但利用 Roberts算子提取边缘的结果是边缘比较粗，因此边缘定位不是很准确。</td></tr><tr><td>Sobel</td><td>对灰度渐变和噪声较多的图像处理效果比较好， Sobel算子对边缘定位比较准确。</td></tr><tr><td>Kirsch</td><td>对灰度渐变和噪声较多的图像处理效果较好。</td></tr><tr><td>Prewitt</td><td>对灰度渐变和噪声较多的图像处理效果较好。</td></tr><tr><td>aplacian</td><td>对图像中的阶跃性边缘点定位准确，对噪声非常敏感，丢失一部分边缘的方向信息，造成一些不连续的检测边缘。</td></tr><tr><td>LoG</td><td>算 子 经 常 出 现 双 边 缘 像 素 边 界 ， 而 且 该 检 测 方 法 对 噪 声 比铰 敏 感 ， 所 以 很 少 用 LoG算 子 检 测 边 缘 ， 而 是 用 来 判 断 边 缘 像素是位于图像的明区还是暗区。</td></tr><tr><td>Canny</td><td>此方法不容易受噪声的干扰，能够检测到真正的弱边缘。在edge函数中，最有效的边缘检测方法是 Canny方法。该方法的优点在于使用两种不同的阈值分别检测强边缘和弱边缘，并且汉当弱边缘与强边缘相连时，才将弱边缘包含在输出图像中。因此，这种方法不容易被噪声“填充”，跟容易检测出真正的弱边缘。</td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构相关_6_16</title>
      <link href="/2018/07/10/MavenPeizhi/"/>
      <url>/2018/07/10/MavenPeizhi/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Maven项目配置</p><a id="more"></a><p>pom.xml配置</p><h2 id="配置编码格式为UTF-8"><a href="#配置编码格式为UTF-8" class="headerlink" title="配置编码格式为UTF-8"></a>配置编码格式为UTF-8</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">&lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt;</span><br><span class="line">&lt;spring.version&gt;5.0.6.RELEASE&lt;/spring.version&gt;//配置统一版本号</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure><h2 id="配置编程环境版本-maven配置"><a href="#配置编程环境版本-maven配置" class="headerlink" title="配置编程环境版本 maven配置"></a>配置编程环境版本 maven配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">&lt;finalName&gt;pp&lt;/finalName&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">&lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> GitHub </tag>
            
            <tag> Mysql </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习—聚类降维</title>
      <link href="/2018/07/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E9%99%8D%E7%BB%B4_GMM_KMEANS/"/>
      <url>/2018/07/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E9%99%8D%E7%BB%B4_GMM_KMEANS/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>机器学习—聚类降维</p><a id="more"></a><h3 id="机器学习—Kmeans"><a href="#机器学习—Kmeans" class="headerlink" title="机器学习—Kmeans"></a>机器学习—Kmeans</h3><p>聚类属于无监督学习，朴素贝叶斯、SVM等都是有类别标签y的，即已经给出了样本的分类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、随机给K个聚类质心 v</span><br><span class="line">2、重复下面过程直到收敛</span><br><span class="line">2.1对于每一个样例i，计算其应该属于的类 </span><br><span class="line">隶属度 ：zi=argmin||xi−μj||^2</span><br><span class="line">求距离近的</span><br><span class="line">2.2 </span><br><span class="line">聚类中心 u=</span><br></pre></td></tr></table></figure><p>其聚类精度明显优于传统的随机选择种子的方法，且计算速度也比较快。而对于更大型的数据集，kmeans++需要进一步扩展，才能获取更好的表现，即kmeans是高度可扩展的。</p><h3 id="机器学习—GMM"><a href="#机器学习—GMM" class="headerlink" title="机器学习—GMM"></a>机器学习—GMM</h3><p>常用作聚类，可以运动目标检测。</p><p>高斯混合模型（Gaussian Mixed Model）指的是多个高斯分布函数的线性组合，理论上GMM可以拟合出任意类型的分布，通常用于解决同一集合下的数据包含多个不同的分布的情况（或者是同一类分布但参数不一样，或者是不同类型的分布，比如正态分布和伯努利分布）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">//  基于混合高斯模型的运动目标检测</span><br><span class="line">//  Author： http://blog.csdn.net/icvpr  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"> </span><br><span class="line">#include &lt;opencv2/opencv.hpp&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">std::string videoFile = &quot;../test.avi&quot;;</span><br><span class="line"> </span><br><span class="line">cv::VideoCapture capture;</span><br><span class="line">capture.open(videoFile);</span><br><span class="line"> </span><br><span class="line">if (!capture.isOpened())</span><br><span class="line">&#123;</span><br><span class="line">std::cout&lt;&lt;&quot;read video failure&quot;&lt;&lt;std::endl;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">cv::BackgroundSubtractorMOG2 mog;</span><br><span class="line"> </span><br><span class="line">cv::Mat foreground;</span><br><span class="line">cv::Mat background;</span><br><span class="line"> </span><br><span class="line">cv::Mat frame;</span><br><span class="line">long frameNo = 0;</span><br><span class="line">while (capture.read(frame))</span><br><span class="line">&#123;</span><br><span class="line">++frameNo;</span><br><span class="line"> </span><br><span class="line">std::cout&lt;&lt;frameNo&lt;&lt;std::endl;</span><br><span class="line"> </span><br><span class="line">// 运动前景检测，并更新背景</span><br><span class="line">mog(frame, foreground, 0.001);       </span><br><span class="line"></span><br><span class="line">// 腐蚀</span><br><span class="line">cv::erode(foreground, foreground, cv::Mat());</span><br><span class="line"></span><br><span class="line">// 膨胀</span><br><span class="line">cv::dilate(foreground, foreground, cv::Mat());</span><br><span class="line"> </span><br><span class="line">mog.getBackgroundImage(background);   // 返回当前背景图像</span><br><span class="line"> </span><br><span class="line">cv::imshow(&quot;video&quot;, foreground);</span><br><span class="line">cv::imshow(&quot;background&quot;, background);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">if (cv::waitKey(25) &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EM算法："><a href="#EM算法：" class="headerlink" title="EM算法："></a>EM算法：</h3><p>第一步先求出要估计参数的粗略值。<br>第二步使用第一步的值最大化似然函数。因此要先求出GMM的似然函数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Opencv </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown 基本用法(常用)</title>
      <link href="/2018/07/01/markdown/"/>
      <url>/2018/07/01/markdown/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>markdown 基本用法<br><a id="more"></a></p><p><a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown" target="_blank" rel="noopener">在线markdown编辑器</a></p><h2 id="标题类别"><a href="#标题类别" class="headerlink" title="标题类别"></a>标题类别</h2><p></p><h1>一级标题</h1><br>用”<h数字>&lt;/h数字&gt;”或者多个”#”隔开<p></p><pre><code>&lt;h1&gt;一级标题&lt;/h1&gt;# 一级标题</code></pre><h2>二级标题</h2><pre><code>&lt;h2&gt;二级标题&lt;/h2&gt;## 二级标题</code></pre><p>以此类推</p><hr><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>四个空格后开始写代码<br>（空空空空zxcvbasdfgqwert）</p><p>或者用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><pre><code>AAA<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"> (四个空格两个字节)zxcvbasdfgqwert</span><br><span class="line"></span><br><span class="line">--- </span><br><span class="line">## 语句强调</span><br><span class="line">&lt;h3&gt;斜体&lt;/h3&gt;</span><br><span class="line">文字两端使用1个&quot;*&quot;或者&quot;_&quot;夹起来</span><br><span class="line"></span><br><span class="line">*a*</span><br><span class="line"></span><br><span class="line">    *a*</span><br><span class="line">    或者</span><br><span class="line">    _a_</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 粗体</span><br><span class="line">文字两端使用2个&quot;*&quot;或者&quot;_&quot;夹起来</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 分隔线</span><br><span class="line">三个&quot;*&quot;或者&quot;-&quot;</span><br><span class="line"></span><br><span class="line">    ***</span><br><span class="line">    ---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 无序列表</span><br><span class="line"></span><br><span class="line">使用加号&quot;+&quot;或是减号&quot;-&quot;作为列表标记：</span><br><span class="line"></span><br><span class="line">+ 可乐</span><br><span class="line">+ 雪碧</span><br><span class="line"></span><br><span class="line">    +（空格）可乐</span><br><span class="line">    +（空格）雪碧</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">## emoji表情</span><br><span class="line">Markdown文档支持文中插入emoji表情</span><br><span class="line"></span><br><span class="line">比如：&lt;br&gt;</span><br><span class="line"></span><br><span class="line">`:laughing:` 表示:laughing:</span><br><span class="line">`:heart:` 表示:heart:</span><br><span class="line">其他emoji的地址如下链接：</span><br><span class="line">[emoji地址](https://github.com/guodongxiaren/README/blob/master/emoji.md)</span><br><span class="line"></span><br><span class="line">## 引用</span><br><span class="line">`&gt;`表示引用 </span><br><span class="line">`&gt;&gt;` 表示引用中的引用</span><br><span class="line">效果展示:</span><br><span class="line"></span><br><span class="line">&gt;引用(一个小于号) </span><br><span class="line">&gt;&gt; 引用中的引用（两个小于号）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 1. 斜体和粗体</span><br><span class="line"></span><br><span class="line">使用 * 和 ** 表示斜体和粗体。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">这是 *斜体*，这是 **粗体**。</span><br><span class="line"></span><br><span class="line">### 2. 分级标题</span><br><span class="line"></span><br><span class="line">使用 === 表示一级标题，使用 --- 表示二级标题。</span><br><span class="line"></span><br><span class="line">示例：</span><br></pre></td></tr></table></figure></code></pre><h1 id="这是一个一级标题"><a href="#这是一个一级标题" class="headerlink" title="这是一个一级标题"></a>这是一个一级标题</h1><h2 id="这是一个二级标题"><a href="#这是一个二级标题" class="headerlink" title="这是一个二级标题"></a>这是一个二级标题</h2><h3 id="这是一个三级标题"><a href="#这是一个三级标题" class="headerlink" title="这是一个三级标题"></a>这是一个三级标题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。</span><br><span class="line"></span><br><span class="line">### 3. 外链接</span><br><span class="line"></span><br><span class="line">使用 \[描述](链接地址) 为文字增加外链接。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">这是去往 [本人博客](http://ghosertblog.github.com) 的链接。</span><br><span class="line"></span><br><span class="line">### 4. 无序列表</span><br><span class="line"></span><br><span class="line">使用 `*`，`+`或者`-` 表示无序列表。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">- 无序列表项 一</span><br><span class="line">- 无序列表项 二</span><br><span class="line">- 无序列表项 三</span><br><span class="line"></span><br><span class="line">### 5. 有序列表</span><br><span class="line"></span><br><span class="line">使用数字和点表示有序列表。`1.`</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">1. 有序列表项 一</span><br><span class="line">2. 有序列表项 二</span><br><span class="line">3. 有序列表项 三</span><br><span class="line"></span><br><span class="line">### 6. 文字引用</span><br><span class="line"></span><br><span class="line">使用 &gt; 表示文字引用。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">&gt; 野火烧不尽，春风吹又生。</span><br><span class="line"></span><br><span class="line">### 7. 行内代码块</span><br><span class="line"></span><br><span class="line">使用 上顿点\`代码` 表示行内代码块。</span><br><span class="line">&gt;`代码`</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">让我们聊聊 `html`。</span><br><span class="line"></span><br><span class="line">### 8.  代码块</span><br><span class="line"></span><br><span class="line">使用 四个缩进空格 或者上下三个上顿点 表示代码块。</span><br><span class="line">&gt;\`    上顿点前后各三个</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">    这是一个代码块，此行左侧有四个不可见的空格。</span><br><span class="line"></span><br><span class="line">### 9.  插入图像</span><br><span class="line"></span><br><span class="line">使用 \!\[描述](图片链接地址) 插入图像。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">[![kZq279.jpg](https://s2.ax1x.com/2019/01/24/kZq279.jpg)](https://imgchr.com/i/kZq279)</span><br><span class="line"></span><br><span class="line"># Cmd Markdown 高阶语法手册</span><br><span class="line"></span><br><span class="line">### 1. 内容目录</span><br><span class="line"></span><br><span class="line">在段落中填写 `[TOC]` 以显示全文内容的目录结构。</span><br><span class="line"></span><br><span class="line">[TOC]</span><br><span class="line"></span><br><span class="line">### 2. 标签分类</span><br><span class="line"></span><br><span class="line">在编辑区任意行的列首位置输入以下代码给文稿标签：</span><br><span class="line"></span><br><span class="line">标签： 数学 英语 Markdown</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">Tags： 数学 英语 Markdown</span><br><span class="line"></span><br><span class="line">### 3. 删除线</span><br><span class="line"></span><br><span class="line">使用 ~~ 表示删除线。</span><br><span class="line"></span><br><span class="line">~~这是一段错误的文本。~~</span><br><span class="line"></span><br><span class="line">### 4. 注脚</span><br><span class="line"></span><br><span class="line">使用 [^keyword] 表示注脚。</span><br><span class="line"></span><br><span class="line">这是一个注脚[^footnote]的样例。</span><br><span class="line"></span><br><span class="line">这是第二个注脚[^footnote2]的样例。</span><br><span class="line"></span><br><span class="line">### 5. LaTeX 公式</span><br><span class="line"></span><br><span class="line">$ 表示行内公式： </span><br><span class="line"></span><br><span class="line">质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</span><br><span class="line"></span><br><span class="line">$$ 表示整行公式：</span><br><span class="line"></span><br><span class="line">$$\sum_&#123;i=1&#125;^n a_i=0$$</span><br><span class="line"></span><br><span class="line">$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$</span><br><span class="line"></span><br><span class="line">$$\sum^&#123;j-1&#125;_&#123;k=0&#125;&#123;\widehat&#123;\gamma&#125;_&#123;kj&#125; z_k&#125;$$</span><br><span class="line"></span><br><span class="line">访问 [MathJax](http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference) 参考更多使用方法。</span><br><span class="line"></span><br><span class="line">### 6. 加强的代码块</span><br><span class="line"></span><br><span class="line">支持四十一种编程语言的语法高亮的显示，行号显示。</span><br><span class="line"></span><br><span class="line">非代码示例：</span><br></pre></td></tr></table></figure><p>$ sudo apt-get install vim-gnome<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Python 示例：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">@requires_authorization</span><br><span class="line">def somefunc(param1=&apos;&apos;, param2=0):</span><br><span class="line">    &apos;&apos;&apos;A docstring&apos;&apos;&apos;</span><br><span class="line">    if param1 &gt; param2: # interesting</span><br><span class="line">        print &apos;Greater&apos;</span><br><span class="line">    return (param2 - param1 + 1) or None</span><br><span class="line"></span><br><span class="line">class SomeClass:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; message = &apos;&apos;&apos;interpreter</span><br><span class="line">... prompt&apos;&apos;&apos;</span><br></pre></td></tr></table></figure></p><p>JavaScript 示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* nth element in the fibonacci series.</span></span><br><span class="line"><span class="comment">* @param n &gt;= 0</span></span><br><span class="line"><span class="comment">* @return the nth element, &gt;= 0.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> tmp;</span><br><span class="line">  <span class="keyword">while</span> (--n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    tmp = a;</span><br><span class="line">    a += b;</span><br><span class="line">    b = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(fib(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><h3 id="7-流程图"><a href="#7-流程图" class="headerlink" title="7. 流程图"></a>7. 流程图</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start:&gt;https://www.zybuluo.com</span><br><span class="line">io=&gt;inputoutput: verification</span><br><span class="line">op=&gt;operation: Your Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">sub=&gt;subroutine: Your Subroutine</span><br><span class="line">e=&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;io-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;sub-&gt;io</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：流程图语法参考"><a href="#更多语法参考：流程图语法参考" class="headerlink" title="更多语法参考：流程图语法参考"></a>更多语法参考：<a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">流程图语法参考</a></h4><h3 id="8-序列图"><a href="#8-序列图" class="headerlink" title="8. 序列图"></a>8. 序列图</h3><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Title: Here is a title</span><br><span class="line">A-&gt;B: Normal line</span><br><span class="line">B--&gt;C: Dashed line</span><br><span class="line">C-&gt;&gt;D: Open arrow</span><br><span class="line">D--&gt;&gt;A: Dashed open arrow</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：序列图语法参考"><a href="#更多语法参考：序列图语法参考" class="headerlink" title="更多语法参考：序列图语法参考"></a>更多语法参考：<a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">序列图语法参考</a></h4><h3 id="9-甘特图"><a href="#9-甘特图" class="headerlink" title="9. 甘特图"></a>9. 甘特图</h3><p>甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">title 项目开发流程</span><br><span class="line">section 项目确定</span><br><span class="line">    需求分析       :a1, 2016-06-22, 3d</span><br><span class="line">    可行性报告     :after a1, 5d</span><br><span class="line">    概念验证       : 5d</span><br><span class="line">section 项目实施</span><br><span class="line">    概要设计      :2016-07-05  , 5d</span><br><span class="line">    详细设计      :2016-07-08, 10d</span><br><span class="line">    编码          :2016-07-15, 10d</span><br><span class="line">    测试          :2016-07-22, 5d</span><br><span class="line">section 发布验收</span><br><span class="line">    发布: 2d</span><br><span class="line">    验收: 3d</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：甘特图语法参考"><a href="#更多语法参考：甘特图语法参考" class="headerlink" title="更多语法参考：甘特图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#gant-diagrams" target="_blank" rel="noopener">甘特图语法参考</a></h4><h3 id="10-Mermaid-流程图"><a href="#10-Mermaid-流程图" class="headerlink" title="10. Mermaid 流程图"></a>10. Mermaid 流程图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A[Hard edge] --&gt;|Link text| B(Round edge)</span><br><span class="line">B --&gt; C&#123;Decision&#125;</span><br><span class="line">C --&gt;|One| D[Result one]</span><br><span class="line">C --&gt;|Two| E[Result two]</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：Mermaid-流程图语法参考"><a href="#更多语法参考：Mermaid-流程图语法参考" class="headerlink" title="更多语法参考：Mermaid 流程图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#flowcharts-basic-syntax" target="_blank" rel="noopener">Mermaid 流程图语法参考</a></h4><h3 id="11-Mermaid-序列图"><a href="#11-Mermaid-序列图" class="headerlink" title="11. Mermaid 序列图"></a>11. Mermaid 序列图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;John: Hello John, how are you?</span><br><span class="line">loop every minute</span><br><span class="line">    John--&gt;Alice: Great!</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：Mermaid-序列图语法参考"><a href="#更多语法参考：Mermaid-序列图语法参考" class="headerlink" title="更多语法参考：Mermaid 序列图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#sequence-diagrams" target="_blank" rel="noopener">Mermaid 序列图语法参考</a></h4><h3 id="12-表格支持"><a href="#12-表格支持" class="headerlink" title="12. 表格支持"></a>12. 表格支持</h3><div class="table-container"><table><thead><tr><th>项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td>计算机</td><td style="text-align:right">$1600</td><td style="text-align:center">5</td></tr><tr><td>手机</td><td style="text-align:right">$12</td><td style="text-align:center">12</td></tr><tr><td>管线</td><td style="text-align:right">$1</td><td style="text-align:center">234</td></tr></tbody></table></div><h3 id="13-定义型列表"><a href="#13-定义型列表" class="headerlink" title="13. 定义型列表"></a>13. 定义型列表</h3><p>名词 1<br>:   定义 1（左侧有一个可见的冒号和四个不可见的空格）</p><p>代码块 2<br>:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</p><pre><code>    代码块（左侧有八个不可见的空格）</code></pre><h3 id="14-Html-标签"><a href="#14-Html-标签" class="headerlink" title="14. Html 标签"></a>14. Html 标签</h3><p>本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格：</p><pre><code>&lt;table&gt;    &lt;tr&gt;        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;        &lt;th&gt;星期一&lt;/th&gt;        &lt;th&gt;星期二&lt;/th&gt;        &lt;th&gt;星期三&lt;/th&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;李强&lt;/td&gt;        &lt;td&gt;张明&lt;/td&gt;        &lt;td&gt;王平&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><table>    <tr>        <th rowspan="2">值班人员</th>        <th>星期一</th>        <th>星期二</th>        <th>星期三</th>    </tr>    <tr>        <td>李强</td>        <td>张明</td>        <td>王平</td>    </tr></table><h3 id="15-内嵌图标"><a href="#15-内嵌图标" class="headerlink" title="15. 内嵌图标"></a>15. 内嵌图标</h3><p>本站的图标系统对外开放，在文档中输入</p><pre><code>&lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt;</code></pre><p>即显示微博的图标： <i class="icon-weibo icon-2x"></i></p><p>替换 上述 <code>i 标签</code> 内的 <code>icon-weibo</code> 以显示不同的图标，例如：</p><pre><code>&lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt;</code></pre><p>即显示人人的图标： <i class="icon-renren icon-2x"></i></p><p>更多的图标和玩法可以参看 <a href="http://fortawesome.github.io/Font-Awesome/3.2.1/icons/" target="_blank" rel="noopener">font-awesome</a> 官方网站。</p><h3 id="16-待办事宜-Todo-列表"><a href="#16-待办事宜-Todo-列表" class="headerlink" title="16. 待办事宜 Todo 列表"></a>16. 待办事宜 Todo 列表</h3><p>使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：</p><pre><code>- [ ] **Cmd Markdown 开发**    - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率    - [ ] 支持以 PDF 格式导出文稿    - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)    - [x] 改进 LaTex 功能        - [x] 修复 LaTex 公式渲染问题        - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)- [ ] **七月旅行准备**    - [ ] 准备邮轮上需要携带的物品    - [ ] 浏览日本免税店的物品    - [x] 购买蓝宝石公主号七月一日的船票</code></pre><p>对应显示如下待办事宜 Todo 列表：</p><ul><li>[ ] <strong>Cmd Markdown 开发</strong><ul><li>[ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li><li>[ ] 支持以 PDF 格式导出文稿</li><li>[x] 新增Todo列表功能 <a href="https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments" target="_blank" rel="noopener">语法参考</a></li><li>[x] 改进 LaTex 功能<ul><li>[x] 修复 LaTex 公式渲染问题</li><li>[x] 新增 LaTex 公式编号功能 <a href="http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers" target="_blank" rel="noopener">语法参考</a></li></ul></li></ul></li><li>[ ] <strong>七月旅行准备</strong><ul><li>[ ] 准备邮轮上需要携带的物品</li><li>[ ] 浏览日本免税店的物品</li><li>[x] 购买蓝宝石公主号七月一日的船票</li></ul></li></ul><blockquote id="fn_footnote"><sup>footnote</sup>. 这是一个 <em>注脚</em> 的 <strong>文本</strong>。<a href="#reffn_footnote" title="Jump back to footnote [footnote] in the text."> &#8617;</a></blockquote><blockquote id="fn_footnote2"><sup>footnote2</sup>. 这是另一个 <em>注脚</em> 的 <strong>文本</strong>。<a href="#reffn_footnote2" title="Jump back to footnote [footnote2] in the text."> &#8617;</a></blockquote><hr><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;</span><br><span class="line">&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;</span><br><span class="line">&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;</span><br><span class="line">&lt;font color=#0099ff size=7 face=&quot;黑体&quot;&gt;color=#0099ff size=72 face=&quot;黑体&quot;&lt;/font&gt;</span><br><span class="line">&lt;font color=#00ffff size=72&gt;color=#00ffff&lt;/font&gt;</span><br><span class="line">&lt;font color=gray size=72&gt;color=gray&lt;/font&gt;</span><br></pre></td></tr></table></figure><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">颜色名十六进制颜色值颜色</span><br><span class="line">AliceBlue#F0F8FFrgb(240, 248, 255)</span><br><span class="line">AntiqueWhite#FAEBD7rgb(250, 235, 215)</span><br><span class="line">Aqua#00FFFFrgb(0, 255, 255)</span><br><span class="line">Aquamarine#7FFFD4rgb(127, 255, 212)</span><br><span class="line">Azure#F0FFFFrgb(240, 255, 255)</span><br><span class="line">Beige#F5F5DCrgb(245, 245, 220)</span><br><span class="line">Bisque#FFE4C4rgb(255, 228, 196)</span><br><span class="line">Black#000000rgb(0, 0, 0)</span><br><span class="line">BlanchedAlmond#FFEBCDrgb(255, 235, 205)</span><br><span class="line">Blue#0000FFrgb(0, 0, 255)</span><br><span class="line">BlueViolet#8A2BE2rgb(138, 43, 226)</span><br><span class="line">Brown#A52A2Argb(165, 42, 42)</span><br><span class="line">BurlyWood#DEB887rgb(222, 184, 135)</span><br><span class="line">CadetBlue#5F9EA0rgb(95, 158, 160)</span><br><span class="line">Chartreuse#7FFF00rgb(127, 255, 0)</span><br><span class="line">Chocolate#D2691Ergb(210, 105, 30)</span><br><span class="line">Coral#FF7F50rgb(255, 127, 80)</span><br><span class="line">CornflowerBlue#6495EDrgb(100, 149, 237)</span><br><span class="line">Cornsilk#FFF8DCrgb(255, 248, 220)</span><br><span class="line">Crimson#DC143Crgb(220, 20, 60)</span><br><span class="line">Cyan#00FFFFrgb(0, 255, 255)</span><br><span class="line">DarkBlue#00008Brgb(0, 0, 139)</span><br><span class="line">DarkCyan#008B8Brgb(0, 139, 139)</span><br><span class="line">DarkGoldenRod#B8860Brgb(184, 134, 11)</span><br><span class="line">DarkGray#A9A9A9rgb(169, 169, 169)</span><br><span class="line">DarkGreen#006400rgb(0, 100, 0)</span><br><span class="line">DarkKhaki#BDB76Brgb(189, 183, 107)</span><br><span class="line">DarkMagenta#8B008Brgb(139, 0, 139)</span><br><span class="line">DarkOliveGreen#556B2Frgb(85, 107, 47)</span><br><span class="line">Darkorange#FF8C00rgb(255, 140, 0)</span><br><span class="line">DarkOrchid#9932CCrgb(153, 50, 204)</span><br><span class="line">DarkRed#8B0000rgb(139, 0, 0)</span><br><span class="line">DarkSalmon#E9967Argb(233, 150, 122)</span><br><span class="line">DarkSeaGreen#8FBC8Frgb(143, 188, 143)</span><br><span class="line">DarkSlateBlue#483D8Brgb(72, 61, 139)</span><br><span class="line">DarkSlateGray#2F4F4Frgb(47, 79, 79)</span><br><span class="line">DarkTurquoise#00CED1rgb(0, 206, 209)</span><br><span class="line">DarkViolet#9400D3rgb(148, 0, 211)</span><br><span class="line">DeepPink#FF1493rgb(255, 20, 147)</span><br><span class="line">DeepSkyBlue#00BFFFrgb(0, 191, 255)</span><br><span class="line">DimGray#696969rgb(105, 105, 105)</span><br><span class="line">DodgerBlue#1E90FFrgb(30, 144, 255)</span><br><span class="line">Feldspar#D19275rgb(209, 146, 117)</span><br><span class="line">FireBrick#B22222rgb(178, 34, 34)</span><br><span class="line">FloralWhite#FFFAF0rgb(255, 250, 240)</span><br><span class="line">ForestGreen#228B22rgb(34, 139, 34)</span><br><span class="line">Fuchsia#FF00FFrgb(255, 0, 255)</span><br><span class="line">Gainsboro#DCDCDCrgb(220, 220, 220)</span><br><span class="line">GhostWhite#F8F8FFrgb(248, 248, 255)</span><br><span class="line">Gold#FFD700rgb(255, 215, 0)</span><br><span class="line">GoldenRod#DAA520rgb(218, 165, 32)</span><br><span class="line">Gray#808080rgb(128, 128, 128)</span><br><span class="line">Green#008000rgb(0, 128, 0)</span><br><span class="line">GreenYellow#ADFF2Frgb(173, 255, 47)</span><br><span class="line">HoneyDew#F0FFF0rgb(240, 255, 240)</span><br><span class="line">HotPink#FF69B4rgb(255, 105, 180)</span><br><span class="line">IndianRed#CD5C5Crgb(205, 92, 92)</span><br><span class="line">Indigo#4B0082rgb(75, 0, 130)</span><br><span class="line">Ivory#FFFFF0rgb(255, 255, 240)</span><br><span class="line">Khaki#F0E68Crgb(240, 230, 140)</span><br><span class="line">Lavender#E6E6FArgb(230, 230, 250)</span><br><span class="line">LavenderBlush#FFF0F5rgb(255, 240, 245)</span><br><span class="line">LawnGreen#7CFC00rgb(124, 252, 0)</span><br><span class="line">LemonChiffon#FFFACDrgb(255, 250, 205)</span><br><span class="line">LightBlue#ADD8E6rgb(173, 216, 230)</span><br><span class="line">LightCoral#F08080rgb(240, 128, 128)</span><br><span class="line">LightCyan#E0FFFFrgb(224, 255, 255)</span><br><span class="line">LightGoldenRodYellow#FAFAD2rgb(250, 250, 210)</span><br><span class="line">LightGrey#D3D3D3rgb(211, 211, 211)</span><br><span class="line">LightGreen#90EE90rgb(144, 238, 144)</span><br><span class="line">LightPink#FFB6C1rgb(255, 182, 193)</span><br><span class="line">LightSalmon#FFA07Argb(255, 160, 122)</span><br><span class="line">LightSeaGreen#20B2AArgb(32, 178, 170)</span><br><span class="line">LightSkyBlue#87CEFArgb(135, 206, 250)</span><br><span class="line">LightSlateBlue#8470FFrgb(132, 112, 255)</span><br><span class="line">LightSlateGray#778899rgb(119, 136, 153)</span><br><span class="line">LightSteelBlue#B0C4DErgb(176, 196, 222)</span><br><span class="line">LightYellow#FFFFE0rgb(255, 255, 224)</span><br><span class="line">Lime#00FF00rgb(0, 255, 0)</span><br><span class="line">LimeGreen#32CD32rgb(50, 205, 50)</span><br><span class="line">Linen#FAF0E6rgb(250, 240, 230)</span><br><span class="line">Magenta#FF00FFrgb(255, 0, 255)</span><br><span class="line">Maroon#800000rgb(128, 0, 0)</span><br><span class="line">MediumAquaMarine#66CDAArgb(102, 205, 170)</span><br><span class="line">MediumBlue#0000CDrgb(0, 0, 205)</span><br><span class="line">MediumOrchid#BA55D3rgb(186, 85, 211)</span><br><span class="line">MediumPurple#9370D8rgb(147, 112, 216)</span><br><span class="line">MediumSeaGreen#3CB371rgb(60, 179, 113)</span><br><span class="line">MediumSlateBlue#7B68EErgb(123, 104, 238)</span><br><span class="line">MediumSpringGreen#00FA9Argb(0, 250, 154)</span><br><span class="line">MediumTurquoise#48D1CCrgb(72, 209, 204)</span><br><span class="line">MediumVioletRed#C71585rgb(199, 21, 133)</span><br><span class="line">MidnightBlue#191970rgb(25, 25, 112)</span><br><span class="line">MintCream#F5FFFArgb(245, 255, 250)</span><br><span class="line">MistyRose#FFE4E1rgb(255, 228, 225)</span><br><span class="line">Moccasin#FFE4B5rgb(255, 228, 181)</span><br><span class="line">NavajoWhite#FFDEADrgb(255, 222, 173)</span><br><span class="line">Navy#000080rgb(0, 0, 128)</span><br><span class="line">OldLace#FDF5E6rgb(253, 245, 230)</span><br><span class="line">Olive#808000rgb(128, 128, 0)</span><br><span class="line">OliveDrab#6B8E23rgb(107, 142, 35)</span><br><span class="line">Orange#FFA500rgb(255, 165, 0)</span><br><span class="line">OrangeRed#FF4500rgb(255, 69, 0)</span><br><span class="line">Orchid#DA70D6rgb(218, 112, 214)</span><br><span class="line">PaleGoldenRod#EEE8AArgb(238, 232, 170)</span><br><span class="line">PaleGreen#98FB98rgb(152, 251, 152)</span><br><span class="line">PaleTurquoise#AFEEEErgb(175, 238, 238)</span><br><span class="line">PaleVioletRed#D87093rgb(216, 112, 147)</span><br><span class="line">PapayaWhip#FFEFD5rgb(255, 239, 213)</span><br><span class="line">PeachPuff#FFDAB9rgb(255, 218, 185)</span><br><span class="line">Peru#CD853Frgb(205, 133, 63)</span><br><span class="line">Pink#FFC0CBrgb(255, 192, 203)</span><br><span class="line">Plum#DDA0DDrgb(221, 160, 221)</span><br><span class="line">PowderBlue#B0E0E6rgb(176, 224, 230)</span><br><span class="line">Purple#800080rgb(128, 0, 128)</span><br><span class="line">Red#FF0000rgb(255, 0, 0)</span><br><span class="line">RosyBrown#BC8F8Frgb(188, 143, 143)</span><br><span class="line">RoyalBlue#4169E1rgb(65, 105, 225)</span><br><span class="line">SaddleBrown#8B4513rgb(139, 69, 19)</span><br><span class="line">Salmon#FA8072rgb(250, 128, 114)</span><br><span class="line">SandyBrown#F4A460rgb(244, 164, 96)</span><br><span class="line">SeaGreen#2E8B57rgb(46, 139, 87)</span><br><span class="line">SeaShell#FFF5EErgb(255, 245, 238)</span><br><span class="line">Sienna#A0522Drgb(160, 82, 45)</span><br><span class="line">Silver#C0C0C0rgb(192, 192, 192)</span><br><span class="line">SkyBlue#87CEEBrgb(135, 206, 235)</span><br><span class="line">SlateBlue#6A5ACDrgb(106, 90, 205)</span><br><span class="line">SlateGray#708090rgb(112, 128, 144)</span><br><span class="line">Snow#FFFAFArgb(255, 250, 250)</span><br><span class="line">SpringGreen#00FF7Frgb(0, 255, 127)</span><br><span class="line">SteelBlue#4682B4rgb(70, 130, 180)</span><br><span class="line">Tan#D2B48Crgb(210, 180, 140)</span><br><span class="line">Teal#008080rgb(0, 128, 128)</span><br><span class="line">Thistle#D8BFD8rgb(216, 191, 216)</span><br><span class="line">Tomato#FF6347rgb(255, 99, 71)</span><br><span class="line">Turquoise#40E0D0rgb(64, 224, 208)</span><br><span class="line">Violet#EE82EErgb(238, 130, 238)</span><br><span class="line">VioletRed#D02090rgb(208, 32, 144)</span><br><span class="line">Wheat#F5DEB3rgb(245, 222, 179)</span><br><span class="line">White#FFFFFFrgb(255, 255, 255)</span><br><span class="line">WhiteSmoke#F5F5F5rgb(245, 245, 245)</span><br><span class="line">Yellow#FFFF00rgb(255, 255, 0)</span><br><span class="line">YellowGreen#9ACD32rgb(154, 205, 50)</span><br></pre></td></tr></table></figure></h数字>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git上传文件到Github</title>
      <link href="/2018/07/01/git_git2github/"/>
      <url>/2018/07/01/git_git2github/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>准备工作：</p><a id="more"></a><p>1、电脑装有Git<br>2、GitHub 已有仓库</p><p>1、克隆GitHub仓库，到本地</p><p>文件夹右键选择Git Bash Here，输入代码<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Git clone git@github.com:用户名/仓库名.git</span><br></pre></td></tr></table></figure><p>2、放置代码内容到第一步下载的文件夹里</p><p>3、执行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;情况说明&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>4、上传成功</p><hr><h3 id="多电脑同步"><a href="#多电脑同步" class="headerlink" title="多电脑同步"></a>多电脑同步</h3><p>使用电脑搭建好博客后可能面临如下问题</p><p>1、是在家里私人电脑上搭建的，想在公司也可以愉快的写文章<br>2、换了一台新的电脑（挣钱了要换装备😂）<br>3、电脑系统崩了😭</p><p>关于多电脑同步解决方案1</p><p>gitHub分支管理，master分支存博客静态网页资源，Hexo分支存所有源文件（设置为默认分支）<br>每个电脑每次更新文章前需要正常的git同步操作<br>每个电脑每次更新文章后需要正常的git同步操作<br>但是个人感觉不安全，别人可能直接把你的Hexo分支拉取下来就等于获取了你的全部博客资源（虽然我的博客没什么有用的价值😂）<br>具体分支实现可参考利用分支同步<br>关于多电脑同步解决方案2</p><p>每次手动拷贝最新的文件夹替换另一台电脑旧文件夹（想想就麻烦）<br>通过云盘如Dropbox自动同步整个文件夹，使所有的电脑都可以同步到最新的<br>目标电脑获取到最新的博客文件后</p><p>如果是情形3可以考虑先把整个博客目录拷贝出来到新的系统博客目录下<br>GitHub添加配置新电脑的<code>SSH key</code> 和搭建时一样参考<code>Mac</code>搭建<code>Hexo</code>博客及<code>NexT</code>主题配置优化<br>配置运行环境，执行如下指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install node   // 安装Node.js</span><br><span class="line">npm install -g hexo // 安装hexo</span><br></pre></td></tr></table></figure></p><p>切换到博客目录下安装博客模块和插件 (具体参考之前安装过的插件)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line"> npm install hexo-deployer-git --save</span><br><span class="line"> npm install hexo-generator-feed --save</span><br><span class="line"> npm install hexo-generator-sitemap --save</span><br><span class="line"> npm install hexo-generator-feed --save</span><br><span class="line"> npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">npm install -g gulp </span><br><span class="line">    npm install gulp-minify-css --save</span><br><span class="line">    npm install gulp-uglify --save</span><br><span class="line">    npm install gulp-htmlmin --save</span><br><span class="line">    npm install gulp-htmlclean --save</span><br><span class="line">    npm install gulp-imagemin --save</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java相关小知识_6_15</title>
      <link href="/2018/06/15/Java_6_16/"/>
      <url>/2018/06/15/Java_6_16/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>实体完整性要求每个表都有唯一标识符，每一个表中的主键字段不能为空或者重复的值。<br><a id="more"></a></p><p>参照完整性要求关系中不允许引用不存在的实体。设定相应的更新删除插入规则来更新参考表。</p><p>Java语言使用的是<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">HashMap不能保证元素的顺序，HashMap能够将键设为null，也可以将值设为null，与之对应的是Hashtable，(注意大小写：不是HashTable)，Hashtable不能将键和值设为null，否则运行时会报空指针异常错误。&lt;br&gt;</span><br><span class="line">HashMap线程不安全，Hashtable线程安全</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">for循环的执行顺序：&lt;br&gt;</span><br><span class="line">for(条件1;条件2;条件3) &#123;</span><br><span class="line">    //语句</span><br><span class="line">&#125;</span><br><span class="line">执行顺序是条件1-&gt;条件2-&gt;语句-&gt;条件3-&gt;条件2-&gt;语句-&gt;条件3-&gt;条件2........</span><br><span class="line">如果条件2为true，则一直执行。如果条件2位false，则for循环结束</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">java1.8后，抽象类中的抽象方法和非抽象方法在不加修饰符的情况下，都是默认的default</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">substring    方法将返回一个包含从    start    到最后（不包含    end    ）的子字符串的字符串。（左闭右开）</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">### 在为传统面向对象语言的程序做单元测试的时候,经常用到mock对象。Mock对象通过反射数。请问反射最大程度破坏了面向对象的以下哪个特性？ ：封装性</span><br><span class="line"></span><br><span class="line">mock对象：也成为伪对象，在测试中的利用mock对象来代替真实对象，方便测试的进行。&lt;br&gt;</span><br><span class="line">java的封装性：指的是将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，通过该类提供的方法实现对内部信息的操作访问。&lt;br&gt;</span><br><span class="line">反射机制：在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法;对于任意一个对象，都能够调用它的任意一个方法和属性。&lt;br&gt;</span><br><span class="line">反射破坏代码的封装性，破坏原有的访问修饰符访问限制  </span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">### try-catch-finally执行顺序&lt;br&gt;</span><br><span class="line">&gt;博文try-catch-finally执行顺序详解：http://qing0991.blog.51cto.com/1640542/1387200</span><br><span class="line">try块中抛出异常，try、catch和finally中都有return语句</span><br></pre></td></tr></table></figure></p><p>public static int WithException(){</p><p>int i=10;</p><p>try{</p><p>System.out.println(“i in try block is ： “+i);</p><p>i = i/0;</p><p>return —i;</p><p>}</p><p>catch(Exception e){</p><p>System.out.println(“i in catch - form try block is ： “+i);</p><p>—i;</p><p>System.out.println(“i in catch block is ： “+i);</p><p>return —i;</p><p>}</p><p>finally{</p><p>System.out.println(“i in finally - from try or catch block is—“+i);</p><p>—i;</p><p>System.out.println(“i in finally block is—“+i);</p><p>return —i;</p><p>}</p><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行结果：</span><br></pre></td></tr></table></figure></p><p>============WithException==================</p><p>i in try block is ： 10</p><p>i in catch - form try block is ： 10</p><p>i in catch block is ： 9</p><p>i in finally - from try or catch block is—8</p><p>i in finally block is—7</p><p>6<br>```<br>===============================<br><br>执行顺序：</p><p>抛出异常后，执行catch块，在catch块的return的—i执行完后，并不直接返回而是执行finally，因finally中有return语句，所以，执行，返回结果6。</p><p>结论：</p><p>try块中抛出异常，try、catch和finally中都有return语句，返回值是finally中的return。</p><p>总体结论：</p><p>结论一：</p><p>return语句并不是函数的最终出口，如果有finally语句，这在return之后还会执行finally（return的值会暂存在栈里面，等待finally执行后再返回）<br>结论二：</p><p>finally里面不建议放return语句，根据需要，return语句可以放在try和catch里面和函数的最后。可行的做法有四：<br>（1）return语句只在函数最后出现一次。<br>（2）return语句仅在try和catch里面都出现。<br>（3）return语句仅在try和函数的最后都出现。<br>（4）return语句仅在catch和函数的最后都出现。<br>注意，除此之外的其他做法都是不可行的，编译器会报错</p><hr><p>Statement在JDBC中相当于SQL语句的载体<br><br>Statement—-是最基本的用法，采用字符串拼接的方式，存在注入漏洞<br><br>PreparedStatement—-对Statement中的SQL语句进行预编译，同时检查合法性，效率高<br><br>CallableStatement—接口扩展 PreparedStatement，用来调用存储过程,它提供了对输出和输入/输出参数的支持。CallableStatement 接口还具有对 PreparedStatement 接口提供的输入参数的支持。<br><br>BatchedStatement—不是标准的Statement类</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> GitHub </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库相关_6_15</title>
      <link href="/2018/06/15/sql_6_15/"/>
      <url>/2018/06/15/sql_6_15/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>关系规范化中的删除操作异常是</p><h3>不该删除的数据被删除</h3><br><a id="more"></a><p></p><p>关系规范化中的删除操作失败是</p><h3>应该删除的数据未被删除</h3><p></p><hr><p>数据库中通常采用is NULL和is not NULL进行比较不用=等于号</p><p>插图<br>矩形框：表示实体，在框中记入实体名。<br>菱形框：表示联系，在框中记入联系名。<br>椭圆形框：表示实体或联系的属性，将属性名记入框中。对于主属性名，则在其名称下划一下划线。<br>连线：实体与属性之间；实体与联系之间；联系与属性之间用直线相连，并在直线上标注联系的类型。（对于一对一联系，要在两个实体连线方向各写1； 对于一对多联系，要在一的一方写1，多的一方写N；对于多对多关系，则要在两个实体连线方向各写N,M。)</p><hr><p>一个m：n联系转换为一个关系模式，关系的码为各实体码的组合；一个1：n联系转换为一个关系模式，关系的码为n端实体的码；一个1：1联系转换为一个关系模式，关系的码为任意一端实体的码。</p><p>满足最低程度要求的范式属于第一范式，简称1NF；在第一范式中进一步满足一些要求的关系属于第二范式，简称2NF，依次类推，还有3NF、BCNF、4NF、5NF，这些都是关系范式。对关系模式的属性间的函数依赖加以不同的限制就形成了不同的范式。这些范式是递进的，即如果是一个关系是1NF的，它比不是1NF的关系要好；同样，2NF的关系比1NF的关系要好等等，范式越高、规范化程度越高，关系模式就越好。<br>总而言之：<br>  满足第三范式（3NF）必须先满足第二范式（2NF）。满足第二范式（2NF）必须先满足第一范式（1NF）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> GitHub </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库相关_6_15</title>
      <link href="/2018/06/15/sql_6_16/"/>
      <url>/2018/06/15/sql_6_16/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>数据库系统达到了数据独立性是因为采用了<strong>三级模式结构</strong><br><a id="more"></a></p><p>人们为数据库设计了一个严谨的体系结构，数据库领域公认的标准结构是三级模式结构，它包括<code>外模式、概念模式、内模式</code>，有效地组织、管理数据，提高了数据库的逻辑独立性和物理独立性。用户级对应外模式，概念级对应概念模式，物理级对应内模式，使不同级别的用户对数据库形成不同的视图。</p><div class="table-container"><table><thead><tr><th>级别</th><th style="text-align:right">模式</th></tr></thead><tbody><tr><td>用户级</td><td style="text-align:right">外模式</td></tr><tr><td>概念级</td><td style="text-align:right">概念模式</td></tr><tr><td>物理级</td><td style="text-align:right">内模式</td></tr></tbody></table></div><p>所谓视图，就是指观察、认识和理解数据的范围、角度和方法，是数据库在用户“眼中”的反映，很显然，不同层次（级别）用户所“看到”的数据库是不相同的。</p><hr><p>索引顺序查找又称为<code>分块查找</code>，是介于顺序查找和二分查找之间的一种查找方法</p><hr><p>MySQL有多种存储引擎，每种存储引擎有各自的优缺点，可以择优选择使用： </p><p>MyISAM、InnoDB、MERGE、MEMORY(HEAP)、BDB(BerkeleyDB)、EXAMPLE、FEDERATED、ARCHIVE、CSV、BLACKHOLE。</p><p><code>MySQL</code>支持数个存储引擎作为对不同表的类型的处理器。MySQL存储引擎包括处理事务安全表的引擎和处理非事务安全表的引擎： </p><p><code>MyISAM</code>管理非事务表。它提供高速存储和检索，以及全文搜索能力。MyISAM在所有MySQL配置里被支持，它是默认的存储引擎，除非你配置MySQL默认使用另外一个引擎。 </p><p><code>MEMORY</code>存储引擎提供“内存中”表。MERGE存储引擎允许集合将被处理同样的MyISAM表作为一个单独的表。就像MyISAM一样，MEMORY和MERGE存储引擎处理非事务表，这两个引擎也都被默认包含在MySQL中。 </p><p>注释：MEMORY存储引擎正式地被确定为HEAP引擎。 </p><p><code>InnoDB</code>和<code>BDB</code>存储引擎提供事务安全表。BDB被包含在为支持它的操作系统发布的MySQL-Max二进制分发版里。InnoDB也默认被包括在所 有MySQL 5.1二进制分发版里，你可以按照喜好通过配置MySQL来允许或禁止任一引擎。 </p><p><code>EXAMPLE</code>存储引擎是一个“存根”引擎，它不做什么。你可以用这个引擎创建表，但没有数据被存储于其中或从其中检索。这个引擎的目的是服务，在 MySQL源代码中的一个例子，它演示说明如何开始编写新存储引擎。同样，它的主要兴趣是对开发者。 </p><p><code>NDB Cluster</code>是被MySQL Cluster用来实现分割到多台计算机上的表的存储引擎。它在MySQL-Max 5.1二进制分发版里提供。这个存储引擎当前只被Linux, Solaris, 和Mac OS X 支持。在未来的MySQL分发版中，我们想要添加其它平台对这个引擎的支持，包括Windows。</p><p><code>ARCHIVE</code>存储引擎被用来无索引地，非常小地覆盖存储的大量数据。 </p><p><code>CSV</code>存储引擎把数据以逗号分隔的格式存储在文本文件中。 </p><p><code>BLACKHOLE</code>存储引擎接受但不存储数据，并且检索总是返回一个空集。 </p><p><code>FEDERATED</code>存储引擎把数据存在远程数据库中。在MySQL 5.1中，它只和MySQL一起工作，使用MySQL C Client API。在未来的分发版中，我们想要让它使用其它驱动器或客户端连接方法连接到另外的数据源。</p><h2 id="比较常用的是MyISAM和InnoBD"><a href="#比较常用的是MyISAM和InnoBD" class="headerlink" title="比较常用的是MyISAM和InnoBD"></a>比较常用的是MyISAM和InnoBD</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> GitHub </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库相关_6_8</title>
      <link href="/2018/06/08/sql_6_8/"/>
      <url>/2018/06/08/sql_6_8/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>数据库的设计总体上分为6个阶段：</p><a id="more"></a><p></p><h2>1、 需求分析阶段</h2><br>    准确了解用户的需求，撰写需求说明<p></p><p></p><h2>2、概念设计阶段</h2><br>    它是整个数据库设计的关键，通过对用户需求进行综合，归纳与抽象，形成一个独立于具体DBMS的概念模型。E-R图的设计在此阶段。<p></p><p></p><h2>3、逻辑结构设计阶段</h2><br>   将概念结果转换为某个DBMS所支持的数据模型。也就是指E-R图和关系模型的转换，具体为将实体，实体的属性和实体之间的联系转换为关系模式。<p></p><p></p><h2>4、数据库物理设计阶段</h2><br>   为逻辑结果选取一个最适合应用环境的物理结构，包括存储结构和存取方法。<p></p><p></p><h2>5、数据库实施阶段</h2><br>  此阶段利用SQL语句实现逻辑结构设计和物理设计阶段的内容，包括建立数据库，编制与调试应用程序等。<p></p><p></p><h2>6、数据库运行和维护阶段</h2><br>  运行过程中不断的调整，修改和优化数据库系统。<p></p><hr><p></p><h2>聚集索引</h2><br>　　一种索引，该索引中键值的逻辑顺序决定了表中相应行的物理顺序。<br>　　聚集索引确定表中数据的物理顺序。聚集索引类似于电话簿，后者按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。　　<br>　　聚集索引对于那些经常要搜索范围值的列特别有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。聚簇索引的顺序就是数据的物理存储的顺序，叶子节点就是数据节点。物理排序只有一种，所以聚簇索引只有一种,当索引值唯一时，使用聚集索引查找特定的行也很有效率。<p></p><p></p><h2>非聚集索引</h2><br>　　一种索引，该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。<p></p><pre><code>索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块</code></pre><h3>下面的表总结了何时使用聚集索引或非聚集索引（很重要）：</h3><div class="table-container"><table><thead><tr><th>动作描述</th><th style="text-align:right">使用聚集索引</th><th style="text-align:center">使用非聚集索引</th></tr></thead><tbody><tr><td>列经常被分组排序</td><td style="text-align:right">应</td><td style="text-align:center">应</td></tr><tr><td>返回某范围内的数据</td><td style="text-align:right">应</td><td style="text-align:center">不应</td></tr><tr><td>一个或极少不同值</td><td style="text-align:right">不应</td><td style="text-align:center">不应</td></tr><tr><td>小数目的不同值</td><td style="text-align:right">应</td><td style="text-align:center">不应</td></tr><tr><td>大数目的不同值</td><td style="text-align:right">不应</td><td style="text-align:center">应</td><td></td></tr><tr><td>频繁更新的列</td><td style="text-align:right">不应</td><td style="text-align:center">应</td></tr><tr><td>外键列</td><td style="text-align:right">应</td><td style="text-align:center">应</td></tr><tr><td>主键列</td><td style="text-align:right">应</td><td style="text-align:center">应</td></tr><tr><td>频繁修改索引列</td><td style="text-align:right">不应</td><td style="text-align:center">应</td></tr></tbody></table></div><hr><p>对数据库的操作都是在事务中进行的。 </p><p></p><h2>事务</h2><br>事务是指一组相互依赖的操作行为。事务中的操作是不可分割的工作单元，由一组在业务逻辑上相互依赖的SQL语句组成，有ACID特征。 <p></p><p>Atomic（原子性）：事务中包含的操作被看做一个逻辑单元，这个逻辑单元中的操作要么全部成功，要么全部失败。 </p><p>Consistency（一致性）：只有合法的数据可以被写入数据库，否则事务应该将其回滚到最初状态。</p><p>Isolation（隔离性）：事务允许多个用户对同一个数据进行并发访问，而不破坏数据的正确性和完整性。同时，并行事务的修改必须与其他并行事务的修改相互独立。 </p><p>Durability（持久性）：事务结束后，事务处理的结果必须能够得到固化。 </p><p>数据库中有多个事务同时存在，就是事务并发，此时就不能保证事务隔离性，SQL-92定义了事务隔离级别，描述了给定事务的行为对其它并发执行事务的暴露程度，或者说是一个事务必须与其它事务进行隔离的程度。隔离级别由低到高为： </p><p>Read Uncommitted，Read Committed，Repeatable Read， Serializable<br>隔离级别越高，越能保证数据的完整性和一致性，但对并发性能的影响也越大</p><p></p><h2>DML（data manipulation language）</h2><br>       它们是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言<p></p><p></p><h2>DDL（data definition language）</h2><br>       DDL比DML要多，主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用<p></p><p></p><h2>DCL（Data Control Language）</h2><br>       是数据库控制功能。是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL<p></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> GitHub </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决连接MySQL，报错10061，系统错误5</title>
      <link href="/2018/06/04/database_3/"/>
      <url>/2018/06/04/database_3/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>解决连接MySQL，报错10061，系统错误5</p><a id="more"></a><h2 id="解决连接MySQL，报错10061，系统错误5"><a href="#解决连接MySQL，报错10061，系统错误5" class="headerlink" title="解决连接MySQL，报错10061，系统错误5"></a>解决连接MySQL，报错10061，系统错误5</h2><p>mysql登录不上去，报错10061，百度后得，mysql服务未启动。。</p><h3 id="方法一、选择dos窗口命令行打开mysql"><a href="#方法一、选择dos窗口命令行打开mysql" class="headerlink" title="方法一、选择dos窗口命令行打开mysql"></a>方法一、选择dos窗口命令行打开mysql</h3><p>输入代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure><p>报错，如图所示。系统错误 5</p><p><a href="https://imgchr.com/i/kZHauQ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/24/kZHauQ.png" alt="kZHauQ.png"></a></p><hr><h3 id="方法二、手工启动"><a href="#方法二、手工启动" class="headerlink" title="方法二、手工启动"></a>方法二、手工启动</h3><p>计算机-&gt;右键-&gt;管理-&gt;计算机管理<br>找到mysql，右键启动</p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/mysql_error5_a.png" alt="这里写图片描述"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装mysql，和遇到的一些错误及解决方案</title>
      <link href="/2018/03/28/database_install/"/>
      <url>/2018/03/28/database_install/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p></p><h2>安装mysql</h2><br><a id="more"></a><p></p><p></p><h2>1、下载</h2><br>mysql-5.7.20是解压版免安装的，mysql-5.7.20下载地址：<a href="http://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">http://dev.mysql.com/downloads/mysql/</a><p></p><hr><p></p><h2>2、安装</h2><br>  解压在你喜欢的位置<p></p><hr><p></p><h2>3、配置</h2><br>  新建一个ini文件，并命名为my.ini，放置到mysql根目录下，文件内容如下<p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[mysql]  </span><br><span class="line"># 设置mysql客户端默认字符集  </span><br><span class="line">default-character-set=utf8  </span><br><span class="line">[mysqld]  </span><br><span class="line">#设置3306端口  </span><br><span class="line">port = 3306  </span><br><span class="line"># 设置mysql的安装目录  </span><br><span class="line">basedir=E:\program2\javaTool\mysql-5.7.20-winx64</span><br><span class="line"># 设置mysql数据库的数据的存放目录  </span><br><span class="line">datadir=E:\program2\javaTool\mysql-5.7.20-winx64\data</span><br><span class="line"># 允许最大连接数  </span><br><span class="line">max_connections=200  </span><br><span class="line"># 服务端使用的字符集默认为8比特编码的latin1字符集  </span><br><span class="line">character-set-server=utf8  </span><br><span class="line"># 创建新表时将使用的默认存储引擎  </span><br><span class="line">default-storage-engine=INNODB</span><br></pre></td></tr></table></figure><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/mysql_my_ini.png" alt="这里写图片描述"></p><p>注：<br>设置mysql的安装目录 basedir=<br>设置mysql数据库的数据的存放目录 datadir=<br>这两个参数改为你所解压后的文件夹的位置</p><hr><p></p><h2>4、安装mysql服务</h2><br>&lt;/h3&gt;4.1、管理员身份打开cmd.exe&lt;/h3&gt;<br>文件位置C:\Windows\System32\cmd.exe,找到右击选择管理员身份打开（重点），如果没有一管理员身份打开运行cmd.exe，会报错<p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install/Remove of the Service Denied! mysql</span><br></pre></td></tr></table></figure><p>将目录切换到你mysql安装目录的bin目录后，在cmd窗口输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld install</span><br></pre></td></tr></table></figure><p>回车运行即可。</p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/mysql_succ_insta.png" alt="这里写图片描述"></p><p></p><h3>4.2、创建data文件</h3><br>将目录切换到你mysql安装目录的bin目录后，再输入<p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --initialize -insecure --user=mysql</span><br></pre></td></tr></table></figure><p>在软件目录下生成data文件夹。mysql登录的用户名为root，密码为空</p><p>之前的my.ini中两个参数要改为自己的：<br>设置mysql的安装目录 basedir=软件安装目录<br>设置mysql数据库的数据的存放目录   datadir=软件安装目录\data<br>这两个参数改为你所解压后的文件夹的位置，否则会报错“无法初始化库文件等”如下图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld: Can&apos;t create/write to file</span><br></pre></td></tr></table></figure><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/mysql_not_craet_direc.png" alt="这里写图片描述"></p><p></p><h3>4.3 测试启动</h3><br>启动mysql服务：<p></p><p>将目录切换到你mysql安装目录的bin目录，输入 net start mysql 启动服务，OK成功。</p><p><em>4.3.1 报错</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Found option without preceding group in config file:XXX;</span><br><span class="line">Fatal error in defaults handling.</span><br></pre></td></tr></table></figure><p>原因：用记事本配置my.ini编码格式有问题，一般情况下是UTF-8编码格式，但是这里需要ANSI编码格式<br>用记事本打开my.ini文件，然后点击：文件—&gt;另存为—&gt;将编码修改为：ANSI—&gt;保存！</p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/mysql_my_ini_word.png" alt="这里写图片描述"></p><p>然后cmd窗口输入命令行启动mysql</p><p><em>4.3.2 报错</em></p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/mysql_error5.png" alt="这里写图片描述"></p><p>解决：以管理员身份来运行cmd程序来启动mysql。</p><p><em>4.3.3运行 net start mysql</em></p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/mysql_starting.png" alt="这里写图片描述"></p><p>报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务正在启动或停止中，请稍候片刻后再试一次。</span><br></pre></td></tr></table></figure></p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/mysql_start_and_stop.png" alt="这里写图片描述"></p><p>解决方法：打开任务管理器，把mysql进程关闭，再次启动mysql服务器</p><p>启动成功</p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/mysql_suc_start.png" alt="这里写图片描述"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab的gui图像处理操作界面，实现重置和退出按钮功能</title>
      <link href="/2018/03/09/matlab_gui_exit/"/>
      <url>/2018/03/09/matlab_gui_exit/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>axes控件实现了展示图片，动态txt控件实现了展示或者输入参数。<br><a id="more"></a></p><p>在gui界面右键点击“重置”pushbotton回到代码块callback，编写代码</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/jiemian_chongzhi%20(2" alt="在这里插入图片描述">.png)</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/jiemian_chongzhi%20(1" alt="在这里插入图片描述">.png)</p><p>以下代码是实现图片和参数数字重置，是重置按钮（puttern）的功能实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function pushbutton1_Callback(hObject, eventdata, handles)</span><br><span class="line">% hObject    handle to pushbutton1 (see GCBO)</span><br><span class="line">% eventdata  reserved - to be defined in a future version of MATLAB</span><br><span class="line">% handles    structure with handles and user data (see GUIDATA)</span><br><span class="line">% 重置清空图片 美滋滋</span><br><span class="line">cla(handles.axes1,&apos;reset&apos;);</span><br><span class="line">cla(handles.axes2,&apos;reset&apos;);</span><br><span class="line">cla(handles.axes3,&apos;reset&apos;);</span><br><span class="line">cla(handles.axes4,&apos;reset&apos;);</span><br><span class="line">cla(handles.axes5,&apos;reset&apos;);</span><br><span class="line"></span><br><span class="line">% 重置清空动态txt的文字 美滋滋</span><br><span class="line">set(handles.edit1,&apos;string&apos;,&apos;&apos;)</span><br><span class="line">set(handles.edit2,&apos;string&apos;,&apos;&apos;)</span><br><span class="line">set(handles.edit3,&apos;string&apos;,&apos;&apos;)</span><br><span class="line">set(handles.edit4,&apos;string&apos;,&apos;&apos;)</span><br></pre></td></tr></table></figure></p><hr><p>退出按钮：<br>在gui界面右键点击“退出”pushbotton回到代码块callback，编写代码<br>即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Matlab </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eclipse在主题商城下载安装黑色主题</title>
      <link href="/2018/03/08/eclipse_black_theme/"/>
      <url>/2018/03/08/eclipse_black_theme/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>eclipse在主题商城下载安装黑色主题<br><a id="more"></a></p><p>Eclipse配置黑色主题方法：</p><h2 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h2><p>借用国外一个Elipse主题网站分享的主题配置文件来配置一个黑色的主题.</p><p><a href="http://www.eclipsecolorthemes.org/?q=" target="_blank" rel="noopener">主题网址</a></p><p><img src="https://img-blog.nos-eastchina1.126.net/EC_theme1.png" alt></p><h2 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h2><p>在这个网站下载自己喜欢的主题,单击主题进入下载页面,建议大家选择EPF格式的进行下载.</p><p><img src="https://img-blog.nos-eastchina1.126.net/EC_theme2.png" alt></p><h2 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h2><p>下载好之后打开Eclipse,单击File菜单下的Import选项</p><p><img src="https://img-blog.nos-eastchina1.126.net/EC_theme3.png" alt></p><h2 id="4、"><a href="#4、" class="headerlink" title="4、"></a>4、</h2><p>在弹出的窗口中,点击General下面的Preferences选项,然后点击Next<br><img src="https://img-blog.nos-eastchina1.126.net/EC_theme4.png" alt></p><h2 id="5、"><a href="#5、" class="headerlink" title="5、"></a>5、</h2><p>单击Browse选择你下载的EPF配置文件,然后点击Finish</p><p><img src="https://img-blog.nos-eastchina1.126.net/EC_theme5.png" alt></p><h2 id="6、"><a href="#6、" class="headerlink" title="6、"></a>6、</h2><p>这个时候如果你如果之前选择的是Eclipse默认的主题的话,那么只有代码区变成了黑色,那么你就需要再单击windos下的Preferences选项,然后再打开General下面的Appearance,在Theme选择那个Dark主题,然后点确定就可以了.</p><p><img src="https://img-blog.nos-eastchina1.126.net/EC_theme6.png" alt></p><p><img src="https://img-blog.nos-eastchina1.126.net/EC_theme7.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Theme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客cnzz网站访问量统计</title>
      <link href="/2018/03/08/hexo_cnzz/"/>
      <url>/2018/03/08/hexo_cnzz/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>cnzz网站访问量统计<br><a id="more"></a></p><p>使用友盟第三方的统计插件，网址：<code>http://www.umeng.com/</code><br>进入网站先注册账号然后根据下列图片进入添加站点。<br><img src="https://img-blog.nos-eastchina1.126.net/blog_cnzz11.png" alt></p><p><img src="https://img-blog.nos-eastchina1.126.net/blog_cnzz12.png" alt></p><p><img src="https://img-blog.nos-eastchina1.126.net/blog_cnzz13.png" alt></p><p>添加站点，自己搭建的博客，需要统计访问量的网站(这里加入我的博客网站)，然后点击统计代码进入代码页</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog_cnzz14.png" alt></p><p>代码页有很多样式，我的是红框的演示，纯文字统计，简洁大方，选择其他样式也可以</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog_cnzz15.png" alt><br>选择样式，复制样式代码到<code>..\themes\yilia\layout\_partial</code>下的<br><code>footer.ejs</code>中加入如下代码块<code>&lt;div&gt;</code>和<code>&lt;/div&gt;</code>即可</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog_cnzz16.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    里面是从CNZZ复制的代码</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>代码块<code>&lt;div&gt;</code>和<code>&lt;/div&gt;</code>一定要在<code>&lt;footer&gt;</code>和<code>&lt;/fotter&gt;</code>之间</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
            <tag> yilia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客添加背景音乐和音乐歌单(举例网易云音乐)</title>
      <link href="/2018/03/08/hexo_music_list/"/>
      <url>/2018/03/08/hexo_music_list/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>添加背景音乐<br><a id="more"></a></p><h3 id="1、-打开网易云音乐首页，然后搜索你要添加的背景音乐"><a href="#1、-打开网易云音乐首页，然后搜索你要添加的背景音乐" class="headerlink" title="1、 打开网易云音乐首页，然后搜索你要添加的背景音乐"></a>1、 打开网易云音乐首页，然后搜索你要添加的背景音乐</h3><pre><code>    http://music.163.com/</code></pre><p><img src="https://img-blog.nos-eastchina1.126.net/163music3.png" alt></p><h3 id="2、-搜索到歌曲点击生成外链播放器，进去下一个界面"><a href="#2、-搜索到歌曲点击生成外链播放器，进去下一个界面" class="headerlink" title="2、 搜索到歌曲点击生成外链播放器，进去下一个界面"></a>2、 搜索到歌曲点击生成外链播放器，进去下一个界面</h3><p><img src="https://img-blog.nos-eastchina1.126.net/163music2.png" alt></p><h3 id="3、-复制外链播放器的代码"><a href="#3、-复制外链播放器的代码" class="headerlink" title="3、 复制外链播放器的代码"></a>3、 复制外链播放器的代码</h3><p>打开yilia主题下的_partial文件夹下的left-col.ejs文件<br>        复制文件内容到最下端</p><p><img src="https://img-blog.nos-eastchina1.126.net/163music1.png" alt></p><p>红线内的iframe框为复制的外链播放器代码，如图红线内，把代码放在div框<br>        例如：</p><pre><code>&lt;div style=&quot;position:absolute; bottom:120px left:auto; width:85%&quot;&gt;    &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=260 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=422428548&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;    &lt;/div&gt;</code></pre><p>这样就可以了</p><p>注：调节播放器大小，改变外链播放器的代码块，长度宽度即可<br>        width=260 height=86</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Music </tag>
            
            <tag> yilia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab2014a vs2015编译器解决方法</title>
      <link href="/2018/03/07/matlab_vs2015/"/>
      <url>/2018/03/07/matlab_vs2015/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><a id="more"></a><p>前提：<br>电脑已经安装<br>1、Matlab版本2014a<br>2、VS版本2015</p><p>目标：<br>结合Matlab和VS2015，实现Matlab的GUI文件和.m文件转化为.exe文件，然后可以单独运行.exe文件</p><p>首先在Matlab命令行输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mbuild -setup</span><br></pre></td></tr></table></figure></p><p>报错红色，显示没有选择项，此处没有截图不直观<br>我猜测可能是matlab2014a的破解不完全</p><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>下载资源链接：<a href="https://pan.b链aidu.com/s/1hoDxMKFU2l-3ZhTObFetCw" target="_blank" rel="noopener">https://pan.b链aidu.com/s/1hoDxMKFU2l-3ZhTObFetCw</a> </p><p>密码：vdlq</p><p>然后替换文件</p><p>附件下面的将<code>mexopts/</code>下的<code>msvc2015.xml</code>和<code>msvcpp2015.xml</code><br><br>复制到<code>Matlab</code>目录下的<code>bin/win64/mexopts</code>下就可以了</p><p>首先在Matlab命令行输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mbuild -setup</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.nos-eastchina1.126.net/VS2015_1.png" alt="原始效果"></p><p>然后输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mex -setup</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.nos-eastchina1.126.net/VS2015_2.png" alt="原始效果"></p><p>选项都选择C++的就哦了</p>]]></content>
      
      
      
        <tags>
            
            <tag> Matlab </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决方案matlab2014a破解不完全，报错Test checkout of feature &#39;Compiler&#39; failed</title>
      <link href="/2018/03/07/matlab_exe/"/>
      <url>/2018/03/07/matlab_exe/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><a id="more"></a><p>报错情况： 目标是把<code>.m</code>文件转化为<code>.exe</code>文件，先运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mcc -m</span><br></pre></td></tr></table></figure><p>你的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">后缀</span><br><span class="line"></span><br><span class="line">如果报错</span><br></pre></td></tr></table></figure></p><p>Test checkout of feature ‘Compiler’ failed<br>``` <br>是因为你的matlab2014a破解不完全。<br>前提是你的电脑已经安装好了VS编译器</p><p>2014a的解决办法：<br><br>下载资源：ht链tps://pan.baidu.com/s/1KNZqVqxMx6f接IaxQULAIq_g<br><br>密码：cti0</p><p>下载后解压，把install.jar以及相应位数的三个文件（compiler.dll，mcc.exe，libmwservices.dll）复制到对应位置替换即可。<br><br>在matlab安装目录下搜索到文件然后替换，保险起见先把要替换的文件剪切出来，实际上我的操作是成功的，万一万一万一不成功还能复原回去</p><p>另外把license.lic改为与MATLAB\licenses文件夹下的那个lic文件同名，复制并替换之。<br><br>如图所示，我把需要替换的文件都拿了出来，其中license文件是绑定了你的电脑名称，所以需要把新文件改名</p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/VSjietu.png" alt="原始效果"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Matlab </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库Mysql_约束</title>
      <link href="/2018/03/04/database_2/"/>
      <url>/2018/03/04/database_2/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>数据库约束<br><a id="more"></a></p><h2 id="数据库约束"><a href="#数据库约束" class="headerlink" title="数据库约束"></a>数据库约束</h2><h3 id="1-1-默认值约束-default"><a href="#1-1-默认值约束-default" class="headerlink" title="1.1 默认值约束(default)"></a>1.1 默认值约束(default)</h3><h3 id="1-2-非空约束-not-null"><a href="#1-2-非空约束-not-null" class="headerlink" title="1.2 非空约束( not null )"></a>1.2 非空约束( not null )</h3><h3 id="1-3-唯一约束-unique"><a href="#1-3-唯一约束-unique" class="headerlink" title="1.3 唯一约束(unique)"></a>1.3 唯一约束(unique)</h3><pre><code>CREATE TABLE test(id INT  UNIQUE ,-- 唯一NAME VARCHAR(20) NOT NULL, -- 非空gender VARCHAR(2) DEFAULT &#39;男&#39; -- 默认值约束);</code></pre><h3 id="1-4-主键约束-primary-key-作用-非空-唯一约束"><a href="#1-4-主键约束-primary-key-作用-非空-唯一约束" class="headerlink" title="1.4 主键约束(primary key 作用:非空+唯一约束)"></a>1.4 主键约束(primary key 作用:非空+唯一约束)</h3><h3 id="1-5-自增长约束-auto-increment"><a href="#1-5-自增长约束-auto-increment" class="headerlink" title="1.5 自增长约束(auto_increment)"></a>1.5 自增长约束(auto_increment)</h3><pre><code>CREATE TABLE test2(    id INT  PRIMARY KEY AUTO_INCREMENT,-- 非空+唯一约束+自增长约束    NAME VARCHAR(20) ,    gender VARCHAR(2) ,);</code></pre><h3 id="1-6-外键约束-属于数据库中表的设计"><a href="#1-6-外键约束-属于数据库中表的设计" class="headerlink" title="1.6 外键约束(属于数据库中表的设计)"></a>1.6 外键约束(属于数据库中表的设计)</h3><h3 id="1-6-1-外键约束-约束两个或者两个以上的表的数据，一般情况有两种表-主表-副表"><a href="#1-6-1-外键约束-约束两个或者两个以上的表的数据，一般情况有两种表-主表-副表" class="headerlink" title="1.6.1 外键约束:约束两个或者两个以上的表的数据，一般情况有两种表(主表,副表)"></a>1.6.1 外键约束:约束两个或者两个以上的表的数据，一般情况有两种表(主表,副表)</h3><pre><code>DROP TABLE employee2DELETE FROM employee2SELECT * FROM employee2SELECT * FROM dept</code></pre><h3 id="1-6-2-员工表"><a href="#1-6-2-员工表" class="headerlink" title="1.6.2 员工表"></a>1.6.2 员工表</h3><pre><code>CREATE TABLE employee2(    id INT PRIMARY KEY AUTO_INCREMENT,    NAME VARCHAR(20),    deptId INT,    -- 添加外键约束    CONSTRAINT employee_dept_fk FOREIGN KEY (deptId) REFERENCES dept(id)--     声明         外键名称    外键    被约束的字段  关联     部门表中id的字段);INSERT INTO employee2 (NAME,deptId) VALUES(&#39;张三&#39;,1) ;INSERT INTO employee2 (NAME,deptId) VALUES(&#39;李四&#39;,2) ;INSERT INTO employee2 (NAME,deptId) VALUES(&#39;王五&#39;,1) ;INSERT INTO employee2 (NAME,deptId) VALUES(&#39;陈六&#39;,1) ;</code></pre><p>可以设计一个独立的表-部门表 专门用来存储部门名称,来解决数据冗余的问题</p><h3 id="1-6-3-部门表-主表-约束别人的表"><a href="#1-6-3-部门表-主表-约束别人的表" class="headerlink" title="1.6.3 部门表(主表,约束别人的表)"></a>1.6.3 部门表(主表,约束别人的表)</h3><pre><code>CREATE TABLE dept(    id INT PRIMARY KEY AUTO_INCREMENT ,    NAME VARCHAR(20) -- 部门名称);</code></pre><h4 id="插入几个部门名称"><a href="#插入几个部门名称" class="headerlink" title="插入几个部门名称"></a>插入几个部门名称</h4><pre><code>INSERT INTO dept (NAME) VALUES (&#39;软件开发部&#39;) ;INSERT INTO dept (NAME) VALUES (&#39;软件维护部&#39;) ;</code></pre><h4 id="给员工表中插入数据"><a href="#给员工表中插入数据" class="headerlink" title="给员工表中插入数据"></a>给员工表中插入数据</h4><pre><code>INSERT INTO employee2 (NAME,deptId) VALUES(&#39;王五&#39;,1) ;INSERT INTO employee2 (NAME,deptId) VALUES(&#39;陈六&#39;,1) ;INSERT INTO employee2 (NAME,deptId) VALUES(&#39;李四&#39;,2) ;</code></pre><h4 id="给部门表添加数据"><a href="#给部门表添加数据" class="headerlink" title="给部门表添加数据"></a>给部门表添加数据</h4><pre><code>INSERT INTO dept (id,NAME) VALUES(3,&#39;硬件开发部&#39;);</code></pre><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><pre><code>UPDATE employee2 SET deptId = 3 WHERE id = 3;</code></pre><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><pre><code>DELETE FROM employee2 WHERE id =2;</code></pre><h3 id="1-7-补充"><a href="#1-7-补充" class="headerlink" title="1.7 补充"></a>1.7 补充</h3><p>—常遇到字段类型:</p><h4 id="1-char-20-vs-varchar-20"><a href="#1-char-20-vs-varchar-20" class="headerlink" title="1)char(20) vs varchar(20)"></a>1)char(20) vs varchar(20)</h4><blockquote><p>char(20):是一个固定长度的字符串,存储字符串内容,一定是20个字符串。<br><br>varchar(20):可变的字符串长度,实际存储的时候是根据当前实际的字符串长度</p></blockquote><p>DROP TABLE test ;</p><h4 id="2-int-和int-4"><a href="#2-int-和int-4" class="headerlink" title="2) int 和int(4)"></a>2) int 和int(4)</h4><blockquote><p>int:默认的长度11位,再存储数值类型的时候,存储实际长度<br><br>int(4):固定长度</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库Mysql_3_4</title>
      <link href="/2018/03/04/database_1/"/>
      <url>/2018/03/04/database_1/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>mysql常用命令<br><a id="more"></a></p><h2 id="一、-mysql常用命令"><a href="#一、-mysql常用命令" class="headerlink" title="一、 mysql常用命令"></a>一、 mysql常用命令</h2><h3 id="1-1-管理"><a href="#1-1-管理" class="headerlink" title="1.1 管理"></a>1.1 管理</h3><pre><code>CREATE DATABASE Aoman_OS -- 创建数据库USE  Aoman_OS -- 使用数据库DROP DATABASE Aoman_OS  -- 删除数据库</code></pre><h3 id="1-2-数据库内容"><a href="#1-2-数据库内容" class="headerlink" title="1.2 数据库内容"></a>1.2 数据库内容</h3><pre><code>CREATE TABLE employee(  -- 创建数据库表格id INT,NAME VARCHAR(20),gender VARCHAR(2),title VARCHAR(10),email VARCHAR(20));SELECT * FROM employee -- 查看数据库表格</code></pre><h3 id="2-1-增加数据库内容"><a href="#2-1-增加数据库内容" class="headerlink" title="2.1 增加数据库内容"></a>2.1 增加数据库内容</h3><pre><code>INSERT INTO employee VALUES(1,&#39;依依&#39;,&#39;女&#39;,&#39;程序员鼓励师&#39;,&#39;123@163.com&#39;);INSERT INTO employee VALUES(2,&#39;尔尔&#39;,&#39;男&#39;,&#39;程序开发工程师&#39;,&#39;124@163.com&#39;);INSERT INTO employee VALUES(3,&#39;散散&#39;,&#39;男&#39;,&#39;程序维护工程师&#39;,&#39;125@163.com&#39;);</code></pre><h3 id="2-2-插入部分数据"><a href="#2-2-插入部分数据" class="headerlink" title="2.2 插入部分数据"></a>2.2 插入部分数据</h3><pre><code>    INSERT INTO employee (id,NAME) VALUES (4,&#39;思思&#39;);</code></pre><h3 id="2-3-修改数据"><a href="#2-3-修改数据" class="headerlink" title="2.3 修改数据"></a>2.3 修改数据</h3><pre><code>UPDATE employee SET gender=&#39;女&#39;,title=&#39;文秘&#39; WHERE id =4;</code></pre><h3 id="2-4-删除表中所有数据"><a href="#2-4-删除表中所有数据" class="headerlink" title="2.4 删除表中所有数据"></a>2.4 删除表中所有数据</h3><pre><code>DELETE     * FROM employee</code></pre><h3 id="2-5-删除数据表"><a href="#2-5-删除数据表" class="headerlink" title="2.5 删除数据表"></a>2.5 删除数据表</h3><pre><code>DROP FROM employee</code></pre><h3 id="3-1-查询"><a href="#3-1-查询" class="headerlink" title="3.1 查询"></a>3.1 查询</h3><pre><code>SELECT id AS &#39;1&#39; FROM employeeSELECT id AS &#39;1&#39; ，NAME AS &#39;尔尔&#39; FROM employee</code></pre><h3 id="3-2-不重复的查询"><a href="#3-2-不重复的查询" class="headerlink" title="3.2 不重复的查询"></a>3.2 不重复的查询</h3><pre><code>SELECT DISTINCT email FROM employee</code></pre><h3 id="3-3-条件查询"><a href="#3-3-条件查询" class="headerlink" title="3.3 条件查询"></a>3.3 条件查询</h3><pre><code>SELECT * FROM employee WHERE id=1 OR NAME = &#39;思思&#39; ; -- or 并集SELECT * FROM employee WHERE id=1 AND NAME = &#39;思思&#39; ; -- and 交集</code></pre><h3 id="3-4-判断查询"><a href="#3-4-判断查询" class="headerlink" title="3.4 判断查询"></a>3.4 判断查询</h3><pre><code>大于 &gt; ,小于 &lt; ,等于 = 不等于 ！= 或者 &lt;&gt;， 在什么之间 between 1 and 2，非空 isnot null 或者 不等于 &#39;&#39;</code></pre><h3 id="3-5-模糊查询"><a href="#3-5-模糊查询" class="headerlink" title="3.5 模糊查询"></a>3.5 模糊查询</h3><pre><code>SELECT * FROM studet WHERE NAME LIKE &#39;思%&#39;%代替任何字符，任何长度的字符-仅仅代替一个字符</code></pre><h3 id="3-6-asc-升序-desc-降序"><a href="#3-6-asc-升序-desc-降序" class="headerlink" title="3.6 asc 升序 desc 降序"></a>3.6 asc 升序 desc 降序</h3><pre><code>默认情况下:是按照插入顺序进行排序SELECT * FROM student ORDER BY id ASC ;需求:servlet成绩是一个降序排序SELECT * FROM student ORDER BY servlet DESC ;</code></pre><h2 id="二、小练习"><a href="#二、小练习" class="headerlink" title="二、小练习"></a>二、小练习</h2><pre><code>CREATE TABLE student2(    id INT,    NAME VARCHAR(20),    chinese FLOAT,    english FLOAT,    math FLOAT);INSERT INTO student2(id,NAME,chinese,english,math) VALUES(1,&#39;张小明&#39;,89,78,90);INSERT INTO student2(id,NAME,chinese,english,math) VALUES(2,&#39;李进&#39;,67,53,95);INSERT INTO student2(id,NAME,chinese,english,math) VALUES(3,&#39;王五&#39;,87,78,77);INSERT INTO student2(id,NAME,chinese,english,math) VALUES(4,&#39;李一&#39;,88,98,92);INSERT INTO student2(id,NAME,chinese,english,math) VALUES(5,&#39;李来财&#39;,82,84,67);INSERT INTO student2(id,NAME,chinese,english,math) VALUES(6,&#39;张进宝&#39;,55,85,45);INSERT INTO student2(id,NAME,chinese,english,math) VALUES(7,&#39;黄蓉&#39;,75,65,30)</code></pre><h4 id="查询操作练习-在学生表数据基础上：student-sql"><a href="#查询操作练习-在学生表数据基础上：student-sql" class="headerlink" title="查询操作练习(在学生表数据基础上：student.sql)"></a>查询操作练习(在学生表数据基础上：student.sql)</h4><p>—     查询表中所有学生的信息。</p><pre><code>SELECT * FROM student2 ;</code></pre><p>— 查询表中所有学生的姓名和对应的英语成绩。</p><pre><code>SELECT  NAME ,english FROM student2</code></pre><p>—     使用别名表示学生分数。</p><pre><code>SELECT id AS &#39;编号&#39;,NAME AS &#39;姓名&#39;,chinese AS &#39;语文&#39;,english AS &#39;英语&#39;,math AS &#39;数学&#39; FROM student2 ;</code></pre><p>—     查询姓名为李一的学生成绩</p><pre><code>SELECT * FROM student2 WHERE NAME = &#39;李一&#39;;</code></pre><p>—     查询英语成绩大于等于90分的同学</p><pre><code>SELECT * FROM student2 WHERE english &gt;=90</code></pre><p>—     查询总分大于200分的所有同学</p><pre><code>SELECT * FROM student2 WHERE (chinese+english+math)&gt;200;</code></pre><p>—     查询所有姓李的学生英语成绩。</p><pre><code>SELECT NAME,english FROM student2 WHERE NAME LIKE &#39;李%&#39;</code></pre><p>—     查询英语&gt;80或者总分&gt;200的同学</p><pre><code>SELECT * FROM student2 WHERE english &gt;80 OR (chinese+english+math)&gt;200;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客Yilia主题_缺失模块_解决方案</title>
      <link href="/2018/02/08/hexo_Yilia%E7%BC%BA%E5%A4%B1%E6%A8%A1%E5%9D%97/"/>
      <url>/2018/02/08/hexo_Yilia%E7%BC%BA%E5%A4%B1%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>hexo博客yilia主题<br><a id="more"></a><br>hexo博客yilia主题,左侧栏目有一个全部文章的按钮，刚开始开始报错缺失模块，如下图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzYyODA5NjYtZDNmYjI4YjVhMWRjYjY5Yy5wbmc" alt="这里写图片描述"></p><p>我解决了这个问题着实不容易饶了弯路，但是跟着提示步骤，其实很简单，走起：</p><p>1、查看node版本<br><code>win键+R键</code>打开命令控制台，输入代码  </p><p><code>node -v</code>查看node版本，如下图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzYyODA5NjYtZTc5ODE1NWVkZjlkM2M2MC5wbmc" alt="这里写图片描述"></p><p>只要node的版本高于6.2就行</p><p>2、博客根目录下运行命令行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i  hexo-generator-json-content --save</span><br></pre></td></tr></table></figure></p><p>如果这个包已经存在，会报错，图忘了截了。</p><p>但是你需要在theme文件夹的yilia主题文件夹下，找到<code>node——modules</code>文件夹。如果<code>hexo-generator-json-content</code>这个包是存在的就OK，可以进行第三步了，见下图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzYyODA5NjYtN2JkYzM2MzljYTA1Y2M2NC5wbmc" alt="这里写图片描述"></p><p>3、配置文件<br>博客根目录下，找到_config.yml，打开找一个空白地方复制一下配置信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">jsonContent:</span><br><span class="line"></span><br><span class="line">  meta: false</span><br><span class="line"></span><br><span class="line">  pages: false</span><br><span class="line"></span><br><span class="line">  posts:</span><br><span class="line"></span><br><span class="line">    title: true</span><br><span class="line"></span><br><span class="line">    date: true</span><br><span class="line"></span><br><span class="line">    path: true</span><br><span class="line"></span><br><span class="line">    text: false</span><br><span class="line"></span><br><span class="line">    raw: false</span><br><span class="line"></span><br><span class="line">    content: false</span><br><span class="line"></span><br><span class="line">    slug: false</span><br><span class="line"></span><br><span class="line">    updated: false</span><br><span class="line"></span><br><span class="line">    comments: false</span><br><span class="line"></span><br><span class="line">    link: false</span><br><span class="line"></span><br><span class="line">    permalink: false</span><br><span class="line"></span><br><span class="line">    excerpt: false</span><br><span class="line"></span><br><span class="line">    categories: false</span><br><span class="line"></span><br><span class="line">    tags: true</span><br></pre></td></tr></table></figure><p></p><h4><strong>注（重点）：细节处—复制的信息格式要调好<br>1、配置文件内找空白处粘贴文件<br>2、第一行jsonContent:    即下图46行前没有空格<br>47、48、49行前有一个空格<br>剩下的有两个空格</strong><p></p><p>如下图所示：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzYyODA5NjYtMzBlNDY4ZGQ0NzMyZWE0Mi5wbmc" alt="这里写图片描述"></p><p>保存后同步文件在看你的博客，点全部文章按钮</p><p>应该是修复了缺失模块这个报错</p><p>谢谢</p><h1 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h1><h1 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h1><h1 id="我的简书主页，欢迎访问"><a href="#我的简书主页，欢迎访问" class="headerlink" title="我的简书主页，欢迎访问"></a><a href="https://www.jianshu.com/u/4082f682db35" target="_blank" rel="noopener">我的简书主页，欢迎访问</a></h1><h1 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h1></h4>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> yilia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客Yilia主题_more截断文章_多标签添加</title>
      <link href="/2018/02/08/hexo_more_article/"/>
      <url>/2018/02/08/hexo_more_article/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Hexo博客Yilia主题<em>more截断文章</em>多标签添加<br><a id="more"></a><br>以下均为自己遇到的问题并加以修改或者纠正.</p><p>在文章下方可以使用more语句进行截断，这样博客首页只会出现文章的前面一小部分，看起来很清爽简约</p><p> 或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">language: zh-CN</span><br><span class="line">&lt;!--more--&gt; //在需要阶段的地方插入该代码语句</span><br><span class="line">aa</span><br></pre></td></tr></table></figure></p><p>在这里，yilia主题会判断含有<code>&lt;!--more--&gt;</code>的位置，然后文章截断两部分，第一部分展示在博客首页，第二部分即上方的aa只能点开展开全文，才能继续阅读文章。</p><p>截断效果如下图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzYyODA5NjYtZGZmNzFiY2MxOGRmNzU4My5wbmc" alt="效果"></p><p>在这里我对yilia主题做了修改</p><p>原始效果为：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzYyODA5NjYtMmJjNzQ0Njg1N2JjMDRlNi5wbmc" alt="原始效果"></p><p>修改后为：去掉了more按钮，打开文章可以点击文章或者点击展开全文</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzYyODA5NjYtNTFlYTczNmZmZDk0MGQyYy5wbmc" alt="修改效果"></p><p>做法很简单，进入theme目录，打开yilia目录下的_config.yml文件，修改excerpt_link参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">excerpt_link：之后的more单词换成空格</span><br><span class="line">注：‘excerpt_link： ’。其中：后有一个空格键</span><br></pre></td></tr></table></figure><p>修改图如下图</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzYyODA5NjYtYzNlYzBiMjE1NDIxYmNlZS5wbmc" alt="这里写图片描述"></p><p>如何给文章加多个标签：</p><p>修改如下图，格式为<code>[tag1, tag2]</code></p><p>注：逗号之后要有一个空格。<code>[tag1, tag2]= [tag1+逗号+空格+tag2]</code></p><p>修改如下图所示：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzYyODA5NjYtNjIzMDVjOTQwZmVlMjA4Mi5wbmc" alt="这里写图片描述"></p><h1 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h1><h1 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h1><h1 id="我的简书主页，欢迎访问"><a href="#我的简书主页，欢迎访问" class="headerlink" title="我的简书主页，欢迎访问"></a><a href="https://www.jianshu.com/u/4082f682db35" target="_blank" rel="noopener">我的简书主页，欢迎访问</a></h1><h1 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> yilia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客Yilia主题首页菜单中文乱码两种解决方案</title>
      <link href="/2018/02/06/hexo_error_chinese/"/>
      <url>/2018/02/06/hexo_error_chinese/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>hexo-github博客首页菜单中文乱码两种解决方案<br><a id="more"></a></p><h2 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h2><p>菜单设置成中文显示，编辑博客根目录下的<code>_config.yml</code>文件</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82MjgwOTY2LWJhMDVlNGQ3YjAwNWI4ODYucG5n" alt="在这里插入图片描述"></p><p>设置<code>language</code>字段如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language: zh-Hans</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language: zh-CN</span><br></pre></td></tr></table></figure></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82MjgwOTY2LTlkMjk2MTRlNWFlN2JmM2UucG5n" alt="这里写图片描述"></p><p>取决于你的主题theme目录下的language目录下有<code>zh-Hans.yml</code>还是<code>zh-CN.yml</code><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82MjgwOTY2LTViYTFiZGIwNjhkNjQ3YTAucG5n" alt="这里写图片描述"></p><h2 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h2><p>根目录下的配置文件是_config.yml文件</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82MjgwOTY2LTdiZDY5Yzc3Y2U0NWNhOTgucG5n" alt="在这里插入图片描述"><br>我们需要打开此文件，然后编辑文字。</p><p>但是保存之后的格式可能跟文件本身的格式编码不一样，所以会出现乱码问题。</p><p>推荐用<code>sublime</code>，<code>VScode</code>，<code>atom</code>等文本编辑器打开，这三款开源软件写代码也很便利。<br>此处用atom文本编辑器打开编辑，保存后不会出现乱码问题了</p><p>最后效果如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82MjgwOTY2LWU3YWE2MmI0YmZhNjQ0MTMucG5n" alt="这里写图片描述"></p><p>希望能帮助到各位！<br><a href="http://www.aomanhao.top/2018/02/06/hexo_1/">我的个人博客文章地址，欢迎访问</a></p><p><a href="https://blog.csdn.net/Aoman_Hao/article/details/79275570" target="_blank" rel="noopener">我的CSDN文章地址，欢迎访问</a></p><p><a href="https://www.jianshu.com/p/81027eb27a39" target="_blank" rel="noopener">我的简书文章地址，欢迎访问</a></p><p><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>米pad记事本 0828刷好lineage系统</title>
      <link href="/2018/01/10/%E8%AE%B0%E4%BA%8B18_08_28/"/>
      <url>/2018/01/10/%E8%AE%B0%E4%BA%8B18_08_28/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>记事本</p><a id="more"></a><h3 id="18-11-20"><a href="#18-11-20" class="headerlink" title="18-11-20"></a>18-11-20</h3><p>87还是不够简约，入手凯酷84，心情大好</p><h3 id="18-10-09"><a href="#18-10-09" class="headerlink" title="18-10-09"></a>18-10-09</h3><p>红轴 贼鸥 87 舒服</p><h3 id="18-10-09-1"><a href="#18-10-09-1" class="headerlink" title="18-10-09"></a>18-10-09</h3><p>贼鸥87键 机械键盘改装，改樱桃红轴，键帽换为PBT键帽，磨砂手感，很不错</p><p><img width="800" height="800" src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/keyboard_pcb1.jpg"><br><img width="800" height="800" src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/keyboard_pcb2.jpg"><br><img width="800" height="800" src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/keyboard_pcb3.jpg"><br><img width="800" height="800" src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/keyboard_pcb4.jpg"><br><!--<img width="800" height="800" src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/shangluo1.jpg"/>--></p><h3 id="18-08-28"><a href="#18-08-28" class="headerlink" title="18-08-28"></a>18-08-28</h3><p>0828平板刷好lineage系统，奈斯，大夫</p><p>  魔趣系统bug有点多，无故重启，故刷入lineage系统0811版，运行完美<br><img width="800" height="800" src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/pad/pad%20%288%29.jpg"></p><h3 id="18-07-29"><a href="#18-07-29" class="headerlink" title="18-07-29"></a>18-07-29</h3><p>  入了一款小米平板，自带系统安卓4.4.4，系统太丑，找了第三方安装包魔趣7.1，升级到安卓7，比miui流畅多了，魔趣大法好<br><img width="800" height="800" src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/pad/pad%20%281%29.jpg"><br><img width="800" height="800" src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/pad/pad%20%282%29.jpg"><br><img width="800" height="800" src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/pad/pad%20%285%29.jpg"><br><img width="800" height="800" src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/pad/pad%20%286%29.jpg"><br><img width="800" height="800" src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/pad/pad%20%287%29.jpg"></p><p><img width="800" height="800" src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/pad/pad%20%289%29.jpg"></p><h3 id="18-07-20"><a href="#18-07-20" class="headerlink" title="18-07-20"></a>18-07-20</h3><p>纪念自己做的电容笔（右），虽然丑，用着还行，但是精确度比较差，还是买了一个10块的用用。</p><p>通过香烟盒里的锡纸连接手与屏幕导电，屏幕上的电极感应，然后确定操作点击屏幕。<br><img width="800" height="800" src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/pad/pad%20%284%29.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更新日志</title>
      <link href="/2018/01/01/UpdateLog/"/>
      <url>/2018/01/01/UpdateLog/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>博客更新日志<br><a id="more"></a></p><hr><blockquote><p>更新日志</p><p>[2019-02-24] 更新<br>优化网页，注入压缩静态文件插件，</p><p>[2019-02-24] 更新<br>随机变换背景图片，但是背景图片加载较慢。</p><p>[2019-02-23] 更新<br>本文字数和阅读时间功能更新。<br></p><p>[2019-02-19] 更新<br>更新Valine评论系统，阅读文章次数可见功能。<br></p><p>[2019-02-18] 更新<br>添加并修复站内搜索功能。<br></p><p>[2019-01-30] 更新<br>更新修改<code>Next</code>主题配置信息，可玩性较高。<br></p><p>[2019-01-29] 更新<br>使用<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">Next</a>主题修饰博客</p><p>期间主题配置等过程不计</p><p>[2018-08-09] 更新<br>使用<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">Yilia</a>主题修饰博客</p><p>[2018-08-08] 更新<br>注册并启用aomanhao.top网站</p><p>[2017-11-27] 更新<br>博客建立，使用<a href="http://hexo.io/" target="_blank" rel="noopener">Hexo</a>框架</p></blockquote><hr><blockquote><p>问题记录，更新需求</p><p>[2019-02-24] 更新<br>可以考虑用腾讯云作为新图床以满足图片加载</p><p>[2019-02-24] 更新<br>图片加载较慢<br>右侧CSDN没有icon图标</p><p>[2019-01-30] 更新<br>网页底部需要一颗心跳动的效果</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网页记录小本本</title>
      <link href="/2016/04/03/HtmlNote/"/>
      <url>/2016/04/03/HtmlNote/</url>
      
        <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>网页记录小本本<br><a id="more"></a><br>留言板记录网页以供后续参考</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
