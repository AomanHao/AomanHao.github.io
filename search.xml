<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>云储存选择做Hexo博客图床（腾讯云、七牛云、网易云）</title>
      <link href="/2019/02/26/hexo_cloud/"/>
      <url>/2019/02/26/hexo_cloud/</url>
      
        <content type="html"><![CDATA[<p>博客图床<br><a id="more"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>博客里需要添加很多图片作为内容的补充，但是把图片放在本地博客文件夹里，上传到网上后，加载这些图片就是一个很大的问题，他们会拖累网页加载的速度，所以建议把图片放图床里，通过外链来访问和加载这些图片。</p><h2 id="云对象储存服务商"><a href="#云对象储存服务商" class="headerlink" title="云对象储存服务商"></a>云对象储存服务商</h2><p>国内免费的云对象储存的服务商(网易云、七牛云、腾讯云)</p><h3 id="1-网易云"><a href="#1-网易云" class="headerlink" title="1.网易云"></a>1.网易云</h3><p>官网：<a href="https://www.163yun.com/" target="_blank" rel="noopener">https://www.163yun.com/</a><br><img src="https://img-blog.nos-eastchina1.126.net/blog/cloud163.jpg" alt="网易云"><br>网易NOS（Netease Object Storage）网易对象存储为你提供基于互联网的数据存取服务，通过使用 NOS，你可以随时通过网络将你的文本、图片、音视频等各类文件存储到 NOS 系统中，并随时可以通过网络进行安全访问。</p><p>NOS 对象存储从三个维度进行计量收费：存储容量、流量、接口调用次数。存储容量0-50 GB是免费，下载流量在0-20 GB免费，每月前 10 万次 Put 请求免费，每月前 100 万次 Get 请求免费。</p><h3 id="2-七牛云"><a href="#2-七牛云" class="headerlink" title="2.七牛云"></a>2.七牛云</h3><p>官网：<a href="https://www.qiniu.com/" target="_blank" rel="noopener">https://www.qiniu.com/</a></p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/cloud_qiniu.jpg" alt="七牛云"></p><p>七牛云存储提供云存储、云处理、云加速分发一站式服务，注册成为标准用户后可获得10GB免费存储空间、每月10GB下载流量、每月10万次Put请求、每月100万次Get请求。</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>临时域名仅有三个月，三个月后没有自己的备案域名，所有图片均会失效</p><h3 id="3-腾讯云"><a href="#3-腾讯云" class="headerlink" title="3.腾讯云"></a>3.腾讯云</h3><p>官网：<a href="https://cloud.tencent.com/" target="_blank" rel="noopener">https://cloud.tencent.com/</a></p><p><img src="https://img-blog.nos-eastchina1.126.net/blog/cloud_tencent.png" alt=""></p><p>腾讯云对象存储服务COS，全称为Cloud Object Service，主要是为开发者提供安全、稳定、高效、实惠的对象存储服务，开发者可以将任意动态、静态生成的数据，存放到COS上，再通过HTTP的方式进行访问。</p><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><p>自2019年后新建用户可以领取一个6月有效期，50G的存储量。6月过后，按照存储量和流量收费。</p><hr><h2 id="在线图床选择"><a href="#在线图床选择" class="headerlink" title="在线图床选择"></a>在线图床选择</h2><p><a href="https://sm.ms" target="_blank" rel="noopener">https://sm.ms</a> SM图床</p><p><a href="https://tu.aixinxi.net/" target="_blank" rel="noopener">https://tu.aixinxi.net/</a> 爱信息图床</p><p><a href="https://imgchr.com/" target="_blank" rel="noopener">https://imgchr.com/</a> 路过图床</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>云储存选择<code>网易云</code></p><p>图床选择<code>路过图床</code></p><p>目前还在用路过图床，缺点是图片链接不能看到任何图片名称等图片信息，不方便插入在博客里</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo主题Next配置及加载优化</title>
      <link href="/2019/02/25/theme_Nextpro/"/>
      <url>/2019/02/25/theme_Nextpro/</url>
      
        <content type="html"><![CDATA[<p>Hexo主题Next配置及加载优化</p><a id="more"></a><h2 id="主题源加载优化"><a href="#主题源加载优化" class="headerlink" title="主题源加载优化"></a>主题源加载优化</h2><p>把在NexT主题的_config.yml里面的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Uri of fonts host. E.g. //fonts.googleapis.com (Default)</span><br><span class="line">host:</span><br></pre></td></tr></table></figure></p><p>改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Uri of fonts host. E.g. //fonts.googleapis.com (Default)</span><br><span class="line">host: //fonts.lug.ustc.edu.cn</span><br></pre></td></tr></table></figure></p><p>因为<code>fonts.lug.ustc.edu.cn</code>是中科大的源，相比之前能快一下</p><hr><h2 id="博客双线部署"><a href="#博客双线部署" class="headerlink" title="博客双线部署"></a>博客双线部署</h2><p><a href="https://www.ieclipse.cn/2016/08/29/Web/Hexo-deploy-lines/" target="_blank" rel="noopener">参考文章地址</a></p><hr><h2 id="压缩网页静态资源"><a href="#压缩网页静态资源" class="headerlink" title="压缩网页静态资源"></a>压缩网页静态资源</h2><p><a href="https://blog.csdn.net/lewky_liu/article/details/82432003" target="_blank" rel="noopener">参考文章地址</a><br><a href="https://github.com/rozbo/hexo-neat" target="_blank" rel="noopener">hexo-neat插件github地址</a></p><p>常规的做法是使用<code>gulp</code>来进行压缩，每次压缩时还需要输入额外的命令，比较繁琐</p><h3 id="配置hexo-neat压缩插件"><a href="#配置hexo-neat压缩插件" class="headerlink" title="配置hexo-neat压缩插件"></a>配置hexo-neat压缩插件</h3><h4 id="在站点根目录下安装hexo-neat"><a href="#在站点根目录下安装hexo-neat" class="headerlink" title="在站点根目录下安装hexo-neat"></a>在站点根目录下安装hexo-neat</h4><p>博客目录下运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-neat --save</span><br></pre></td></tr></table></figure></p><p>如果报错，选择克隆插件，然后手动复制到插件目录里面<code>hexo目录\node_modules\</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/rozbo/hexo-neat</span><br></pre></td></tr></table></figure></p><h4 id="站点配置文件添加相关配置"><a href="#站点配置文件添加相关配置" class="headerlink" title="站点配置文件添加相关配置"></a>站点配置文件添加相关配置</h4><p>配置信息添加到博客目录文件夹下的<code>hexo目录\_config.yml</code>的末尾，可以安装自己的需求去自定义配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># hexo-neat</span><br><span class="line"># 博文压缩</span><br><span class="line">neat_enable: true</span><br><span class="line"># 压缩html</span><br><span class="line">neat_html:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line"># 压缩css  </span><br><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - &apos;**/*.min.css&apos;</span><br><span class="line"># 压缩js</span><br><span class="line">neat_js:</span><br><span class="line">  enable: true</span><br><span class="line">  mangle: true</span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">    - &apos;**/*.min.js&apos;</span><br><span class="line">    - &apos;**/jquery.fancybox.pack.js&apos;</span><br><span class="line">    - &apos;**/index.js&apos;</span><br></pre></td></tr></table></figure></p><h4 id="报错及相应解决"><a href="#报错及相应解决" class="headerlink" title="报错及相应解决"></a>报错及相应解决</h4><p><a href="https://blog.csdn.net/dataiyangu/article/details/84963491" target="_blank" rel="noopener">参考文章地址</a></p><h4 id="1、跳过压缩文件的正确配置方式"><a href="#1、跳过压缩文件的正确配置方式" class="headerlink" title="1、跳过压缩文件的正确配置方式"></a>1、跳过压缩文件的正确配置方式</h4><p>如果按照官方插件的文档说明来配置exclude，你会发现完全不起作用。这是因为配置的文件路径不对，压缩时找不到你配置的文件，自然也就无法跳过了。你需要给这些文件指定正确的路径，万能的配置方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">neat_css:</span><br><span class="line">enable: true</span><br><span class="line">exclude:</span><br><span class="line">- &apos;**/*.min.css&apos;</span><br></pre></td></tr></table></figure></p><h4 id="2、压缩html时不要跳过-md文件"><a href="#2、压缩html时不要跳过-md文件" class="headerlink" title="2、压缩html时不要跳过.md文件"></a>2、压缩html时不要跳过.md文件</h4><p>.md文件就是我们写文章时的markdown文件，如果跳过压缩.md文件，而你又刚好在文章中使用到了NexT自带的tab标签，那么当hexo在生成静态页面时就会发生解析错误。这会导致使用到了tab标签的页面生成失败而无法访问。</p><h4 id="3、压缩html时不要跳过-swig文件"><a href="#3、压缩html时不要跳过-swig文件" class="headerlink" title="3、压缩html时不要跳过.swig文件"></a>3、压缩html时不要跳过.swig文件</h4><p>.swig文件是模板引擎文件，简单的说hexo可以通过这些文件来生成对应的页面。如果跳过这些文件，那么你将会发现，你的所有页面完全没有起到压缩的效果，页面源代码里依然存在着一大堆空白。</p><h4 id="4、点击的桃心效果消失"><a href="#4、点击的桃心效果消失" class="headerlink" title="4、点击的桃心效果消失"></a>4、点击的桃心效果消失</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 压缩js</span><br><span class="line">neat_js:</span><br><span class="line">  enable: true</span><br><span class="line">  mangle: true</span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">    - &apos;**/*.min.js&apos;</span><br><span class="line">    - &apos;**/jquery.fancybox.pack.js&apos;</span><br><span class="line">    - &apos;**/index.js&apos;  </span><br><span class="line">    - &apos;**/love.js&apos;</span><br></pre></td></tr></table></figure><p>gitalk js文件报错<br>在上面的代码底部加入如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &apos;**/comments.gitalk.js&apos;</span><br></pre></td></tr></table></figure></p><h4 id="5、jquery-pjax-min-js报错"><a href="#5、jquery-pjax-min-js报错" class="headerlink" title="5、jquery pjax min js报错"></a>5、jquery pjax min js报错</h4><p>我这里的 jquery pjax min js是指的加入pjax前需要以来的两个cdn文件，一个是jq，一个是它，我将它下载到了本地，不要在意这些细节~<br>同样加入如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &apos;**/jquery_pjax_min_js.js&apos;</span><br></pre></td></tr></table></figure></p><hr><h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><p><a href="http://www.zhaojun.im/hexo-lazyload/" target="_blank" rel="noopener">参考文章地址</a></p><p>懒加载，在需要的时候才加载图片，而不是一次性加载完整个页面的图片<br>使用<code>lazyload</code>插件，适用于本地图片很多的情况</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>在<code>Hexo</code>博客目录下，执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-lazyload --save</span><br></pre></td></tr></table></figure></p><p>然后在你的 <code>Hexo</code>目录的配置文件 <code>_config.yml</code> 中添加配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lazyload:</span><br><span class="line">  enable: true</span><br><span class="line">  # className: #可选 e.g. .J-lazyload-img</span><br><span class="line">  # loadingImg: #可选 eg. ./images/loading.png</span><br></pre></td></tr></table></figure></p><p>参数：<br><code>loadingImg</code> - 图片未加载时的代替图</p><p>默认路径: <code>/js/lazyload-plugin/loading.svg</code><br>如果需要自定义，添填入 <code>loading</code> 图片地址，如果是本地图片，不要忘记把图片添加到你的主题目录下。</p><p><code>className</code> - 需要延迟加载的图片 <code>class</code>选择器</p><p>默认会延迟加载文章中的所有图片。<br>如果不为空，请填入需要延迟加载的图片<code>class</code> 选择器</p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客使用valine评论系统无效果及终极解决方案</title>
      <link href="/2019/02/20/hexo_valine/"/>
      <url>/2019/02/20/hexo_valine/</url>
      
        <content type="html"><![CDATA[<p> Hexo博客使用valine评论系统无效果及终极解决方案<br><a id="more"></a></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>有一些博主valine评论系统无效果，有一些原因：</p><blockquote><p>1、很大程度是因为next的版本升级导致某些参数设置不同<br>2、valine评论是基于LeanCloud，还有一个文章阅读次数功能也是用LeanCloud，两者会有一点冲突</p></blockquote><p>之后会给出一些解决方案</p><h2 id="评论系统选择"><a href="#评论系统选择" class="headerlink" title="评论系统选择"></a>评论系统选择</h2><p>Hexo可用的评论系统有很多，如下：  </p><p>来必力：<a href="https://livere.com" target="_blank" rel="noopener">https://livere.com</a> （需要邮箱注册，加载慢，较卡顿）</p><p>畅言： <a href="http://changyan.kuaizhan.com" target="_blank" rel="noopener">http://changyan.kuaizhan.com</a> （安装需要备案号）</p><p>Gitment： <a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">https://github.com/imsun/gitment</a> （加载慢，有Bug）</p><p>Valine: <a href="https://github.com/xCss/Valine" target="_blank" rel="noopener">https://github.com/xCss/Valine</a> (简约，实用，使用Leancloud作为线上数据库）</p><h2 id="评论系统配置过程"><a href="#评论系统配置过程" class="headerlink" title="评论系统配置过程"></a>评论系统配置过程</h2><p><code>next</code> 集成了 <code>leancloud</code> 。可以在<code>leancloud</code>进行账号注册。</p><h3 id="1、注册LeanCloud"><a href="#1、注册LeanCloud" class="headerlink" title="1、注册LeanCloud"></a>1、注册LeanCloud</h3><p>注册地址 <a href="https://leancloud.cn/" target="_blank" rel="noopener">https://leancloud.cn/</a></p><h3 id="2、配置LeanCloud"><a href="#2、配置LeanCloud" class="headerlink" title="2、配置LeanCloud"></a>2、配置LeanCloud</h3><p>创建一个新的应用<br><img src="https://s2.ax1x.com/2019/02/20/k2FG0s.png" alt="k2FG0s.png"></p><p>随便取个名字，自己看着取吧<br><img src="https://s2.ax1x.com/2019/02/20/k2FdpT.png" alt="k2FdpT.png"></p><p>应用创建完成，点开配置按钮<br><img src="https://s2.ax1x.com/2019/02/20/k2F8mj.png" alt="k2F8mj.png"></p><p>点击<code>设置</code> &gt; <code>应用Key</code> 复制App ID 和 App Key<br><img src="https://s2.ax1x.com/2019/02/20/k2FNt0.png" alt="k2FNt0.png"></p><p>点击<code>设置</code> &gt; <code>安全中心</code> 把自己博客网址添加到安全中心，保证数据的调用安全。<br><img src="https://s2.ax1x.com/2019/02/20/k2FUhV.png" alt="k2FUhV.png"></p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>在主题<code>themes</code>目录下有第三方提供的主题配置文件<code>\themes\next\_config.yml</code><br>打开主题配置文件 添加<code>appid</code> 和<code>appkey</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Valine</span><br><span class="line"># You can get your appid and appkey from https://leancloud.cn</span><br><span class="line"># More info available at https://valine.js.org</span><br><span class="line">valine:</span><br><span class="line">  enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version.</span><br><span class="line">  appid: 粘贴id</span><br><span class="line">  appkey: 粘贴key</span><br><span class="line">  notify: false # mail notifier, See: https://github.com/xCss/Valine/wiki</span><br><span class="line">  verify: false # Verification code</span><br><span class="line">  placeholder: 欢迎交流讨论... # comment box placeholder</span><br><span class="line">  avatar: mm # gravatar style</span><br><span class="line">  guest_info: nick,mail,link # custom comment header</span><br><span class="line">  pageSize: 10 # pagination size</span><br></pre></td></tr></table></figure><h2 id="阅读次数功能配置过程"><a href="#阅读次数功能配置过程" class="headerlink" title="阅读次数功能配置过程"></a>阅读次数功能配置过程</h2><h3 id="创建阅读次数Class类"><a href="#创建阅读次数Class类" class="headerlink" title="创建阅读次数Class类"></a>创建阅读次数Class类</h3><p>在应用里面创建名称为<code>Counter</code>的<code>Class</code>，名称必须为<code>Counter</code><br><img src="https://s2.ax1x.com/2019/02/20/k2Ftkq.png" alt="k2Ftkq.png"></p><p>创建完成，效果如下：<br><img src="https://s2.ax1x.com/2019/02/20/k2FJ7n.png" alt="k2FJ7n.png"></p><h2 id="修改配置文件-1"><a href="#修改配置文件-1" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  appid: 粘贴id</span><br><span class="line">  appkey: 粘贴key</span><br></pre></td></tr></table></figure><h2 id="评论系统无效原因及解决方案"><a href="#评论系统无效原因及解决方案" class="headerlink" title="评论系统无效原因及解决方案"></a>评论系统无效原因及解决方案</h2><h3 id="1、next的版本不同导致某些参数设置不同"><a href="#1、next的版本不同导致某些参数设置不同" class="headerlink" title="1、next的版本不同导致某些参数设置不同"></a>1、next的版本不同导致某些参数设置不同</h3><p>next为5.X版本的时候，配置文件<code>themes\next\_config.yml</code>的<code>valine</code>的<code>id</code>和<code>key</code>的书写方式为<code>appid</code>和<code>appkey</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">valine:</span><br><span class="line">  appid: 粘贴id</span><br><span class="line">  appkey: 粘贴key</span><br></pre></td></tr></table></figure><p>next为6.X版本的时候，配置文件<code>themes\next\_config.yml</code>的<code>valine</code>的<code>id</code>和<code>key</code>的书写方式为<code>app_id</code>和<code>app_key</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">valine:</span><br><span class="line">  app_id: 粘贴id</span><br><span class="line">  app_key: 粘贴key</span><br></pre></td></tr></table></figure></p><p>而<code>Valine</code>文件<code>themes\next\layout\_third-party\comments\valine.swig</code>内调用函数依旧为<code>appid</code>和<code>appkey</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appId: &apos;&#123;&#123; theme.valine.appid &#125;&#125;&apos;,</span><br><span class="line">   appKey: &apos;&#123;&#123; theme.valine.appkey &#125;&#125;&apos;,</span><br></pre></td></tr></table></figure></p><h3 id="参数设置不同解决方案"><a href="#参数设置不同解决方案" class="headerlink" title="参数设置不同解决方案"></a>参数设置不同解决方案</h3><p>配置文件<code>themes\next\_config.yml</code>的<code>valine</code>的<code>id</code>和<code>key</code>的书写方式统一为为<code>appid</code>和<code>appkey</code></p><h3 id="2、valine评论和文章阅读次数功能均基于LeanCloud，两者有冲突"><a href="#2、valine评论和文章阅读次数功能均基于LeanCloud，两者有冲突" class="headerlink" title="2、valine评论和文章阅读次数功能均基于LeanCloud，两者有冲突"></a>2、valine评论和文章阅读次数功能均基于LeanCloud，两者有冲突</h3><p>valine评论和文章阅读次数功能均基于LeanCloud，在配置文件<code>themes\next\_config.yml</code>中，<code>valine</code>的配置项和文章阅读次数的配置项均需要填写<code>LeanCloud</code>的<code>id</code>和<code>key</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: 粘贴id</span><br><span class="line">  app_key: 粘贴key</span><br><span class="line"></span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  appid: 粘贴id</span><br><span class="line">  appkey: 粘贴key</span><br></pre></td></tr></table></figure></p><p>即valine评论和文章阅读功能不能同时为<code>true</code>，只能单选一个功能。</p><h3 id="功能冲突解决方案"><a href="#功能冲突解决方案" class="headerlink" title="功能冲突解决方案"></a>功能冲突解决方案</h3><p>valine作者已经给出了方案，一个两种合一的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">valine:</span><br><span class="line">  ...</span><br><span class="line">  visitor: true # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors&apos; for counter compatibility. Article reading statistic https://valine.js.org/visitor.html</span><br><span class="line">  comment_count: true # if false, comment count will only be displayed in post page, not in home page</span><br></pre></td></tr></table></figure><p>相比之前的配置项多了<code>visitor</code>和<code>comment_count</code>两项参数。即要想拥有Valine评论与文章阅读次数可见，设置<code>Valine:</code>为<code>true</code>，<code>leancloud_visitors:</code>为<code>false</code>，配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Valine</span><br><span class="line"># You can get your appid and appkey from https://leancloud.cn</span><br><span class="line"># More info available at https://valine.js.org</span><br><span class="line">valine:</span><br><span class="line">  enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version.</span><br><span class="line">  appid: 粘贴id</span><br><span class="line">  appkey: 粘贴key </span><br><span class="line">  notify: false # mail notifier, See: https://github.com/xCss/Valine/wiki</span><br><span class="line">  verify: false # Verification code</span><br><span class="line">  placeholder: 欢迎交流讨论... # comment box placeholder</span><br><span class="line">  avatar: mm # gravatar style</span><br><span class="line">  guest_info: nick,mail,link # custom comment header</span><br><span class="line">  pageSize: 10 # pagination size</span><br><span class="line">  visitor: true # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors&apos; for counter compatibility. Article reading statistic https://valine.js.org/visitor.html</span><br><span class="line">  comment_count: true # if false, comment count will only be displayed in post page, not in home page</span><br><span class="line"></span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: false</span><br></pre></td></tr></table></figure><h2 id="Valine的CDN修改"><a href="#Valine的CDN修改" class="headerlink" title="Valine的CDN修改"></a>Valine的CDN修改</h2><p>官方自带的CDN加载慢，建议将CDN改成第三方CDN<code>valine:</code>，修改如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># valine</span><br><span class="line"> # See: https://github.com/xCss/Valine</span><br><span class="line"> # Example:</span><br><span class="line"> # valine: //cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js</span><br><span class="line"> #valine: //cdnjs.cloudflare.com/ajax/libs/valine/1.3.4/Valine.min.js</span><br><span class="line"> valine: //cdn.jsdelivr.net/npm/valine@1.3.4/dist/Valine.min.js</span><br></pre></td></tr></table></figure><p>以上内容完成Valine评论的配置相关，都是自己踩的坑，合并了文章阅读次数的功能。</p><p> <a href="http://www.aomanhao.top/2019/02/20/hexo_valine/#more">我的个人博客文章地址，欢迎访问</a><br> <a href="https://blog.csdn.net/Aoman_Hao/article/details/87809762" target="_blank" rel="noopener">我的CSDN文章地址，欢迎访问</a><br> <a href="https://www.jianshu.com/p/f4658df66a15" target="_blank" rel="noopener">我的简书文章地址，欢迎访问</a><br> <a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客Next主题站内搜索模块相关，解决搜索无效、一直loading的问题</title>
      <link href="/2019/01/30/hexo_theme_next_search/"/>
      <url>/2019/01/30/hexo_theme_next_search/</url>
      
        <content type="html"><![CDATA[<p>Hexo博客Next主题站内搜索模块相关，解决搜索无效、一直loading的问题</p><a id="more"></a><h2 id="站内搜索配置"><a href="#站内搜索配置" class="headerlink" title="站内搜索配置"></a>站内搜索配置</h2><p>设置方法：<br>首先安装<code>hexo-generator-searchdb</code>插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><p>编辑博客根目录下的<code>博客本地目录/_config.yml</code>站点配置文件，新增以下内容到任意位置，<code>search</code>顶格放否则可能没效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/klzbon" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/30/klzbon.md.png" alt="klzbon.md.png"></a></p><p>编辑<code>博客本地目录/themes/next/_config.yml</code> 主题配置文件，启用本地搜索功能,将<code>local_search:</code>下面的<code>enable:</code>的值，改成<code>true</code>，<code>local_search</code>顶格放置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  # unescape html strings to the readable one</span><br><span class="line">  unescape: false</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/k1pk7j" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/30/k1pk7j.md.png" alt="k1pk7j.md.png"></a></p><p>可以输入以下命令，先清理缓存，然后本地部署调试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></p><p>命令输入完成，提示：<strong>Hexo is running at <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></strong>，可以把网址复制到浏览器上，查看本地生成的博客搜索功能</p><hr><h2 id="搜索无效、一直loading的问题"><a href="#搜索无效、一直loading的问题" class="headerlink" title="搜索无效、一直loading的问题"></a>搜索无效、一直loading的问题</h2><p>根据以上配置出的搜索框有可能出现无法加载，搜索无效，动画一直loading的问题，如下图：</p><p><a href="https://imgchr.com/i/klzjzT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/30/klzjzT.md.jpg" alt="klzjzT.md.jpg"></a></p><p>按F12可以查看请求命令的状态，状态码<code>200</code>表示请求成功。但是搜索动画还是一直在转。</p><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>为了解决以上问题，也是花了很多时间在寻找办法，找个几个办法，终于解决了我的问题。</p><p><a href="https://www.sqlsec.com/2017/12/hexosearch.html" target="_blank" rel="noopener">国光的博客地址</a></p><p><a href="https://linchao1002.github.io/linchao1002.github.io/2019/01/23/Next%20%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">Linchao的博客地址</a></p><p>现给出比较详细的解决方法，如果搜索不成功，可能是以下原因之一</p><h3 id="1、搜索插件没有配置好"><a href="#1、搜索插件没有配置好" class="headerlink" title="1、搜索插件没有配置好"></a>1、搜索插件没有配置好</h3><p>配置就按照文章前面配置的步骤走就行了</p><h3 id="2、文章中包含特殊字符，文件编码时出错"><a href="#2、文章中包含特殊字符，文件编码时出错" class="headerlink" title="2、文章中包含特殊字符，文件编码时出错"></a>2、文章中包含特殊字符，文件编码时出错</h3><p>一般情况下，博客部署到网上想要进行本地调试，输入以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></p><p><a href="https://imgchr.com/i/klzLiq" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/30/klzLiq.md.png" alt="klzLiq.md.png"></a></p><p>报错先不用管，命令输入完成，提示：<strong>Hexo is running at <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></strong>。可以把网址复制到浏览器上，查看本地生成的博客，体验跟网站版的差不多，不出所料搜索框的动画还是会一直loading。<br><img src="https://s2.ax1x.com/2019/01/30/klzxQU.png" alt="klzxQU.png"></p><p>现在就要检查<code>search.xml</code> 文件，复制以下网址到浏览器，查看<code>search.xml</code>文件内容，是否报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost:4000/search.xml</span><br></pre></td></tr></table></figure></p><p>效果图如下：<br><a href="https://imgchr.com/i/klzzyF" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/30/klzzyF.md.png" alt="klzzyF.md.png"></a></p><p>可以看到，有报错，报错内容就是说<code>search.xml</code> 文件有一些不能读取的内容，因为xml文件是有特殊符号不能使用。如果报错，浏览器右侧滑条拉到底，看看是哪里的文章出现问题。</p><p>效果图如下：<br><a href="https://imgchr.com/i/klzOJ0" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/30/klzOJ0.md.png" alt="klzOJ0.md.png"></a></p><p>从最后的文字中找到<code>一些信息</code>，打开博客根目录下的<code>search.xml</code>文件</p><p><a href="https://imgchr.com/i/klzXWV" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/30/klzXWV.png" alt="klzXWV.png"></a></p><p>打开<code>search.xml</code>文件，找到包含那<code>一些信息</code>的那篇文章，最好是能开MarkDown在线编辑，也可以把有问题的<code>.md</code>文件拿出来，重新部署博客。</p><p>修改完成后，照平时那样部署博客就行。如果还有错，继续排查。</p><h3 id="我的个人博客主页，欢迎访问"><a href="#我的个人博客主页，欢迎访问" class="headerlink" title="我的个人博客主页，欢迎访问"></a><a href="http://www.aomanhao.top/">我的个人博客主页，欢迎访问</a></h3><h3 id="我的CSDN主页，欢迎访问"><a href="#我的CSDN主页，欢迎访问" class="headerlink" title="我的CSDN主页，欢迎访问"></a><a href="https://blog.csdn.net/Aoman_Hao" target="_blank" rel="noopener">我的CSDN主页，欢迎访问</a></h3><h3 id="我的简书主页，欢迎访问"><a href="#我的简书主页，欢迎访问" class="headerlink" title="我的简书主页，欢迎访问"></a><a href="https://www.jianshu.com/u/4082f682db35" target="_blank" rel="noopener">我的简书主页，欢迎访问</a></h3><h3 id="我的GitHub主页，欢迎访问"><a href="#我的GitHub主页，欢迎访问" class="headerlink" title="我的GitHub主页，欢迎访问"></a><a href="https://github.com/AomanHao" target="_blank" rel="noopener">我的GitHub主页，欢迎访问</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客Next主题阅读次数热度不能读取的问题，报错Counter not initialized! More info at console err msg.</title>
      <link href="/2019/01/30/theme_next_leancloud/"/>
      <url>/2019/01/30/theme_next_leancloud/</url>
      
        <content type="html"><![CDATA[<p>Hexo博客Next主题阅读次数热度不能读取的问题<br><a id="more"></a></p><h3 id="加入valine在线评论"><a href="#加入valine在线评论" class="headerlink" title="加入valine在线评论"></a>加入valine在线评论</h3><p>设置效果：</p><p>设置方法：<br>首先要先去<a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a>注册一个帐号.然后再创建一个应用.</p><p>拿到<code>appid</code>和<code>appkey</code>之后，打开<code>themes/next/_config.yml</code>主题配置文件，查找<code>valine</code>，填入<code>appid</code>和 <code>appkey</code><br>我的配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># You can get your appid and appkey from https://leancloud.cn</span><br><span class="line"># More info available at https://valine.js.org</span><br><span class="line">valine:</span><br><span class="line">  enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version.</span><br><span class="line">  appid: </span><br><span class="line">  appkey: </span><br><span class="line">  notify: true # mail notifier, See: https://github.com/xCss/Valine/wiki</span><br><span class="line">  verify: true # Verification code</span><br><span class="line">  placeholder: 欢迎交流讨论... # comment box placeholder</span><br><span class="line">  avatar: mm # gravatar style</span><br><span class="line">  guest_info: nick,mail,link # custom comment header</span><br><span class="line">  pageSize: 10 # pagination size</span><br><span class="line">  visitor: false # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors&apos; for counter compatibility. Article reading statistic https://valine.js.org/visitor.html</span><br><span class="line">  comment_count: true # if false, comment count will only be displayed in post page, not in home page</span><br></pre></td></tr></table></figure><hr><h2 id="Hexo添加阅读次数"><a href="#Hexo添加阅读次数" class="headerlink" title="Hexo添加阅读次数"></a>Hexo添加阅读次数</h2><p><code>next</code> 集成了 <code>leancloud</code> 。可以在<code>leancloud</code>进行账号注册。<br>创建一个新的应用。点击应用进入。<br>创建名称为<code>Counter</code>的<code>Class</code>，名称必须为<code>Counter</code></p><p><a href="https://imgchr.com/i/k1gdSK" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/31/k1gdSK.md.png" alt="k1gdSK.md.png"></a></p><p>点击设置 &gt; 应用Key 复制App ID 和 App Key<br><a href="https://imgchr.com/i/k1gUW6" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/31/k1gUW6.md.png" alt="k1gUW6.md.png"></a></p><p>修改配置文件<br>在主题<code>themes</code>目录下有第三方提供的主题配置文件<code>\themes\next_config.yml</code><br>打开主题配置文件 添加<code>app_id</code> 和<code>app_key</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Show number of visitors to each article.</span><br><span class="line"># You can visit https://leancloud.cn get AppID and AppKey.文章热度</span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: llBsNPTabKsl2d4aU3OvrmSz-gzGzoHsz</span><br><span class="line">  app_key: gzSQowSIzhnuc5eYPj4k7c7z</span><br><span class="line">  # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security</span><br><span class="line">  # If you don&apos;t care about security in leancloud counter and just want to use it directly</span><br><span class="line">  # (without hexo-leancloud-counter-security plugin), set `security` to `false`.</span><br><span class="line">  security: false</span><br><span class="line">  betterPerformance: false</span><br></pre></td></tr></table></figure></p><p>修改统计设置<br>打开主题配置文件 定位到 <code>post_wordcount</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https://github.com/willin/hexo-wordcount</span><br><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: true</span><br><span class="line">  min2read: true</span><br><span class="line">  totalcount: false</span><br><span class="line">  separated_meta: true</span><br></pre></td></tr></table></figure></p><p>Web安全性<br>为了保证应用的统计计数功能仅应用于自己的博客，你可以在应用 &gt; 设置 &gt; 安全中心的Web安全域名中加入自己的博客域名，保证数据的调用安全。</p><p><a href="https://imgchr.com/i/k1gwQO" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/31/k1gwQO.md.png" alt="k1gwQO.md.png"></a></p><hr><h2 id="显示文章热度"><a href="#显示文章热度" class="headerlink" title="显示文章热度"></a>显示文章热度</h2><p>首先要先去<a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a>注册一个帐号.然后再创建一个应用.</p><p>设置方法：<br><code>next</code>主题集成<code>leanCloud</code>，打开<code>themes/next/layout/_macro/post.swig</code>,准备添加<code>℃</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;# LeanCloud PageView #&#125;</span><br><span class="line">&#123;% if theme.leancloud_visitors.enable or (theme.valine.enable and theme.valine.appid and theme.valine.appkey and theme.valine.visitor) %&#125;</span><br><span class="line">  &lt;span id=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; class=&quot;leancloud_visitors&quot; data-flag-title=&quot;&#123;&#123; post.title &#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &#123;% if theme.post_meta.item_text %&#125;</span><br><span class="line">      &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123; __(&apos;post.views&apos;) + __(&apos;symbol.colon&apos;) &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">      &lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;℃&lt;/span&gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>插入摄氏度到倒数第三句，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;℃&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><p>打开，<code>themes/next/languages/zh-CN.yml</code>,将<code>views</code>后的文字描述改为热度.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">views: 热度</span><br></pre></td></tr></table></figure></p><p>有的版本不一样，打开，<code>themes/next/languages/zh-Hans.yml</code>，将以下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visitors: 热度</span><br></pre></td></tr></table></figure><p>然后打开<code>themes/next/_config.yml</code>找到<code>leancloud_visitors</code>,将<code>enable:</code>改成<code>true</code>,再填上自己<code>LeanCloud</code>的<code>app_id</code>和<code>app_key</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Show number of visitors to each article.</span><br><span class="line"># You can visit https://leancloud.cn get AppID and AppKey.文章热度</span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: 你自己的id</span><br><span class="line">  app_key: 你自己的key</span><br><span class="line">  # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security</span><br><span class="line">  # If you don&apos;t care about security in leancloud counter and just want to use it directly</span><br><span class="line">  # (without hexo-leancloud-counter-security plugin), set `security` to `false`.</span><br><span class="line">  security: true</span><br><span class="line">  betterPerformance: false</span><br></pre></td></tr></table></figure></p><h3 id="报错Counter-not-initialized-More-info-at-console-err-msg"><a href="#报错Counter-not-initialized-More-info-at-console-err-msg" class="headerlink" title="报错Counter not initialized! More info at console err msg."></a>报错Counter not initialized! More info at console err msg.</h3>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字数统计和阅读时长(网站底部/文章内)</title>
      <link href="/2019/01/30/hexo_next_wordcount/"/>
      <url>/2019/01/30/hexo_next_wordcount/</url>
      
        <content type="html"><![CDATA[<p>字数统计和阅读时长（旧版本新版本）<br><a id="more"></a><br>插件地址：<br><a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">https://github.com/theme-next/hexo-symbols-count-time</a><br>安装插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure><p>修改 站点配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line"> #文章内是否显示</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line"> # 网页底部是否显示</span><br><span class="line">  total_symbols: true</span><br><span class="line">  total_time: true</span><br></pre></td></tr></table></figure></p><p>修改 主题配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span><br><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true</span><br><span class="line">  #文章中的显示是否显示文字（本文字数|阅读时长） </span><br><span class="line">  item_text_post: true</span><br><span class="line">  #网页底部的显示是否显示文字（站点总字数|站点阅读时长） </span><br><span class="line">  item_text_total: false</span><br><span class="line">  # Average Word Length (chars count in word)</span><br><span class="line">  awl: 4</span><br><span class="line">  # Words Per Minute</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo主题Next配置algolia站内搜索</title>
      <link href="/2019/01/30/hexo_theme_next_algolia/"/>
      <url>/2019/01/30/hexo_theme_next_algolia/</url>
      
        <content type="html"><![CDATA[<p>Hexo主题Next配置algolia站内搜索</p><a id="more"></a><p>Algolia是一家为网站与移动应用提供托管式搜索API的初创企业，成立于2012年，总部位于旧金山，曾参加过去年的YC训练营。网站或移动应用只需嵌入简单代码数分钟即可实现搜索功能。</p><p>实现的效果如下</p><p>search</p><p>注册Algolia<br>打开Algolia进行注册。可直接使用github账号进行注册。</p><p>创建index<br>点击 NEW INDEX创建一个新的index。Index Name 后面会使用到。如图所示：<br>INDEX</p><p>编辑KEY<br>点击侧边栏API Keys可以看到 Application ID、 Search-Only API Key 、 Admin API Key。后面我们需要用到。 点击 ALL API KEYS，编辑KEY。如图所示。<br>INDEX</p><p>安装<code>hexo-algoliasearch</code>插件<br>在<code>Hexo</code>的根目录下执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-algoliasearch --save</span><br></pre></td></tr></table></figure></p><p>配置站点信息<br>打开 站点配置文件，添加algolia配置信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">algolia:</span><br><span class="line">  applicationID: </span><br><span class="line">  apiKey: </span><br><span class="line">  adminApiKey: </span><br><span class="line">  indexName: #创建index使用的Index Name</span><br><span class="line">  chunkSize: 5000</span><br></pre></td></tr></table></figure></p><p>打开 主题配置文件，添加algolia配置信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Algolia Search</span><br><span class="line">algolia_search:</span><br><span class="line">  enable: true</span><br><span class="line">  hits:</span><br><span class="line">    per_page: 10</span><br><span class="line">  labels:</span><br><span class="line">    input_placeholder: Search for Posts</span><br><span class="line">    hits_empty: &quot;We didn&apos;t find any results for the search: $&#123;query&#125;&quot;</span><br><span class="line">    hits_stats: &quot;$&#123;hits&#125; results found in $&#123;time&#125; ms&quot;</span><br></pre></td></tr></table></figure></p><p>在环境变量中添加 <code>HEXO_ALGOLIA_INDEXING_KEY</code>， 在Hexo的根目录执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export HEXO_ALGOLIA_INDEXING_KEY=粘贴上一步复制的 API KEY</span><br></pre></td></tr></table></figure></p><p>再次执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo algolia</span><br></pre></td></tr></table></figure></p><p>至此，我们的工作就完成了。</p><hr><p>参考：</p><p><a href="http://sophieb.cn/hexo/build-blog-hexo-next-algolia/" target="_blank" rel="noopener">Hexo+next 添加搜索功能</a></p><p><a href="http://www.qingpingshan.com/m/view.php?aid=386198" target="_blank" rel="noopener">Hexo+Next集成Algolia搜索</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo主题Next配置（二）</title>
      <link href="/2019/01/20/theme_NextConfig2/"/>
      <url>/2019/01/20/theme_NextConfig2/</url>
      
        <content type="html"><![CDATA[<p>Hexo主题Next配置（二）</p><a id="more"></a><h2 id="随机背景图片加载"><a href="#随机背景图片加载" class="headerlink" title="随机背景图片加载"></a>随机背景图片加载</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>自动更换背景是修改添加背景的css样式实现</p><h3 id="图片来源"><a href="#图片来源" class="headerlink" title="图片来源"></a>图片来源</h3><p><a href="https://source.unsplash.com/" target="_blank" rel="noopener">https://source.unsplash.com/</a></p><h3 id="修改背景样式"><a href="#修改背景样式" class="headerlink" title="修改背景样式"></a>修改背景样式</h3><p>修改<code>themes\next\source\css\ _custom\custom.styl</code>文件，这个是Next故意留给用户自己个性化定制一些样式的文件，添加以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background:url(https://source.unsplash.com/random/1600x900);</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">    background-position:50% 50%;</span><br><span class="line">    background-size:cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参数细节"><a href="#参数细节" class="headerlink" title="参数细节"></a>参数细节</h4><p><code>url</code>可更换为自己喜欢的图片的地址。<br><code>repeat：</code>是否重复出现<br><code>attachment：</code>定义背景图片随滚动轴的移动方式<br><code>position：</code>设置背景图像的起始位置。<br><code>background-size:cover</code>为可能有助于大分辨率下背景图的显示</p><h3 id="修改不透明度（可加可不加，看实际效果）"><a href="#修改不透明度（可加可不加，看实际效果）" class="headerlink" title="修改不透明度（可加可不加，看实际效果）"></a>修改不透明度（可加可不加，看实际效果）</h3><p>因为next主题的背景是纯透明的，这样子就造成背景图片的影响看不见文字，这对于博客来说肯定不行。</p><p>调整背景的不透明度可以更加美观，参数<code>opacity:</code>建议调整<code>0.8</code>至<code>0.95</code>之间。<br>修改<code>themes\next\source\css\ _custom\custom.styl</code>文件。在后面添加如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.main-inner &#123; </span><br><span class="line">    margin-top: 60px;</span><br><span class="line">    padding: 60px 60px 60px 60px;</span><br><span class="line">    background: #fff;</span><br><span class="line">    opacity: 0.9;</span><br><span class="line">    min-height: 500px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中：<code>background: #fff;</code> 白色<br><code>opacity: 0.9;</code>为不透明度</p><p>注：效果还可以，但是博客备份在github上，网速限制加载的比较忙，建议博客放在国内的Coding上</p><hr><h2 id="固定背景图片加载"><a href="#固定背景图片加载" class="headerlink" title="固定背景图片加载"></a>固定背景图片加载</h2><p><code>hexo\themes\next\source\images\</code> 的路径下；<br>在文件的最上方加上一代码 body { background:url(/images/backGround.jpg（这是你之前加的背景图片的名字）);} 就完事了。</p><h3 id="修改背景样式-1"><a href="#修改背景样式-1" class="headerlink" title="修改背景样式"></a>修改背景样式</h3><p>修改<code>themes\next\source\css\ _custom\custom.styl</code>文件，添加以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background:url(/images/图片.jpg);</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">    background-position:50% 50%;</span><br><span class="line">    background-size:cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="侧边栏社交小图标设置"><a href="#侧边栏社交小图标设置" class="headerlink" title="侧边栏社交小图标设置"></a>侧边栏社交小图标设置</h3><p>侧边栏默认只有<br>打开主题配置文件（_config.yml），搜索social_icons:,在fontawesome图标库（<a href="https://fontawesome.com/" target="_blank" rel="noopener">网址</a>）找自己喜欢的小图标，并将名字复制在如下位置配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/yourname || github</span><br><span class="line">  E-Mail: mailto:邮箱地址 || envelope</span><br><span class="line">  Weibo: https://weibo.com/yourname || weibo</span><br><span class="line">  CSDN: https://me.csdn.net/yourname || book</span><br><span class="line">  #Google: https://plus.google.com/yourname || google</span><br><span class="line">  #Twitter: https://twitter.com/yourname || twitter</span><br><span class="line">  #FB Page: https://www.facebook.com/yourname || facebook</span><br><span class="line">  #VK Group: https://vk.com/yourname || vk</span><br><span class="line">  #StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span><br><span class="line">  #YouTube: https://youtube.com/yourname || youtube</span><br><span class="line">  #Instagram: https://instagram.com/yourname || instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || skype</span><br></pre></td></tr></table></figure><h3 id="设置网站图标"><a href="#设置网站图标" class="headerlink" title="设置网站图标"></a>设置网站图标</h3><h4 id="下载图标"><a href="#下载图标" class="headerlink" title="下载图标"></a>下载图标</h4><p><a href="https//www.easyicon.net/">图标网站</a></p><p>下载尺寸32 X 32的图标，文件名必须是favicon.ico。</p><h4 id="图标放在"><a href="#图标放在" class="headerlink" title="图标放在"></a>图标放在</h4><p>2.将图标放在下一个/源极/图像文件夹目录下面。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>3.配置主题目录中的配置文件（敲黑板，重点）</p><p>之前网上查到的方法如下:(并没有成功）</p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo主题Next配置</title>
      <link href="/2019/01/20/theme_NextConfig1/"/>
      <url>/2019/01/20/theme_NextConfig1/</url>
      
        <content type="html"><![CDATA[<p>Hexo主题Next配置</p><a id="more"></a><h3 id="新建404界面"><a href="#新建404界面" class="headerlink" title="新建404界面"></a>新建404界面</h3><p>在站点根目录下，输入<code>hexo new page 404</code>，在默认<code>Hexo站点下/source/404/index.md</code><br>打开新建的404界面，编辑属于自己的404界面，可以显示腾讯公益404界面，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;</span><br><span class="line">  &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt;</span><br><span class="line">  &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://qzone.qq.com/gy/404/style/404style.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script type=&quot;text/plain&quot; src=&quot;http://www.qq.com/404/search_children.js&quot;</span><br><span class="line">          charset=&quot;utf-8&quot; homePageUrl=&quot;/&quot;</span><br><span class="line">          homePageName=&quot;回到我的主页&quot;&gt;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;https://qzone.qq.com/gy/404/data.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;https://qzone.qq.com/gy/404/page.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="静态资源压缩"><a href="#静态资源压缩" class="headerlink" title="静态资源压缩"></a>静态资源压缩</h3><p>静态资源压缩</p><p>在站点目录下安装插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install gulp -g</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp-minify-css --save</span><br><span class="line">npm install gulp-uglify --save</span><br><span class="line">npm install gulp-htmlmin --save</span><br><span class="line">npm install gulp-htmlclean --save</span><br><span class="line">npm install gulp-imagemin --save</span><br></pre></td></tr></table></figure><p>在Hexo站点下添加<code>gulpfile.js</code>文件，文件内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;);</span><br><span class="line">var minifycss = require(&apos;gulp-minify-css&apos;);</span><br><span class="line">var uglify = require(&apos;gulp-uglify&apos;);</span><br><span class="line">var htmlmin = require(&apos;gulp-htmlmin&apos;);</span><br><span class="line">var htmlclean = require(&apos;gulp-htmlclean&apos;);</span><br><span class="line">var imagemin = require(&apos;gulp-imagemin&apos;);</span><br><span class="line">// 压缩css文件</span><br><span class="line">gulp.task(&apos;minify-css&apos;, function() &#123;</span><br><span class="line">  return gulp.src(&apos;./public/**/*.css&apos;)</span><br><span class="line">  .pipe(minifycss())</span><br><span class="line">  .pipe(gulp.dest(&apos;./public&apos;));</span><br><span class="line">&#125;);</span><br><span class="line">// 压缩html文件</span><br><span class="line">gulp.task(&apos;minify-html&apos;, function() &#123;</span><br><span class="line">  return gulp.src(&apos;./public/**/*.html&apos;)</span><br><span class="line">  .pipe(htmlclean())</span><br><span class="line">  .pipe(htmlmin(&#123;</span><br><span class="line">    removeComments: true,</span><br><span class="line">    minifyJS: true,</span><br><span class="line">    minifyCSS: true,</span><br><span class="line">    minifyURLs: true,</span><br><span class="line">  &#125;))</span><br><span class="line">  .pipe(gulp.dest(&apos;./public&apos;))</span><br><span class="line">&#125;);</span><br><span class="line">// 压缩js文件</span><br><span class="line">gulp.task(&apos;minify-js&apos;, function() &#123;</span><br><span class="line">    return gulp.src([&apos;./public/**/.js&apos;,&apos;!./public/js/**/*min.js&apos;])</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(&apos;./public&apos;));</span><br><span class="line">&#125;);</span><br><span class="line">// 压缩 public/demo 目录内图片</span><br><span class="line">gulp.task(&apos;minify-images&apos;, function() &#123;</span><br><span class="line">    gulp.src(&apos;./public/demo/**/*.*&apos;)</span><br><span class="line">        .pipe(imagemin(&#123;</span><br><span class="line">           optimizationLevel: 5, //类型：Number  默认：3  取值范围：0-7（优化等级）</span><br><span class="line">           progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片</span><br><span class="line">           interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染</span><br><span class="line">           multipass: false, //类型：Boolean 默认：false 多次优化svg直到完全优化</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(&apos;./public/uploads&apos;));</span><br><span class="line">&#125;);</span><br><span class="line">// 默认任务</span><br><span class="line">gulp.task(&apos;default&apos;, [</span><br><span class="line">  &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;,&apos;minify-images&apos;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure></p><p>需要只在每次执行generate命令后执行gulp就可以实现对静态资源的压缩，完成压缩后执行deploy命令同步到服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">gulp</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><hr><h3 id="隐藏网页底部powered-By-Hexo-强力驱动"><a href="#隐藏网页底部powered-By-Hexo-强力驱动" class="headerlink" title="隐藏网页底部powered By Hexo / 强力驱动"></a>隐藏网页底部powered By Hexo / 强力驱动</h3><p>打开<code>themes/next/layout/_partials/footer.swig</code>,使用<code>&lt;!--</code>与<code>--&gt;</code>隐藏之间的代码即可，或者直接删除。位置如图：<br><img src="http://upload-images.jianshu.io/upload_images/5308475-8e8340c7a0489bce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hexo"></p><hr><h3 id="各版块透明度修改"><a href="#各版块透明度修改" class="headerlink" title="各版块透明度修改"></a>各版块透明度修改</h3><h4 id="内容板块透明"><a href="#内容板块透明" class="headerlink" title="内容板块透明"></a>内容板块透明</h4><p>根博客目录<code>themes\next\source\css\_schemes\Pisces\_layout.styl</code>文件<code>.content-wrap</code>标签下<code>background: white</code>修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: rgba(255,255,255,0.7); //0.7是透明度</span><br></pre></td></tr></table></figure></p><h4 id="菜单栏背景"><a href="#菜单栏背景" class="headerlink" title="菜单栏背景"></a>菜单栏背景</h4><p>根博客目录<code>themes\next\source\css\_schemes\Pisces\_layout.styl</code>文件<code>.header-inner</code>标签下<code>background: white</code>修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: rgba(255,255,255,0.7); //0.7是透明度</span><br></pre></td></tr></table></figure></p><h4 id="站点概况背景"><a href="#站点概况背景" class="headerlink" title="站点概况背景"></a>站点概况背景</h4><p>根博客目录<code>themes\next\source\css\_schemes\Pisces\_sidebar.styl</code>文件<code>.sidebar-inner</code>标签下<code>background: white</code>修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: rgba(255,255,255,0.7); //0.7是透明度</span><br></pre></td></tr></table></figure></p><p>修改然后根博客目录<code>themes\next\source\css\_schemes\Pisces\_layout.styl</code>文件<code>.sidebar</code>标签下<code>background: $body-bg-color</code>修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: rgba(255,255,255,0.7); //0.7是透明度</span><br></pre></td></tr></table></figure></p><hr><h3 id="网站底部字数统计"><a href="#网站底部字数统计" class="headerlink" title="网站底部字数统计"></a>网站底部字数统计</h3><p>具体方法实现</p><p>切换到根目录下，然后运行如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure></p><p>然后在<code>/themes/next/layout/_partials/footer.swig</code>文件尾部加上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;theme-info&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><hr><h3 id="添加侧栏推荐阅读"><a href="#添加侧栏推荐阅读" class="headerlink" title="添加侧栏推荐阅读"></a>添加侧栏推荐阅读</h3><p>编辑主题配置文件，如下配置即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Blog rolls</span><br><span class="line">links_icon: link</span><br><span class="line">links_title: 推荐阅读</span><br><span class="line">#links_layout: block</span><br><span class="line">links_layout: inline</span><br><span class="line">links:</span><br><span class="line">  Swift 4: https://developer.apple.com/swift/</span><br><span class="line">  Objective-C: https://developer.apple.com/documentation/objectivec</span><br></pre></td></tr></table></figure></p><hr><h3 id="博文置顶"><a href="#博文置顶" class="headerlink" title="博文置顶"></a>博文置顶</h3><p>修改<code>hexo-generator-index</code>插件，把<code>node_modules/hexo-generator-index/lib/generator.js</code>中代码替换为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">var pagination = require(&apos;hexo-pagination&apos;);</span><br><span class="line">module.exports = function(locals)&#123;</span><br><span class="line">  var config = this.config;</span><br><span class="line">  var posts = locals.posts;</span><br><span class="line">    posts.data = posts.data.sort(function(a, b) &#123;</span><br><span class="line">        if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义</span><br><span class="line">            if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排</span><br><span class="line">            else return b.top - a.top; // 否则按照top值降序排</span><br><span class="line">        &#125;</span><br><span class="line">        else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else return b.date - a.date; // 都没定义按照文章日期降序排</span><br><span class="line">    &#125;);</span><br><span class="line">  var paginationDir = config.pagination_dir || &apos;page&apos;;</span><br><span class="line">  return pagination(&apos;&apos;, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [&apos;index&apos;, &apos;archive&apos;],</span><br><span class="line">    format: paginationDir + &apos;/%d/&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>文章添加Top值，值越大，越靠前：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo-NexT主题配置</span><br><span class="line">date: 2018-01-20 20:41:08</span><br><span class="line">categories: Hexo</span><br><span class="line">tags:</span><br><span class="line">- Hexo</span><br><span class="line">- NexT</span><br><span class="line">top: 100</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><hr><h3 id="网页底部信息隐藏"><a href="#网页底部信息隐藏" class="headerlink" title="网页底部信息隐藏"></a>网页底部信息隐藏</h3><p>网页底默认最新一次使用，需要取消<code>since</code>注释，设定年份</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">footer:</span><br><span class="line">  # Specify the date when the site was setup.</span><br><span class="line">  # If not defined, current year will be used.</span><br><span class="line">  since: 2017</span><br><span class="line"></span><br><span class="line">  # Icon between year and copyright info.</span><br><span class="line">  icon:</span><br><span class="line">    # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons/</span><br><span class="line">    # `heart` is recommended with animation in red (#ff0000).</span><br><span class="line">    name: user #设置图标，想修改图标从https://fontawesome.com/v4.7.0/icons获取</span><br><span class="line">    # If you want to animate the icon, set it to true.</span><br><span class="line">    animated: false</span><br><span class="line">    # Change the color of icon, using Hex Code.</span><br><span class="line">    color: &quot;#808080&quot;</span><br><span class="line"></span><br><span class="line">  # If not defined, `author` from Hexo main config will be used.</span><br><span class="line">  copyright:  by AomanHao  #版权</span><br></pre></td></tr></table></figure><hr><h3 id="显示文章阅读进度百分比"><a href="#显示文章阅读进度百分比" class="headerlink" title="显示文章阅读进度百分比"></a>显示文章阅读进度百分比</h3><p>设置方法：<br>打开<code>themes/next/_config.yml</code>主题配置文件,找到<code># Scroll percent label in b2t button</code>将<code>scrollpercent:</code>的值,改成<code>true</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Scroll percent label in b2t button</span><br><span class="line">  scrollpercent: true</span><br></pre></td></tr></table></figure><hr><h3 id="浏览页面的时候显示当前浏览进度"><a href="#浏览页面的时候显示当前浏览进度" class="headerlink" title="浏览页面的时候显示当前浏览进度"></a>浏览页面的时候显示当前浏览进度</h3><p>如果想把top按钮放在侧边栏,打开<code>themes/next</code>下的<code>_config.yml</code>,搜索关键字<code>b2t</code>,把<code>false</code>改为<code>true</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Back to top in sidebar</span><br><span class="line"> b2t: true</span><br><span class="line">    </span><br><span class="line"> # Scroll percent label in b2t button</span><br><span class="line"> scrollpercent: true</span><br></pre></td></tr></table></figure><hr><h3 id="加入valine在线评论"><a href="#加入valine在线评论" class="headerlink" title="加入valine在线评论"></a>加入valine在线评论</h3><p>设置效果：</p><p>设置方法：<br>首先要先去<a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a>注册一个帐号.然后再创建一个应用.</p><p>拿到<code>appid</code>和<code>appkey</code>之后，打开<code>themes/next/_config.yml</code>主题配置文件，查找<code>valine</code>，填入<code>appid</code>和 <code>appkey</code><br>我的配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># You can get your appid and appkey from https://leancloud.cn</span><br><span class="line"># More info available at https://valine.js.org</span><br><span class="line">valine:</span><br><span class="line">  enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version.</span><br><span class="line">  appid: </span><br><span class="line">  appkey: </span><br><span class="line">  notify: true # mail notifier, See: https://github.com/xCss/Valine/wiki</span><br><span class="line">  verify: true # Verification code</span><br><span class="line">  placeholder: 欢迎交流讨论... # comment box placeholder</span><br><span class="line">  avatar: mm # gravatar style</span><br><span class="line">  guest_info: nick,mail,link # custom comment header</span><br><span class="line">  pageSize: 10 # pagination size</span><br><span class="line">  visitor: false # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors&apos; for counter compatibility. Article reading statistic https://valine.js.org/visitor.html</span><br><span class="line">  comment_count: true # if false, comment count will only be displayed in post page, not in home page</span><br></pre></td></tr></table></figure><hr><h3 id="Hexo添加阅读次数"><a href="#Hexo添加阅读次数" class="headerlink" title="Hexo添加阅读次数"></a>Hexo添加阅读次数</h3><p><code>next</code> 集成了 <code>leancloud</code> 。可以在<code>leancloud</code>进行账号注册。<br>创建一个新的应用。点击应用进入。<br>创建名称为<code>Counter</code>的<code>Class</code>，名称必须为<code>Counter</code></p><p><a href="https://imgchr.com/i/k1gdSK" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/31/k1gdSK.md.png" alt="k1gdSK.md.png"></a></p><p>点击设置 &gt; 应用Key 复制App ID 和 App Key<br><a href="https://imgchr.com/i/k1gUW6" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/31/k1gUW6.md.png" alt="k1gUW6.md.png"></a></p><p>修改配置文件<br>在主题<code>themes</code>目录下有第三方提供的主题配置文件<code>\themes\next_config.yml</code><br>打开主题配置文件 添加<code>app_id</code> 和<code>app_key</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Show number of visitors to each article.</span><br><span class="line"># You can visit https://leancloud.cn get AppID and AppKey.文章热度</span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: </span><br><span class="line">  app_key: </span><br><span class="line">  # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security</span><br><span class="line">  # If you don&apos;t care about security in leancloud counter and just want to use it directly</span><br><span class="line">  # (without hexo-leancloud-counter-security plugin), set `security` to `false`.</span><br><span class="line">  security: false</span><br><span class="line">  betterPerformance: false</span><br></pre></td></tr></table></figure></p><p>Web安全性<br>为了保证应用的统计计数功能仅应用于自己的博客，你可以在应用 &gt; 设置 &gt; 安全中心的Web安全域名中加入自己的博客域名，保证数据的调用安全。</p><p><a href="https://imgchr.com/i/k1gwQO" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/31/k1gwQO.md.png" alt="k1gwQO.md.png"></a></p><hr><h3 id="显示文章热度"><a href="#显示文章热度" class="headerlink" title="显示文章热度"></a>显示文章热度</h3><p>首先要先去<a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a>注册一个帐号.然后再创建一个应用.</p><p>设置方法：<br><code>next</code>主题集成<code>leanCloud</code>，打开<code>themes/next/layout/_macro/post.swig</code>,准备添加<code>℃</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;# LeanCloud PageView #&#125;</span><br><span class="line">&#123;% if theme.leancloud_visitors.enable or (theme.valine.enable and theme.valine.appid and theme.valine.appkey and theme.valine.visitor) %&#125;</span><br><span class="line">  &lt;span id=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; class=&quot;leancloud_visitors&quot; data-flag-title=&quot;&#123;&#123; post.title &#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &#123;% if theme.post_meta.item_text %&#125;</span><br><span class="line">      &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123; __(&apos;post.views&apos;) + __(&apos;symbol.colon&apos;) &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">      &lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;℃&lt;/span&gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>插入摄氏度到倒数第三句，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;℃&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><p>打开，<code>themes/next/languages/zh-CN.yml</code>,将<code>views</code>后的文字描述改为热度.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">views: 热度</span><br></pre></td></tr></table></figure></p><p>有的版本不一样，打开，<code>themes/next/languages/zh-Hans.yml</code>，将以下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visitors: 热度</span><br></pre></td></tr></table></figure><p>然后打开<code>themes/next/_config.yml</code>找到<code>leancloud_visitors</code>,将<code>enable:</code>改成<code>true</code>,再填上自己<code>LeanCloud</code>的<code>app_id</code>和<code>app_key</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Show number of visitors to each article.</span><br><span class="line"># You can visit https://leancloud.cn get AppID and AppKey.文章热度</span><br><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: 你自己的id</span><br><span class="line">  app_key: 你自己的key</span><br><span class="line">  # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security</span><br><span class="line">  # If you don&apos;t care about security in leancloud counter and just want to use it directly</span><br><span class="line">  # (without hexo-leancloud-counter-security plugin), set `security` to `false`.</span><br><span class="line">  security: true</span><br><span class="line">  betterPerformance: false</span><br></pre></td></tr></table></figure></p><hr><h3 id="添加网站已运行时间"><a href="#添加网站已运行时间" class="headerlink" title="添加网站已运行时间"></a>添加网站已运行时间</h3><p>在<code>themes/layout/_parrials/footer.swing</code>后添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var now = new Date(); </span><br><span class="line">    function createtime() &#123; </span><br><span class="line">        var grt= new Date(&quot;11/27/2017 12:00:00&quot;);//在此处修改你的建站时间</span><br><span class="line">        now.setTime(now.getTime()+250); </span><br><span class="line">        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); </span><br><span class="line">        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); </span><br><span class="line">        if(String(hnum).length ==1 )&#123;hnum = &quot;0&quot; + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); </span><br><span class="line">        mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = &quot;0&quot; + mnum;&#125; </span><br><span class="line">        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); </span><br><span class="line">        snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = &quot;0&quot; + snum;&#125; </span><br><span class="line">        document.getElementById(&quot;timeDate&quot;).innerHTML = &quot; Runing &quot;+dnum+&quot; D &quot;; </span><br><span class="line">        document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; H &quot; + mnum + &quot; M &quot; + snum + &quot; S&quot;; </span><br><span class="line">    &#125; </span><br><span class="line">setInterval(&quot;createtime()&quot;,250);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="添加头像"><a href="#添加头像" class="headerlink" title="添加头像"></a>添加头像</h3><p>打开<code>themes/next下的_config.yml</code>文件，搜索 <code>Avatar</code>关键字，修改url的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">avatar:</span><br><span class="line">  # in theme directory(source/images): /images/avatar.gif</span><br><span class="line">  # in site  directory(source/uploads): /uploads/avatar.gif</span><br><span class="line">  # You can also use other linking images.</span><br><span class="line">  url: /images/avatar.gif</span><br><span class="line">  # If true, the avatar would be dispalyed in circle.</span><br><span class="line">  rounded: true</span><br><span class="line">  # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar.</span><br><span class="line">  opacity: 1</span><br><span class="line">  # If true, the avatar would be rotated with the cursor.</span><br><span class="line">  rotated: false</span><br></pre></td></tr></table></figure></p><p>url链接默认是<code>themes/next/source/images</code>下的<code>avatar.gif</code>文件,有两种方法修改连接</p><p>1、本地连接，不建议用比较大的图片（大于1M文件），加载图片需要时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url: /images/avatar.gif</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">url: /images/xx.jpg等类型图片</span><br></pre></td></tr></table></figure></p><p>2、图床外链，建议使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url: http://example.com/avatar.png</span><br></pre></td></tr></table></figure></p><hr><h3 id="添加站内搜索"><a href="#添加站内搜索" class="headerlink" title="添加站内搜索"></a>添加站内搜索</h3><p>设置效果：</p><p>设置方法：<br>安装<code>hexo-generator-searchdb</code>插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></p><p>编辑<code>_config.yml</code>站点配置文件，新增以下内容到任意位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></p><p>编辑<code>themes/next/_config.yml</code>主题配置文件，启用本地搜索功能,将<code>local_search:</code>下面的<code>enable:</code>的值，改成<code>true</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><hr><h3 id="底部跳动图标实现"><a href="#底部跳动图标实现" class="headerlink" title="底部跳动图标实现"></a>底部跳动图标实现</h3><p>注意点：需要到<code>next\layout_partials下的footer.swig</code>文件中，在你所需要调动的图标所对应的span中增加对应的ID<br>去到主体的<code>css</code>文件（<code>next\source\css_variables\custom.styl</code>，增加以下代码即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//底部爱心小图标跳动</span><br><span class="line">keyframes heartAnimate &#123;</span><br><span class="line">    0%,100%&#123;transform:scale(1);&#125;</span><br><span class="line">    10%,30%&#123;transform:scale(0.9);&#125;</span><br><span class="line">    20%,40%,60%,80%&#123;transform:scale(1.1);&#125;</span><br><span class="line">    50%,70%&#123;transform:scale(1.1);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//图标所对应的span中的ID</span><br><span class="line">#heart &#123;</span><br><span class="line">    animation: heartAnimate 1.33s ease-in-out infinite;</span><br><span class="line">&#125;</span><br><span class="line">.with-love &#123;</span><br><span class="line">    color: rgb(255, 113, 113);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="实现统计功能"><a href="#实现统计功能" class="headerlink" title="实现统计功能"></a>实现统计功能</h3><p>具体实现方法:在根目录下安装 <code>hexo-wordcount</code>,运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure></p><p>然后在主题的配置文件中，配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https://github.com/willin/hexo-wordcount</span><br><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: true</span><br><span class="line">  min2read: true</span><br></pre></td></tr></table></figure></p><hr><h3 id="修改界面内容显示区域宽度"><a href="#修改界面内容显示区域宽度" class="headerlink" title="修改界面内容显示区域宽度"></a>修改界面内容显示区域宽度</h3><p><code>Next</code>主题默认的设置，两边留白的区域很大。当然我们可以修改设置<br>在<code>themes\next\source\css\_custom的custom.styl</code>添加下面参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 屏幕宽度小于1600px</span><br><span class="line">$content-desktop = 700px</span><br><span class="line"></span><br><span class="line">// 屏幕宽度大于或等于 1600px</span><br><span class="line">$content-desktop-large = 900px</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理_噪声检测</title>
      <link href="/2018/12/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%99%AA%E5%A3%B0%E6%A3%80%E6%B5%8B/"/>
      <url>/2018/12/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%99%AA%E5%A3%B0%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<p>噪声检测</p><a id="more"></a><h2 id="噪声检测方法"><a href="#噪声检测方法" class="headerlink" title="噪声检测方法"></a>噪声检测方法</h2><p>将噪声和信号区分开来是影响去噪效果好坏的重要因素之一。近年来，学者们提出了诸多噪声判断方法，其中较经典的方法包括：开关阈值法、极值法、两级门限法，下面对这三种方法进行介绍，并进行对比。<br>1.1 常见的噪声检测方法<br>（1）开关阈值法<br>开关阈值判断法[1]基本思想是：该方法通过一定的规则将噪声点和信号点进行判断，区分成两种类别来控制开关单元。若该像素点被判断为噪声点，则开关单元与滤波器相连接，即该点经过滤波后输出；若该像素点被判断为信号点，则开关单元对该点保持原像素值输出。开关阈值法的重点在于噪声检测器的设置，<br>其中较为常见的一种开关阈值判断法表示如下： </p><script type="math/tex; mode=display">X_(i,j=)\begin{cases}S,|f(i,j)-average(W[x_(i,j)])|<=T\\N,其他\\\end{cases}</script><p>式中 $x<em>(i,j)$是像素点，$S$是信号点，$N$是噪声点 ，$f(x,y)$是像素灰度值，$averageW(x</em>(i,j))$是邻域系统内所有灰度值的平均值，$T$ 为开关阈值。 </p><script type="math/tex; mode=display">T=(1/3)[\sqrt{\sum_{k=-1}^{k=1}\sum_{r=-1}^{r=1}[f(i+k,j+r)-average(W[x_(i,j)])]^2}</script><p>上述开关阈值判断法的优点是利用了图像邻域内的所有灰度值信息，缺点是阈值$T$ 的值对噪声点和信号点的判断影响很大。 </p><p>（2）极值法 </p><p>极值法[2]的基本思想是：在一幅图像中，邻域内的像素点和其它像素点存在较大的关联性，大多数情况下信号点与邻近像素点的灰度值差别不是太大，但噪声点相差较大；被椒盐噪声污染的像素点通常以最大值或最小值（纯黑或纯白）的灰度值出现，在噪声点检测时，若灰度值在最大值和最小值的区间范围内，则判断该像素点为信号点，反之为噪声点。具体方法如下： </p><script type="math/tex; mode=display">X_(i,j=)\begin{cases}S,minW[x_(i,j)]<f(i,j)<maxW[x_(i,j)]\\N,f(i,j)=minW[x_(i,j)]或者f(i,j)=maxW[x_(i,j)]\\\end{cases}</script><p>其中$x<em>(i,j)$为像素点，$S$为像素点，$N$为噪声点，$f(i,j)$是像素灰度值。<br>$minW[x</em>(i,j)]$是某邻域内所有像素点灰度值的最小值，$maxW[x_(i,j)]$是某邻域内所有像素点灰度值的最大值。<br>极值判断法在一定程度上能区分噪声点和信号点，尤其椒盐噪声图像，且该方法不用设置阈值，传统的自适应中值去噪方法即采用的是极值法，但该方法对椒盐去噪时，邻域内的某些极值信号像素点在判断过程中易被误判为噪声点。</p><p>（3）两级门限法<br>两级门限法[3]的思想是：椒盐噪声点的灰度值通常是集中在 255 或 0 附近，有一个大致的范围，并不一定就以最大值或最小值的形式出现；所以通过给定一个范围来判断像素值是否为噪声点，若像素灰度值落在范围内，则判断为噪声点，反之为信号点。检测方法如下： </p><script type="math/tex; mode=display">X_(i,j=)\begin{cases}S,\alpha<f(i,j)<255-\alpha\\N,0<=f(i,j)<\alpha或者255-\alpha\alpha\\\end{cases}</script><p>其中$x<em>(i,j)$为像素点，$S$为像素点，$N$为噪声点，$f(i,j)$是像素灰度值。<br>判断方法：首先设置一个阈值$\alpha$ ，规定盐点灰度值范围为 [255-$\alpha$,255]，椒点的灰度值范围为 [0,$\alpha$]。若中心像素点$x</em>(i,j)$的灰度值在盐点和椒点范围内，则该像素点为噪声点，反之是信号点。阈值$\alpha$既不能设置太大，否则易噪声误判；也不能设置太小，否则易造成漏判，文献[3]通过研究给出$\alpha=10$。该方法充分考虑到了椒盐噪声的特点，弥补了极值法的不足，提高了噪声点检测的准确性。但该方法仍需设置阈值。 </p><h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><ol><li>Sun T, Neuvo Y. Detail-preserving median based filters in image processing[J]. Pattern Recognition Letters, 1994, 15(4): 341-347.</li><li>邢藏菊 ,王守觉 ,邓浩江 ,罗予普 .一种基于极值中值的新型去噪算法 [J].中国图<br>象图形学报,2001, 6A(6):533-536</li><li>董继扬 ,  张军英 .  一种简单的椒盐噪声去噪 算法 .  计算机工程与 应用 ,  2003,<br>39(20): 28-31 </li></ol><h3 id="章节来源："><a href="#章节来源：" class="headerlink" title="章节来源："></a>章节来源：</h3><p>《图像椒盐噪声去噪算法研究及应用》-邓中东</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理_DCT（占坑）</title>
      <link href="/2018/10/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_DCT/"/>
      <url>/2018/10/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_DCT/</url>
      
        <content type="html"><![CDATA[<p>DCT<br><a id="more"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理_图像噪声</title>
      <link href="/2018/10/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E5%99%AA%E5%A3%B0/"/>
      <url>/2018/10/25/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E5%99%AA%E5%A3%B0/</url>
      
        <content type="html"><![CDATA[<p>图像噪声</p><a id="more"></a><h2 id="噪声"><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h2><p>加性噪声一般指热噪声、散弹噪声等，它们与信号的关系是相加，不管有没有信号，噪声都存在。 </p><blockquote><p>高斯白噪声包括热噪声和散粒噪声。在通信信道测试和建模中，高斯噪声被用作加性白噪声以产生加性白高斯噪声。</p><p>加性高斯白噪声只是白噪声的一种，另有泊松白噪声等,加性高斯白噪声在通信领域中指的是一种各频谱分量服从均匀分布（即白噪声），且幅度服从高斯分布的噪声信号。因其可加性、幅度服从高斯分布且为白噪声的一种而得名。</p></blockquote><p>而乘性噪声一般由信道不理想引起，它们与信号的关系是相乘，信号在它在，信号不在他也就不在。 </p><p>一般通信中把加性随机性看成是系统的背景噪声； </p><p>而乘性随机性看成系统的时变性（如衰落或者多普勒）或者非线性所造成的。</p><h3 id="椒盐噪声"><a href="#椒盐噪声" class="headerlink" title="椒盐噪声"></a>椒盐噪声</h3><p>定义：椒盐噪声又称为双极脉冲噪声，这种噪声表现的特点是噪声像素的灰度值与邻域像素有着明显差异，而其余像素的灰度值保持不变，因此在图像中造成过亮或过暗的像素点。椒盐噪声严重影响图像的视觉质量，给图像的边缘检测、纹理或者特征点提取等造成困难。</p><p>去椒盐噪声办法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、中值滤波</span><br><span class="line"></span><br><span class="line">2、开关中值滤波器 SMF（Switching Median Filter）[参考文献](Detail - preserving median based filters in image rocessing)</span><br><span class="line"></span><br><span class="line">3、自适应中值滤波器 AMF（Adaptive Median Filter）[参考文献](Adaptive median filters : New algorithms and results)</span><br><span class="line"></span><br><span class="line">4、自适应中心加权中值滤波器 ACWMF（Adaptive Center Weighted Median Filter） [参考文献](adaptive impulse detection using center Weighted median filter)</span><br><span class="line"></span><br><span class="line">5、基于决策的算法ＤＢＡ ( Decision Based Algorithm) [参考文献](A new fast and efficient decision Based algorithm for removal of high density impulse noises)</span><br></pre></td></tr></table></figure></p><p>一般会选择先检测再滤波的思路，通过开关机制抑制噪声，上述方法对低噪声水平的椒盐噪声处理效果良好，噪声水平过高无法得到理想的结果。因为基于中值的滤波方法仅考虑图像局部区域像素点的顺序阶信息，没有充分利用像素点之间的相关性或相似性。噪声像素点的估计值可能与真实值有较大偏差，很难保持图像的细节信息。</p><h3 id="高斯噪声"><a href="#高斯噪声" class="headerlink" title="高斯噪声"></a>高斯噪声</h3><p>高斯噪声是指概率密度函数服从高斯分布（即正态分布）的一类噪声。如果一个噪声，它的幅度服从高斯分布，而它的功率谱密度又是分布均匀的，则称它为高斯白噪声。高斯白噪声的二阶矩不想关，一阶矩为常数，是指先后信号在时间上的相关性。高斯白噪声包括热噪声和散粒噪声。高斯噪声完全由其时变平均值和两瞬时的协方差函数来确定，若噪声为平稳的，则平均值与时间无关，而协方差函数则变成仅和所考虑的两瞬时之方差有关的相关函数，它在意义上等效于功率谱密度。高斯噪声可以由大量独立的脉冲产生，从而在任何有限时间间隔内，这些脉冲中的每一个脉冲值与所有脉冲值的总和相比都可以忽略不计</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo添加相册</title>
      <link href="/2018/09/23/Hexo%E7%9B%B8%E5%86%8C/"/>
      <url>/2018/09/23/Hexo%E7%9B%B8%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p>相册<br><a id="more"></a></p><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>1.在主页上必须有一个可供点击的相册连接<br>2.要用 hexo 生成一个 photos.html 文件<br>3.photos.html 中的图片数据来源?因为这是一个静态页面所有要有一个 json 文件<br>4.json 文件中有含有信息,图片的文件名.<br>5.图片要有一个完整的路径,用github的空间<br>6.Python脚本剪裁、压缩、上传图片到自定义的github备份仓库中<br>不多说废话了,顺着思路逐一解决问题吧</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="1-在主页上必须有一个可供点击的连接"><a href="#1-在主页上必须有一个可供点击的连接" class="headerlink" title="1.在主页上必须有一个可供点击的连接"></a>1.在主页上必须有一个可供点击的连接</h3><p><code>BLOG\source</code>目录下创建一个<code>photos</code>目录，目的是存放利用脚本生成的json 文件和渲染文件。</p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/blog_photos_1.png" alt=""></p><p>配置 Yilia 主题让其显示出来.<br>yourBlog/themes/yilia/_config.yml文件<br>添加相册</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相册: /photos/</span><br></pre></td></tr></table></figure><p><img src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/blog_head_photo1.png" alt=""></p><h3 id="2-如何生成-photos-html-文件来"><a href="#2-如何生成-photos-html-文件来" class="headerlink" title="2.如何生成 photos.html 文件来"></a>2.如何生成 photos.html 文件来</h3><p>在github上新建一个仓库，主要用于存储图片，可以通过url访问到，也方便管理，备份图片和其他东西</p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/blog_backup1.png" alt=""></p><p><code>git clone</code> 到本地，模仿作者的文件目录结构</p><p><code>source</code>文件夹是备份图片，<code>theme</code>是备份yilia配置文件等<br><img src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/blog_backup2.png" alt=""></p><p><code>min_photos</code>是缩略图文件夹，<code>photos</code>是原图文件夹，<code>blog_photos_copy</code>是渲染文件备份，最后再弄<br><img src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/blog_backup3.png" alt=""></p><p>备份渲染文件，最后再弄<br><img src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/blog_backup4.png" alt=""></p><p>ejs 文件是以后要hexo 文件渲染的文件.</p><p>ins.js 文件设置自己的东西.</p><h3 id="3-修改-ejs-模板文件"><a href="#3-修改-ejs-模板文件" class="headerlink" title="3.修改 ejs 模板文件"></a>3.修改 ejs 模板文件</h3><h4 id="3-1-index-ejs文件可以不用修改"><a href="#3-1-index-ejs文件可以不用修改" class="headerlink" title="3.1 index.ejs文件可以不用修改"></a>3.1 index.ejs文件可以不用修改</h4><h4 id="3-2-修改-ins-js-文件的-render-函数-这个函数是用来渲染数据的"><a href="#3-2-修改-ins-js-文件的-render-函数-这个函数是用来渲染数据的" class="headerlink" title="3.2 修改 ins.js 文件的 render()函数.这个函数是用来渲染数据的"></a>3.2 修改 ins.js 文件的 render()函数.这个函数是用来渲染数据的</h4><p>修改图片的路径地址.minSrc 小图的路径. src 大图的路径.修改为自己的图片路径(github的路径).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var minSrc = &apos;https://raw.githubusercontent.com/AomanHao/Blog-Back-Up/master/source/min_photos/&apos; + data.link[i];</span><br><span class="line">var src = &apos;https://raw.githubusercontent.com/AomanHao/Blog-Back-Up/master/source/photos/&apos; + data.link[i];</span><br></pre></td></tr></table></figure><p>这个链接不是直接的图片url，是需要点“下载”才能看到的url。</p><p>github仓库上传的图片文件<br><img src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/blog_photos_git_1.png" alt=""></p><p>下载选项，看网址</p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/blog_photos_git_2.png" alt=""></p><p>黄色画出了链接网址，路径地址.minSrc 小图的路径. src 大图的路径<br><img src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/blog_photos_git_3.png" alt=""></p><p>我的路径有<code>source/min_photos/</code>和<code>source/photos</code>，分别是缩略图（压缩的图快速加载预览）和原图（点击查看图片）</p><h4 id="3-3生成-json-文件"><a href="#3-3生成-json-文件" class="headerlink" title="3.3生成 json 文件."></a>3.3生成 json 文件.</h4><p>这一步是关键的一步,也是最后一步.先用脚本把图片处理成一套大图和一套小图,<br>然后上传的七牛或者 github 上再回头生成这个 json文件.<br>每次更新图片都要执行脚本重新生成 json 文件.这个json 文件会出现在<br>yourBlog/source/photos/data.json</p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/blog_photos_2.png" alt=""></p><h3 id="4-处理图片"><a href="#4-处理图片" class="headerlink" title="4.处理图片"></a>4.处理图片</h3><p>处理脚本试用python语言写的，运行环境也是python</p><p>python脚本文件原作者GitHub地址：<code>https://github.com/lawlite19/Blog-Back-Up</code></p><p>下载python2或者3，在<code>cmd</code>运行窗口运行<code>python tool.py</code></p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/blog_python1.png" alt=""></p><p><code>tool.py</code>是运行主函数，<code>ImageProcess</code>图像处理功能函数，包括裁剪、压缩等</p><p>git_operation()方法:</p><p>如果你把图片上传到你的 github上这个方法就不用更改了.但是要确保在可以push到github的文件夹里，按照之前操作兴建了博客文件备份仓库</p><p>handle<em>photo()方法:<br>注意: 该脚本对图片的命名规则有要求.<br>最前面是日期，然后用</em>进行分隔；后面是图片的描述信息，注意不要包含_和.符号<br><img src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/blog_photos_git_4.png" alt=""></p><h3 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5.注意事项"></a>5.注意事项</h3><p>5.1<br>最前面是日期，然后用<em>进行分隔；后面是图片的描述信息，注意不要包含</em>和.符号</p><p>图片应该这样命名: 2016-10-12_xxx.jpg/png；存放在photos中，然后脚本运行会生成压缩图片，放置在<code>min_photos</code>文件夹中。</p><p>5.2</p><p><code>tool.py</code>文件中<code>open</code>里面的设置的是本地博客路径</p><p>如<code>D:/GitHub/AomanHao.github.io/source/photos/data.json</code></p><p><code>D:/GitHub/AomanHao.github.io/</code>是你的博客在本地的路径，<code>data.json</code>是图片信息文件</p><p>5.3<br>点开图片可以显示，缩略图不显示</p><p>下载empty图，<a href="https://raw.githubusercontent.com/wardseptember/BlogPicture/master/assets/img/empty.png" target="_blank" rel="noopener">下载地址</a>，直接右键另存，保存为“empty.png”。</p><p>在你博客的本地仓库source下新建一个文件夹命名为assets,再在assets下新建一个文件夹命名为img。最后把empty.png放到img里面。</p><p>我的目录如下：<br><img src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/blog_photos_git_5.png" alt=""></p><p>结尾：<br>在github上新建一个仓库，主要用于存储图片，可以通过url访问到，也方便管理<br>将要放到相册的图片处理成json格式的数据，然后进行访问，这里json的格式需要配合要使用的样式，所以需要处理成特定格式的json数据，下面会给出<br>图片裁剪，因为相册显示的样式最好是正方形的的图片，这里使用脚本处理一下<br>图片压缩，相册显示的图片是压缩后的图片，提高加载的速度，打开后的图片是原图。</p><p>问题：<br>当我用中文作为相册名字的时候，无法生成data.json文件，很纳闷，报错 UTF8的编码错误</p><p>算了，暂时找不改正的方法，科恩你是python是2.多的原因吧，我的相片都是用了英文命名</p><p><a href="https://www.jianshu.com/p/a9f309aaa0e0" target="_blank" rel="noopener">参考文章1</a><br><a href="http://lawlite.me/2017/04/13/Hexo-Github%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%86%8C%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">参考文章2</a><br><a href="https://blog.csdn.net/wardseptember/article/details/82780684" target="_blank" rel="noopener">参考文章3</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VScode配置</title>
      <link href="/2018/09/19/VScode%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/09/19/VScode%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>VScode配置</p><a id="more"></a><h3 id="VScode插件"><a href="#VScode插件" class="headerlink" title="VScode插件"></a>VScode插件</h3><p>Git History（装完输入 git log有惊喜)</p><p>Git Lens（让本就集成了 git 的 VSC 更加强大</p><p>Markdown Preview Enhanced(markdown 预览)</p><p>Emoji Code</p><p>Dracula Official 吸血鬼主题，暗黑风格</p><p>Code Runner  —- 支持多种语言例如： C，C++，Java，JavaSript，PHP，Python，Perl，Perl6 等</p><p>Bracket Pair Colorizer 和 Indent Rainbow，这两个插件可以让不同缩减的括号显示不同的颜色。</p><p>Auto Close Tag 和 Auto Rename Tag 插件，自动补全标签和联动重名标签</p><p>Studio Icons 图标展示，丰富界面</p><h3 id="VScode设置中文界面"><a href="#VScode设置中文界面" class="headerlink" title="VScode设置中文界面"></a>VScode设置中文界面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、按f1，搜索 Configore Display Language </span><br><span class="line"></span><br><span class="line">设置 zh-cn 关闭软件重启。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、如果重启菜单等还是英文的，在商店查看已安装的插件，把中文插件重新安装一遍，然后重启软件。</span><br><span class="line"></span><br><span class="line">应用商店搜索插件-chinese(simplified)</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/p930318/article/details/80491499?utm_source=copy" target="_blank" rel="noopener">参考文章</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> VScode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git配置</title>
      <link href="/2018/09/19/Git%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/09/19/Git%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>Git配置</p><a id="more"></a><h3 id="右键菜单配置-Git-Bash-Here-功能键"><a href="#右键菜单配置-Git-Bash-Here-功能键" class="headerlink" title="右键菜单配置 Git Bash Here 功能键"></a>右键菜单配置 Git Bash Here 功能键</h3><p>运行regedit.exe进入注册表，在HKEY_CLASSES_ROOT\Directory\Background\shell中进行设置。</p><p>1.新建项Git Bush Here，此时你可以看到在桌面右键会出现“Git Bush Here”菜单。</p><p>2.添加Git Bush Icon，在第一步的新建项Git Bush Here下，新建字符串值Icon，然后编辑该值为“C:\Program Files\Git\mingw64\share\git\git-for-windows.ico”，你需要根据你安装的Git 目录进行配置修改。完成此步后，你会发现右键菜单“Git Bush Here”会多出一个Icon。</p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/git_bash1.png" alt=""></p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/git_bash2.png" alt=""></p><p>3.添加Command项。在“Git Bush Here”下再新建项“Command”，将其默认值改为“C:\Program Files\Git\bin\bash.exe —login -i”，这样，你就可以通过右键菜单的方式快速进入Git命令行工具，进行代码版本管理。</p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/git_command1.png" alt=""></p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/git_command2.png" alt=""></p><h3 id="git-命令"><a href="#git-命令" class="headerlink" title="git 命令"></a>git 命令</h3><p>1.git config</p><p>该命令允许你获得和设置配置变量；这些变量可以控制Git的外观和操作的各个方面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用方法: git config –global user.name “[name]”</span><br><span class="line"></span><br><span class="line">使用方法: git config –global user.email “[email address]”</span><br></pre></td></tr></table></figure></p><p>2.git init</p><p>git init命令创建一个空的Git仓库或重新初始化一个现有仓库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用方法：git init [repository name]</span><br></pre></td></tr></table></figure></p><p>3.git clone</p><p>git clone命令将存储库克隆到新目录中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用方法：git clone [url]</span><br></pre></td></tr></table></figure></p><p>4.git add</p><p>git add命令将文件内容添加到索引(将修改添加到暂存区)。也就是将要提交的文件的信息添加到索引库中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用方法: git add [file] ;</span><br></pre></td></tr></table></figure></p><p>5.git commit<br>该命令用于将更改记录(提交)到存储库。将索引的当前内容与描述更改的用户和日志消息一起存储在新的提交中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用方法: git commit -m “[ Type in the commit message]”</span><br><span class="line"></span><br><span class="line">使用方法：git commit -a</span><br></pre></td></tr></table></figure><p>在修改文件后,需要使用gitadd把文件加入暂存区,这样gitcommit时才能把已经修改的信息加入版本库,而使用gitcommit-a可以不用再git add。</p><p>6.git diff</p><p>该命令用于显示提交和工作树等之间的更改。此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用方法: git diff</span><br><span class="line"></span><br><span class="line">使用方法：git diff –staged</span><br></pre></td></tr></table></figure></p><p>gitdiff—staged显示的是暂存区和版本库差异</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用方法：git diff [first branch] [second branch]</span><br></pre></td></tr></table></figure><p>命令显示两个分支之间的差异。</p><p>7.git reset<br>git reset命令用于将当前HEAD复位到指定状态。一般用于撤消之前的一些操作(如:git add,git commit等)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用方法: git reset [file]</span><br><span class="line"></span><br><span class="line">使用方法: git reset [commit]</span><br></pre></td></tr></table></figure></p><p>撤消指定提交后的所有提交，并在本地保留更改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用方法：git reset –hard [commit]</span><br></pre></td></tr></table></figure><p>丢弃所有历史记录并返回到指定的提交。</p><p>8.git status<br>该命令用于显示工作目录和暂存区的状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用方法: git status</span><br></pre></td></tr></table></figure></p><p>9.git rm<br>该命令用于从工作区和索引中删除文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用方法: git rm [file]</span><br></pre></td></tr></table></figure></p><p>10.git log<br>该命令用于显示提交日志信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用方法: git log</span><br><span class="line"></span><br><span class="line">使用方法：git log –follow[file]</span><br></pre></td></tr></table></figure></p><p>列出文件的版本历史记录，包括文件的重命名。</p><p>11.git show<br>该命令用于显示各种类型的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用方法: git show [commit]</span><br></pre></td></tr></table></figure></p><p>12.git tag<br>该命令用于创建,列出,删除或验证使用GPG签名的标签对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用方法: git tag [commitID]</span><br></pre></td></tr></table></figure></p><p>13.git branch</p><p>该命令列出当前存储库中的所有本地分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用方法: git branch</span><br><span class="line"></span><br><span class="line">使用方法：git branch [branch name]</span><br></pre></td></tr></table></figure></p><p>创建一个新分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用方法：git branch -d [branch name]</span><br></pre></td></tr></table></figure><p>删除分支</p><p>14.git checkout</p><p>该命令命令用于从一个分支切换到另一个分支。</p><p>使用方法：git checkout [branch name]</p><p>使用方法: git checkout -b [branch name]</p><p>该命令创建一个新分支并切换过去。</p><p>15.git merge<br>该命令用于将两个或两个以上的开发历史加入(合并)一起。</p><p>使用方法: git merge [branch name]</p><p>16.git remote<br>该命令管理一组跟踪的存储库。</p><p>使用方法: git remote add [variable name] [Remote Server Link]</p><p>17.git push<br>该命令用于将本地分支的更新,推送到远程主机。</p><p>使用方法: git push [variable name] master</p><p>使用方法：git push [variable name] [branch]</p><p>将分支提交到远程存储库。</p><p>使用方法：git push –all [variable name]</p><p>将所有分支推送到远程存储库。</p><p>使用方法: git push [variable name] :[branch name]</p><p>删除远程存储库上的分支。</p><p>18.git pull<br>该命令用于从另一个存储库或本地分支获取并集成(整合)。</p><p>使用方法: git pull [Repository Link]</p><p>19.git stash<br>该命令临时存储所有已修改的跟踪文件。。</p><p>使用方法: git stash save</p><p>使用方法：git stash pop</p><p>可恢复最近隐藏的文件。</p><p>使用方法：git stash list</p><p>列出所有存储的更改集。</p><p>使用方法：git stash drop</p><p>移除stash</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理_灰度变换_直方图</title>
      <link href="/2018/09/07/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2_%E7%9B%B4%E6%96%B9%E5%9B%BE/"/>
      <url>/2018/09/07/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2_%E7%9B%B4%E6%96%B9%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>图像处理<em>灰度变换</em>直方图</p><a id="more"></a><h2 id="直方图均衡化-Histogram-Equalization"><a href="#直方图均衡化-Histogram-Equalization" class="headerlink" title="直方图均衡化 Histogram Equalization"></a>直方图均衡化 Histogram Equalization</h2><p>假如图像的灰度分布不均匀，其灰度分布集中在较窄的范围内，使图像的细节不够清晰，对比度较低。通常采用<strong>直方图均衡化</strong>及<strong>直方图规定化</strong>两种变换，使图像的灰度范围拉开或使灰度均匀分布，从而增大反差，使图像细节清晰，以达到增强的目的。<br>直方图均衡化，对图像进行非线性拉伸，重新分配图像的灰度值，使一定范围内图像的灰度值大致相等。这样，原来直方图中间的峰值部分对比度得到增强，而两侧的谷底部分对比度降低，输出图像的直方图是一个较为平坦的直方图。</p><h3 id="均衡化算法"><a href="#均衡化算法" class="headerlink" title="均衡化算法"></a>均衡化算法</h3><p>直方图的均衡化实际也是一种灰度的变换过程，将当前的灰度分布通过一个变换函数，变换为范围更宽、灰度分布更均匀的图像。也就是将原图像的直方图修改为在整个灰度区间内大致均匀分布，因此扩大了图像的动态范围，增强图像的对比度。通常均衡化选择的变换函数是灰度的累积概率，直方图均衡化算法的步骤：</p><p>1、计算原图像的灰度直方图 $P(S_k)=n_kn$，其中$n$为像素总数，$n_k$为灰度级$S_k$的像素个数</p><p>2、计算原始图像的累积直方图<br>$CDF(S<em>k)=\sum</em>{i=0}^kn<em>in=\sum</em>{i=0}^kPs(Si)$<br>$D_j=L⋅CDF(S_i)$<br>其中 $D_j$是目的图像的像素，$CDF(S_i)$是源图像灰度为i的累积分布，$L$是图像中最大灰度级（灰度图为255）直接应用该方法得到图像的灰度直方图</p><p>3、将灰度直方图进行归一化，计算灰度的累积概率；<br>创建灰度变化的查找表<br>应用查找表，将原图像变换为灰度均衡的图像</p><h4 id="均衡化过程中，必须要保证两个条件"><a href="#均衡化过程中，必须要保证两个条件" class="headerlink" title="均衡化过程中，必须要保证两个条件"></a>均衡化过程中，必须要保证两个条件</h4><blockquote><p>1、像素无论怎么映射，一定要保证原来的大小关系不变，较亮的区域，依旧是较亮的，较暗依旧暗，只是对比度增大，绝对不能明暗颠倒；<br><br>2、如果是八位图像，那么像素映射函数的值域应在0和255之间的，不能越界。</p></blockquote><p>综合以上两个条件，累积分布函数是个好的选择，因为<strong>累积分布函数</strong>是<strong>单调增函数</strong>（控制大小关系），并且值域是0到1（控制越界问题），所以直方图均衡化中使用的是累积分布函数。</p><h4 id="累积分布函数"><a href="#累积分布函数" class="headerlink" title="累积分布函数"></a>累积分布函数</h4><p>累积分布函数具有一些好的性质，那么如何运用累积分布函数使得直方图均衡化？比较概率分布函数和累积分布函数，前者的二维图像是参差不齐的，后者是单调递增的。直方图均衡化过程中，映射方法是</p><script type="math/tex; mode=display">S_k = \sum_{j=0}^k\frac{n_j}{n} . k=0,1...,L-1</script><p>$n$是图像素总和，$n_k$是当前灰度级的像素个数，$L$是图像中灰度级总数</p><p>操作步骤有:<br><img src="https://img-blog.nos-eastchina1.126.net/huidu_junheng1.png" alt=""></p><h3 id="直方图规定化"><a href="#直方图规定化" class="headerlink" title="直方图规定化"></a>直方图规定化</h3><p>直方图规定化，就是对原始图像做变换，使得变换后的图像的直方图跟我们规定的一样。</p><p>具体步骤如下：</p><p>1、首先对原始图像做直方图均衡化，得到每个像素s和累积分布T(s);</p><p>2、根据需要的规定化直方图，求累积分布G(Z)；</p><p>3、显然，如果累积直方图中有0值，那么是不会分配像素值的，因为0乘以255还是零。</p><p>4、对于每一个T（s）（假设其像素值为ss）,找到在G（Z）中与其差值最小的那个G（z）值（假设对应的像素值为zz），那么规定化后就把ss变换为zz。</p><p>直方图规定化流程下图：<br><img src="https://img-blog.nos-eastchina1.126.net/huidu_guiding1.png" alt=""></p><p>1、计算原图像的累积直方图</p><p>2、计算规定直方图的累积直方图</p><p>3、计算两累积直方图的差值的绝对值</p><p>4、根据累积直方图差值建立灰度级的映射</p><h3 id="局部直方图处理-amp-直方图统计"><a href="#局部直方图处理-amp-直方图统计" class="headerlink" title="局部直方图处理&amp;直方图统计"></a>局部直方图处理&amp;直方图统计</h3><h3 id="Opencv代码"><a href="#Opencv代码" class="headerlink" title="Opencv代码"></a>Opencv代码</h3><h4 id="灰度直方图均衡"><a href="#灰度直方图均衡" class="headerlink" title="灰度直方图均衡"></a>灰度直方图均衡</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">// HistogramGrayEqualizeHist.cpp : 定义控制台应用程序的入口点。</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;opencv2/core/core.hpp&gt;   //cvGetSize  cvCreateImage</span><br><span class="line">#include &lt;opencv2/highgui/highgui.hpp&gt;</span><br><span class="line">#include &lt;opencv2/opencv.hpp&gt;  //cvResize cvInitMatHeader cvGetMinMaxHistValue cvCvtColor</span><br><span class="line">#include &lt;opencv2/imgproc/imgproc.hpp&gt;</span><br><span class="line"></span><br><span class="line">#ifdef _DEBUG</span><br><span class="line">#pragma comment(lib, &quot;opencv_core244d&quot;)</span><br><span class="line">#pragma comment(lib, &quot;opencv_highgui244d&quot;)</span><br><span class="line">#pragma comment(lib, &quot;opencv_imgproc244d&quot;)  //cvResize</span><br><span class="line">#else</span><br><span class="line">#pragma comment(lib, &quot;opencv_core244d&quot;)</span><br><span class="line">#pragma comment(lib, &quot;opencv_highgui244d&quot;)</span><br><span class="line">#pragma comment(lib, &quot;opencv_imgproc244d&quot;)  //cvResize</span><br><span class="line">#endif</span><br><span class="line">#define cvQueryHistValue_1D(hist,idx0) ((float)cvGetReal1D( (hist)-&gt;bins, (idx0)))</span><br><span class="line"></span><br><span class="line">using namespace std;  </span><br><span class="line">#pragma comment(linker, &quot;/subsystem:\&quot;windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;)  </span><br><span class="line">void FillWhite(IplImage *pImage)  </span><br><span class="line">&#123;  </span><br><span class="line">    cvRectangle(pImage, cvPoint(0, 0), cvPoint(pImage-&gt;width, pImage-&gt;height), CV_RGB(255, 255, 255), CV_FILLED);  </span><br><span class="line">&#125;  </span><br><span class="line">// 创建灰度图像的直方图  </span><br><span class="line">CvHistogram* CreateGrayImageHist(IplImage **ppImage)  </span><br><span class="line">&#123;  </span><br><span class="line">    int nHistSize = 256;  </span><br><span class="line">    float fRange[] = &#123;0, 255&#125;;  //灰度级的范围    </span><br><span class="line">    float *pfRanges[] = &#123;fRange&#125;;    </span><br><span class="line">    CvHistogram *pcvHistogram = cvCreateHist(1, &amp;nHistSize, CV_HIST_ARRAY, pfRanges);  </span><br><span class="line">    cvCalcHist(ppImage, pcvHistogram);  </span><br><span class="line">    return pcvHistogram;  </span><br><span class="line">&#125;  </span><br><span class="line">// 根据直方图创建直方图图像  </span><br><span class="line">IplImage* CreateHisogramImage(int nImageWidth, int nScale, int nImageHeight, CvHistogram *pcvHistogram)  </span><br><span class="line">&#123;  </span><br><span class="line">    IplImage *pHistImage = cvCreateImage(cvSize(nImageWidth * nScale, nImageHeight), IPL_DEPTH_8U, 1);  </span><br><span class="line">    FillWhite(pHistImage);  </span><br><span class="line">  </span><br><span class="line">    //统计直方图中的最大直方块  </span><br><span class="line">    float fMaxHistValue = 0;  </span><br><span class="line">    cvGetMinMaxHistValue(pcvHistogram, NULL, &amp;fMaxHistValue, NULL, NULL);  </span><br><span class="line">  </span><br><span class="line">    //分别将每个直方块的值绘制到图中  </span><br><span class="line">    int i;  </span><br><span class="line">    for(i = 0; i &lt; nImageWidth; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        float fHistValue = cvQueryHistValue_1D(pcvHistogram, i); //像素为i的直方块大小  </span><br><span class="line">        int nRealHeight = cvRound((fHistValue / fMaxHistValue) * nImageHeight);  //要绘制的高度  </span><br><span class="line">        cvRectangle(pHistImage,  </span><br><span class="line">            cvPoint(i * nScale, nImageHeight - 1),  </span><br><span class="line">            cvPoint((i + 1) * nScale - 1, nImageHeight - nRealHeight),  </span><br><span class="line">            cvScalar(i, 0, 0, 0),   </span><br><span class="line">            CV_FILLED  </span><br><span class="line">            );   </span><br><span class="line">    &#125;  </span><br><span class="line">    return pHistImage;  </span><br><span class="line">&#125;  </span><br><span class="line">int main( int argc, char** argv )  </span><br><span class="line">&#123;     </span><br><span class="line">    const char *pstrWindowsSrcTitle = &quot;原图&quot;;  </span><br><span class="line">    const char *pstrWindowsGrayTitle = &quot;灰度图&quot;;  </span><br><span class="line">    const char *pstrWindowsHistTitle = &quot;直方图&quot;;  </span><br><span class="line">    const char *pstrWindowsGrayEqualizeTitle = &quot;灰度图-均衡化后&quot;;  </span><br><span class="line">    const char *pstrWindowsHistEqualizeTitle = &quot;直方图-均衡化后&quot;;  </span><br><span class="line">      </span><br><span class="line">    // 从文件中加载原图  </span><br><span class="line">    // IplImage *pSrcImage = cvLoadImage(&quot;./images/yangmi.jpg&quot;, CV_LOAD_IMAGE_UNCHANGED);  </span><br><span class="line">    IplImage *pSrcImage = cvLoadImage(&quot;./images/beauty.png&quot;, CV_LOAD_IMAGE_UNCHANGED);  </span><br><span class="line">    IplImage *pGrayImage = cvCreateImage(cvGetSize(pSrcImage), IPL_DEPTH_8U, 1);  </span><br><span class="line">    IplImage *pGrayEqualizeImage = cvCreateImage(cvGetSize(pSrcImage), IPL_DEPTH_8U, 1);  </span><br><span class="line">      </span><br><span class="line">    // 灰度图  </span><br><span class="line">    cvCvtColor(pSrcImage, pGrayImage, CV_BGR2GRAY);  </span><br><span class="line">    // 直方图图像数据  </span><br><span class="line">    int nHistImageWidth = 255;  </span><br><span class="line">    int nHistImageHeight = 150;   </span><br><span class="line">    int nScale = 2;    </span><br><span class="line">  </span><br><span class="line">    // 灰度直方图及直方图图像  </span><br><span class="line">    CvHistogram *pcvHistogram = CreateGrayImageHist(&amp;pGrayImage);  </span><br><span class="line">    IplImage *pHistImage = CreateHisogramImage(nHistImageWidth, nScale, nHistImageHeight, pcvHistogram);  </span><br><span class="line">  </span><br><span class="line">    // 均衡化 </span><br><span class="line">    //函数功能：直方图均衡化，该函数能归一化图像亮度和增强对比度</span><br><span class="line">    //第一个参数表示输入图像，必须为灰度图（8位，单通道图）</span><br><span class="line">    //第二个参数表示输出图像</span><br><span class="line">    //该函数采用如下法则对输入图像进行直方图均衡化：</span><br><span class="line">        //1：计算输入图像的直方图H。</span><br><span class="line">        //2：直方图归一化，因此直方块和为255。</span><br><span class="line">        //3：计算直方图积分，H&apos;(i) = Sum(H(j)) (0&lt;=j&lt;=i)。</span><br><span class="line">        //4：采用H&apos;作为查询表：dst(x, y) = H&apos;(src(x, y))进行图像变换。</span><br><span class="line">    cvEqualizeHist(pGrayImage, pGrayEqualizeImage);  </span><br><span class="line">  </span><br><span class="line">    // 均衡化后的灰度直方图及直方图图像  </span><br><span class="line">    CvHistogram *pcvHistogramEqualize = CreateGrayImageHist(&amp;pGrayEqualizeImage);         </span><br><span class="line">    IplImage *pHistEqualizeImage = CreateHisogramImage(nHistImageWidth, nScale, nHistImageHeight, pcvHistogramEqualize);  </span><br><span class="line">  </span><br><span class="line">    // 显示  </span><br><span class="line">    cvNamedWindow(pstrWindowsSrcTitle); </span><br><span class="line">    cvNamedWindow(pstrWindowsGrayTitle); </span><br><span class="line">    cvNamedWindow(pstrWindowsGrayEqualizeTitle); </span><br><span class="line">    cvNamedWindow(pstrWindowsHistTitle); </span><br><span class="line">    cvNamedWindow(pstrWindowsHistEqualizeTitle); </span><br><span class="line">    cvShowImage(pstrWindowsSrcTitle,pSrcImage);</span><br><span class="line">    cvShowImage(pstrWindowsGrayTitle,pGrayImage);</span><br><span class="line">    cvShowImage(pstrWindowsGrayEqualizeTitle,pGrayEqualizeImage);</span><br><span class="line">    cvShowImage(pstrWindowsHistTitle,pHistImage);</span><br><span class="line">    cvShowImage(pstrWindowsHistEqualizeTitle,pHistEqualizeImage);</span><br><span class="line">    cvWaitKey(0);  </span><br><span class="line">    //回收资源代码…  </span><br><span class="line">    cvDestroyWindow(pstrWindowsSrcTitle);</span><br><span class="line">    cvDestroyWindow(pstrWindowsGrayTitle);</span><br><span class="line">    cvDestroyWindow(pstrWindowsGrayEqualizeTitle);</span><br><span class="line">    cvDestroyWindow(pstrWindowsHistTitle);</span><br><span class="line">    cvDestroyWindow(pstrWindowsHistEqualizeTitle);</span><br><span class="line">    cvReleaseImage(&amp;pSrcImage);</span><br><span class="line">    cvReleaseImage(&amp;pGrayImage);</span><br><span class="line">    cvReleaseImage(&amp;pGrayEqualizeImage);</span><br><span class="line">    cvReleaseImage(&amp;pHistImage);</span><br><span class="line">    cvReleaseImage(&amp;pHistEqualizeImage);</span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="直方图规定化-1"><a href="#直方图规定化-1" class="headerlink" title="直方图规定化"></a>直方图规定化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">void hist_specify(const Mat &amp;src, const Mat &amp;dst,Mat &amp;result)</span><br><span class="line">&#123;</span><br><span class="line">    Histogram1D hist1D;</span><br><span class="line">    MatND src_hist = hist1D.getHistogram(src);</span><br><span class="line">    MatND dst_hist = hist1D.getHistogram(dst);</span><br><span class="line"></span><br><span class="line">    float src_cdf[256] = &#123; 0 &#125;;</span><br><span class="line">    float dst_cdf[256] = &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">    // 源图像和目标图像的大小不一样，要将得到的直方图进行归一化处理</span><br><span class="line">    src_hist /= (src.rows * src.cols);</span><br><span class="line">    dst_hist /= (dst.rows * dst.cols);</span><br><span class="line"></span><br><span class="line">    // 计算原始直方图和规定直方图的累积概率</span><br><span class="line">    for (int i = 0; i &lt; 256; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (i == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            src_cdf[i] = src_hist.at&lt;float&gt;(i);</span><br><span class="line">            dst_cdf[i] = dst_hist.at&lt;float&gt;(i);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            src_cdf[i] = src_cdf[i - 1] + src_hist.at&lt;float&gt;(i);</span><br><span class="line">            dst_cdf[i] = dst_cdf[i - 1] + dst_hist.at&lt;float&gt;(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 累积概率的差值</span><br><span class="line">    float diff_cdf[256][256];</span><br><span class="line">    for (int i = 0; i &lt; 256; i++)</span><br><span class="line">        for (int j = 0; j &lt; 256; j++)</span><br><span class="line">            diff_cdf[i][j] = fabs(src_cdf[i] - dst_cdf[j]);</span><br><span class="line"></span><br><span class="line">    // 构建灰度级映射表</span><br><span class="line">    Mat lut(1, 256, CV_8U);</span><br><span class="line">    for (int i = 0; i &lt; 256; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        // 查找源灰度级为ｉ的映射灰度</span><br><span class="line">        //　和ｉ的累积概率差值最小的规定化灰度</span><br><span class="line">        float min = diff_cdf[i][0];</span><br><span class="line">        int index = 0;</span><br><span class="line">        for (int j = 1; j &lt; 256; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (min &gt; diff_cdf[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                min = diff_cdf[i][j];</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lut.at&lt;uchar&gt;(i) = static_cast&lt;uchar&gt;(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 应用查找表，做直方图规定化</span><br><span class="line">    LUT(src, lut, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> Opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习面试</title>
      <link href="/2018/09/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%B2%BE%E5%8D%8E/"/>
      <url>/2018/09/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%B2%BE%E5%8D%8E/</url>
      
        <content type="html"><![CDATA[<p>机器学习面试</p><a id="more"></a><h3 id="SVM："><a href="#SVM：" class="headerlink" title="SVM："></a>SVM：</h3><blockquote><p>简单介绍SVM（详细原理）：从分类平面，到求两类间的最大间隔，到转化为求间隔分之一，等优化问题，然后就是优化问题的解决办法，首先是用拉格拉日乘子把约束优化转化为无约束优化，对各个变量求导令其为零，得到的式子带入拉格朗日式子从而转化为对偶问题， 最后再利用SMO（序列最小优化）来解决这个对偶问题。svm里面的c有啥用</p><p>SVM的推导，解释原问题和对偶问题，SVM原问题和对偶问题的关系，KKT限制条件，KKT条件用哪些，完整描述；软间隔问题，解释支持向量、核函数（哪个地方引入、画图解释高维映射，高斯核可以升到多少维，如何选择核函数），引入拉格朗日的优化方法的原因，最大的特点，损失函数解释，</p><p>SVM与LR最大区别，LR和SVM对于outlier的敏感程度分析，逻辑回归与SVM的区别</p><p>为什么要把原问题转换为对偶问题？因为原问题是凸二次规划问题，转换为对偶问题更加高效。为什么求解对偶问题更加高效？因为只用求解alpha系数，而alpha系数只有支持向量才非0，其他全部为0.alpha系数有多少个？样本点的个数</p><p>加大训练数据量一定能提高SVM准确率吗？</p><p>与感知器的联系和优缺点比较</p><p>如何解决多分类问题、可以做回归吗，怎么做</p><p>它与其他分类器对比的优缺点，它的速度</p><p>机器学习有很多关于核函数的说法，核函数的定义和作用是什么？<a href="https://www.zhihu.com/question/24627666" target="_blank" rel="noopener">https://www.zhihu.com/question/24627666</a></p><p>支持向量机(SVM)是否适合大规模数据？<a href="https://www.zhihu.com/question/19591450" target="_blank" rel="noopener">https://www.zhihu.com/question/19591450</a></p><p>SVM和逻辑斯特回归对同一样本A进行训练，如果某类中增加一些数据点，那么原来的决策边界分别会怎么变化？<a href="https://www.zhihu.com/question/30123068" target="_blank" rel="noopener">https://www.zhihu.com/question/30123068</a></p><p>各种机器学习的应用场景分别是什么？例如，k近邻,贝叶斯，决策树，svm，逻辑斯蒂回归和最大熵模型。<a href="https://www.zhihu.com/question/26726794" target="_blank" rel="noopener">https://www.zhihu.com/question/26726794</a></p><p>Linear SVM 和 LR 有什么异同？<a href="https://www.zhihu.com/question/26768865" target="_blank" rel="noopener">https://www.zhihu.com/question/26768865</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VM转化为对偶问题后，分类只需要计算与少数几个支持向量的距离，这个在进行复杂核函数计算时优势很明显，能够大大简化模型和计算量。</span><br></pre></td></tr></table></figure><h3 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h3><blockquote><p>LR推导（伯努利过程，极大似然，损失函数，梯度下降）有没有最优解？</p><p>LR可以用核么？可以怎么用？l1和l2正则项是啥？lr加l1还是l2好？加哪个可以用核（加l2正则项，和svm类似，加l2正则项可以用核方便处理）</p><p>LR可以用来处理非线性问题么？（还是lr啊 只不过是加了核的lr 这里加核是显式地把特征映射到高维 然后再做lr）怎么做？可以像SVM那样么？为什么？</p><p>为什么LR需要归一化或者取对数，为什么LR把特征离散化后效果更好，为什么把特征组合之后还能提升，反正这些基本都是增强了特征的表达能力，或者说更容易线性可分吧</p><p>美团技术团队《Logistic Regression 模型简介》<a href="https://tech.meituan.com/intro_to_logistic_regression.html" target="_blank" rel="noopener">https://tech.meituan.com/intro_to_logistic_regression.html</a></p><p>SVM和logistic回归分别在什么情况下使用？<a href="https://www.zhihu.com/question/21704547" target="_blank" rel="noopener">https://www.zhihu.com/question/21704547</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">两种方法都是常见的分类算法，</span><br><span class="line">svm-统计的方法      LR-几何的方法   </span><br><span class="line"></span><br><span class="line">区别在于</span><br><span class="line">1、</span><br><span class="line">（损失函数的目的都是增加对分类影响较大的数据点的权重）</span><br><span class="line">逻辑回归采用的是logistical loss</span><br><span class="line">svm采用的是hinge loss</span><br><span class="line"></span><br><span class="line">2、LR~不带核函数的svm</span><br><span class="line">特征少，样本数量适中--用svm算法</span><br><span class="line">特征多，样本数量少  --用LR或者不带核函数的svm   </span><br><span class="line">特征少，样本数量很多--先增加更多的feature，再使用LR算法或者不带核函数的SVM    </span><br><span class="line"></span><br><span class="line">3、</span><br><span class="line">svm对异常点敏感</span><br><span class="line">LR对异常点不敏感</span><br></pre></td></tr></table></figure><blockquote><p>逻辑斯蒂回归能否解决非线性分类问题？<a href="https://www.zhihu.com/question/29385169" target="_blank" rel="noopener">https://www.zhihu.com/question/29385169</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对特征做非线性变换 比如kernel，最后一层看成是lr 前面看成是提特征。lr的应用场景主要是特征很多的情况</span><br><span class="line">LR用kernel容易过拟合，svm不容易过拟合</span><br></pre></td></tr></table></figure><blockquote><p>为什么LR可以用来做CTR预估？<a href="https://www.zhihu.com/question/23652394" target="_blank" rel="noopener">https://www.zhihu.com/question/23652394</a></p><p>逻辑回归估计参数时的目标函数 （就是极大似然估计那部分），逻辑回归估计参数时的目标函数 （呵呵，第二次） 逻辑回归估计参数时的目标函数 如果加上一个先验的服从高斯分布的假设，会是什么样（天啦。我不知道，其实就是在后面乘一个东西，取log后就变成加一个东西，实际就变成一个正则项）</p><p>逻辑回归估计参数时的目标函数逻辑回归的值表示概率吗？（值越大可能性越高，但不能说是概率）</p><p>手推逻辑回归目标函数，正类是1，反类是-1，这里挖了个小坑，一般都是正例是1，反例是0的，他写的时候我就注意到这个坑了，然而写的太快又给忘了，衰，后来他提醒了一下，改了过来，就是极大似然函数的指数不一样，然后说我这里的面试就到这了。</p><p>看没看过scikit-learn源码LR的实现？（回头看了一下是调用的liblinear，囧）</p></blockquote><p>为什么LR需要归一化或者取对数，为什么LR把特征离散化后效果更好，为什么把特征组合之后还能提升，反正这些基本都是增强了特征的表达能力，或者说更容易线性可分吧<br>naive bayes和logistic regression的区别<a href="http://m.blog.csdn.net/blog/muye5/19409615" target="_blank" rel="noopener">http://m.blog.csdn.net/blog/muye5/19409615</a></p><blockquote><p>LR为什么用sigmoid函数。这个函数有什么优点和缺点？为什么不用其他函数？sigmoid函数由那个指数族分布，加上二项分布导出来的。损失函数是由最大似然估计求出的。<br>了解其他的分类模型吗，问LR缺点，LR怎么推导（当时我真没准备好，写不出来）写LR目标函数，目标函数怎么求最优解（也不会）讲讲LR的梯度下降，梯度下降有哪几种，逻辑函数是啥</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="L1和L2"><a href="#L1和L2" class="headerlink" title="L1和L2"></a>L1和L2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">L2正则化，为什么L2正则化可以防止过拟合？L1正则化是啥？</span><br><span class="line">深度学习里面怎么防止过拟合？（data aug；dropout；multi-task learning）如何防止过拟合，我跟他列举了4中主要防止过拟合方法：Early Stopping、数据集扩充、正则化法以及dropout，还详细跟他说了每种方法原理及使用的场景，并解释我在哪些项目里具体用到了这些方法，</span><br><span class="line">机器学习中使用「正则化来防止过拟合」到底是一个什么原理？为什么正则化项就可以防止过拟合？https://www.zhihu.com/question/20700829</span><br><span class="line">机器学习中常常提到的正则化到底是什么意思？https://www.zhihu.com/question/20924039</span><br><span class="line">什么是正则项，L1范式，L2范式区别是什么，各自用在什么地方？L1 与 L2 的区别以及如何解决 L1 求导困难；</span><br><span class="line">L1正则为什么能让系数变为0？L1正则怎么处理0点不可导的情形？（这个谁会？近端梯度下降）</span><br><span class="line">L0，L1，L2正则化(如果能推导绝对是加分项，一般人最多能画个等高线，L0是NP问题)其实上面的这些问题基本都能在《李航：统计学习方法》《周志华：机器学习》里面找到，能翻个4，5遍基本就无压力了</span><br><span class="line">避免过拟合策略、如何提高模型泛化能力、L1与L2正则区别，优缺点、生成式，判别式模型、深度学习这块了解多少、</span><br><span class="line">如何克服过拟合，欠拟合</span><br><span class="line">L1 与 L2 的区别以及如何解决 L1 求导困难；</span><br><span class="line">L1正则为什么可以把系数压缩成0，坐标下降法的具体实现细节</span><br><span class="line">为什么L1正则可以实现参数稀疏，而L2正则不可以？为什么L1很多系数可以被压缩为0，L2是被压缩至接近于0？</span><br><span class="line">树模型</span><br></pre></td></tr></table></figure><h3 id="决策树："><a href="#决策树：" class="headerlink" title="决策树："></a>决策树：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">rf ， gbdt 的区别； gbdt ， xgboost 的区别（烂大街的问题最好从底层原理去分析回答）</span><br><span class="line">介绍决策树，谈了3种决策树及其区别和适应场景</span><br><span class="line">决策树处理连续值的方法；简单介绍决策树几种算法，有什么区别？</span><br><span class="line">决策树基本模型介绍？决策树算法中缺失值怎么处理？决策树算法在应用中有什么值得注意的地方。SVM、LR、决策树的对比？GBDT 和 决策森林 的区别？决策树的特性？（3 ）决策树处理连续值的方法；</span><br><span class="line">解释下随机森林和gbdt的区别。gbdt的boosting体现在哪里。解释下随机森林节点的分裂策略，以及它和gbdt做分类有什么区别？哪个效果更好些？为什么？哪个更容易过拟合？为什么？ 问了随机森林的损失函数，和lr的优缺点对比， adaboost和随机森林的比较，为了防止随机森林过拟合可以怎么做，是否用过随机森林，怎么用的。</span><br><span class="line">随机森林和GBDT的区别？CART（回归树用平方误差最小化准则，分类树用基尼指数最小化准则）</span><br><span class="line">GBDT（利用损失函数的负梯度在当前模型的值作为回归问题提升树算法中的残差的近似值，拟合一个回归树）</span><br><span class="line">随机森林（Bagging+CART）</span><br><span class="line">SVM与随机森林比较</span><br><span class="line">改变随机森林的训练样本数据量，是否会影响到随机森林学习到的模型的复杂度</span><br><span class="line">Logistics与随机森林比较</span><br><span class="line">GBDT与随机森林比较随机森林的学习过程；随机森林中的每一棵树是如何学习的；随机森林学习算法中CART树的基尼指数是什么？</span><br><span class="line">RF 与 GBDT 区别，原理优缺点适用场景分析，哪个具备交叉验证功能等</span><br><span class="line">接着写一下信息增益的公式。之后就是问机器学习相关算法，说了一下bagging跟boosting，之后问了GBDT（没做过，只能说说大体思路）。（2 ） rf ， gbdt 的区别； gbdt ， xgboost 的区别；</span><br><span class="line">说说xgboost、gbdt区别、Tree-based Model如何处理连续型特征。</span><br><span class="line">让我把一个完整的数据挖掘流程讲一下，从预处理，特征工程，到模型融合。介绍常用的算法，gbdt和xgboost区别，具体怎么做预处理，特征工程，模型融合常用方式，融合一定会提升吗？</span><br><span class="line">gbdt树根据什么分裂（瞎扯的梯度近似残差、梯度下降方向，其实还是信息增益这种东西）</span><br><span class="line">gbdt怎么并发（特征选择层面，树层面不能并发）</span><br><span class="line">介绍LR、RF、GBDT ，分析它们的优缺点，是否写过它们的分布式代码</span><br><span class="line">XGB和GBDT区别与联系也会经常问到：https://www.zhihu.com/question/41354392/answer/128008021?group_id=773629156532445184</span><br><span class="line">CART（回归树用平方误差最小化准则，分类树用基尼指数最小化准则）、Logistics（推导）、GBDT（利用损失函数的负梯度在当前模型的值作为回归问题提升树算法中的残差的近似值，拟合一个回归树）</span><br><span class="line">在面试过程中主动引导面试官提问，比如面试官让你讲解 gbdt 原理时，这会你可以跟他说，一般说起 gbdt ，我们都会跟 rf 以及 xgboost 一块讲，然后你就可以主动地向面试官输出你的知识；面试并不是死板地你问我答，而是一种沟通交流，所以尽可能地把面试转化成聊天式的对话，多输出自己一些有价值的观点而不是仅仅为了回答面试官的问题；</span><br><span class="line">几种树模型的原理和对比，</span><br><span class="line">特征选取怎么选？ 为什么信息增益可以用来选特征？</span><br><span class="line">信息熵和基尼指数的关系(信息熵在x=1处一阶泰勒展开就是基尼指数)</span><br><span class="line">介绍xgboost一下。写下xgboost目标函数。（因为我提到xgboost在目标函数里显式地加入了正则项..血雪崩）怎么调整XGB参数；xgboost原理</span><br></pre></td></tr></table></figure><h3 id="K-means"><a href="#K-means" class="headerlink" title="K-means"></a>K-means</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">k-means 聚类的原理以及缺点及对应的改进；kmeans 算法的优缺点。。。。</span><br><span class="line">kmeans 的原理，优缺点以及改进；</span><br><span class="line">em 与 kmeans 的关系；</span><br><span class="line">kmeans 代码；</span><br><span class="line">说说 Kmeans 算法， Kmeans 算法 K 怎么设置、适用什么样数据集、怎么评价 Kmeans 聚类结果、 Kmeans 有什么优缺点？你的项目中使用 Kmeans 遇到哪些问题，怎么解决的 ?</span><br><span class="line">用 EM 算法推导解释 Kmeans。</span><br><span class="line">KMeans的算法伪代码</span><br><span class="line">如何判断自己实现的 LR、Kmeans 算法是否正确？</span><br><span class="line">如何优化kmeans算法</span><br><span class="line">如何用hadoop实现k-means</span><br><span class="line">手写k-means的伪代码（就6行）</span><br></pre></td></tr></table></figure><h3 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bagging和boosting是怎么做的和他们的比较</span><br><span class="line">详细讨论了样本采样和bagging的问题</span><br><span class="line">聊的比较多的是如何知道一个特征的重要性，如何做ensemble哪些方法比较好。聊了聊计算广告方面FM，embedding。</span><br><span class="line">常见融合框架原理，优缺点，bagging，stacking，boosting，为什么融合能提升效果</span><br><span class="line">是否了解线性加权、bagging、boosting、cascade等模型融合方式</span><br><span class="line">K-means起始点http://www.cnki.com.cn/Article/CJFDTotal-DNZS200832067.htm</span><br></pre></td></tr></table></figure><h3 id="贝叶斯"><a href="#贝叶斯" class="headerlink" title="贝叶斯"></a>贝叶斯</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">朴素贝叶斯分类器原理以及公式，出现估计概率值为 0 怎么处理（拉普拉斯平滑），缺点；</span><br><span class="line">解释贝叶斯公式和朴素贝叶斯分类。</span><br><span class="line">贝叶斯分类，这是一类分类方法，主要代表是朴素贝叶斯，朴素贝叶斯的原理，重点在假设各个属性类条件独立。然后能根据贝叶斯公式具体推导。考察给你一个问题，如何利用朴素贝叶斯分类去分类，比如：给你一个人的特征，判断是男是女，比如身高，体重，头发长度等特征的的数据，那么你要能推到这个过程。给出最后的分类器公式。</span><br><span class="line">那你说说贝叶斯怎么分类啊？比如说看看今天天气怎么样？我：blabla，，，利用天气的历史数据，可以知道天气类型的先验分布，以及每种类型下特征数据（比如天气数据的特征：温度啊，湿度啊）的条件分布，这样我们根据贝叶斯公式就能求得天气类型的后验分布了。。。。面试官：en（估计也比较满意吧）那你了解关于求解模型的优化方法吗？一般用什么优化方法来解？</span><br><span class="line">贝叶斯分类器的优化和特殊情况的处理</span><br></pre></td></tr></table></figure><h3 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">解释一下CNN、介绍CNN、卷积公式，以及特点，假设面试官什么都不懂，详细解释 CNN 的原理；问CNN的细节特点，哪些特点使得CNN这么好用，哪些场景用CNN可以，抽象一下这些场景的特征，可以降采样但仍能保持主要信息；局部连接可以保证获取局部信息；权值共享保证高效，DNN和CNN相比有哪些区别，用过RNN么？画一下RNN的图，你在深度学习过程中遇到过哪些问题？如果出现过拟合你怎么办？dropout是什么？它有什么用？你会怎么用它？当全连接跟dropout连着用需要注意什么？你之前过拟合怎么解决的？如果本身training loss就很大你怎么办？如果数据不变，怎么调整网络结构解决这个问题？（batch normalization）梯度消失知道么？为什么会出现梯度消失？dnn和rnn中的梯度消失原理一样么？dnn中是哪个部分导致梯度消失？（激活层如sigmoid）rnn中怎么解决梯度消失问题？（lstm的结构相对普通RNN多了加和，为避免梯度消散提供了可能。线性自连接的memory是关键。）讲一下CNN吧，有哪些重要的特点？CNN可以处理哪些场景？为什么CNN要用权值共享？（每个卷积核相当于一个特征提取器，它的任务是匹配局部图像中的特征，权值共享后，匹配的特征方式都是一样的，提取若干特征后就知道学习的是啥了）CNN里面哪些层？讲一下卷积。卷积的形式是啥样？给定一个输入，算输出的feature map大小。卷积有啥用？池化有啥用？有哪些池化方式？池化除了降采样还有啥用？（就不知道了）还有哪些层你用过？讲讲dropout。dropout内部是怎么实现只让部分信号通过并不更新其余部分对于输入的权值的？讲讲BN（BatchNormalization）为什么好？全连接有什么用处？知道RNN么？讲讲RNN大致的实现思路。知道梯度消失么？为什么会出现梯度消失？RNN里的梯度消失一般怎么处理？细讲下lstm的结构，这样设计为什么好？（门关闭，当前信息不需要，只有历史依赖；门打开，历史和当前加权平均）你觉得梯度消失靠引入一些新的激活层可以完全解决么？为什么？</span><br><span class="line">问了做的比赛里面使用tensorflow的细节，LSTM里调参的细节</span><br><span class="line">用过哪些库或者工具，mkl，cuda这些会用吗？</span><br><span class="line">有一个弱分类器和大量未被标记过的图像数据，如何人工标记图像来对分类器进行提升</span><br><span class="line">介绍下RNN和它的优缺点</span><br><span class="line">让我推导BP反向传播、随机梯度下降法权重更新公式</span><br><span class="line">卷积神经网络结构特点、各参数对模型结果影响、项目进展遇到的难题、推导BP神经网络参数更新方式、随机梯度下降法（SGD）优化函数存在的缺点以及拟牛顿法在优化函数使用上更有优势、修改Caffe开源框架、开源社区代码贡献量就跟我聊了很多行业发展趋势及问题，知道目前深度学习的一个趋势，也了解到最新行业发展动态，改进相机智能化程度，也聊到了美颜相机美颜效果以及小米相机人脸分类、年龄检测等等不足之处，了解到新兴行业大佬商汤科技和旷视科技（face++脸草）在研究的热门方向</span><br><span class="line">看到有deep learning相关的项目，就问了deep learning 相关问题：如何减少参数（权值共享、VGG的感受野、GoogLeNet的inception ），激活函数的选择（sigmoid-&gt;ReLu-&gt;LReLU-&gt;PReLU ），为什么之前没有深度网络出现（数据量不够+机器性能），由数据引申到数据不平衡怎么处理（10W正例，1W负例，牛客上有原题），</span><br><span class="line">后面问了下DNN原理，应用，瞎扯一通……</span><br><span class="line">你了解神经网络吗？我：了解一些，讲感知机，然后是BP网络。简单讲了一下原理。</span><br><span class="line">图像处理题：如何找相似图片。我说用感知哈希算法，计算汉明距离，他说这种方法精度不行；我说那就用SIFT算法吧，他说SIFT效果还可以，但计算有点繁重，有没有轻量级的方法？我想起来去年在美图秀秀实习时，曾经做过一种图像滤波算法，有一步是把像素点用K-means聚类。我就说先把图片灰度化，然后用K-means聚类，把聚类后的各个中心点作为一张图片的特征向量如果两张图片的特征向量相近则说明这两张图片相似。貌似我这个答案有点出乎他的意料，他意味深长地说了个“行吧~~~~”（个人觉得颜色直方图匹配是个他期待的常规回答）</span><br><span class="line">介绍卷积神经网络，和 DBN 有什么区别？</span><br><span class="line">Deep CNN, Deep RNN, RBM的典型应用与局限，看Hinton讲义和Paper去吧</span><br><span class="line">神经网络,plsi的推导</span><br><span class="line">验证码图片的去噪和提取字符</span><br><span class="line">有限状态自动机,然后要我画状态转移图.</span><br></pre></td></tr></table></figure><h3 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用过哪些聚类算法，解释密度聚类算法。</span><br><span class="line">聚类算法中的距离度量有哪些？</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">梯度下降的优缺点；主要问最优化方面的知识，梯度下降法的原理以及各个变种（批量梯度下降，随机梯度下降法， mini 梯度下降法），以及这几个方法会不会有局部最优问题，牛顿法原理和适用场景，有什么缺点，如何改进（拟牛顿法）</span><br><span class="line">常用优化算法：1.梯度下降法：又有随机梯度下降和负梯度下降，2.牛顿法 主要是问了各自的优缺点，速度，能不能得到全局最优解，牛顿法的二次收敛等</span><br><span class="line">问你如果有若干个极小值点，如何避免陷入局部最优解。</span><br><span class="line">它们间的牛顿学习法、SGD如何训练，</span><br><span class="line">如何判断函数凸或非凸？</span><br><span class="line">线性回归的梯度下降和牛顿法求解公式的推导</span><br><span class="line">最速下降法和共轭梯度法 wolfe条件 最速下降法和共轭梯度法的收敛速度如何判断</span><br><span class="line">深刻理解常用的优化方法：梯度下降、牛顿法、各种随机搜索算法（基因、蚁群等等），深刻理解的意思是你要知道梯度下降是用平面来逼近局部，牛顿法是用曲面逼近局部等等。</span><br></pre></td></tr></table></figure><h3 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">介绍SVD、SVD++</span><br><span class="line">推荐系统的冷启动问题如何解决</span><br><span class="line">深度学习在推荐系统上可能有怎样的发挥？</span><br><span class="line">推荐系统的算法中最近邻和矩阵分解各自适用场景</span><br><span class="line">白板写SVD/SVD++公式，SGD迭代更新p，q矩阵公式，SVD/SVD++优化方法</span><br><span class="line">对推荐算法的未来看法；</span><br><span class="line">用过什么算法？最好是在项目/实习的大数据场景里用过，比如推荐里用过 CF、LR，</span><br><span class="line">我面的推荐，问了各类协同过滤的好与坏。</span><br><span class="line">问了一个很有意思的问题，现实应用中的Top-N推荐问题和学术研究中的评分预测问题之间有什么不同。问我ItemCF的工程实现，面对大数据如何实现，又追问了有没有什么工程优化算法。这个问题我没答好，一开始我说了一个MapReduce模型，他问能不能更快一点，我就卡那了。。。最后面试官告诉我，不能只从算法角度分析，要从系统设计分析，利用内存来减小MapReduce的吞吐量。（当然也许从MapReduce那一刻开始我就输了也不一定）</span><br><span class="line">推荐系统的算法中最近邻和矩阵分解各自适用场景http://www.doc88.com/p-3961053026557.html</span><br></pre></td></tr></table></figure><h3 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">那你对pca了解吗？我：了解啊，面试官：那讲一下pca是用来干嘛的？我：pca啊，可以用来分析主方向啊，降维啊，特征筛选啊，具体方法是用svd分解得到特征值矩阵和特征向量矩阵，然后根据不同的任务对选择特征值或向量进行计算。</span><br></pre></td></tr></table></figure><p>EM<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">采用 EM 算法求解的模型有哪些，为什么不用牛顿法或梯度下降法？</span><br></pre></td></tr></table></figure></p><h3 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用过哪些 NLP 算法项目中用过哪些机器学习算法。</span><br><span class="line">海量的 item 算文本相似度的优化方法；</span><br><span class="line">解释 word2vec 的原理以及哈夫曼树的改进；word2vec的原理</span><br><span class="line">二面面试官主要跟我聊简历上的几个项目，他好像不能理解词向量的形式，反复解释了很多遍，问的问题都比较简单，有TF-IDF,余弦相似度，分词工具等等。</span><br><span class="line">然后我说我做过LDA，问我，Dirichlet Distribution的定义和性质，并问我，为什么它和multinomial distribution是共轭的，顺便问了我啥叫共轭分布。</span><br></pre></td></tr></table></figure><h3 id="关联分析："><a href="#关联分析：" class="headerlink" title="关联分析："></a>关联分析：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目中涉及到频繁模式挖掘，于是问了一下如何实现的？ 用的是 Apriori算法，描述他的原理过程，关键字眼：支持度，支持度计数，k项候选频繁项集，怎么从k项到k+1项等，连接剪枝过程。</span><br></pre></td></tr></table></figure><h3 id="hadoop"><a href="#hadoop" class="headerlink" title="hadoop"></a>hadoop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">简单介绍 MapReduce 原理，有没有看过源码，说说 Map 阶段怎么实现的,</span><br><span class="line">MapReduce 实现统计出现次数最多的前 100 个访问 IP.</span><br><span class="line">MapReduce 实现统计不重复用户 ID,MapReduce 实现两个数据集求交集。</span><br><span class="line">HBase 行健怎么设计,spark 性能一般优化方法,spark streaming 和 storm 区别.给了一张笔试题， 10 道选择，一道大题。选择题是 java 基础知识，大题一个有三问：根据场景写出 Hive 建表语句； Hsql 从表中查询；</span><br><span class="line">用MapReduce写好友推荐，在一堆单词里面找出现次数最多的k个</span><br><span class="line">用分布式的方法做采样怎么保证采样结果完全符合预期？</span><br><span class="line">后面又问了Hadoop,Spark,storm下面的产品，原理，适用场景，</span><br><span class="line">写一个 Hadoop 版本的 wordcount。</span><br></pre></td></tr></table></figure><h3 id="HMM"><a href="#HMM" class="headerlink" title="HMM"></a>HMM</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">实现 hmm 的状态转移代码；</span><br><span class="line">机器学习理论</span><br><span class="line">讲机器学习中常用的损失函数有哪些？交叉熵有什么好处？（凸优化问题）</span><br><span class="line">判别模型与生成模型的本质区别是什么</span><br><span class="line">分类模型和回归模型的区别，分类模型可以做回归分析吗？反过来可以吗？（我回答是分类不可以做回归，回归倒是可以做分类，不知道对不对）</span><br><span class="line">k折交叉验证 中k取值多少有什么关系 （我不知道，随便答，然后面试官后面问我知道bias和variance吗？估计是和这两个东西有关， 知乎上有个问题讨论了k值大小与bias和variance的关系）</span><br><span class="line">解释局部相关性</span><br><span class="line">特征选择的方法；</span><br><span class="line">在模型的训练迭代中，怎么评估效果；</span><br><span class="line">特征选择方法有哪些(能说出来10种以上加分)，之后和面试官仔细聊了一下特征选择的问题，我介绍了了解的几种基本的特征选择思路（错误率选择、基于熵的选择、类内类间距离的选择）；</span><br><span class="line">有没有接触过机器学习的前沿，深度学习看过paper没有？（并没有）</span><br><span class="line">如何用尽可能少的样本训练模型同时又保证模型的性能；</span><br><span class="line">你读哪些期刊会议的论文？你遇到的比较有意思的算法？</span><br><span class="line">生成模型，判别模型</span><br><span class="line">线性分类和非线性分类各有哪些模型</span><br><span class="line">比较各个模型的Loss function，</span><br><span class="line">设计一个结构存取稀疏矩阵 （面试官最后告诉我了一个极度压缩的存法，相同行或列存偏差，我当时没听懂，还不懂装懂，最后还是没记住）</span><br><span class="line">PageRank原理，怎么用模型来查找异常用户，我讲了一大堆我的理解，然后面试官一句你怎么不用规则把我噎到了……</span><br><span class="line">无监督和有监督算法的区别？</span><br><span class="line">经典算法推导(加分项)，原理，各个损失函数之间区别，使用场景，如何并行化，有哪些关键参数</span><br><span class="line">什么叫判别模型什么叫生成模型。</span><br><span class="line">先针对项目十分细致地询问了各种细节，然后就问我如何处理数据中的噪声点、数据清洗算法（正好自己做了一个算法）、如何选择特征等。</span><br><span class="line">校招TST内推，面过了2面，还是跟之前那个有点类似的游戏开发的安全部门，因为我也玩LOL，又问到怎么来判断玩家有没有作弊之类的问题，这次我小心翼翼的说用模型怎么做，用规则怎么做，感觉这次聊的都挺开心的。</span><br><span class="line">是否了解A/B Test以及A/B Test结果的置信度特征工程经验是否了解mutual infomation、chi-square、LR前后向、树模型等特征选择方式</span><br><span class="line">深刻理解各种算法对应采用的数据结构和对应的搜索方法。比如KNN对应的KD树、如何给图结构设计数据结构？如何将算法map-red化</span><br><span class="line">矩阵的各种变换，尤其是特征值相关的知识。分布式的矩阵向量乘的算法</span><br><span class="line">线性分类器与非线性分类器的区别及优劣；特征比数据量还大时，选择什么样的分类器？对于维度很高的特征，你是选择线性还是非线性分类器？对于维度极低的特征，你是选择线性还是非线性分类器？如何解决过拟合问题？L1和L2正则的区别，如何选择L1和L2正则？</span><br><span class="line">项目中的数据是否会归一化处理，哪个机器学习算法不需要归一化处理</span><br><span class="line">并行计算、压缩算法LDA http://www.doc88.com/p-1621945750499.html</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 笔面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab背景颜色修改</title>
      <link href="/2018/09/01/matlab_%E8%83%8C%E6%99%AF/"/>
      <url>/2018/09/01/matlab_%E8%83%8C%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>Matlab背景颜色修改</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>将<code>修改内容</code>添加到matlab的matlab.prf文件中，文件路径为在matlab中运行prefdir的结果,直接添加这些内容保存就好。 </p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>1， 在<code>matlab</code>命令行中运行<code>prefdir</code>， 获取<code>matlab.prf</code>文件所在路径</p><p>2， 打开<code>matlab.prf</code>所在路径， 找到<code>matlab.prf</code>文件， 作备份</p><p>3， 在新的<code>matlab.prf</code>中修改与<code>color</code>有关的属性</p><p>4，重启<code>matlab</code>，修改主题就完成了</p><h2 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h2><h3 id="黑色主题"><a href="#黑色主题" class="headerlink" title="黑色主题"></a>黑色主题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Editor.VariableHighlighting.Color=C-6931898</span><br><span class="line">ColorsText=C-460558</span><br><span class="line">Colors_M_SystemCommands=C-448910</span><br><span class="line">Editorhighlight-lines=C-11974594</span><br><span class="line">Colors_M_Warnings=C-27648</span><br><span class="line">Colors_M_Strings=C-1647756</span><br><span class="line">Editor.NonlocalVariableHighlighting.TextColor=C-5471745</span><br><span class="line">Colors_HTML_HTMLLinks=C-16732805</span><br><span class="line">Colors_M_Comments=C-8355712</span><br><span class="line">Colors_M_Errors=C-65536</span><br><span class="line">Colors_M_UnterminatedStrings=C-5111808</span><br><span class="line">ColorsBackground=C-14211038</span><br><span class="line">Colors_M_Keywords=C-10036753</span><br><span class="line">Color_CmdWinWarnings=C-39936</span><br><span class="line">ColorsMLintAutoFixBackground=C-7973573</span><br><span class="line">Colors_M_Keywords=C-10036753</span><br><span class="line">Editorhighlight-lines=C-13553108</span><br><span class="line">Editorhighlight-caret-row-boolean-color=C-2167080</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ColorsUseSystem=Bfalse</span><br></pre></td></tr></table></figure><h3 id="暖色主题"><a href="#暖色主题" class="headerlink" title="暖色主题"></a>暖色主题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Color_CmdWinErrors=C-1703936</span><br><span class="line">Color_CmdWinWarnings=C-39936</span><br><span class="line">ColorsBackground=C-198941</span><br><span class="line">ColorsMLintAutoFixBackground=C-1121868</span><br><span class="line">ColorsText=C-16304574</span><br><span class="line">ColorsUseMLintAutoFixBackground=Btrue</span><br><span class="line">ColorsUseSystem=Bfalse</span><br><span class="line">Colors_HTML_HTMLLinks=C-2935166</span><br><span class="line">Colors_M_Comments=C-7167583</span><br><span class="line">Colors_M_Errors=C-65536</span><br><span class="line">Colors_M_Keywords=C-8021760</span><br><span class="line">Colors_M_Strings=C-13983336</span><br><span class="line">Colors_M_SystemCommands=C-3454186</span><br><span class="line">Colors_M_UnterminatedStrings=C-5111808</span><br><span class="line">Colors_M_Warnings=C-27648</span><br><span class="line">Editor.NonlocalVariableHighlighting.TextColor=C-32640</span><br><span class="line">Editor.VariableHighlighting.Color=C-7167583</span><br><span class="line">EditorRightTextLimitLineColor=C-3355444</span><br></pre></td></tr></table></figure><h3 id="darkmate"><a href="#darkmate" class="headerlink" title="darkmate"></a>darkmate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ColorsUseSystem=Bfalse</span><br><span class="line">ColorsUseMLintAutoFixBackground=Btrue</span><br><span class="line">Editor.VariableHighlighting.Automatic=Btrue</span><br><span class="line">Editor.NonlocalVariableHighlighting=Btrue</span><br><span class="line">EditorCodepadHighVisible=Btrue</span><br><span class="line">EditorCodeBlockDividers=Btrue</span><br><span class="line">Editorhighlight-caret-row-boolean=Btrue</span><br><span class="line">EditorRightTextLineVisible=Btrue</span><br><span class="line">EditorRightTextLimitLineWidth=I4                             # slightly wider</span><br><span class="line">ColorsText=C-1118482                                         # white</span><br><span class="line">ColorsBackground=C-14474461                                  # carbon</span><br><span class="line">Colors_M_Keywords=C-26368                                    # ambra</span><br><span class="line">Colors_M_Comments=C-10920873                                 # asfalto</span><br><span class="line">Colors_M_Strings=C-6881536                                   # lime</span><br><span class="line">Colors_M_UnterminatedStrings=C-202417                        # yellow</span><br><span class="line">Colors_M_SystemCommands=C-16725605                           # alga</span><br><span class="line">Colors_M_Errors=C-53398                                      # red</span><br><span class="line">Colors_HTML_HTMLLinks=C-6385153                              # violet</span><br><span class="line">Colors_M_Warnings=C-26368                                    # ambra</span><br><span class="line">ColorsMLintAutoFixBackground=C-11184811                      # </span><br><span class="line">Editor.VariableHighlighting.Color=C-4495617                  # purple</span><br><span class="line">Editor.NonlocalVariableHighlighting.TextColor=C-16725760     # green</span><br><span class="line">Editorhighlight-lines=C-15132391                             # </span><br><span class="line">Editorhighlight-caret-row-boolean-color=C-16777216           # black</span><br><span class="line">EditorRightTextLimitLineColor=C-13948117                     # </span><br><span class="line"># XML/HTML</span><br><span class="line">Editor.Language.XML.Color.pi-content=C-6425200</span><br></pre></td></tr></table></figure><h3 id="darksteel"><a href="#darksteel" class="headerlink" title="darksteel"></a>darksteel</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">ColorsUseSystem=Bfalse</span><br><span class="line">ColorsUseMLintAutoFixBackground=Btrue</span><br><span class="line">Editor.VariableHighlighting.Automatic=Btrue</span><br><span class="line">Editor.NonlocalVariableHighlighting=Btrue</span><br><span class="line">EditorCodepadHighVisible=Btrue</span><br><span class="line">EditorCodeBlockDividers=Btrue</span><br><span class="line">Editorhighlight-caret-row-boolean=Btrue</span><br><span class="line">EditorRightTextLineVisible=Btrue</span><br><span class="line">EditorRightTextLimitLineWidth=I1</span><br><span class="line">ColorsText=C-1</span><br><span class="line">ColorsBackground=C-15066598</span><br><span class="line">Colors_M_Keywords=C-1208813</span><br><span class="line">Colors_M_Comments=C-14114579</span><br><span class="line">Colors_M_Strings=C-16724992</span><br><span class="line">Colors_M_UnterminatedStrings=C-4210944</span><br><span class="line">Colors_M_SystemCommands=C-7123493</span><br><span class="line">Colors_M_Errors=C-45747</span><br><span class="line">Colors_HTML_HTMLLinks=C-10592257</span><br><span class="line">Colors_M_Warnings=C-27648</span><br><span class="line">ColorsMLintAutoFixBackground=C-9223357</span><br><span class="line">Editor.VariableHighlighting.Color=C-11184786</span><br><span class="line">Editor.NonlocalVariableHighlighting.TextColor=C-16735351</span><br><span class="line">Editorhighlight-lines=C-14408662</span><br><span class="line">Editorhighlight-caret-row-boolean-color=C-12632257</span><br><span class="line">EditorRightTextLimitLineColor=C-5723992</span><br><span class="line"># TLC</span><br><span class="line">Editor.Language.TLC.Color.Colors_M_Keywords=C-16735351</span><br><span class="line"># C/C++</span><br><span class="line">Editor.Language.C.Color.preprocessor=C-16735351</span><br><span class="line"># VHDL</span><br><span class="line">Editor.Language.VHDL.Color.operator=C-16735351</span><br><span class="line"># Verilog</span><br><span class="line">Editor.Language.Verilog.Color.operator=C-16735351</span><br><span class="line"># XML</span><br><span class="line">Editor.Language.XML.Color.operator=C-1710454</span><br><span class="line">Editor.Language.XML.Color.doctype=C-6578958</span><br><span class="line">Editor.Language.XML.Color.pi-content=C-9868801</span><br></pre></td></tr></table></figure><h3 id="monokai"><a href="#monokai" class="headerlink" title="monokai"></a>monokai</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ColorsUseSystem=Bfalse</span><br><span class="line">ColorsUseMLintAutoFixBackground=Btrue</span><br><span class="line">Editor.VariableHighlighting.Automatic=Btrue</span><br><span class="line">Editor.NonlocalVariableHighlighting=Btrue</span><br><span class="line">EditorCodepadHighVisible=Btrue</span><br><span class="line">EditorCodeBlockDividers=Btrue</span><br><span class="line">Editorhighlight-caret-row-boolean=Bfalse</span><br><span class="line">EditorRightTextLineVisible=Btrue</span><br><span class="line">EditorRightTextLimitLineWidth=I1</span><br><span class="line">ColorsText=C-460560</span><br><span class="line">ColorsBackground=C-14211038</span><br><span class="line">Colors_M_Keywords=C-448910</span><br><span class="line">Colors_M_Comments=C-9080482</span><br><span class="line">Colors_M_Strings=C-1647756</span><br><span class="line">Colors_M_UnterminatedStrings=C-65536</span><br><span class="line">Colors_M_SystemCommands=C-16711936</span><br><span class="line">Colors_M_Errors=C-65536</span><br><span class="line">Colors_HTML_HTMLLinks=C-16711681</span><br><span class="line">Colors_M_Warnings=C-27648</span><br><span class="line">ColorsMLintAutoFixBackground=C-11974594</span><br><span class="line">Editor.VariableHighlighting.Color=C-10066330</span><br><span class="line">Editor.NonlocalVariableHighlighting.TextColor=C-16729641</span><br><span class="line">Editorhighlight-lines=C-13421773</span><br><span class="line">Editorhighlight-caret-row-boolean-color=C-10066330</span><br><span class="line">EditorRightTextLimitLineColor=C-3355444</span><br><span class="line">Color_CmdWinWarnings=C-26368</span><br></pre></td></tr></table></figure><p>参考github效果：<br><a href="https://github.com/scottclowe/matlab-schemer/tree/master/schemes" target="_blank" rel="noopener">https://github.com/scottclowe/matlab-schemer/tree/master/schemes</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql基础</title>
      <link href="/2018/08/31/Mysql%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/08/31/Mysql%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>Mysql基础</p><a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础</title>
      <link href="/2018/08/31/Linux%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/08/31/Linux%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>Linux基础</p><a id="more"></a><h2 id="VIM-三个模式"><a href="#VIM-三个模式" class="headerlink" title="VIM 三个模式"></a>VIM 三个模式</h2><ul><li>一般指令模式（Command mode）：VIM 的默认模式，可以用于移动游标查看内容；</li><li>编辑模式（Insert mode）：按下 “i” 等按键之后进入，可以对文本进行编辑；</li><li>指令列模式（Bottom-line mode）：按下 “:” 按键之后进入，用于保存退出等操作。</li></ul><p>在指令列模式下，有以下命令用于离开或者保存文件。</p><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">:w</td><td style="text-align:center">写入磁盘</td></tr><tr><td style="text-align:center">:w!</td><td style="text-align:center">当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关</td></tr><tr><td style="text-align:center">:q</td><td style="text-align:center">离开</td></tr><tr><td style="text-align:center">:q!</td><td style="text-align:center">强制离开不保存</td></tr><tr><td style="text-align:center">:wq</td><td style="text-align:center">写入磁盘后离开</td></tr><tr><td style="text-align:center">:wq!</td><td style="text-align:center">强制写入磁盘后离开</td></tr></tbody></table></div><h2 id="磁盘的文件名"><a href="#磁盘的文件名" class="headerlink" title="磁盘的文件名"></a>磁盘的文件名</h2><p>Linux 中每个硬件都被当做一个文件，包括磁盘</p><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><h3 id="1-MBR"><a href="#1-MBR" class="headerlink" title="1. MBR"></a>1. MBR</h3><p>MBR 中，第一个扇区最重要，里面有主要开机记录（Master boot record, MBR）及分区表（partition table），其中主要开机记录占 446 bytes，分区表占 64 bytes。</p><h3 id="2-GPT"><a href="#2-GPT" class="headerlink" title="2. GPT"></a>2. GPT</h3><p>不同的磁盘有不同的扇区大小，GPT 第 1 个区块记录了主要开机记录（MBR）</p><h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><p>用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。</p><p>使用 ls 查看一个文件时，会显示一个文件的信息，例如 <code>drwxr-xr-x. 3 root root 17 May 6 00:14 .config</code>，对这个信息的解释如下：</p><ul><li>drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段</li><li>3：链接数</li><li>root：文件拥有者</li><li>root：所属群组</li><li>17：文件大小</li><li>May 6 00:14：文件最后被修改的时间</li><li>.config：文件名</li></ul><p>常见的文件类型及其含义有：</p><ul><li>d：目录</li><li>-：文件</li><li>l：链接文件</li></ul><p>9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。</p><p>文件时间有以下三种：</p><ul><li>modification time (mtime)：文件的内容更新就会更新；</li><li>status time (ctime)：文件的状态（权限、属性）更新就会更新；</li><li>access time (atime)：读取文件时就会更新。</li></ul><h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。</p><p>孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。</p><p>由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。</p><h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。</p><p>僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。</p><p>系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p><p>要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 所收养，这样 init 就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理推荐资料</title>
      <link href="/2018/08/31/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E6%8E%A8%E8%8D%90%E8%B5%84%E6%96%99/"/>
      <url>/2018/08/31/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E6%8E%A8%E8%8D%90%E8%B5%84%E6%96%99/</url>
      
        <content type="html"><![CDATA[<p>图像处理推荐资料</p><a id="more"></a><p>图像处理与计算机视觉相关的书籍</p><ol><li>数学<br>   我们所说的图像处理实际上就是数字图像处理，是把真实世界中的连续三维随机信号投影到传感器的二维平面上，采样并量化后得到二维矩阵。数字图像处理就是二维矩阵的处理，而从二维图像中恢复出三维场景就是计算机视觉的主要任务之一。这里面就涉及到了图像处理所涉及到的三个重要属性：连续性，二维矩阵，随机性。所对应的数学知识是高等数学（微积分），线性代数（矩阵论），概率论和随机过程。这三门课也是考研数学的三个组成部分，构成了图像处理和计算机视觉最基础的数学基础。如果想要更进一步，就要到网上搜搜林达华推荐的数学书目了。</li><li>信号处理<br> 图像处理其实就是二维和三维信号处理，而处理的信号又有一定的随机性，因此经典信号处理和随机信号处理都是图像处理和计算机视觉中必备的理论基础。<br>2.1经典信号处理<br>信号与系统(第2版) Alan V.Oppenheim等著 刘树棠译</li></ol><p>离散时间信号处理(第2版) A.V.奥本海姆等著 刘树棠译</p><p>数字信号处理:理论算法与实现 胡广书 (编者)</p><p>2.2随机信号处理<br>现代信号处理 张贤达著</p><p>统计信号处理基础:估计与检测理论 Steven M.Kay等著 罗鹏飞等译</p><p>自适应滤波器原理(第4版) Simon Haykin著 郑宝玉等译</p><p>2.3 小波变换<br>信号处理的小波导引:稀疏方法(原书第3版) tephane Malla著, 戴道清等译</p><p>2.4 信息论<br>信息论基础(原书第2版) Thomas M.Cover等著 阮吉寿等译</p><ol><li>模式识别<br>Pattern Recognition and Machine Learning Bishop, Christopher M. Springer</li></ol><p>模式识别(英文版)(第4版) 西奥多里德斯著</p><p>Pattern Classification (2nd Edition) Richard O. Duda等著</p><p>Statistical Pattern Recognition, 3rd Edition Andrew R. Webb等著</p><p>模式识别(第3版) 张学工著</p><ol><li>图像处理与计算机视觉的书籍推荐<br>图像处理，分析与机器视觉 第三版 Sonka等著 艾海舟等译</li></ol><p>Image Processing, Analysis and Machine Vision</p><pre><code>            ( 附：这本书是图像处理与计算机视觉里面比较全的一本书了，几乎涵盖了图像视觉领域的各个方面。中文版的个人感觉也还可以，值得一看。)</code></pre><p>数字图像处理 第三版 冈萨雷斯等著</p><p>Digital Image Processing</p><p>(附：数字图像处理永远的经典，现在已经出到了第三版，相当给力。我的导师曾经说过，这本书写的很优美，对写英文论文也很有帮助，建议购买英文版的。)</p><p>计算机视觉：理论与算法 Richard Szeliski著</p><p>Computer Vision: Theory and Algorithm</p><pre><code>            (附：微软的Szeliski写的一本最新的计算机视觉著作。内容非常丰富，尤其包括了作者的研究兴趣，比如一般的书里面都没有的Image Stitching和                       Image Matting等。这也从另一个侧面说明这本书的通用性不如Sonka的那本。不过作者开放了这本书的电子版，可以有选择性的阅读。              http://szeliski.org/Book/              Multiple View Geometry in Computer Vision 第二版Harley等著             引用达一万多次的经典书籍了。第二版到处都有电子版的。第一版曾出过中文版的，后来绝版了。网上也可以找到中英文版的电子版。)</code></pre><p>计算机视觉：一种现代方法 DA Forsyth等著</p><p>Computer Vision: A Modern Approach</p><p>MIT的经典教材。虽然已经过去十年了，还是值得一读。期待第二版</p><p>Machine vision: theory, algorithms, practicalities 第三版 Davies著</p><p>(附：为数不多的英国人写的书，偏向于工业应用。)</p><p>数字图像处理 第四版 Pratt著</p><p>Digital Image Processing</p><p>(附：写作风格独树一帜，也是图像处理领域很不错的一本书。网上也可以找到非常清晰的电子版。)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理_图像插值</title>
      <link href="/2018/08/28/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E6%8F%92%E5%80%BC/"/>
      <url>/2018/08/28/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E6%8F%92%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>图像插值<br><a id="more"></a></p><p>比较常用的插值算法有这么几种：最邻近插值，双线性二次插值，三次插值，Lanczos插值等等</p><h3 id="1，最邻近插值"><a href="#1，最邻近插值" class="headerlink" title="1，最邻近插值"></a>1，最邻近插值</h3><pre><code>最邻近插值算法也叫做零阶插值算法，主要原理是让输出像素的像素值等于邻域内</code></pre><p>离它距离最近的像素值。</p><p>这种放大图像的方法叫做最临近插值算法，这是一种最基本、最简单的图像缩放算法，效果也是最不好的，放大后的图像有很严重的马赛克，缩小后的图像有很严重的失真；效果不好的根源就是其简单的最临近插值方法引入了严重的图像失真。</p><h3 id="2，双线性二次插值"><a href="#2，双线性二次插值" class="headerlink" title="2，双线性二次插值"></a>2，双线性二次插值</h3><h3 id="3、三次内插法"><a href="#3、三次内插法" class="headerlink" title="3、三次内插法"></a>3、三次内插法</h3><h3 id="内插值，外插值"><a href="#内插值，外插值" class="headerlink" title="内插值，外插值"></a>内插值，外插值</h3><p>两张图像混合时通过内插与外插值方法可以实现图像亮度、对比度、饱和度、填色、锐化等常见的图像处理操作。在两张图像混合时最常见是线性插值方法，使用的混合权重公式如下：</p><script type="math/tex; mode=display">Out(x,y) = Src2(x,y) *\alpha + Src1(x,y)(1-\alpha)</script><p>$\alpha$的范围是[0,1]之间</p><p>内插值方法：常见的值属于[0,1]之间。</p><p>外插值方法：可以用来生成跟内插值效果相反的图像。</p><p>比如内插值模糊图像，通过外插值可以去模糊，外插值可以调节饱和度，可以实现图像一些列的处理比如亮度、饱和度、对比度、锐化调整。</p><h3 id="插值算法的类型："><a href="#插值算法的类型：" class="headerlink" title="插值算法的类型："></a>插值算法的类型：</h3><p>一般分为两类: 自适应和非自适应。自适应的方法可以根据插值的内容来改变（尖锐的边缘或者是平滑的纹理），非自适应的方法对所有的像素点都进行同样的处理。 </p><p>非自适应算法包括: 最邻近方法, 双线性, 双三次, 样条, sinc, lanczos 和其他。由于其复杂度, 这些插值的时候使用从0 to 256 (or more) 邻近像素。 包含越多的邻近像素，他们越精确，但是花费的时间也越长。这些算法可以用来扭曲和缩放照片。</p><p>Original<br>Enlarged 250%<br>自适应算法包含许多专利，如: Qimage, PhotoZoom Pro, Genuine Fractals和其他。许多应用他们插值的不同版本 (on a pixel-by-pixel basis)当他们检测边缘时 —目标是最小化插值干扰。</p><h4 id="最邻近插值"><a href="#最邻近插值" class="headerlink" title="最邻近插值"></a>最邻近插值</h4><p>最邻近算法在所有插值算法中时间最短，因为它只考虑一个像素点—离待插像素点最近的像素点。</p><h4 id="双线性插值"><a href="#双线性插值" class="headerlink" title="双线性插值"></a>双线性插值</h4><p>双线性插值考虑待插像素最近的 2x2 已知像素点。需要加权四个像素值来求得最终的像素值。这使得插值出来比最邻近插值平滑。</p><p>双三次插值</p><p>基于双线性插值，考虑最近的 4x4已知像素点 —总共16个像素点。由于离待插像素点的距离不同， 在计算中距离近的像素给出的权重较大。双三次产生的图像比前两次的尖锐，有理想的处理时间和输出质量。因此，在很多图像编辑程序中是标准算法 (包括 Adobe Photoshop), 打印机和相机插值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像插值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客 报错 Cannot read property &#39;replace&#39; of null</title>
      <link href="/2018/08/28/hexo_error_replace/"/>
      <url>/2018/08/28/hexo_error_replace/</url>
      
        <content type="html"><![CDATA[<p><img width="800" height="800" src="http://ph04wnm2q.bkt.clouddn.com/bg/magazine-unlock-01-2.3.1003-_888F66AA592CE88202C711A7FB9371B2.jpg"></p><a id="more"></a><h3 id="报错内容-情况"><a href="#报错内容-情况" class="headerlink" title="报错内容-情况"></a>报错内容-情况</h3><p>报错内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FATAL Cannot read property &apos;replace&apos; of null</span><br><span class="line"></span><br><span class="line">TypeError: Cannot read property &apos;replace&apos; of null</span><br></pre></td></tr></table></figure></p><p>如图：<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/hexo_error_replace.png" alt=""></p><p>报错情况，执行 <code>hexo clean</code> 清理本地缓存或者 <code>hexo g</code> 生成本地缓存时报此错误</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>打开 hexo配置文件，配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: https://www.aomanhao.top</span><br><span class="line">root: AomanHao.github.io</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure></p><p>root，url属性配置正确，填写自己对应的</p><p><a href="https://www.jianshu.com/p/449accb044b4" target="_blank" rel="noopener">参考文章</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谷歌浏览器加载静态文件错误，请修改DNS配置</title>
      <link href="/2018/08/24/DNS_error/"/>
      <url>/2018/08/24/DNS_error/</url>
      
        <content type="html"><![CDATA[<p>谷歌浏览器加载静态文件错误，请修改DNS配置<br><a id="more"></a></p><p><img src="https://img-blog.nos-eastchina1.126.net/niuke_error.png" alt=""></p><p>当我登陆CSDN/牛客网的时候，页面不能正常显示，只能显示纯文字，访问百度或者视频网站的时候是可以的<br>报错提示</p><h3>静态文件加载出错，请检查当前网络情况是否正常，或者按照下面步骤修改电脑的DNS等等</h3><br>折腾了一晚上<p></p><hr><h3 id="修改DNS"><a href="#修改DNS" class="headerlink" title="修改DNS"></a>修改DNS</h3><p><img src="https://img-blog.nos-eastchina1.126.net/changedns1.png" alt=""><br><a href="https://jingyan.baidu.com/article/2fb0ba40833b0a00f2ec5f28.html" target="_blank" rel="noopener">百度经验修改DNS</a></p><p>按照要求修改了dns，失败，仍然不能正常加载网页</p><hr><h3 id="修改hosts文件"><a href="#修改hosts文件" class="headerlink" title="修改hosts文件"></a>修改hosts文件</h3><p><a href="http://jingyan.baidu.com/article/425e69e6e479a2be15fc16e1.html?allowHTTP=1" target="_blank" rel="noopener">百度经验修改hosts文件</a></p><p>hosts属于系统文件，需要谨慎操作，需要很高的权限<br><img src="https://img-blog.nos-eastchina1.126.net/hosts_error.png" alt=""></p><p>打开hosts文件，发现最后一行是<code>192.168.137.1 windows10.microdone.cn</code><br>神秘代码有没有，寻找其出处，网友指出他是<code>银联网银插件</code>修改的<br><a href="https://www.v2ex.com/t/273757" target="_blank" rel="noopener">代码解释链接</a></p><p>解决方法：<br>卸载最近安装的 网银插件/控件<br>（我没有就不用卸载了）</p><p>然后按照百度经验修改<code>hosts</code>文件，保存后，发现过一会打开又出现了<code>192.168.137.1 windows10.microdone.cn</code><br>这下怀疑中病毒了</p><h3 id="使用360断网急救箱"><a href="#使用360断网急救箱" class="headerlink" title="使用360断网急救箱"></a>使用360断网急救箱</h3><p><img src="https://img-blog.nos-eastchina1.126.net/360duanwnag.png" alt=""><br>诊断确实是 <code>hosts</code>文件出现异常</p><p>修复在检测，依然有问题</p><h3 id="使用360系统急救箱"><a href="#使用360系统急救箱" class="headerlink" title="使用360系统急救箱"></a>使用360系统急救箱</h3><p>深度检测，删了一些文件（可能中毒）<br>重启电脑，依然<code>CSDN/牛客网</code>的时候，页面不能正常显示</p><hr><h3 id="谷歌浏览器插件问题"><a href="#谷歌浏览器插件问题" class="headerlink" title="谷歌浏览器插件问题"></a>谷歌浏览器插件问题</h3><p>我鬼使神差的试试用微软自带的Eage浏览器登陆<code>CSDN/牛客网</code>，可以<font color="red" size="10">正常显示</font>，惊了。我这一通操作，就是换个浏览器的题</p><p>仔细回想一下，之前安装的<code>谷歌访问助手</code>插件崩溃了，我就卸载了</p><p>1、卸载<code>谷歌浏览器</code>，重新安装</p><blockquote><p>失败，不能正常显示网页<code>CSDN/牛客网</code></p></blockquote><p>2、安装<code>谷歌访问助手</code>插件</p><blockquote><p><code>CSDN/牛客网</code>可以正常显示了。</p></blockquote><p>原因：怀疑是插件的上网代理搞鬼</p><hr><h2 id="解决方法：谷歌浏览器谷歌访问助手重新安装"><a href="#解决方法：谷歌浏览器谷歌访问助手重新安装" class="headerlink" title="解决方法：谷歌浏览器谷歌访问助手重新安装"></a>解决方法：谷歌浏览器谷歌访问助手重新安装</h2>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客yilia主题首页添加helper-live2d模型插件</title>
      <link href="/2018/08/23/hexo-helper-live2d/"/>
      <url>/2018/08/23/hexo-helper-live2d/</url>
      
        <content type="html"><![CDATA[<p>Hexo添加helper-live2d模型插件<br><a id="more"></a></p><p>插件效果<br><a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">插件的github地址</a><br>插件作者提供了较为详细的安装步骤，我结合自己操作和图示，提供大家。</p><p>效果展示：红框内为2d模型，可以随鼠标移动而变化<br><img src="https://img-blog.nos-eastchina1.126.net/koharu4.png" alt=""></p><h2 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块:"></a>安装模块:</h2><p>hexo博客根目录选择<code>cmd</code>命令窗口或者<code>git bash</code> 输入以下代码，安装插件</p><h3 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.nos-eastchina1.126.net/koharu1.png" alt=""></p><h3 id="下载模型"><a href="#下载模型" class="headerlink" title="下载模型"></a>下载模型</h3><p>作者提供了三个下载模型的办法，我选择操作比较简单的一种<br><code>npm 模块名</code> 的方法</p><p>作者提供以下模型的模型包，模型包预览地址见下面的链接，选择你想用的模型，记住名字，选择对应的后缀模型包</p><p><a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">作者各种模型包展示</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">live2d-widget-model-chitose</span><br><span class="line">live2d-widget-model-epsilon2_1</span><br><span class="line">live2d-widget-model-gf</span><br><span class="line">live2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)</span><br><span class="line">live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)</span><br><span class="line">live2d-widget-model-haruto</span><br><span class="line">live2d-widget-model-hibiki</span><br><span class="line">live2d-widget-model-hijiki</span><br><span class="line">live2d-widget-model-izumi</span><br><span class="line">live2d-widget-model-koharu</span><br><span class="line">live2d-widget-model-miku</span><br><span class="line">live2d-widget-model-ni-j</span><br><span class="line">live2d-widget-model-nico</span><br><span class="line">live2d-widget-model-nietzsche</span><br><span class="line">live2d-widget-model-nipsilon</span><br><span class="line">live2d-widget-model-nito</span><br><span class="line">live2d-widget-model-shizuku</span><br><span class="line">live2d-widget-model-tororo</span><br><span class="line">live2d-widget-model-tsumiki</span><br><span class="line">live2d-widget-model-unitychan</span><br><span class="line">live2d-widget-model-wanko</span><br><span class="line">live2d-widget-model-z16</span><br></pre></td></tr></table></figure><p>选择好对应的模型，使用 <code>npm install 模型的包名</code>来安装，比如我选择的的是<code>live2d-widget-model-koharu</code> 模型包</p><h3 id="操作：-1"><a href="#操作：-1" class="headerlink" title="操作："></a>操作：</h3><p>在hexo博客根目录选择<code>cmd</code>命令窗口或者<code>git bash</code> 输入以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install live2d-widget-model-koharu</span><br></pre></td></tr></table></figure><p>执行安装就完事了</p><p><img src="https://img-blog.nos-eastchina1.126.net/koharu3.png" alt=""></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>请向<code>Hexo</code>的 <code>_config.yml</code> 文件添加配置.</p><h3 id="操作：-2"><a href="#操作：-2" class="headerlink" title="操作："></a>操作：</h3><p>打开个人Hexo博客文件根目录下的 <code>_config.yml</code> 文件，在最后添加一下代码<br>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local</span><br><span class="line">  pluginRootPath: live2dw/</span><br><span class="line">  pluginJsPath: lib/</span><br><span class="line">  pluginModelPath: assets/</span><br><span class="line">  tagMode: false</span><br><span class="line">  debug: false</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-koharu</span><br><span class="line">  display:</span><br><span class="line">    position: right</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: true</span><br></pre></td></tr></table></figure><p>你需要配置的是<code>use: live2d-widget-model-koharu</code><br><code>use</code>后为你选择的安装包的全称</p><p><img src="https://img-blog.nos-eastchina1.126.net/koharu2.png" alt=""></p><p>插件部署与应用就完成了，接下来就是部署hexo博客和个人主页</p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> yilia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理_Retinex图像增强</title>
      <link href="/2018/08/17/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_Retinex%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/"/>
      <url>/2018/08/17/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_Retinex%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/</url>
      
        <content type="html"><![CDATA[<p>图像处理_Retinex图像增强</p><a id="more"></a><h3 id="单尺度SSR"><a href="#单尺度SSR" class="headerlink" title="单尺度SSR"></a>单尺度SSR</h3><p>(Single Scale Retinex)</p><p>图像$S(x,y)$分解为两个不同的图像：反射图像$R(x,y)$,入射图像$L(x,y)$<br><img src="https://img-blog.csdn.net/20170508211020962?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWppYW55aW5neGlhb3FpbmdoYW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>图像可以看做是入射图像和反射图像构成，入射光照射在反射物体上，通过反射物体的反射，形成反射光进入人眼。最后形成的图像$r(x,y)$可以如下公式表示</p><script type="math/tex; mode=display">r(x,y)=logR(x,y)=log\frac{S(x,y)}{L(x,y)}</script><p>R(x, y)表示了物体的反射性质，即图像内在属性，我们应该最大程度的保留；而L(x, y)表示入射光图像，决定了图像像素能达到的动态范围，我们应该尽量去除。 </p><p>我们把照射图像假设估计为空间平滑图像，原始图像为S(x, y)，反射图像为R(x, y)，亮度图像为L(x, y)，使用公式</p><script type="math/tex; mode=display">r(x,y)=logR(x,y)=log\frac{S(x,y)}{L(x,y)}</script><p>或者</p><script type="math/tex; mode=display">r(x,y)=logS(x,y)-log[F(x,y)⨂S(x,y)]</script><p>其中r(x, y)是输出图像,卷积运算，$F(x, y)$是中心环绕函数</p><script type="math/tex; mode=display">F(x,y)=\lambda*e^{-\frac{x^2+y^2}{c^2}}</script><p>其中C是高斯环绕尺度，λ是一个尺度，满足$∫∫F(x,y)dxdy=1$</p><blockquote><p>SSR算法中的卷积是对入射图像的计算，其物理意义是通过计算像素点与周围区域在加权平均的作用下，估计图像中照度的变化，并将L(x,y)去除，只保留S(x,y)属性。</p></blockquote><h3 id="多尺度MSR"><a href="#多尺度MSR" class="headerlink" title="多尺度MSR"></a>多尺度MSR</h3><p>(Multi-Scale Retinex)</p><blockquote><p>MSR是在SSR基础上发展来的，优点是可以同时保持图像高保真度与对图像的动态范围进行压缩的同时，MSR也可实现色彩增强、颜色恒常性、局部动态范围压缩、全局动态范围压缩，也可以用于X光图像增强。</p></blockquote><script type="math/tex; mode=display">r(x,y)=∑_k^Kw_klogS(x,y)-log[F_k(x,y)*S(x,y)]</script><p>K是高斯中心环绕函数的个数。当K=1时，MSR退化为SSR,K取值通常为3</p><script type="math/tex; mode=display">w1=w2=w3=\frac13</script><blockquote><p>缺点:边缘锐化不足，阴影边界突兀，部分颜色发生扭曲，纹理不清晰，高光区域细节没有得到明显改善，对高光区域敏感度小</p></blockquote><h3 id="带颜色恢复的MSR方法MSRCR"><a href="#带颜色恢复的MSR方法MSRCR" class="headerlink" title="带颜色恢复的MSR方法MSRCR"></a>带颜色恢复的MSR方法MSRCR</h3><p>(Multi-Scale Retinex with Color Restoration)<br>SSR和MSR普遍都存在明显的偏色问题</p><blockquote><p>MSRCR在MSR的基础上，加入了色彩恢复因子C来调节由于图像局部区域对比度增强而导致颜色失真的缺陷。</p></blockquote><p>改进公式：</p><script type="math/tex; mode=display">R_{MSRCR_i}(x,y)=C_i(x,y)R_{MSR_i}(x,y)</script><p>其中</p><script type="math/tex; mode=display">C_i(x,y)=f[I_i^{'}(x,y)]=f[\frac{I_i(x,y)}{∑_{j=1}^{N}I_j(x,y)}]</script><p>其中</p><script type="math/tex; mode=display">f[I_i^{'}(x,y)]=βlog[αI_i^{'}(x,y)]=β{log[αI_i^{'}i(x,y)]-log[∑_{j=1}^NI_j(x,y)]}</script><p>参数说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ii(x, y)表示第i个通道的图像</span><br><span class="line">Ci表示第i个通道的彩色回复因子，用来调节3个通道颜色的比例；</span><br><span class="line">f(·)表示颜色空间的映射函数；</span><br><span class="line">β是增益常数；</span><br><span class="line">α是受控制的非线性强度；</span><br></pre></td></tr></table></figure></p><p>MSRCR算法利用彩色恢复因子C，调节原始图像中3个颜色通道之间的比例关系，从而把相对较暗区域的信息凸显出来，达到了消除图像色彩失真的缺陷。<br>处理后的图像局部对比度提高，亮度与真实场景相似，在人们视觉感知下，图像显得更加逼真。</p><p><a href="https://blog.csdn.net/ajianyingxiaoqinghan/article/details/71435098" target="_blank" rel="noopener">参考文章</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> Opencv </tag>
            
            <tag> 图像增强 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-梯度消失爆炸</title>
      <link href="/2018/08/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E7%88%86%E7%82%B8/"/>
      <url>/2018/08/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E7%88%86%E7%82%B8/</url>
      
        <content type="html"><![CDATA[<p>机器学习-梯度消失爆炸</p><a id="more"></a><h3 id="梯度消失"><a href="#梯度消失" class="headerlink" title="梯度消失"></a>梯度消失</h3><p>本层的神经元的激活等于上一层神经元对应的权值进行加权和运算，<br>最后通过一个非线性函数（激活函数）如ReLu，sigmoid等函数，<br>最后得到的结果就是本层神经元的输出，<br>逐层逐神经元通过该操作向前传播，最终得到输出层的结果。 </p><p>梯度消失的影响：<br>1) 浅层基本不学习，后面几层一直在学习，失去深度的意义。<br>2) 无法收敛。</p><p>梯度消失的现象呢？因为通常神经网络所用的激活函数是sigmoid函数<br>这个函数有个特点:<br></p><blockquote><p>就是能将负无穷到正无穷的数映射到0和1之间，并且对这个函数求导的结果是f′(x)=f(x)(1−f(x))。<br>因此两个0到1之间的数相乘，得到的结果就会变得很小了。<br>神经网络的反向传播是逐层对函数偏导相乘，因此当神经网络层数非常深的时候<br>最后一层产生的偏差就因为乘了很多的小于1的数而越来越小，最终就会变为0，从而导致层数比较浅的权重没有更新</p><p>一是在深层网络中，网络层数过多二是采用了不合适的损失函数，比如sigmoid</p></blockquote><h3 id="梯度爆炸"><a href="#梯度爆炸" class="headerlink" title="梯度爆炸"></a>梯度爆炸</h3><p>就是由于初始化权值过大，前面层会比后面层变化的更快，就会导致权值越来越大，梯度爆炸的现象就发生了。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>用ReLU激活函数来替代sigmoid函数。 </p><blockquote><p>区别：（1）sigmoid函数值在[0,1],ReLU函数值在[0,+无穷]，所以sigmoid函数可以描述概率，ReLU适合用来描述实数；（2）sigmoid函数的梯度随着x的增大或减小和消失，而ReLU不会。</p></blockquote><p>早期多层神经网络如果用sigmoid函数或者hyperbolic tangent作为激活函数，如果不进行pre-training的话，会因为gradient vanishing problem而无法收敛。 </p><p>而预训练的用处：规则化，防止过拟合；压缩数据，去除冗余；强化特征，减小误差；加快收敛速度。而采用ReLu则不需要进行pre-training。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解</title>
      <link href="/2018/08/16/leetcode_sum/"/>
      <url>/2018/08/16/leetcode_sum/</url>
      
        <content type="html"><![CDATA[<p><img width="800" height="800" src="http://ph04wnm2q.bkt.clouddn.com/bg/magazine-unlock-01-2.3.971-_c98a796eb65a419dbcfa164bbb6563e7.jpg"></p><a id="more"></a><h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p><h3 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1    Two Sum"></a>1    Two Sum</h3><p>5    array、set    sort、Two Pointers</p><h3 id="8-String-to-Integer-atoi-5-string-Math"><a href="#8-String-to-Integer-atoi-5-string-Math" class="headerlink" title="8    String to Integer (atoi)    5    string    Math"></a>8    String to Integer (atoi)    5    string    Math</h3><h3 id="15-3Sum-5-array-Two-Pointers"><a href="#15-3Sum-5-array-Two-Pointers" class="headerlink" title="15    3Sum    5    array    Two Pointers"></a>15    3Sum    5    array    Two Pointers</h3><h3 id="20-Valid-Parentheses-5-string-Stack"><a href="#20-Valid-Parentheses-5-string-Stack" class="headerlink" title="20    Valid Parentheses    5    string    Stack"></a>20    Valid Parentheses    5    string    Stack</h3><h3 id="21-Merge-Two-Sorted-Lists-5-linked-list-sort、Two-Pointers、merge"><a href="#21-Merge-Two-Sorted-Lists-5-linked-list-sort、Two-Pointers、merge" class="headerlink" title="21    Merge Two Sorted Lists    5    linked list    sort、Two Pointers、merge"></a>21    Merge Two Sorted Lists    5    linked list    sort、Two Pointers、merge</h3><h3 id="28-Implement-strStr-5-string-Two-Pointers、KMP、rolling-hash"><a href="#28-Implement-strStr-5-string-Two-Pointers、KMP、rolling-hash" class="headerlink" title="28    Implement strStr()    5    string    Two Pointers、KMP、rolling hash"></a>28    Implement strStr()    5    string    Two Pointers、KMP、rolling hash</h3><h3 id="50-Pow-x-n-5-Binary-Search、Math"><a href="#50-Pow-x-n-5-Binary-Search、Math" class="headerlink" title="50    Pow(x, n)    5         Binary Search、Math"></a>50    Pow(x, n)    5         Binary Search、Math</h3><h3 id="56-Merge-Intervals-5-array、linked-list、red-black-tree-sort、merge"><a href="#56-Merge-Intervals-5-array、linked-list、red-black-tree-sort、merge" class="headerlink" title="56    Merge Intervals    5    array、linked list、red-black tree    sort、merge"></a>56    Merge Intervals    5    array、linked list、red-black tree    sort、merge</h3><h3 id="57-Insert-Interval-5-array-sort"><a href="#57-Insert-Interval-5-array-sort" class="headerlink" title="57    Insert Interval    5    array    sort"></a>57    Insert Interval    5    array    sort</h3><h3 id="65-Valid-Number-5-string-Math"><a href="#65-Valid-Number-5-string-Math" class="headerlink" title="65    Valid Number    5    string    Math"></a>65    Valid Number    5    string    Math</h3><h3 id="70-Climbing-Stairs-5-DP"><a href="#70-Climbing-Stairs-5-DP" class="headerlink" title="70    Climbing Stairs    5         DP"></a>70    Climbing Stairs    5         DP</h3><h3 id="73-Set-Matrix-Zeroes-5-array"><a href="#73-Set-Matrix-Zeroes-5-array" class="headerlink" title="73    Set Matrix Zeroes    5    array"></a>73    Set Matrix Zeroes    5    array</h3><h3 id="88-Merge-Sorted-Array-5-array-Two-Pointers、merge"><a href="#88-Merge-Sorted-Array-5-array-Two-Pointers、merge" class="headerlink" title="88    Merge Sorted Array    5    array    Two Pointers、merge"></a>88    Merge Sorted Array    5    array    Two Pointers、merge</h3><h3 id="98-Validate-Binary-Search-Tree-5-tree-DFS"><a href="#98-Validate-Binary-Search-Tree-5-tree-DFS" class="headerlink" title="98    Validate Binary Search Tree    5    tree    DFS"></a>98    Validate Binary Search Tree    5    tree    DFS</h3><h3 id="125-Valid-Palindrome-5-string-Two-Pointers"><a href="#125-Valid-Palindrome-5-string-Two-Pointers" class="headerlink" title="125    Valid Palindrome    5    string    Two Pointers"></a>125    Valid Palindrome    5    string    Two Pointers</h3><h3 id="127-Word-Ladder-5-graph-BFS、path"><a href="#127-Word-Ladder-5-graph-BFS、path" class="headerlink" title="127    Word Ladder    5    graph    BFS、path"></a>127    Word Ladder    5    graph    BFS、path</h3><h3 id="2-Add-Two-Numbers-4-linked-list-Two-Pointers、Math"><a href="#2-Add-Two-Numbers-4-linked-list-Two-Pointers、Math" class="headerlink" title="2    Add Two Numbers    4    linked list    Two Pointers、Math"></a>2    Add Two Numbers    4    linked list    Two Pointers、Math</h3><h3 id="12-Integer-to-Roman-4-Math"><a href="#12-Integer-to-Roman-4-Math" class="headerlink" title="12    Integer to Roman    4         Math"></a>12    Integer to Roman    4         Math</h3><h3 id="13-Roman-to-Integer-4-Math"><a href="#13-Roman-to-Integer-4-Math" class="headerlink" title="13    Roman to Integer    4         Math"></a>13    Roman to Integer    4         Math</h3><h3 id="22-Generate-Parentheses-4-string-DFS"><a href="#22-Generate-Parentheses-4-string-DFS" class="headerlink" title="22    Generate Parentheses    4    string    DFS"></a>22    Generate Parentheses    4    string    DFS</h3><h3 id="23-Merge-k-Sorted-Lists-4-linked-list、heap-sort、Two-Pointersmerge"><a href="#23-Merge-k-Sorted-Lists-4-linked-list、heap-sort、Two-Pointersmerge" class="headerlink" title="23    Merge k Sorted Lists    4    linked list、heap    sort、Two Pointersmerge"></a>23    Merge k Sorted Lists    4    linked list、heap    sort、Two Pointersmerge</h3><p>24    Swap Nodes in Pairs    4    linked list<br>27    Remove Element    4    array    Two Pointers<br>46    Permutations    4    array    permutation<br>49    Anagrams    4    string、hashtable<br>67    Add Binary    4    string    Two Pointers、Math<br>69    Sqrt(x)    4         Binary Search<br>77    Combinations    4         combination<br>78    Subsets    4    array    Recursion、combination<br>79    Word Search    4    array    DFS<br>91    Decode Ways    4    string    Recursion、DP<br>102    Binary Tree Level Order Traversal    4    tree    BFS<br>129    Sum Root to Leaf Numbers    4    tree    DFS<br>131    Palindrome Partitioning    4    string    DFS<br>4    Median of Two Sorted Arrays    3    array    Binary Search<br>7    Reverse Integer    3         Math<br>10    Regular Expression Matching    3    string    Recursion、DP<br>17    Letter Combinations of a Phone Number    3    string    DFS<br>19    Remove Nth Node From End of List    3    linked list    Two Pointers<br>26    Remove Duplicates from Sorted Array    3    array    Two Pointers<br>29    Divide Two Integers    3         Binary Search<br>33    Search in Rotated Sorted Array    3    array    Binary Search<br>34    Search for a Range    3    array    Binary Search<br>39    Combination Sum    3    array    combination<br>43    Multiply Strings    3    string    Two Pointers、Math<br>44    Wildcard Matching    3    string    Recursion、DP、greedy<br>51    N-Queens    3    array    DFS<br>52    N-Queens II    3    array    DFS<br>53    Maximum Subarray    3    array    DP<br>62    Unique Paths    3    array    DP<br>63    Unique Paths II    3    array    DP<br>64    Minimum Path Sum    3    array    DP<br>72    Edit Distance    3    string    DP<br>74    Search a 2D Matrix    3    array    Binary Search<br>81    Search in Rotated Sorted Array II    3    array    Binary Search<br>82    Remove Duplicates from Sorted List II    3    linked list    Recursion、Two Pointers<br>83    Remove Duplicates from Sorted List    3    linked list<br>86    Partition List    3    linked list    Two Pointers<br>93    Restore IP Addresses    3    string    DFS<br>94    Binary Tree Inorder Traversal    3    tree、hashtable    Recursion、morris、Stack<br>103    Binary Tree Zigzag Level Order Traversal    3    queue、tree    BFS、Stack<br>105    Construct Binary Tree from Preorder and Inorder Tr    3    array、tree    DFS<br>106    Construct Binary Tree from Inorder and Postorder T    3    array、tree    DFS<br>108    Convert Sorted Array to Binary Search Tree    3    tree    DFS<br>109    Convert Sorted List to Binary Search Tree    3    linked list    Recursion、Two Pointers<br>112    Path Sum    3    tree    DFS<br>114    Flatten Binary Tree to Linked List    3    tree    Recursion、Stack<br>116    Populating Next Right Pointers in Each Node    3    tree    DFS<br>128    Longest Consecutive Sequence    3    array<br>130    Surrounded Regions    3    array    BFS、DFS<br>132    Palindrome Partitioning II    3    string    DP<br>3    Longest Substring Without Repeating Characters    2    string、hashtable    Two Pointers<br>5    Longest Palindromic Substring    2    string<br>9    Palindrome Number    2         Math<br>11    Container With Most Water    2    array    Two Pointers<br>18    4Sum    2    array<br>25    Reverse Nodes in k-Group    2    linked list    Recursion、Two Pointers<br>31    Next Permutation    2    array    permutation<br>35    Search Insert Position    2    array<br>36    Valid Sudoku    2    array<br>37    Sudoku Solver    2    array    DFS<br>38    Count and Say    2    string    Two Pointers<br>40    Combination Sum II    2    array    combination<br>41    First Missing Positive    2    array    sort<br>42    Trapping Rain Water    2    array    Two Pointers、Stack<br>45    Jump Game II    2    array<br>47    Permutations II    2    array    permutation<br>48    Rotate Image    2    array<br>54    Spiral Matrix    2    array<br>55    Jump Game    2    array<br>59    Spiral Matrix II    2    array<br>61    Rotate List    2    linked list    Two Pointers<br>66    Plus One    2    array    Math<br>68    Text Justification    2    string<br>75    Sort Colors    2    array    sort、Two Pointers<br>76    Minimum Window Substring    2    string    Two Pointers<br>80    Remove Duplicates from Sorted Array II    2    array    Two Pointers<br>84    Largest Rectangle in Histogram    2    array    Stack<br>87    Scramble String    2    string    Recursion、DP<br>89    Gray Code    2         combination<br>90    Subsets II    2    array    Recursion、combination<br>92    Reverse Linked List II    2    linked list    Two Pointers<br>97    Interleaving String    2    string    Recursion、DP<br>99    Recover Binary Search Tree    2    tree    DFS<br>101    Symmetric Tree    2    tree    DFS<br>110    Balanced Binary Tree    2    tree    DFS<br>113    Path Sum II    2    tree    DFS<br>115    Distinct Subsequences    2    string    DP<br>117    Populating Next Right Pointers in Each Node II    2    tree    DFS<br>124    Binary Tree Maximum Path Sum    2    tree    DFS<br>6    ZigZag Conversion    1    string<br>14    Longest Common Prefix    1    string<br>16    3Sum Closest    1    array    Two Pointers<br>30    Substring with Concatenation of All Words    1    string    Two Pointers<br>32    Longest Valid Parentheses    1    string    DP<br>58    Length of Last Word    1    string<br>60    Permutation Sequence    1         permutation、Math<br>71    Simplify Path    1    string    Stack<br>85    Maximal Rectangle    1    array    DP、Stack<br>95    Unique Binary Search Trees II    1    tree    DP、DFS<br>96    Unique Binary Search Trees    1    tree    DP<br>100    Same Tree    1    tree    DFS<br>104    Maximum Depth of Binary Tree    1    tree    DFS<br>107    Binary Tree Level Order Traversal II    1    tree    BFS<br>111    Minimum Depth of Binary Tree    1    tree    DFS<br>118    Pascal’s Triangle    1    array<br>119    Pascal’s Triangle II    1    array<br>120    Triangle    1    array    DP<br>121    Best Time to Buy and Sell Stock    1    array    DP<br>122    Best Time to Buy and Sell Stock II    1    array    greedy<br>123    Best Time to Buy and Sell Stock III    1    array    DP<br>126    Word Ladder II    1</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer算法Code_Java_C++(0820更新)</title>
      <link href="/2018/08/16/%E5%89%91%E6%8C%87Offer%E7%AE%97%E6%B3%95Code_Java_C++/"/>
      <url>/2018/08/16/%E5%89%91%E6%8C%87Offer%E7%AE%97%E6%B3%95Code_Java_C++/</url>
      
        <content type="html"><![CDATA[<p>剑指Offer算法Code_Java_C++</p><a id="more"></a><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><blockquote><p>思路：从左下角元素往上查找，右边元素是比这个元素大，上边是的元素比这个元素小。<br>Java代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean Find(int target, int [][] array) &#123;</span><br><span class="line">        //填写</span><br><span class="line">        int row = array.length;</span><br><span class="line">        int col = array[0].length;</span><br><span class="line">        int i=row-1,j=0;</span><br><span class="line">        while(i&gt;=0&amp;&amp;j&lt;=col-1)&#123;</span><br><span class="line">            if(target&lt;array[i][j])&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;else if(target&gt;array[i][j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;else</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>C++代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123;</span><br><span class="line">        // array是二维数组，这里没做判空操作</span><br><span class="line">        int rows = array.size();</span><br><span class="line">        int cols = array[0].size();</span><br><span class="line">        int i=rows-1,j=0;//左下角元素坐标</span><br><span class="line">        while(i&gt;=0 &amp;&amp; j&lt;cols)&#123;//使其不超出数组范围</span><br><span class="line">            if(target&lt;array[i][j])</span><br><span class="line">                i--;//查找的元素较少，往上找</span><br><span class="line">            else if(target&gt;array[i][j])</span><br><span class="line">                j++;//查找元素较大，往右找</span><br><span class="line">            else</span><br><span class="line">                return true;//找到</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<br>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">    String str1 = str.toString();</span><br><span class="line">        String str2 = str1.replace(&quot; &quot;,&quot;%20&quot;);</span><br><span class="line">        return str2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">        int spacenum = 0;//spacenum为计算空格数</span><br><span class="line">        for(int i=0;i&lt;str.length();i++)&#123;</span><br><span class="line">            if(str.charAt(i)==&apos; &apos;)</span><br><span class="line">                spacenum++;</span><br><span class="line">        &#125;</span><br><span class="line">        int indexold = str.length()-1; //indexold为为替换前的str下标</span><br><span class="line">        int newlength = str.length() + spacenum*2;//计算空格转换成%20之后的str长度</span><br><span class="line">        int indexnew = newlength-1;//indexold为为把空格替换为%20后的str下标</span><br><span class="line">        str.setLength(newlength);//使str的长度扩大到转换成%20之后的长度,防止下标越界</span><br><span class="line">        for(;indexold&gt;=0 &amp;&amp; indexold&lt;newlength;--indexold)&#123; </span><br><span class="line">                if(str.charAt(indexold) == &apos; &apos;)&#123;  //</span><br><span class="line">                str.setCharAt(indexnew--, &apos;0&apos;);</span><br><span class="line">                str.setCharAt(indexnew--, &apos;2&apos;);</span><br><span class="line">                str.setCharAt(indexnew--, &apos;%&apos;);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    str.setCharAt(indexnew--, str.charAt(indexold));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>c++代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">void replaceSpace(char *str,int length) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">        for (int i=0;i&lt;length;i++)&#123;</span><br><span class="line">            if (str[i]==&apos; &apos;)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i=length-1;i&gt;=0;i--)&#123;</span><br><span class="line">                if (str[i]==&apos; &apos;)&#123;</span><br><span class="line">                    count--;</span><br><span class="line">                  str[i+2*count]=&apos;%&apos;;</span><br><span class="line">                str[i+2*count+1]=&apos;2&apos;;</span><br><span class="line">                str[i+2*count+2]=&apos;0&apos;;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                      str[i+2*count]=str[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p><p>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java 递归超简洁版本</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;Integer&gt;();</span><br><span class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">        if(listNode!=null)&#123;</span><br><span class="line">            this.printListFromTailToHead(listNode.next);</span><br><span class="line">            arrayList.add(listNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        return arrayList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C++代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        vector&lt;int&gt; value;</span><br><span class="line">        if (head != NULL)&#123;</span><br><span class="line">            value.insert(value.begin(),head-&gt;val);</span><br><span class="line">            while (head-&gt;next !=NULL)&#123;</span><br><span class="line">                value.insert(value.begin(),head-&gt;next-&gt;val);</span><br><span class="line">                head = head -&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><blockquote><p>递归思想，每次将左右两颗子树当成新的子树进行处理，中序的左右子树索引很好找，前序的开始结束索引通过计算中序中左右子树的大小来计算，然后递归求解，直到startPre&gt;endPre||startIn&gt;endIn说明子树整理完到。方法每次返回左子树活右子树的根节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">    /  \</span><br><span class="line">  2     3</span><br><span class="line"> /\    /</span><br><span class="line">4  5  6</span><br><span class="line"> \    /</span><br><span class="line">  7  8</span><br></pre></td></tr></table></figure></p></blockquote><p>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123;</span><br><span class="line">        TreeNode root=reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    //前序遍历&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125;</span><br><span class="line">    private TreeNode reConstructBinaryTree(int [] pre,int startPre,int endPre,int [] in,int startIn,int endIn) &#123;</span><br><span class="line">         </span><br><span class="line">        if(startPre&gt;endPre||startIn&gt;endIn)</span><br><span class="line">            return null;</span><br><span class="line">        TreeNode root=new TreeNode(pre[startPre]);</span><br><span class="line">         </span><br><span class="line">        for(int i=startIn;i&lt;=endIn;i++)</span><br><span class="line">            if(in[i]==pre[startPre])&#123;</span><br><span class="line">                root.left=reConstructBinaryTree(pre,startPre+1,startPre+i-startIn,in,startIn,i-1);</span><br><span class="line">                root.right=reConstructBinaryTree(pre,i-startIn+startPre+1,endPre,in,i+1,endIn);</span><br><span class="line">                      break;</span><br><span class="line">            &#125;</span><br><span class="line">                 </span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。<br>n&lt;=39</p><p>Java代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int Fibonacci(int n) &#123;</span><br><span class="line">        if(n&lt;1)&#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] ints = new int[n+1];</span><br><span class="line">        ints[0] = 0;</span><br><span class="line">        ints[1] = 1;</span><br><span class="line">        </span><br><span class="line">        for(int i = 2; i &lt;= n; i++ )&#123;</span><br><span class="line">            ints[i] = ints[i-1] + ints[i-2];</span><br><span class="line">        &#125;</span><br><span class="line">        return ints[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C++代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int Fibonacci(int n) &#123;</span><br><span class="line">    int pre = 0;</span><br><span class="line">        int last=1;</span><br><span class="line">            int result =0;</span><br><span class="line">        if(n&lt;=1)&#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=2; i&lt;=n; i++)&#123;</span><br><span class="line">            result=pre+last;</span><br><span class="line">            pre=last;</span><br><span class="line">            last=result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><blockquote><p>思路：，f(1) = 1, f(2) = 2, f(3) = 3, f(4) = 5，  可以总结出f(n) = f(n-1) + f(n-2)的规律<br>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int JumpFloor(int target) &#123;</span><br><span class="line">        int[] ints= new int[target+1];</span><br><span class="line">        if(target &lt;=0 )&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;else if(target==1 || target==2)&#123;</span><br><span class="line">            return target;</span><br><span class="line">        &#125;</span><br><span class="line">        ints[0] = 1;ints[1] = 2;</span><br><span class="line">        for(int i =2; i&lt;=target; i++)&#123;</span><br><span class="line">            ints[i] = ints[i-1] + ints[i-2];</span><br><span class="line">           &#125;</span><br><span class="line">        return ints[target-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>C++代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloor(int number) &#123;</span><br><span class="line">        int first = 1;int second = 2; int result = 0;</span><br><span class="line">        if (number&lt;=0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;else if (number==1||number==2)&#123;</span><br><span class="line">            return number;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i=3; i&lt;=number; i++)&#123;</span><br><span class="line">            result = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><blockquote><p>思路：1自身左移动，然后跟原数字做<strong>与</strong>比较，如果对应相同输出为1，否则为0。<br>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int NumberOf1(int n) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">        int flag = 1;</span><br><span class="line">        while(flag != 0)&#123;</span><br><span class="line">            if((n &amp; flag) !=0 )&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            flag = flag &lt;&lt; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>C++代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">     int  NumberOf1(int n) &#123;</span><br><span class="line">         int count = 0;</span><br><span class="line">         int flag = 1;</span><br><span class="line">         while(flag != 0)&#123;</span><br><span class="line">             if((n &amp; flag)!=0)&#123;</span><br><span class="line">                 count++;    </span><br><span class="line">             &#125;</span><br><span class="line">             flag = flag &lt;&lt; 1;</span><br><span class="line">         &#125;</span><br><span class="line">        return count   ;  </span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="8"><a href="#8" class="headerlink" title="8"></a>8</h3><p>输入一个链表，反转链表后，输出新链表的表头:</p><blockquote><p>整体反转链表，但是要把断开的节点保存起来，才能继续反转链表<br>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode ReverseList(ListNode head) &#123;</span><br><span class="line">       </span><br><span class="line">        if(head==null)</span><br><span class="line">            return null;</span><br><span class="line">        //head为当前节点，如果当前节点为空的话，那就什么也不做，直接返回null；</span><br><span class="line">        ListNode pre = null;</span><br><span class="line">        ListNode next = null;</span><br><span class="line">        //当前节点是head，pre为当前节点的前一节点，next为当前节点的下一节点</span><br><span class="line">        //需要pre和next的目的是让当前节点从pre-&gt;head-&gt;next1-&gt;next2变成pre&lt;-head next1-&gt;next2</span><br><span class="line">        //即pre让节点可以反转所指方向，但反转之后如果不用next节点保存next1节点的话，此单链表就此断开了</span><br><span class="line">        //所以需要用到pre和next两个节点</span><br><span class="line">        //1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line">        //1&lt;-2&lt;-3 4-&gt;5</span><br><span class="line">        while(head!=null)&#123;</span><br><span class="line">            //做循环，如果当前节点不为空的话，始终执行此循环，此循环的目的就是让当前节点从指向next到指向pre</span><br><span class="line">            //如此就可以做到反转链表的效果</span><br><span class="line">            //先用next保存head的下一个节点的信息，保证单链表不会因为失去head节点的原next节点而就此断裂</span><br><span class="line">            next = head.next;</span><br><span class="line">            //保存完next，就可以让head从指向next变成指向pre了，代码如下</span><br><span class="line">            head.next = pre;</span><br><span class="line">            //head指向pre后，就继续依次反转下一个节点</span><br><span class="line">            //让pre，head，next依次向后移动一个节点，继续下一次的指针反转</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果head为null的时候，pre就为最后一个节点了，但是链表已经反转完毕，pre就是反转后链表的第一个节点</span><br><span class="line">        //直接输出pre就是我们想要得到的反转后的链表</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>C++代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* ReverseList(ListNode* pHead) &#123;</span><br><span class="line"></span><br><span class="line">        if(pHead == NULL)&#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* pNode = pHead;//当前指针</span><br><span class="line">        ListNode* pPre = NULL;//链表的前一个指针</span><br><span class="line">        ListNode* pNewHead = NULL;</span><br><span class="line">        </span><br><span class="line">        while(pNode != NULL)&#123;</span><br><span class="line">           ListNode* pNext = pNode-&gt;next;</span><br><span class="line">            if(pNext == NULL)&#123; //尾节点</span><br><span class="line">                pNewHead = pNode;</span><br><span class="line">            &#125;</span><br><span class="line">            pNode-&gt;next = pPre;</span><br><span class="line">            pPre = pNode;</span><br><span class="line">            pNode = pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        return pNewHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="9"><a href="#9" class="headerlink" title="9"></a>9</h3><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><blockquote><p>两两数值对比,merge可以合并两个事物，链表也行，考点在取两个链表比较小的头节点</p></blockquote><p>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode Merge(ListNode list1,ListNode list2) &#123;</span><br><span class="line">        if(list1 == null)&#123;</span><br><span class="line">            return list2;</span><br><span class="line">        &#125;</span><br><span class="line">        if(list2 == null)&#123;</span><br><span class="line">            return list1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(list1.val &lt;= list2.val)&#123;</span><br><span class="line">            list1.next = Merge(list1.next,list2);</span><br><span class="line">                return list1;</span><br><span class="line">              &#125;else&#123;</span><br><span class="line">            list2.next = Merge(list1,list2.next);</span><br><span class="line">            return list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C++代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)</span><br><span class="line">    &#123;</span><br><span class="line">     if(pHead1 == NULL)&#123;</span><br><span class="line">            return pHead2;</span><br><span class="line">        &#125;</span><br><span class="line">        if(pHead2 == NULL)&#123;</span><br><span class="line">            return pHead1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode* NewHead = NULL;</span><br><span class="line">        if(pHead1-&gt;val &lt;= pHead2-&gt;val)&#123;</span><br><span class="line">            NewHead = pHead1;</span><br><span class="line">            NewHead-&gt;next = Merge(pHead1-&gt;next,pHead2);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            NewHead = pHead2;</span><br><span class="line">            NewHead-&gt;next = Merge(pHead1,pHead2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        return NewHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="10"><a href="#10" class="headerlink" title="10"></a>10</h3><p> 从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><p>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">思路是用arraylist模拟一个队列来存储相应的TreeNode</span><br><span class="line">*/</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arr = new ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;TreeNode&gt; TN = new ArrayList&lt;&gt;();</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            return arr;</span><br><span class="line">        &#125;</span><br><span class="line">        TN.add(root);</span><br><span class="line">        while(TN.size()!=0)&#123;</span><br><span class="line">            TreeNode temp = TN.remove(0);</span><br><span class="line">            if(temp.left!= null)&#123;</span><br><span class="line">                TN.add(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if(temp.right!= null)&#123;</span><br><span class="line">                TN.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            arr.add(temp.val);</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C++代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">### 11</span><br><span class="line">1个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。</span><br><span class="line">&gt;思路：两个相同数字异或=0，一个数和0异或还是它本身。&lt;br&gt;</span><br><span class="line">我们首先还是先异或，剩下的数字肯定是A、B异或的结果，这个结果的二进制中的1，表现的是A和B的不同的位。我们就取第一个1所在的位数，假设是第3位，接着把原数组分成两组，分组标准是第3位是否为1。如此，相同的数肯定在一个组，因为相同数字所有位都相同，而不同的数，肯定不在一组。然后把这两个组按照最开始的思路，依次异或，剩余的两个结果就是这两个只出现一次的数字。</span><br><span class="line"></span><br><span class="line">Java代码：</span><br></pre></td></tr></table></figure></p><p>public class Solution {<br>    public void FindNumsAppearOnce(int[] array, int[] num1, int[] num2)    {<br>        int length = array.length;<br>        if(length == 2){<br>            num1[0] = array[0];<br>            num2[0] = array[1];<br>            return;<br>        }<br>        int bitResult = 0;<br>        for(int i = 0; i &lt; length; ++i){<br>            bitResult ^= array[i];<br>        }<br>        int index = findFirst1(bitResult);<br>        for(int i = 0; i &lt; length; ++i){<br>            if(isBit1(array[i], index)){<br>                num1[0] ^= array[i];<br>            }else{<br>                num2[0] ^= array[i];<br>            }<br>        }<br>    }</p><pre><code>private int findFirst1(int bitResult){    int index = 0;    while(((bitResult &amp; 1) == 0) &amp;&amp; index &lt; 32){        bitResult &gt;&gt;= 1;        index++;    }    return index;}private boolean isBit1(int target, int index){    return ((target &gt;&gt; index) &amp; 1) == 1;}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">C++代码：</span><br></pre></td></tr></table></figure></p><p>链接：<a href="https://www.nowcoder.com/questionTerminal/e02fdb54d7524710a7d664d082bb7811" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/e02fdb54d7524710a7d664d082bb7811</a><br>来源：牛客网</p><p>class Solution {<br>public:<br>    void FindNumsAppearOnce(vector<int> data,int<em> num1,int </em>num2) {<br>  if(data.size()<2) return="" ;="" int="" size="data.size();" temp="data[0];" for(int="" i="1;i<size;i++)" if(temp="=0)" index="0;" while((temp&1)="=0){">&gt;1;<br>   ++index;<br>  }<br>  <em>num1=</em>num2=0;<br>  for(int i=0;i<size;i++) {="" if(isbit(data[i],index))="" *num1^="data[i];" else="" *num2^="data[i];" }="" bool="" isbit(int="" num,int="" index)="" num="num">&gt;index;<br>  return (num&amp;1);<br> }<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> ^=:逐位异或 </span><br><span class="line"></span><br><span class="line">### 12</span><br><span class="line">最小的k个数</span><br><span class="line">输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</span><br><span class="line"></span><br><span class="line">Java代码：(快排/最小堆)</span><br></pre></td></tr></table></figure></size;i++)></2)></int></p><p>链接：<a href="https://www.nowcoder.com/questionTerminal/6a296eb82cf844ca8539b57c23e6e9bf" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/6a296eb82cf844ca8539b57c23e6e9bf</a><br>来源：牛客网</p><p>/<em></em>基于堆排序算法，构建最大堆。时间复杂度为O(nlogk)<br><em>如果用快速排序，时间复杂度为O(nlogn)；</em>如果用冒泡排序，时间复杂度为O(n<em>k)</em>/<br>import java.util.ArrayList;<br>public class Solution {<br>    public ArrayList<integer> GetLeastNumbers_Solution(int [] input, int k) {<br>        ArrayList<integer> list=new ArrayList<integer>();<br>        //检查输入的特殊情况<br>        if(input==null || input.length&lt;=0 || input.length<k){ return="" list;="" }="" 构建最大堆="" for(int="" len="k/2-1;">=0; len—){<br>            adjustMaxHeapSort(input,len,k-1);<br>        }<br>        //从第k个元素开始分别与最大堆的最大值做比较，如果比最大值小，则替换并调整堆。<br>        //最终堆里的就是最小的K个数。<br>        int tmp;<br>        for(int i=k; i&lt;input.length; i++){<br>            if(input[i]&lt;input[0]){<br>                tmp=input[0];<br>                input[0]=input[i];<br>                input[i]=tmp;<br>                adjustMaxHeapSort(input,0,k-1);<br>            }<br>        }<br>        for(int j=0; j&lt;k; j++){<br>            list.add(input[j]);<br>        }<br>        return list;<br>    }</k){></integer></integer></integer></p><pre><code>public void adjustMaxHeapSort(int[] input, int pos, int length){    int temp;    int child;    for(temp=input[pos]; 2*pos+1&lt;=length; pos=child){        child=2*pos+1;        if(child&lt;length &amp;&amp; input[child]&lt;input[child+1]){            child++;        }        if(input[child]&gt;temp){            input[pos]=input[child];        }else{            break;        }    }    input[pos]=temp;}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### 二叉树的景象</span><br></pre></td></tr></table></figure></p><p>题目描述<br>操作给定的二叉树，将其变换为源二叉树的镜像。<br>输入描述:<br>二叉树的镜像定义：源二叉树<br>            8<br>           /  \<br>          6   10<br>         / \  / \<br>        5  7 9 11<br>        镜像二叉树<br>            8<br>           /  \<br>          10   6<br>         / \  / \<br>        11 9 7  5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++代码：</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 13</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Java代码：</span><br></pre></td></tr></table></figure><p>public class Solution {<br>    public void Mirror(TreeNode root) {<br>        if(root == null){<br>            return;<br>        }</p><pre><code>    TreeNode temp;    if(root!=null){        temp = root.left;        root.left = root.right;        root.right = temp;    }    if(root.left!=null){        Mirror(root.left);        }    if(root.right!=null){        Mirror(root.right);    }}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">C++代码：</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Java代码：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++代码：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Java代码：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">C++代码：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Java代码：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">C++代码：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Java代码：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++代码：</span><br></pre></td></tr></table></figure><p>```</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经-概率论算法</title>
      <link href="/2018/08/16/%E9%9D%A2%E7%BB%8F-%E6%A6%82%E7%8E%87%E8%AE%BA%E7%AE%97%E6%B3%95/"/>
      <url>/2018/08/16/%E9%9D%A2%E7%BB%8F-%E6%A6%82%E7%8E%87%E8%AE%BA%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><img width="800" height="800" src="http://ph04wnm2q.bkt.clouddn.com/bg/magazine-unlock-01-2.3.971-_c98a796eb65a419dbcfa164bbb6563e7.jpg"></p><a id="more"></a><h3 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h3><p>100人坐飞机，第一个乘客在座位中随便选一个坐下，第100人正确坐到自己坐位的概率是？</p><h3 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h3><p>给定三个随机变量X,Y,Z，已知X和Y的相关系数(correlation)为0.8，X和Z的相关系数为0.8。问Y和Z的相关系数最大／最小为多少？</p><p>答：</p><p>|1|0.8|0.8|<br>|0.8|1|a|<br>|0.8|a|1|</p><h3 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h3><p>几何分布:<br>一个国家重男轻女，只要生了女孩就继续生，直到生出男孩为止，问这个国家的男女比例？</p><p>答：</p><p>1比1</p><p>因为只要生了女孩就继续生，直到生出男孩为止，影响的是家庭男女孩的比例，国家总人数比例还是1比1</p><h3 id="Q4"><a href="#Q4" class="headerlink" title="Q4"></a>Q4</h3><p>有50个红球，50个蓝球，如何放入两个盒子中使得拿到红球的概率最大</p><p>如果要拿两个红的，一个盒子放一个红球，一个盒子放49红，50蓝，取两个红球概率49/99</p><h3 id="Q5"><a href="#Q5" class="headerlink" title="Q5"></a>Q5</h3><p>一根木棍随机折成三段，能组成三角形的概率多大？</p><p>答：任意两边之和大于第三边<br>p=[(1/8)a^2]/[(1/2)a^2]=1/4=0.25  </p><h3 id="Q6"><a href="#Q6" class="headerlink" title="Q6"></a>Q6</h3><h3 id="Q7"><a href="#Q7" class="headerlink" title="Q7"></a>Q7</h3><h3 id="Q8"><a href="#Q8" class="headerlink" title="Q8"></a>Q8</h3><h3 id="Q9"><a href="#Q9" class="headerlink" title="Q9"></a>Q9</h3><h3 id="Q10"><a href="#Q10" class="headerlink" title="Q10"></a>Q10</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 笔面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法_动态规划</title>
      <link href="/2018/08/16/%E7%AE%97%E6%B3%95_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2018/08/16/%E7%AE%97%E6%B3%95_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>算法_动态规划</p><a id="more"></a><p>求解最优化问题</p><h3 id="背包问题1"><a href="#背包问题1" class="headerlink" title="背包问题1"></a>背包问题1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Problem Description:</span><br><span class="line">   有 n 个重量和价值分别为Wi,Vi的物品，现从这些物品中挑选出总量不超过 W 的物品，求所有方案中价值总和的最大值。</span><br><span class="line">Input:</span><br><span class="line">输入包含多组测试用例，每一例的开头为两位整数 n、W（1&lt;=n&lt;=10000,1&lt;=W&lt;=1000）</span><br><span class="line">，接下来有 n 行，每一行有两位整数 Wi、Vi（1&lt;=Wi&lt;=10000,1&lt;=Vi&lt;=100）。</span><br><span class="line">Output:</span><br><span class="line">输出为一行，即所有方案中价值总和的最大值。</span><br><span class="line">Sample Input:</span><br><span class="line">3 4</span><br><span class="line">1 2</span><br><span class="line">2 5</span><br><span class="line">3 7</span><br><span class="line">Sample Output:</span><br><span class="line">9</span><br><span class="line"></span><br><span class="line">Java代码：</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">static Scanner scan = new Scanner(System.in);</span><br><span class="line">static int[] v = new int[10001];</span><br><span class="line">static int[] w = new int[10001];</span><br><span class="line">static int[] dp = new int[10001];</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">while(scan.hasNext())&#123;</span><br><span class="line">int n = scan.nextInt();</span><br><span class="line">int W = scan.nextInt();</span><br><span class="line">v = new int[n+1];</span><br><span class="line">w = new int[n+1];</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">w[i] = scan.nextInt();</span><br><span class="line">v[i] = scan.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 1; i &lt;= n; i++)</span><br><span class="line">                    for(int j = W; j &gt;= 0; j--)&#123;      //每次更新容量为j，所能放下最大价值的物品</span><br><span class="line">                        if(j &gt;= w[i])&#123;        //j一定要大于w[i],要不最大容量为j的背包放不下第i件物品</span><br><span class="line">                            dp[j] = Math.max(dp[j], dp[j-w[i]] + v[i]);    //dp[j] 表示最大容量为j的背包所装下物品最大的价值，         这里求的是第i件物品放和不放的价值的最大的价值</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">System.out.println(dp[W]);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="背包问题2"><a href="#背包问题2" class="headerlink" title="背包问题2"></a>背包问题2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author miracle</span><br><span class="line"> *切割钢条问题：</span><br><span class="line"> *长度：12345678910</span><br><span class="line"> *价格：1589101717202430</span><br><span class="line"> *问长度为n的钢条的最多卖多少钱</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line"> </span><br><span class="line">int[] prices = &#123;0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30&#125;;</span><br><span class="line">int[] dp = new int[prices.length];</span><br><span class="line">public int solve(int[] prices, int n)&#123;</span><br><span class="line">if(n == 0) return 0;</span><br><span class="line">int max = Integer.MIN_VALUE;</span><br><span class="line">for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">max = Math.max(max, prices[i] + solve(prices, n - i));</span><br><span class="line">&#125;</span><br><span class="line">return max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int solveWithMemoUpToBottom(int[] prices, int n)&#123;</span><br><span class="line">if(n == 0 || dp[n] &gt; 0) return dp[n];</span><br><span class="line">int max = Integer.MIN_VALUE;</span><br><span class="line">for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">max = Math.max(max, prices[i] + solve(prices, n - i));</span><br><span class="line">&#125;</span><br><span class="line">dp[n] = max;</span><br><span class="line">return max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int solveBottomToUp(int[] prices, int n)&#123;</span><br><span class="line">int[] dp = new int[prices.length];</span><br><span class="line">for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">int max = Integer.MIN_VALUE;</span><br><span class="line">for(int j = 1; j &lt;= i; j++)&#123;</span><br><span class="line">max = Math.max(max, prices[j] + prices[i - j]);</span><br><span class="line">&#125;</span><br><span class="line">dp[i] = max;</span><br><span class="line">&#125;</span><br><span class="line">return dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String args[])&#123;</span><br><span class="line">Solution s = new Solution();</span><br><span class="line">//System.out.println(s.solve(s.prices, 1));</span><br><span class="line">//System.out.println(s.solve(s.prices, 2));</span><br><span class="line">//System.out.println(s.solve(s.prices, 3));</span><br><span class="line">//System.out.println(s.solve(s.prices, 4));</span><br><span class="line">//System.out.println(s.solve(s.prices, 5));</span><br><span class="line">System.out.println(s.solveBottomToUp(s.prices, 1));</span><br><span class="line">System.out.println(s.solveBottomToUp(s.prices, 2));</span><br><span class="line">System.out.println(s.solveBottomToUp(s.prices, 3));</span><br><span class="line">System.out.println(s.solveBottomToUp(s.prices, 4));</span><br><span class="line">System.out.println(s.solveBottomToUp(s.prices, 5));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归 运算量比较大 O(2^N)</p><h3 id="递归，dp，分治的区别"><a href="#递归，dp，分治的区别" class="headerlink" title="递归，dp，分治的区别"></a>递归，dp，分治的区别</h3><p>递归只是一种编程的思想，只要自己调用自己，就算是递归。</p><p>分治，有三步，先分，再各自处理，最后整合。这里也涉及了子问题，这里的子问题是不重叠的，每一个只被处理一次，因此不需要memo。</p><p>dp，可以使用递归，而且dp的子问题是重复的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10大数据算法排序Java_C++</title>
      <link href="/2018/08/16/10%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8FJava_C++/"/>
      <url>/2018/08/16/10%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8FJava_C++/</url>
      
        <content type="html"><![CDATA[<p>10大数据算法排序Java_C++</p><a id="more"></a><p><img src="https://images0.cnblogs.com/blog2015/731178/201508/272007357503007.jpg" alt=""></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><blockquote><p>依次比较n与后面的数字，大的放右面，小的放左边<br>Java代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 冒泡排序</span><br><span class="line">     * 比较相邻的元素。如果第一个比第二个大，就交换他们两个。  </span><br><span class="line">     * 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。  </span><br><span class="line">     * 针对所有的元素重复以上的步骤，除了最后一个。</span><br><span class="line">     * 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 </span><br><span class="line">     * @param numbers 需要排序的整型数组</span><br><span class="line">     */</span><br><span class="line">    public static void bubbleSort(int[] numbers)</span><br><span class="line">    &#123;</span><br><span class="line">        int temp = 0;</span><br><span class="line">        int size = numbers.length;</span><br><span class="line">        for(int i = 0 ; i &lt; size-1; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">        for(int j = 0 ;j &lt; size-1-i ; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(numbers[j] &gt; numbers[j+1])  //交换两数位置</span><br><span class="line">            &#123;</span><br><span class="line">            temp = numbers[j];</span><br><span class="line">            numbers[j] = numbers[j+1];</span><br><span class="line">            numbers[j+1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>C++代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure></p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><blockquote><p>选择n个数组成的数组arr里最大的一个数，放在arr[n-1]，<br><br>然后维数n-1<br><br>选择前n-1个数组成的数组，取最大数，放在arr</p></blockquote><p>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 选择排序算法</span><br><span class="line">     * 在未排序序列中找到最小元素，存放到排序序列的起始位置  </span><br><span class="line">     * 再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。 </span><br><span class="line">     * 以此类推，直到所有元素均排序完毕。 </span><br><span class="line">     * @param numbers</span><br><span class="line">     */</span><br><span class="line">    public static void selectSort(int[] numbers)</span><br><span class="line">    &#123;</span><br><span class="line">    int size = numbers.length; //数组长度</span><br><span class="line">    int temp = 0 ; //中间变量</span><br><span class="line">    </span><br><span class="line">    for(int i = 0 ; i &lt; size ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int k = i;   //待确定的位置</span><br><span class="line">        //选择出应该在第i个位置的数</span><br><span class="line">        for(int j = size -1 ; j &gt; i ; j--)</span><br><span class="line">        &#123;</span><br><span class="line">        if(numbers[j] &lt; numbers[k])</span><br><span class="line">        &#123;</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //交换两个数</span><br><span class="line">        temp = numbers[i];</span><br><span class="line">        numbers[i] = numbers[k];</span><br><span class="line">        numbers[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>C++代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure></p><h3 id="快速排序及其改进算法C-实现"><a href="#快速排序及其改进算法C-实现" class="headerlink" title="快速排序及其改进算法C++实现"></a>快速排序及其改进算法C++实现</h3><blockquote><p>快速排序可以看成是插入排序的改进，它是一种分治的排序算法<br><img src="http://my.csdn.net/uploads/201207/20/1342782317_4426.jpg" alt="一次快排"><br><img src="http://my.csdn.net/uploads/201207/20/1342782329_8314.jpg" alt="快排流程"></p></blockquote><p>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class FastSort&#123;</span><br><span class="line"></span><br><span class="line">     public static void main(String []args)&#123;</span><br><span class="line">        System.out.println(&quot;Hello World&quot;);</span><br><span class="line">        int[] a = &#123;12,20,5,16,15,1,30,45,23,9&#125;;</span><br><span class="line">        int start = 0;</span><br><span class="line">        int end = a.length-1;</span><br><span class="line">        sort(a,start,end);</span><br><span class="line">        for(int i = 0; i&lt;a.length; i++)&#123;</span><br><span class="line">             System.out.println(a[i]);</span><br><span class="line">         &#125;</span><br><span class="line">        </span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     public void sort(int[] a,int low,int high)&#123;</span><br><span class="line">         int start = low;</span><br><span class="line">         int end = high;</span><br><span class="line">         int key = a[low];</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">         while(end&gt;start)&#123;</span><br><span class="line">             //从后往前比较</span><br><span class="line">             while(end&gt;start&amp;&amp;a[end]&gt;=key)  //如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较</span><br><span class="line">                 end--;</span><br><span class="line">             if(a[end]&lt;=key)&#123;</span><br><span class="line">                 int temp = a[end];</span><br><span class="line">                 a[end] = a[start];</span><br><span class="line">                 a[start] = temp;</span><br><span class="line">             &#125;</span><br><span class="line">             //从前往后比较</span><br><span class="line">             while(end&gt;start&amp;&amp;a[start]&lt;=key)//如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置</span><br><span class="line">                start++;</span><br><span class="line">             if(a[start]&gt;=key)&#123;</span><br><span class="line">                 int temp = a[start];</span><br><span class="line">                 a[start] = a[end];</span><br><span class="line">                 a[end] = temp;</span><br><span class="line">             &#125;</span><br><span class="line">         //此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，右边的值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用</span><br><span class="line">         &#125;</span><br><span class="line">         //递归</span><br><span class="line">         if(start&gt;low) sort(a,low,start-1);//左边序列。第一个索引位置到关键值索引-1</span><br><span class="line">         if(end&lt;high) sort(a,end+1,high);//右边序列。从关键值索引+1到最后一个</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C++代码：<br><a href="https://blog.csdn.net/liuchen1206/article/details/6954074" target="_blank" rel="noopener">cankao</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int array[]=&#123;34,65,12,43,67,5,78,10,3,70&#125;,k;</span><br><span class="line">int len=sizeof(array)/sizeof(int);</span><br><span class="line">cout&lt;&lt;&quot;The orginal arrayare:&quot;&lt;&lt;endl;</span><br><span class="line">for(k=0;k&lt;len;k++)</span><br><span class="line">cout&lt;&lt;array[k]&lt;&lt;&quot;,&quot;;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">quickSort(array,0,len-1);</span><br><span class="line">cout&lt;&lt;&quot;The sorted arrayare:&quot;&lt;&lt;endl;</span><br><span class="line">for(k=0;k&lt;len;k++)</span><br><span class="line">cout&lt;&lt;array[k]&lt;&lt;&quot;,&quot;;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void quickSort(int s[], int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">if (low&lt; high)</span><br><span class="line">&#123;      </span><br><span class="line">int i = low, j = high, x = s[low];</span><br><span class="line">while (i &lt; j)</span><br><span class="line">&#123;</span><br><span class="line">while(i &lt; j &amp;&amp; s[j]&gt;= x) // 从右向左找第一个小于x的数</span><br><span class="line">j--; </span><br><span class="line">if(i &lt; j)</span><br><span class="line">s[i++] = s[j];</span><br><span class="line">while(i &lt; j &amp;&amp; s[i]&lt; x) // 从左向右找第一个大于等于x的数</span><br><span class="line">i++; </span><br><span class="line">if(i &lt; j)</span><br><span class="line">s[j--] = s[i];</span><br><span class="line">&#125;</span><br><span class="line">s[i] = x;</span><br><span class="line">quickSort(s, low, i - 1); // 递归调用</span><br><span class="line">quickSort(s, i + 1, high);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><blockquote><p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。<br><br>分治思想：<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/guibing_1.png" alt=""><br>合并步骤如下<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/guibing_2.png" alt=""></p></blockquote><p>Java代码：<a href="https://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">cankao</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package sortdemo;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by chengxiao on 2016/12/8.</span><br><span class="line"> */</span><br><span class="line">public class MergeSort &#123;</span><br><span class="line">    public static void main(String []args)&#123;</span><br><span class="line">        int []arr = &#123;9,8,7,6,5,4,3,2,1&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    public static void sort(int []arr)&#123;</span><br><span class="line">        int []temp = new int[arr.length];//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span><br><span class="line">        sort(arr,0,arr.length-1,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    private static void sort(int[] arr,int left,int right,int []temp)&#123;</span><br><span class="line">        if(left&lt;right)&#123;</span><br><span class="line">            int mid = (left+right)/2;</span><br><span class="line">            sort(arr,left,mid,temp);//左边归并排序，使得左子序列有序</span><br><span class="line">            sort(arr,mid+1,right,temp);//右边归并排序，使得右子序列有序</span><br><span class="line">            merge(arr,left,mid,right,temp);//将两个有序子数组合并操作</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static void merge(int[] arr,int left,int mid,int right,int[] temp)&#123;</span><br><span class="line">        int i = left;//左序列指针</span><br><span class="line">        int j = mid+1;//右序列指针</span><br><span class="line">        int t = 0;//临时数组指针</span><br><span class="line">        while (i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">            if(arr[i]&lt;=arr[j])&#123;</span><br><span class="line">                temp[t++] = arr[i++];</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                temp[t++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(i&lt;=mid)&#123;//将左边剩余元素填充进temp中</span><br><span class="line">            temp[t++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        while(j&lt;=right)&#123;//将右序列剩余元素填充进temp中</span><br><span class="line">            temp[t++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        t = 0;</span><br><span class="line">        //将temp中的元素全部拷贝到原数组中</span><br><span class="line">        while(left &lt;= right)&#123;</span><br><span class="line">            arr[left++] = temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C++代码：<a href="https://www.cnblogs.com/orion7/p/8242774.html" target="_blank" rel="noopener">cankao</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=500000,INF=0x3f3f3f3f;</span><br><span class="line">int L[maxn/2+2],R[maxn/2+2];</span><br><span class="line">void merge(int a[],int n,int left,int mid,int right)</span><br><span class="line">&#123;</span><br><span class="line">    int n1=mid-left,n2=right-mid;</span><br><span class="line">    for(int i=0;i&lt;n1;i++)</span><br><span class="line">        L[i]=a[left+i];</span><br><span class="line">    for(int i=0;i&lt;n2;i++)</span><br><span class="line">        R[i]=a[mid+i];</span><br><span class="line">    L[n1]=R[n2]=INF;</span><br><span class="line">    int i=0,j=0;</span><br><span class="line">    for(int k=left;k&lt;right;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(L[i]&lt;=R[j])</span><br><span class="line">            a[k]=L[i++];</span><br><span class="line">        else</span><br><span class="line">            a[k]=R[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void mergesort(int a[],int n,int left,int right)</span><br><span class="line">&#123;</span><br><span class="line">    if(left+1&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        int mid=(left+right)/2;</span><br><span class="line">        mergesort(a,n,left,mid);</span><br><span class="line">        mergesort(a,n,mid,right);</span><br><span class="line">        merge(a,n,left,mid,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[maxn],n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    mergesort(a,n,0,n);</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i)</span><br><span class="line">            cout&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p> <a href="http://www.cnblogs.com/MOBIN/p/5374217.html" target="_blank" rel="noopener">http://www.cnblogs.com/MOBIN/p/5374217.html</a></p><blockquote><p>堆排序主要在于理解堆的构造过程和在输出最大元素后如何对堆进行重新调整</p></blockquote><p>大顶堆：父结点始终&gt;子节点<br><img src="https://images2015.cnblogs.com/blog/776259/201604/776259-20160410150915593-1435777167.png" alt="大顶堆"> </p><p>小顶堆：父结点始终&lt;子节点<br><img src="https://images2015.cnblogs.com/blog/776259/201604/776259-20160410150948406-1525110244.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">算法思想(以大顶堆为例)：</span><br><span class="line">1.将长度为n的待排序的数组进行堆有序化构造成一个大顶堆</span><br><span class="line">2.将根节点与尾节点交换并输出此时的尾节点</span><br><span class="line">3.将剩余的n -1个节点重新进行堆有序化</span><br><span class="line">4.重复步骤2，步骤3直至构造成一个有序序列</span><br></pre></td></tr></table></figure></p><p>我们开始只需要扫描一半的元素（n/2-1 ~ 0）,因为(n/2-1)~0的节点才有子节点<br><img src="https://images2015.cnblogs.com/blog/776259/201604/776259-20160410151057625-469827986.png" alt=""></p><p>构建有序堆：<br>1、第一次for循环将节点3和它的子节点7 8的元素进行比较，最大者作为父节点（即元素60作为父节点）<br>红色表示交换后的状态<br><img src="https://images2015.cnblogs.com/blog/776259/201604/776259-20160410151437250-974257904.png" alt=""><br>2、第二次for循环将节点2和它的子节点5 6的元素进行比较，最大者为父节点（元素80作为父节点）<br><img src="https://images2015.cnblogs.com/blog/776259/201604/776259-20160410151453015-690847102.png" alt=""><br>3、第三次for循环将节点1和它的子节点3 4的元素进行比较，最大者为父节点（元素70作为父节点）<br><img src="https://images2015.cnblogs.com/blog/776259/201604/776259-20160410151523218-139482913.png" alt=""></p><p>调整堆<br>1、堆顶元素80和尾40交换后—&gt;调整堆<br><img src="https://images2015.cnblogs.com/blog/776259/201604/776259-20160410151713156-328299797.png" alt=""><br>2、堆顶元素70和尾30交换后—&gt;调整堆<br><img src="https://images2015.cnblogs.com/blog/776259/201604/776259-20160410151728406-2042556892.png" alt=""><br>。。。<br>完成调整<br><img src="https://images2015.cnblogs.com/blog/776259/201604/776259-20160410151755062-2073568164.png" alt=""></p><p>左右父节点下标:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">左：i*2+1</span><br><span class="line">右：i*2+2</span><br><span class="line">父：(i-1)/2</span><br></pre></td></tr></table></figure></p><p>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class HeapSort &#123;</span><br><span class="line">private static void heapSort(int[] arr) &#123;</span><br><span class="line">int len = arr.length -1;</span><br><span class="line">//堆构造，调整结构，符合大顶堆或者小顶堆</span><br><span class="line">for(int i = len/2 ; i &gt;=0; i --)&#123; </span><br><span class="line">heapAdjust(arr,i,len);</span><br><span class="line">&#125;</span><br><span class="line">while (len &gt;=0)&#123;</span><br><span class="line">swap(arr,0,len--); //将堆顶元素与尾节点交换后，长度减1，尾元素最大</span><br><span class="line">heapAdjust(arr,0,len); //再次对堆进行调整</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void heapAdjust(int[] arr,int i,int len)&#123;</span><br><span class="line">int left = 2*i+1,right = 2*i+2,largest = i;</span><br><span class="line">if(left &lt;= len &amp;&amp; arr[left] &gt; arr[i])</span><br><span class="line">largest = left;</span><br><span class="line">if(right &lt;= len &amp;&amp; arr[right] &gt; arr[largest])</span><br><span class="line">largest = right;</span><br><span class="line">if(largest != i) &#123;</span><br><span class="line">swap(arr, i, largest);</span><br><span class="line">heapAdjust(arr,largest,len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void swap(int[] arr,int i,int len)&#123;</span><br><span class="line">int temp = arr[i];</span><br><span class="line">arr[i] = arr[len];</span><br><span class="line">arr[len] = temp;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int array[] = &#123;20,50,20,40,70,10,80,30,60&#125;;</span><br><span class="line">System.out.println(&quot;排序之前：&quot;);</span><br><span class="line">for(int element : array)&#123;</span><br><span class="line">System.out.print(element+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">heapSort(array);</span><br><span class="line">System.out.println(&quot;\n排序之后：&quot;);</span><br><span class="line">for(int element : array)&#123;</span><br><span class="line">System.out.print(element+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C++代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure></p><p>C++代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure></p><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>需要求数组中的最大数<br>1、桶排序不在是一种基于比较的排序方法，而是需要待排序列满足以下两个条件：</p><blockquote><p>1、待排序列的值处于一个可枚举的范围内<br><br>2、待排序列所在可枚举范围不应太大，不然开销会很大。</p></blockquote><p>原理：</p><blockquote><p>假设待排序的数组a中共有N个整数，并且已知数组a中数据的范围[0, MAX)。在桶排序时，创建容量为MAX的桶数组r，并将桶数组元素都初始化为0；将容量为MAX的桶数组中的每一个单元都看作一个”桶”。<br>在排序时，逐个遍历数组a，将数组a的值，作为”桶数组r”的下标。当a中数据被读取时，就将桶的值加1。例如，读取到数组a[3]=5，则将r[5]的值+1。</p></blockquote><p>桶排序适用场景:<br><br>根据桶排序的特点，桶排序一般适用于一些特定的环境，比如数据范围较为局限或者有一些特定的要求，比如需要通过哈希映射快速获取某些值，需要统计每个数的数量。但是这一切都以确认数据的范围为前提，如果范围跨度过大，则考虑用其他算法。</p><p>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 桶排序</span><br><span class="line">///</span><br><span class="line">///如果有重复的数字,则需要 List&lt;int&gt;数组,这里举的例子没有重复的数字</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;unsorted&quot;&gt;待排数组&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;maxNumber&quot;&gt;待排数组中的最大数,如果可以提供的话&lt;/param&gt;</span><br><span class="line">/// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">static int[] bucket_sort(int[] unsorted, int maxNumber = 97)</span><br><span class="line">&#123;</span><br><span class="line"> int[] sorted = new int[maxNumber + 1];</span><br><span class="line"> for (int i = 0; i &lt; unsorted.Length; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  sorted[unsorted[i]] = unsorted[i];</span><br><span class="line"> &#125;</span><br><span class="line"> return sorted;</span><br><span class="line">&#125;</span><br><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line"> int[] x = &#123;49、 38 、 35、 97 、 76、 73 、 27、 49 &#125;;</span><br><span class="line"> var sorted = bucket_sort(x, 97);</span><br><span class="line"> for (int i = 0; i &lt; sorted.Length; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  if (sorted[i] &gt; 0)</span><br><span class="line">   Console.WriteLine(sorted[i]);</span><br><span class="line"> &#125;</span><br><span class="line"> Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C++代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure></p><p>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure></p><p>C++代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure></p><p>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure></p><p>C++代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure></p><p>Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure></p><p>C++代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待补充</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经—机器学习</title>
      <link href="/2018/08/15/%E9%9D%A2%E7%BB%8F%E2%80%94%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/08/15/%E9%9D%A2%E7%BB%8F%E2%80%94%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>面经—机器学习</p><a id="more"></a><h2 id="CVTE面经"><a href="#CVTE面经" class="headerlink" title="CVTE面经"></a>CVTE面经</h2><p>作者：一一后<br>链接：<a href="https://www.nowcoder.com/discuss/88069" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/88069</a><br>来源：牛客网</p><p>1.解释方差</p><p>2.PCA的实现过程；推导PCA</p><p>3.传统的图像特征有哪些</p><p>4.Sift特征为什么能实现尺度不变性（讲sift原理到一半，我发现完全解释不了为啥尺度不变，就停了，尴尬）<br>[参考](<a href="https://blog.csdn.net/u014485485/article/details/78681086?locationNum=1&amp;fps=1）" target="_blank" rel="noopener">https://blog.csdn.net/u014485485/article/details/78681086?locationNum=1&amp;fps=1）</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">尺度不变性：</span><br><span class="line">不管原图尺度是多少，在包含了所有尺度的尺度空间下都能找到那些稳定的极值点，这样就做到了尺度不变！</span><br><span class="line">高斯函数是唯一可行的尺度空间核</span><br></pre></td></tr></table></figure></p><p>5.Hough直线检测的原理</p><p>6.梯度下降和牛顿法的区别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">牛顿法的优缺点</span><br><span class="line">优点：二阶收敛，收敛速度快；</span><br><span class="line">缺点：牛顿法是一种迭代算法，每一步都需要求解目标函数的Hessian矩阵的逆矩阵，计算比较复杂。</span><br><span class="line"></span><br><span class="line">梯度下降法的优化思想是用当前位置负梯度方向作为搜索方向，因为该方向为当前位置的最快下降方向，所以也被称为是”最速下降法“。最速下降法越接近目标值，步长越小，前进越慢</span><br><span class="line">梯度下降法的缺点：</span><br><span class="line">靠近极小值时收敛速度减慢，；</span><br><span class="line">直线搜索时可能会产生一些问题；</span><br><span class="line">可能会“之字形”地下降。</span><br><span class="line"></span><br><span class="line">牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快</span><br></pre></td></tr></table></figure></p><p>7.SVM和Lr的共同点和不同点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LR和SVM都是分类算法</span><br><span class="line">LR和SVM都是线性分类算法</span><br><span class="line">LR和SVM都是监督学习算法</span><br><span class="line">LR和SVM都是判别模型</span><br><span class="line">LR和SVM在学术界和工业界都广为人知并且应用广泛</span><br><span class="line"></span><br><span class="line">不同：</span><br><span class="line">损失函数</span><br><span class="line">LR：逻辑回归方法基于概率理论</span><br><span class="line">逻辑回归考虑全局（远离的点对边界线的确定也起作用）</span><br><span class="line">对数据不做处理</span><br><span class="line">LR必须另外在损失函数上添加正则项</span><br><span class="line"></span><br><span class="line">SVM：几何间隔最大化原理</span><br><span class="line">支持向量机只考虑局部的边界线附近的点，线性SVM不直接依赖于数据分布</span><br><span class="line">线性SVM依赖数据表达的距离测度，所以需要对数据先做归一化</span><br><span class="line">SVM的损失函数就自带正则</span><br></pre></td></tr></table></figure></p><p>8.rf和Adaboost的异同(优秀的基于决策树的组合算法)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1，相同：二者都是bootsrap自助法选取样本。 </span><br><span class="line">2，相同：二者都是要训练很多棵决策树。 </span><br><span class="line">3，不同：adaboost后面树的训练，其在变量抽样选取的时候，对于上一棵树分错的样本，抽中的概率会加大。 </span><br><span class="line">4，不同：随机森林在训练每一棵树的时候，随机挑选了部分变量作为拆分变量，而不是所有的变量都去作为拆分变量。 </span><br><span class="line">5，不同：在预测新数据时，adaboost中所有的树加权投票来决定因变量的预测值，每棵树的权重和错误率有关；随机森林按照所有树中少数服从多数树的分类值来决定因变量的预测值。</span><br></pre></td></tr></table></figure></p><p>9.给出一堆大小不一的矩形框，快速求矩形框的灰度值之和（当时没理解，这不是肯定要遍历么…后来结束后我想这些矩形框可能是重叠的，估计是要问我关于Bing中快速求梯度的算法）</p><p>10.有什么要问他的</p><h3 id="作业帮提前批机器学习算法岗"><a href="#作业帮提前批机器学习算法岗" class="headerlink" title="作业帮提前批机器学习算法岗"></a>作业帮提前批机器学习算法岗</h3><p>作者：编程一头牛<br>链接：<a href="https://www.nowcoder.com/discuss/90245" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/90245</a><br>来源：牛客网</p><p>对数据预处理怎么填充的缺失值，哪些判定为异常值，对连续属性进行离散化有什么好处，Logistic回归能处理浮点数吗？多项式组合特征对哪个模型中效果提升最大。这个没答上来，问了面试官，面试官说是Logistic回归里面提升最大，而且组合起来的两个特征也是想出来的，没什么理论支撑。还问了模型的评价指标AUC是如何计算的，ROC曲线的横纵坐标代表了什么含义。XGBoost模型里面参数有哪些？如何发现过拟合。XGBoost模型中对数据进行采样的好处？</p><p>如何最快的找出两个集合中的交集，提出用哈希表的方法，问了这种方法的复杂度，然后又问如果这两个集合都特别大，不能再内存中构建哈希表该如何做？可能是想让我回答多线程相关的内容，但是我不会。如何设计哈希表？期间也问过有编过多线程多进程的代码吗</p><h3 id="深信服【机器学习】一面"><a href="#深信服【机器学习】一面" class="headerlink" title="深信服【机器学习】一面"></a>深信服【机器学习】一面</h3><p>作者：Rnanprince<br>链接：<a href="https://www.nowcoder.com/discuss/87283" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/87283</a><br>来源：牛客网</p><p>【机器学习】一面：<br>1.项目介绍，研究的最成功的地方，我以写的文章为例，涉及到的知识点就问<br>2.笔试的数组求和100怎么做的？<br>没抽到这个题，但是做过；接着我说做了查找重复字符串最大长度，深搜，过了就没想别的方法<br>一个数组，求最长的连续子序列的起始下标，当时没理解明白，其实有歧义，简单说了一下<br>3.自己的哪些方面的优点没有涉及到，介绍一下<br>提到了SVM和决策树，介绍一下什么情况下使用？<br>svm:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">这个模型的优势是什么？</span><br><span class="line"></span><br><span class="line">分类效果好；</span><br><span class="line">可以有效地处理高维空间的数据；</span><br><span class="line">可以有效地处理变量个数大于样本个数的数据；</span><br><span class="line">只是使用了一部分子集来进行训练模型，所以SVM模型不需要太大的内存；</span><br><span class="line">可以提高泛化能力；</span><br><span class="line">无局部极小值问题；</span><br><span class="line">他什么情况下表现最好？</span><br><span class="line"></span><br><span class="line">数据的维度较高；</span><br><span class="line">需要模型具有非常强的泛化能力；</span><br><span class="line">样本数据量较小时；</span><br><span class="line">解决非线性问题；</span><br><span class="line">这个模型的缺点是什么？</span><br><span class="line"></span><br><span class="line">无法处理大规模的数据集，因为该算法需要较长的训练时间；</span><br><span class="line">无法有效地处理包含噪声太多的数据集；</span><br><span class="line">SVM模型没有直接给出概率的估计值，而是利用交叉验证的方式估计，这种方式耗时较长；</span><br><span class="line">对缺失数据非常敏感；</span><br><span class="line">对于非线性问题，有时很难找到一个合适的核函数。</span><br><span class="line">什么条件下它表现很差？</span><br><span class="line"></span><br><span class="line">数据集的数据量过大；</span><br><span class="line">数据集中的含有噪声；</span><br><span class="line">数据集中的缺失较多的数据；</span><br><span class="line">对算法的训练效率要求较高；</span><br><span class="line">根据我们当前数据集的特点，为什么这个模型适合这个问题。 </span><br><span class="line">该项目所提供的样本数据相对较少；</span><br><span class="line">该问题是属于非线性问题；</span><br><span class="line">数据集经过“独热编码”后，维度较高</span><br></pre></td></tr></table></figure></p><p>决策树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">这个模型的优势是什么？</span><br><span class="line"></span><br><span class="line">决策树易于实现和理解；</span><br><span class="line">对于决策树，数据的准备工作一般比较简单；</span><br><span class="line">能够同时处理多种数据类型</span><br><span class="line">给定一个决策树模型，可以根据产生的决策树推出相应的逻辑表达式；</span><br><span class="line">通过静态测试来对模型的表现进行评价；</span><br><span class="line">在相对较短的时间内可以对大量的数据做出非常好的结果；</span><br><span class="line">决策树可以很好地扩展到大型数据中，同时决策树的大小独立于数据库的大小；</span><br><span class="line">计算复杂度相对较低，结果的输出易于理解，对部分的数据缺失不敏感。</span><br><span class="line">他什么情况下表现最好？</span><br><span class="line"></span><br><span class="line">实例是由“属性-值”对表示的；</span><br><span class="line">目标函数具有离散的输出值；</span><br><span class="line">训练数据集包含部分错误(决策树对错误有适应性)；</span><br><span class="line">训练数据缺少少量属性的实例。</span><br><span class="line">这个模型的缺点是什么？</span><br><span class="line"></span><br><span class="line">易于出现过拟合问题；</span><br><span class="line">忽略了数据集中属性之间的相关性；</span><br><span class="line">对于类比不一致的样本，决策树的信息增益倾向于那些数据值较多的特征</span><br><span class="line">什么条件下它表现很差？</span><br><span class="line"></span><br><span class="line">决策树匹配的数据过多时；</span><br><span class="line">分类的类别过于复杂；</span><br><span class="line">数据的属性之间具有非常强的关联。</span><br><span class="line">根据我们当前数据集的特点，为什么这个模型适合这个问题。</span><br><span class="line"></span><br><span class="line">不需要准备太多的训练数据，不需要对数据过多的处理如删除空白值等；</span><br><span class="line">易于编码；</span><br><span class="line">该问题是非线性问题，决策树能够很好地解决非线性问题；</span><br><span class="line">算法的执行效率高，对机器的要求较小。</span><br></pre></td></tr></table></figure></p><h3 id="360浏览器事业部-推荐算法工程师"><a href="#360浏览器事业部-推荐算法工程师" class="headerlink" title="360浏览器事业部 推荐算法工程师"></a>360浏览器事业部 推荐算法工程师</h3><p>作者：泡了个泡<br>链接：<a href="https://www.nowcoder.com/discuss/77924" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/77924</a><br>来源：牛客网</p><p>二面</p><p>1.项目</p><p>2.SVM原始问题为什么要转化为对偶问题，为什么对偶问题就好求解，原始问题不能求解么</p><p>3.K-means 中我想聚成100类 结果发现只能聚成98类，为什么</p><p>4.进程中的内存分段是怎样的</p><p>5.每个线程有哪些东西是自己独享的</p><p>6.一枚不均匀的硬币，我抛了100次，有70次朝上，那么第101次朝上的概率是多少</p><p>这个概率怎么样，公示是如何推导出来的</p><p>7.给你个字符串，字符串是个数字，怎么转换为int型，不用库函数的话</p><p>8.4个海盗，100个金币，每个人轮流提方案，如果你的方案有半数以上通过，那么久可以，否则就会被杀掉，如果你是第一个人，那么你怎么提方案比较好</p><p>9.你的优点是什么</p><h3 id="腾讯沈阳现场一面"><a href="#腾讯沈阳现场一面" class="headerlink" title="腾讯沈阳现场一面"></a>腾讯沈阳现场一面</h3><p>1.项目</p><p>2.特征选择方法都有用过哪些</p><p>3.随机森林怎么进行特征选择</p><p>4.用过哪些机器学习算法</p><p>5.加密方法知道哪些</p><p>6.MD5可逆么</p><p>7.word2vec用过么</p><p>8.极大似然估计是什么意思</p><p>9.上过哪些课</p><p>10.排序算法哪些时间复杂度比较低</p><p>11.计算机网络了解多少</p><h3 id="阿里-新零售-天猫-算法工程师-机器学习"><a href="#阿里-新零售-天猫-算法工程师-机器学习" class="headerlink" title="阿里 新零售 天猫 算法工程师-机器学习"></a>阿里 新零售 天猫 算法工程师-机器学习</h3><p>一面<br>先是一个简单的自我介绍；<br>1.然后介绍了项目的框架和主要创新点；</p><p>2.说一下随机森林和Adaboost，以及区别</p><p>3.说一下GBDT和Adaboost，以及区别</p><p>4.说一下LDA的原理</p><p>5.对于PCA，会有第一主成分、第二主成分，怎么为什么第一主成分是第一，原因是什么？</p><p>6.PCA的主成分是怎么得到的</p><p>3.面向对象的三要素</p><p>4.对深度学习了解多少</p><p>5.你觉得深度学习的方法和传统机器学习比，有什么大的优势</p><h3 id="腾讯提前批"><a href="#腾讯提前批" class="headerlink" title="腾讯提前批"></a>腾讯提前批</h3><p>作者：IamBright<br>链接：<a href="https://www.nowcoder.com/discuss/75166" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/75166</a><br>来源：牛客网</p><p>女朋友在广州又不想换工作的情况下，微信的机器学习算法工程师是最适合我实习的岗位了，因此最先让腾讯的同学内推了一波，在基本没有准备的情况下，接到了提前批电话一面二面，毫无意外的挂了。</p><p>电话一面<br>聊论文，但多数听我在说，没插话什么问题。最后问我第二篇论文里RNN实现的时候有什么trick。<br>问了问凸优化了解吗？传统机器学习了解吗？我答机器学习基本知识都学过，凸优化只了解和机器学习优化算法相关的。也没有继续问细节了。<br>编程题：打印所有子集，我用了迭代，但是写的比较蠢，好在不用调试运行<br>电话二面<br>聊论文，最后问了我跟什么算法做了对比，问我研究的实际意义，产业界现在的水平<br>编程题：打印螺旋矩阵，要我给一个可运行的结果。很简单的题，我一个符号错误调了很久都没发现，这里应该就印象很差了。<br>linux里查看端口被占用的命令，linux不熟，没答上。<br>AUC是什么？我说了是ROC曲线下面积，但是想不起来ROC是啥。我都是做序列数据，没做过二分类问题。<br>LR和SVM的区别。我说了损失函数不同，然后说了SVM通过核技巧可以更好的应对非线性，但是前面好差，这里也没好好组织语言了。<br>提前批挂的没什么话说，就是没准备，好久没做过算法题的情况下，突然出题做就很不顺手。而且机器学习的基础知识都有点忘了，像AUC这种没用过的，基本一问就懵逼。</p><p>之后跟工作的同学聊了一下，来牛客刷了刷面经，制定了简单的复习内容和刷题计划。花了一周时间，复习了一下西瓜书前11章和deep learning book前11章，刷了leetcode上三四十道medium的题吧（链表、字符串、迭代、dfs、堆、树、动态规划等每天刷一类题练练手），并且给自己做完2篇论文都准备了面试介绍版，又让同学推了阿里和网易，并进入腾讯笔试流程。</p><h3 id="算法、数据挖掘岗面经"><a href="#算法、数据挖掘岗面经" class="headerlink" title="算法、数据挖掘岗面经"></a>算法、数据挖掘岗面经</h3><p>作者：胖胖胖子<br>链接：<a href="https://www.nowcoder.com/discuss/81814" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/81814</a><br>来源：牛客网</p><p>1.华为<br>回国之后参加的第一次面试就是华为的留学生专场招聘，岗位是大数据开放（华为好像填什么岗位都没差吧~），一共只有两面<br>一面：介绍我的项目经历，我介绍完面试官尴尬的笑了笑说他不是做大数据方向的，也就没问我什么，聊了聊天愉快的过了<br>二面：可能会针对笔试提问，因为面试官问我为什么没参加笔试，然后就问了问职业规划，说大数据方向都在深圳工作，然后就一直问怎么看待华为的加班文化，怎么看待压力之类的<br>大概10天之后就直接把offer发到了邮箱里<br>2.第四范式（二面挂）<br>刚面完华为就参加了第四范式的面试，以为面试就是聊聊天，后来发现真是naive，第四范式的岗位是nlp研究员<br>一面：就写了两个代码，一个是逆时针打印矩阵，一个是leetcode原题count and say，虽然当时还没刷过题但写的都是easy难度，就过了<br>二面：二面面试官是牛津大学的phd，问我是不是distinction我说不是，就感受到了一股失望~讲了讲项目，问的很细，但是都在自己的项目范围内，问完之后又是写代码，一个字符串如何删除不匹配的括号然后输出括号匹配的字符串，比如（abc（），输出（abc）和abc（），哼哼唧唧没写出来就跪了<br>3.招银网络<br>招银网络面试岗位是算法工程师，一共两轮技术面，一轮hr面<br>一面：讲项目，问了决策树ID3，C4.5，CART的区别，讲了SVM的原理，然后写了找两个数的最小公倍数的代码<br>二面：讲项目，然后面试官说他是做C++开发的，问我会不会C++，我说学过但很久没用了，就聊了聊天愉快的过了<br>hr面：略（就谈人生谈理想接不接受调岗）</p><ol><li>平安科技<br>招银网络面试岗位是算法工程师，一共两轮技术面，一轮hr面<br>一面：讲项目，问了问当时爬虫有没有用什么框架，然后问为什么文本分类我选择了朴素贝叶斯，然后让我说了一下对word2vec的理解<br>二面：最痛的一次面试，三个面试官，一个问数据结构和数据库：问我知道的数据结构和使用场景，然后口述怎么把单链表变双向链表，讲了一下红黑树，以及红黑树的应用，数据的范式，索引失效的情况，如何优化数据库性能等等。第二个面试官问操作系统和计算机网络：TCP三次握手，四次挥手，第二次挥手和第三次挥手的时间间隔如何界定，TCP拥塞控制，OSI五层模型，每层有什么协议，TCP和UDP的区别，UDP的应用（这个问题我没太理解），ARP协议，python多线程，python3对python2是否有改进。第三个面试官问设计模式和算法：python闭包，bagging/boosting的区别，XGboost特点，tf-idf缺点，单例模式（设计模式我完全不会），怎样设计一个分布式的爬虫。<br>hr面：大概聊了聊对薪资的期望，和工作的部门<br>5.链家<br>链家是参加了牛客的留学生专场，感觉链家的面试官人真的好~岗位是机器学习/数据挖掘工程师，不过链家面试有点坎坷面完前两面才发现我面的大数据开发，其实我想去的是数据挖掘，然后就开始了第三轮面试<br>一面：先写了一个很简单的判断两个二叉树是不是一样的树，然后就说给一台机器内存有限制，然后10台服务器，每个服务器上有一个1G文件，假设文件里单词，如何给这些单词按频率排序，又问了求数据流的中位数，最后是智力题，给你两个一模一样的杯子，假设一共有10层楼，怎样找到杯子摔下来能不碎的最高楼层。<br>二面：面试官先问我职业规划，我说数据挖掘，他就比较懵说他们是大数据开发部门，问我考不考虑，我说还是倾向于做数据挖掘，就开始了面试，问了数据库索引的优缺点，索引失效的情况，然后复合索引如何引用会失效，然后问了ACID，剩下的记不清了，说我基础不错去给我联系数据挖掘的面试官<br>三面：手写LR损失函数，LR/SVM区别，手画word2vec网络结构，bagging，boosting，stacking的区别和联系，如果RF和GBDT达到同样的准确度哪个分裂的树更少为什么，随机梯度下降和梯度下降哪一个更快，XGBoost特点，XGBoost的L1和L2正则化怎么体现，特征工程相关的卡方统计和互信息计算公式，然后写了一个如何用最少的硬币找钱。<br>HR面：介绍了一下链家的福利和部门的发展。<br>6.快手<br>快手4.18的笔试，5.5面试大概是备胎池捞起来了，三轮技术面，一轮hr面<br>一面：介绍项目，边讲项目边提问，然后写了个代码，判断有向图中是否有环<br>二面：介绍项目，边讲项目边提问，问了文本分类问什么朴素贝叶斯比SVM，决策树效果更好，然后分类性能度量，precision，recall，F1 score和ROC AUC对比，写了一个leetcode的flatten nested list iterator<br>三面：只写代码，第一个AABB的字符串输出AB，第二个找数组的最长递增子序列，然后介绍了一下他们做的东西<br>HR面：谈了谈offer</li></ol><h3 id="顺丰提前批人工智能岗技术面面经"><a href="#顺丰提前批人工智能岗技术面面经" class="headerlink" title="顺丰提前批人工智能岗技术面面经"></a>顺丰提前批人工智能岗技术面面经</h3><p>作者：撒泼打滚求Offer<br>链接：<a href="https://www.nowcoder.com/discuss/92370" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/92370</a><br>来源：牛客网</p><ol><li>目标检测了解吗，（了解一点）Faster RCNN跟RCNN有什么区别</li><li>SPP， YOLO了解吗（不了解）（后悔没去看看= =）</li><li>梯度消失梯度爆炸怎么解决</li><li>RNN容易梯度消失，怎么解决（LSTM）</li><li>LSTM跟RNN有啥区别</li><li>传统的机器学习算法了解吗（不怎么了解，说了个KMeans）</li><li>KMeans讲讲，KMeans有什么缺点，K怎么确定（不会）</li><li>卷积层和池化层有什么区别（不是很懂这个问题的点）</li><li><p>防止过拟合有哪些方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、正则化，即在对模型的目标函数（objective function）或代价函数（cost function）加上正则项</span><br><span class="line">  随着模型训练的进行，模型的复杂度会增加，此时模型在训练数据集上的训练误差会逐渐减小，但是在模型的复杂度达到一定程度时，模型在验证集上的误差反而随着模型的复杂度增加而增大。此时便发生了过拟合，即模型的复杂度升高。</span><br><span class="line"></span><br><span class="line">1、early stopping、</span><br><span class="line">    迭代次数（epochs）截断的方法（常用 梯度下降法）；</span><br><span class="line">    训练数据一次遍历结束，计算指标，指标不增加，停止训练；</span><br><span class="line">    记录一个最好的指标，如果之后的10次，20次训练达到的指标都没有之前最好的高，则停止训练。</span><br><span class="line">2、数据增强（Data augmentation）、</span><br><span class="line">    从数据源采集更多数据 </span><br><span class="line">    复制原有数据并加上随机噪声 </span><br><span class="line">    重采样 </span><br><span class="line">    根据当前数据集估计数据分布参数，使用该分布产生更多数据等</span><br><span class="line">3、正则化（Regularization）、</span><br><span class="line">    正则化方法是指在进行目标函数或代价函数优化时，在目标函数或代价函数后面加上一个正则项，一般有L1正则与L2正则等。</span><br><span class="line">4、Dropout</span><br></pre></td></tr></table></figure></li><li><p>dropout咋回事讲讲</p></li><li>你有什么要问我的吗</li></ol><h3 id="联影医疗-Offer"><a href="#联影医疗-Offer" class="headerlink" title="联影医疗  Offer"></a>联影医疗  Offer</h3><p>作者：吃饭睡觉编论文<br>链接：<a href="https://www.nowcoder.com/discuss/52357" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/52357</a><br>来源：牛客网</p><p>联影医疗  Offer<br>一面<br>1、GBDT和xgboost的区别<br>2、GBDT和LR的区别<br>3、讲项目（为什么用GBDT LR？）<br>4、随便讲一个熟悉的传统图像处理中的特征提取和描述子（sift和sift描述子）<br>二面<br>1、写代码：实现统计图像灰度直方图的代码<br>2、熟悉的聚类算法、k-means原理、混合高斯模型原理<br>3、PCA原理、数学解释（应该是一个最优的线性子空间）<br>4、surf相比sift特征点的优化之处<br>5、写代码：dijkstra最短路径算法<br>6、SVM原理、过拟合怎么解决<br>7、霍夫变换检测直线和圆的原理<br>HR面<br>个人优缺点、拿到的offer、期望薪资、是不是独生子、对联影医疗的了解</p><h3 id="VIVO算法"><a href="#VIVO算法" class="headerlink" title="VIVO算法"></a>VIVO算法</h3><p>作者：MadCoder<br>链接：<a href="https://www.nowcoder.com/discuss/94110" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/94110</a><br>来源：牛客网</p><p>1.评估指标<br>2.在AUC值大时，Log损失也大。请问可能的原因<br>3.梯度消失，梯度爆炸原因及解决<br>4.概率题：8支球队循环赛，前四名晋级。求晋级可能性<br>5.Spark和hadoop实现K-MEANS，及优劣比较</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔面试 </tag>
            
            <tag> C++ </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git_update_error1</title>
      <link href="/2018/08/01/git_update_error1/"/>
      <url>/2018/08/01/git_update_error1/</url>
      
        <content type="html"><![CDATA[<p>git 上传报错及解决<br><a id="more"></a></p><h2 id="failed-to-push-some-refs-to"><a href="#failed-to-push-some-refs-to" class="headerlink" title="failed to push some refs to"></a>failed to push some refs to</h2><p>报错内容，不能推送文件到github上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: failed to push some refs to github地址</span><br></pre></td></tr></table></figure></p><p>原因是github项目与本地文件夹一些关键文件的确实，比如.git，readme.md文件等等</p><h2 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h2><p>本地文件夹打开控制命令台 </p><p>1、添加本地文件夹，github项目更新到本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></p><p>2、再上传文件夹到github<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></p><h2 id="fatal-The-remote-end-hung-up-unexpectedly"><a href="#fatal-The-remote-end-hung-up-unexpectedly" class="headerlink" title="fatal: The remote end hung up unexpectedly"></a>fatal: The remote end hung up unexpectedly</h2><p>git推送项目时候出现 “fatal: The remote end hung up unexpectedly ” 原因是推送的文件太大。</p><p>上传网速过慢导致文件传输不完整</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>等一会，重新在push上传一遍 </p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用LaTex添加公式到Hexo博客里</title>
      <link href="/2018/07/23/hexo_LaTex1/"/>
      <url>/2018/07/23/hexo_LaTex1/</url>
      
        <content type="html"><![CDATA[<p>使用LaTex添加公式到Hexo博客里</p><a id="more"></a><font color="blue">代码编辑器，强烈推荐使用微软的 VS code，相比Atom开启迅速，使用方便，扩展丰富</font><h2 id="第一步：-安装Kramed"><a href="#第一步：-安装Kramed" class="headerlink" title="第一步： 安装Kramed"></a>第一步： 安装Kramed</h2><p>hexo 默认的渲染引擎是 marked，但是 marked 不支持 mathjax。，所以需要更换Hexo的markdown渲染引擎为hexo-renderer-kramed引擎，后者支持mathjax公式输出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.nos-eastchina1.126.net/hexo-math1.png" alt=""></p><h2 id="第二步：更改文件配置"><a href="#第二步：更改文件配置" class="headerlink" title="第二步：更改文件配置"></a>第二步：更改文件配置</h2><p>打开<code>/node_modules/hexo-renderer-kramed/lib/renderer.js</code>，更改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Change inline math rule</span><br><span class="line">function formatText(text) &#123;</span><br><span class="line">    // Fit kramed&apos;s rule: $$ + \1 + $$</span><br><span class="line">    return text.replace(/`\$(.*?)\$`/g, &apos;$$$$$1$$$$&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">为，直接返回text</span><br><span class="line"></span><br><span class="line">// Change inline math rule</span><br><span class="line">function formatText(text) &#123;</span><br><span class="line">    return text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.nos-eastchina1.126.net/hexo-math4.png" alt=""></p><h2 id="第三步-停止使用-hexo-math，并安装mathjax包"><a href="#第三步-停止使用-hexo-math，并安装mathjax包" class="headerlink" title="第三步: 停止使用 hexo-math，并安装mathjax包"></a>第三步: 停止使用 hexo-math，并安装mathjax包</h2><p>卸载hexo-math<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-math --save</span><br></pre></td></tr></table></figure></p><p>安装 hexo-renderer-mathjax 包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-mathjax --save</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.nos-eastchina1.126.net/hexo-math2.png" alt=""><br><img src="https://img-blog.nos-eastchina1.126.net/hexo-math3.png" alt=""></p><h2 id="第四步-更新-Mathjax-的-配置文件"><a href="#第四步-更新-Mathjax-的-配置文件" class="headerlink" title="第四步: 更新 Mathjax 的 配置文件"></a>第四步: 更新 Mathjax 的 配置文件</h2><p>打开<code>/node_modules/hexo-renderer-mathjax/mathjax.html</code><br>如图所示更改<code>&lt;script&gt;</code>为：<br>即注释掉<code>&lt;script&gt;</code>代码，并把以下代码复制到对应位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.nos-eastchina1.126.net/hexo-math5.png" alt=""></p><h2 id="第五步-更改默认转义规则"><a href="#第五步-更改默认转义规则" class="headerlink" title="第五步: 更改默认转义规则"></a>第五步: 更改默认转义规则</h2><p>因为LaTeX与markdown语法有语义冲突，所以 hexo 默认的转义规则会将一些字符进行转义，所以我们需要对默认的规则进行修改.<br> 打开<code>/node_modules\kramed\lib\rules\inline.js</code><br> 1、<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span><br></pre></td></tr></table></figure></p><p>更改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">escape: /^\\([`*\[\]()# +\-.!_&gt;])/,</span><br></pre></td></tr></table></figure></p><p>2、<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure></p><p>更改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.nos-eastchina1.126.net/hexo-math6.png" alt=""></p><h2 id="第六步-开启mathjax"><a href="#第六步-开启mathjax" class="headerlink" title="第六步: 开启mathjax"></a>第六步: 开启mathjax</h2><p>打开<code>/themes/yilia</code>主题目录下的<code>config.yml</code>文件<br>因为我用的<code>yilia</code>主题，所以路径是<code>/themes/yilia</code></p><p>我们需要在<code>config.yml</code>文件 中开启 Mathjax， 找到 mathjax 字段添加如下代码：(不同的主题配置方法略微有区别)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mathjax:</span><br><span class="line">    enable: true</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mathjax: true</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.nos-eastchina1.126.net/hexo-math7.png" alt=""></p><p><font color="red" size="2">注意的是：，无论是配置文件还是博客文件，配置项跟配置参数均有有一个空格，否则会配置失败</font><br><br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mathjax: true（mathjax:空格true）</span><br><span class="line">而不是</span><br><span class="line">mathjax:true（mathjax:true）</span><br></pre></td></tr></table></figure></p><p>写博客文件时，要开启 <code>Mathjax</code>选项，， 添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mathjax: true</span><br></pre></td></tr></table></figure><p>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 特征提取——局部特征</span><br><span class="line">date: 2018-07-16 09:39:40</span><br><span class="line">tags: [GitHub, Mysql]</span><br><span class="line">mathjax: true</span><br></pre></td></tr></table></figure></p><p>如下图所示</p><p><img src="https://img-blog.nos-eastchina1.126.net/hexo-math7.5.png" alt=""></p><p>通过以上步骤，我们就可以在 hexo 中使用 Mathjax 来书写数学公式。</p><p>效果展示：</p><p><img src="https://img-blog.nos-eastchina1.126.net/hexo-math8.png" alt=""></p><p><img src="https://img-blog.nos-eastchina1.126.net/hexo-math9.png" alt=""></p><p><a href="https://blog.csdn.net/crazy_scott/article/details/79293576" target="_blank" rel="noopener">参考文章1</a><br><a href="https://www.jianshu.com/p/a0aa94ef8ab2" target="_blank" rel="noopener">参考文章2</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_最优化_损失函数</title>
      <link href="/2018/07/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%9C%80%E4%BC%98%E5%8C%96_%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
      <url>/2018/07/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%9C%80%E4%BC%98%E5%8C%96_%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>机器学习<em>最优化</em>损失函数</p><a id="more"></a><p>通常机器学习每一个算法中都会有一个目标函数，算法的求解过程是通过对这个目标函数优化的过程。</p><p>在分类或者回归问题中，通常使用<strong>损失函数（代价函数）</strong>作为其目标函数。损失函数用来评价模型的预测值和真实值不一样的程度，损失函数越好，通常模型的性能越好。不同的算法使用的损失函数不一样。 </p><blockquote><p>损失函数分为经验风险损失函数和结构风险损失函数</p></blockquote><div class="table-container"><table><thead><tr><th>损失函数</th><th>概念</th></tr></thead><tbody><tr><td>经验风险损失函数</td><td>预测结果和实际结果的差别</td></tr><tr><td>结构风险损失函数</td><td>经验风险损失函数+正则项</td></tr></tbody></table></div><script type="math/tex; mode=display">θ^∗=argmin(1/N)\sum_i=1^n\L(y_i,f(x_i;θ_i))\+λ\phi(\theta)</script><h3 id="0-1损失函数和绝对值损失函数"><a href="#0-1损失函数和绝对值损失函数" class="headerlink" title="0-1损失函数和绝对值损失函数"></a>0-1损失函数和绝对值损失函数</h3><p>原理：预测值和目标值不相等为1，否则为0。<br>绝对值损失函数为：<br></p><script type="math/tex; mode=display">L(Y,f(X))=1, if Y≠f(X)</script><script type="math/tex; mode=display">L(Y,f(X))=0, if Y=f(X)</script><p>感知机就是用的这种损失函数<br><br>改进：Y-f(X)&lt;阈值T判断相等<br>绝对值损失函数为： </p><script type="math/tex; mode=display">L(Y,f(X)=|Y−f(X)|</script><h3 id="log对数损失函数"><a href="#log对数损失函数" class="headerlink" title="log对数损失函数"></a>log对数损失函数</h3><p>原理：假设样本服从伯努利分布（0-1）分布，然后求得满足该分布的似然函数，接着用对数求极值。<br><br>log损失函数的标准形式： <br></p><script type="math/tex; mode=display">L(Y,P(Y|X))=−logP(Y|X)</script><h3 id="平方损失函数"><a href="#平方损失函数" class="headerlink" title="平方损失函数"></a>平方损失函数</h3><p>最小二乘法是线性回归的一种方法，它将回归的问题转化为了凸优化的问题。最小二乘法的基本原则是：最优拟合曲线应该使得所有点到回归直线的距离和最小。通常用欧几里得距离进行距离的度量。<br>平方损失的损失函数为： <br></p><script type="math/tex; mode=display">L(Y|f(X))=∑N(Y−f(X))^2</script><h3 id="指数损失函数"><a href="#指数损失函数" class="headerlink" title="指数损失函数"></a>指数损失函数</h3><p>AdaBoost就是一指数损失函数为损失函数的。<br>指数损失函数的标准形式： <br></p><script type="math/tex; mode=display">L(Y|f(X))=exp[−yf(x)]</script><h3 id="Hinge损失函数"><a href="#Hinge损失函数" class="headerlink" title="Hinge损失函数"></a>Hinge损失函数</h3><p>Hinge损失函数和SVM是息息相关的。在线性支持向量机中，最优化问题可以等价于<br> </p><p><script type="math/tex">1/m\sum_i=1^m\l(wx_i+by_i)+||w||^2</script><br><br>其中<script type="math/tex">l(wx_i+by_i)</script> 就是hinge损失函数，后面相当于L2正则项。 </p><p>Hinge函数的标准形式： <br></p><p><script type="math/tex">L(y)=max(0,1−ty)</script><br></p><blockquote><p>y的值在-1和+1之间就可以了,使分类器可以更专注于整体的分类误差</p></blockquote><p><a href="https://blog.csdn.net/weixin_37933986/article/details/68488339" target="_blank" rel="noopener">参考文章</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 最优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_分类_adaboost</title>
      <link href="/2018/07/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_adaboost/"/>
      <url>/2018/07/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_adaboost/</url>
      
        <content type="html"><![CDATA[<p>机器学习_分类_adaboost</p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Boosting, 也称为增强学习或提升法，是一种重要的集成学习技术， 能够将预测精度仅比随机猜度略高的弱学习器增强为预测精度高的强学习器。</p><blockquote><p>AdaBoost是英文”Adaptive Boosting”（自适应增强）的缩写</p></blockquote><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）首先，是初始化训练数据的权值分布D1。假设有N个训练样本数据，则每一个训练样本最开始时，都被赋予相同的权值：w1=1/N。</span><br><span class="line">2）然后，训练弱分类器hi。具体训练过程中是：如果某个训练样本点，被弱分类器hi准确地分类，那么在构造下一个训练集中，它对应的权值要减小；相反，如果某个训练样本点被错误分类，那么它的权值就应该增大。权值更新过的样本集被用于训练下一个分类器，整个训练过程如此迭代地进行下去。</span><br><span class="line">3）最后，将各个训练得到的弱分类器组合成一个强分类器。各个弱分类器的训练过程结束后，加大分类误差率小的弱分类器的权重，使其在最终的分类函数中起着较大的决定作用，而降低分类误差率大的弱分类器的权重，使其在最终的分类函数中起着较小的决定作用。</span><br></pre></td></tr></table></figure><blockquote><p>误差率低的弱分类器在最终分类器中占的权重较大，否则较小。</p></blockquote><p>alpha值是基于每个弱分类器的错误率进行计算,计算出alpha值之后，可以对权重向量进行更新，以使得那些正确分类的样本的权重降低而错分样本的权重升高，直到错误率为0或者弱分类器的数目达到用户的指定值为止</p><h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/adaboost_liucheng1.png" alt=""></p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/adaboost_liucheng2.png" alt=""></p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/adaboost_liucheng3.png" alt=""></p><p><a href="https://blog.csdn.net/guyuealian/article/details/70995333" target="_blank" rel="noopener">参考文章地址</a></p><p><a href="https://blog.csdn.net/v_july_v/article/details/40718799" target="_blank" rel="noopener">参考文章</a></p><p>数据分类模型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;opencv2/core/core.hpp&quot;  </span><br><span class="line">#include &quot;opencv2/highgui/highgui.hpp&quot;  </span><br><span class="line">#include &quot;opencv2/imgproc/imgproc.hpp&quot;  </span><br><span class="line">#include &quot;opencv2/ml/ml.hpp&quot;  </span><br><span class="line">  </span><br><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">using namespace cv;  </span><br><span class="line">using namespace std;  </span><br><span class="line">  </span><br><span class="line">int main( int argc, char** argv )  </span><br><span class="line">&#123;     </span><br><span class="line">    //训练样本  </span><br><span class="line">    float trainingData[42][2]=&#123; &#123;40, 55&#125;,&#123;35, 35&#125;,&#123;55, 15&#125;,&#123;45, 25&#125;,&#123;10, 10&#125;,&#123;15, 15&#125;,&#123;40, 10&#125;,  </span><br><span class="line">                            &#123;30, 15&#125;,&#123;30, 50&#125;,&#123;100, 20&#125;,&#123;45, 65&#125;,&#123;20, 35&#125;,&#123;80, 20&#125;,&#123;90, 5&#125;,  </span><br><span class="line">                            &#123;95, 35&#125;,&#123;80, 65&#125;,&#123;15, 55&#125;,&#123;25, 65&#125;,&#123;85, 35&#125;,&#123;85, 55&#125;,&#123;95, 70&#125;,  </span><br><span class="line">                            &#123;105, 50&#125;,&#123;115, 65&#125;,&#123;110, 25&#125;,&#123;120, 45&#125;,&#123;15, 45&#125;,  </span><br><span class="line">                            &#123;55, 30&#125;,&#123;60, 65&#125;,&#123;95, 60&#125;,&#123;25, 40&#125;,&#123;75, 45&#125;,&#123;105, 35&#125;,&#123;65, 10&#125;,  </span><br><span class="line">                            &#123;50, 50&#125;,&#123;40, 35&#125;,&#123;70, 55&#125;,&#123;80, 30&#125;,&#123;95, 45&#125;,&#123;60, 20&#125;,&#123;70, 30&#125;,  </span><br><span class="line">                            &#123;65, 45&#125;,&#123;85, 40&#125;   &#125;;  </span><br><span class="line">    Mat trainingDataMat(42, 2, CV_32FC1, trainingData);   </span><br><span class="line">    //训练样本的响应值  </span><br><span class="line">    float responses[42] = &#123;&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,  </span><br><span class="line">                            &apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,  </span><br><span class="line">                        &apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos; &#125;;  </span><br><span class="line">    Mat responsesMat(42, 1, CV_32FC1, responses);  </span><br><span class="line">  </span><br><span class="line">    float priors[2] = &#123;1, 1&#125;;    //先验概率  </span><br><span class="line">  </span><br><span class="line">    CvBoostParams params( CvBoost::REAL, // boost_type    </span><br><span class="line">                          10, // weak_count    </span><br><span class="line">                          0.95, // weight_trim_rate    </span><br><span class="line">                          15, // max_depth    </span><br><span class="line">                          false, // use_surrogates    </span><br><span class="line">                          priors // priors   </span><br><span class="line">                          );    </span><br><span class="line">  </span><br><span class="line">    CvBoost boost;  </span><br><span class="line">    boost.train (   trainingDataMat,   </span><br><span class="line">                    CV_ROW_SAMPLE,   </span><br><span class="line">                    responsesMat,  </span><br><span class="line">                    Mat(),    </span><br><span class="line">                    Mat(),  </span><br><span class="line">                    Mat(),  </span><br><span class="line">                    Mat(),    </span><br><span class="line">                    params  </span><br><span class="line">                    );    </span><br><span class="line">    //预测样本  </span><br><span class="line">    float myData[2] = &#123;55, 25&#125;;  </span><br><span class="line">    Mat myDataMat(2, 1, CV_32FC1, myData);  </span><br><span class="line">    double r = boost.predict( myDataMat );  </span><br><span class="line">  </span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;&quot;result:  &quot;&lt;&lt;(char)r&lt;&lt;endl;  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>基于的OpenCV的检测Demo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;opencv/highgui.h&gt;</span><br><span class="line">#include &lt;opencv/cv.h&gt;</span><br><span class="line">#include &lt;opencv2/imgproc/imgproc_c.h&gt;</span><br><span class="line">#include &lt;opencv2/objdetect/objdetect.hpp&gt;</span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    CascadeClassifier stFaceCascade;</span><br><span class="line">    IplImage *pstImage = NULL;</span><br><span class="line">    std::vector&lt;Rect&gt; faceRects;</span><br><span class="line"></span><br><span class="line">    if( !stFaceCascade.load(&quot;D:\\ProgramFiles\\develop\\opencv2.4.8\\sources\\data\\lbpcascades\\lbpcascade_frontalface.xml&quot;) )</span><br><span class="line">    &#123; </span><br><span class="line">        printf(&quot;Loading cascade error\n&quot;); </span><br><span class="line">        return -1; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pstImage = cvLoadImage(&quot;D:\\test.jpg&quot;, CV_LOAD_IMAGE_COLOR);</span><br><span class="line"></span><br><span class="line">    stFaceCascade.detectMultiScale(pstImage, </span><br><span class="line">        faceRects,            //检出结果</span><br><span class="line">        1.1,                  //缩放步长</span><br><span class="line">        2,                    //框融合时的最小检出个数</span><br><span class="line">        0|CV_HAAR_SCALE_IMAGE,//标志 |CV_HAAR_FIND_BIGGEST_OBJECT|CV_HAAR_DO_ROUGH_SEARCH|CV_HAAR_DO_CANNY_PRUNING</span><br><span class="line">        Size(30, 30),         //最小人脸尺寸</span><br><span class="line">        Size(300, 300) );     //最大人脸尺寸</span><br><span class="line">    printf(&quot;Face Num[%d]\n&quot;, faceRects.size());</span><br><span class="line"></span><br><span class="line">    for( unsigned int j = 0; j &lt; faceRects.size(); j++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cvRectangle(pstImage, </span><br><span class="line">            cvPoint(faceRects[j].x, faceRects[j].y), </span><br><span class="line">            cvPoint(faceRects[j].x + faceRects[j].width, faceRects[j].y + faceRects[j].height),</span><br><span class="line">            cvScalar(0,255,0),</span><br><span class="line">            2,8,0);</span><br><span class="line">    &#125;</span><br><span class="line">    cvShowImage(&quot;FDWin&quot;, pstImage);</span><br><span class="line">    cvWaitKey(0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cvReleaseImage(&amp;pstImage);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_分类_SVM</title>
      <link href="/2018/07/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_SVM/"/>
      <url>/2018/07/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_SVM/</url>
      
        <content type="html"><![CDATA[<p>机器学习_分类_SVM</p><a id="more"></a><h3 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h3><p>（Support Vector Machine, SVM）的基本模型是在特征空间上找到最佳的<code>分离超平面</code>使得训练集上正负样本间隔最大。</p><p>二分类问题的有监督学习算法，引入了核方法之后SVM也可以用来解决非线性问题<br>一般SVM有下面三种：</p><blockquote><p>1、硬间隔支持向量机（线性可分支持向量机）：当训练数据线性可分时，可通过硬间隔最大化学得一个线性可分支持向量机。<br><br>2、软间隔支持向量机：当训练数据近似线性可分时，可通过软间隔最大化学得一个线性支持向量机。<br><br>3、非线性支持向量机：当训练数据线性不可分时，可通过核方法以及软间隔最大化学得一个非线性支持向量机。</p></blockquote><p><img src="https://pic2.zhimg.com/80/v2-d2b03cf98869849d1d6a4d91a05d6571_hd.jpg" alt="SVM"></p><p>SVM算法认为图1中的分类器A在性能上优于分类器B，其依据是A的分类间隔比B要大</p><blockquote><p>这两条平行虚线正中间的分界线就是在保持当前决策面方向不变的前提下的最优决策面。两条虚线之间的垂直距离就是这个最优决策面对应的<code>分类间隔</code>。<br></p><p>那个具有“最大间隔”的决策面就是SVM要寻找的最优解,而这个真正的最优解对应的两侧虚线所穿过的样本点，就是SVM中的支持样本点，称为<code>支持向量</code>。<br></p><p>对于图1中的数据，A决策面就是SVM寻找的最优解，而相应的三个位于虚线上的样本点在坐标系中对应的向量就叫做<code>支持向量</code>。</p></blockquote><h3 id="基于最大间隔分割数据"><a href="#基于最大间隔分割数据" class="headerlink" title="基于最大间隔分割数据"></a>基于最大间隔分割数据</h3><p>优点，错误率低，计算开销不大，结果容易解释<br>缺点，对参数调节敏感，原始分类器不加修改只能解决二类问题。</p><p><script type="math/tex">w^{t}x+b</script>为分类函数<br><br>输人数据给分类器会输出一个类别标签,单位阶跃函数）的函数对<script type="math/tex">w^{t}x+b</script>作用得到<script type="math/tex">f(w^{t}x+b)</script>,其中当u&lt;0时输出-1, 反之则输出+1。这是由于-1和+1仅仅相差一个符号，方便数学上的处理。</p><p>如果数据点处于正方向（即+1类 ）并且离<strong>分隔超平面</strong>很远的位置时，<script type="math/tex">w^{t}x+b</script>会是一个很大的正数，同时<script type="math/tex">label*(w^{t}x+b)</script>也会是一个很大的正数。而如果数据点处于负方向（-1类 ）并且离<strong>分隔超平面</strong>远的位置时，此时由于类别标签为-1，则<script type="math/tex">label*(w^{t}x+b)</script>仍然是一个很大的正数。</p><p>目标：找到分类器定义中的w和b。找到具有最小间隔的数据点即<strong>支持向量</strong>。找到支持向量，对间隔最大化。</p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/svm_1.png" alt="svm"></p><p>SVM的目标函数：<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/svm_2.png" alt="svm"><br>分离超平面分类函数为0，支持向量的分类函数为+-1,为了优化目标函数，固定一个优化另外一个，该问题是一个带约束条件的优化问题。这里的约束条件就是<script type="math/tex">label*(w^{t}x+b)=1</script>。<br><br>注：<script type="math/tex">label*(w^{t}x+b)</script>被称为点到分隔面的函数间隔，<script type="math/tex">label*(w^{t}x+b)*(1/w)</script>称为点到分隔面的几何间隔。<br><br>求解这个问题需要经过一系列的转换。具体如下：<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/svm_3.png" alt="svm"></p><p>求$ 1/W$的最大值相当于求$0.5w^2$的最小值，一个凸二次规划问题<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/svm_4.png" alt="svm"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注：新目标函数约束条件：</span><br><span class="line">alpha&gt;=0,所有的aplha*lable=0</span><br><span class="line">但是数据未必100%线性可分，引人所谓松弛变量C</span><br><span class="line">新目标函数约束条件为：</span><br><span class="line">C&gt;alpha&gt;=0,所有的aplha*lable=0</span><br></pre></td></tr></table></figure><p>SVM中的主要工作就是求解这些alpha。<br><br>SMO算法(序列最小优<br>化（SequentialMinimalOptimization ))<br>的目标是求出一系列alpha和b，一旦求出了这些alpha，就很容易计算出权重向量w，并得到分隔超平面。</p><blockquote><p>SMO的工作原理是：每次循环中选择两个alpha进行优化处理，一旦找到一对合适的alpha，那么就增大其中一个，同时减小另一个。选择的alpha要满足在间隔边界之外的条件，而且还没有进行过区间化处理或者不再边界上。</p></blockquote><h3 id="核函数："><a href="#核函数：" class="headerlink" title="核函数："></a>核函数：</h3><p>大部分时候数据并不是线性可分的，这个时候满足这样条件的超平面就根本不存在。在上文中，我们已经了解到了SVM处理线性可分的情况，那对于非线性的数据SVM咋处理呢？对于非线性的情况，SVM 的处理方法是选择一个核函数，通过将数据映射到高维空间，来解决在原始空间中线性不可分的问题。</p><p>这是原始数据和原始空间，明显有红蓝两类：<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/svm_he_tu1.jpg" alt=""><br>通过核函数，将样本数据映射到更高维的空间（在这里，是二维映射到三维）：<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/svm_he_tu2.jpg" alt=""><br>而后进行分离超平面：<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/svm_he_tu3.jpg" alt=""><br>再将分割的超平面映射回去：<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/svm_he_tu4.jpg" alt=""><br>效果图：<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/svm_he_tu5.jpg" alt=""></p><blockquote><p>核函数的选择变成了支持向量机的最大变数（如果必须得用上核函数，即核化），因此选用什么样的核函数会影响最后的结果。而最常用的核函数有：线性核、多项式核、高斯核、拉普拉斯核、sigmoid核、通过核函数之间的线性组合或直积等运算得出的新核函数。</p></blockquote><p>Opencv代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;opencv2/core/core.hpp&gt;  </span><br><span class="line">#include &lt;opencv2/highgui/highgui.hpp&gt;  </span><br><span class="line">#include &lt;opencv2/ml/ml.hpp&gt;  </span><br><span class="line">  </span><br><span class="line">using namespace cv;  </span><br><span class="line">  </span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    // Data for visual representation  </span><br><span class="line">    int width = 512, height = 512;  </span><br><span class="line">    Mat image = Mat::zeros(height, width, CV_8UC3);  </span><br><span class="line">  </span><br><span class="line">    // Set up training data  </span><br><span class="line">    float labels[5] = &#123;1.0, -1.0, -1.0, -1.0,1.0&#125;;  </span><br><span class="line">    Mat labelsMat(5, 1, CV_32FC1, labels);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    float trainingData[5][2] = &#123; &#123;501, 10&#125;, &#123;255, 10&#125;, &#123;501, 255&#125;, &#123;10, 501&#125;,&#123;501,128&#125; &#125;;  </span><br><span class="line">    Mat trainingDataMat(5, 2, CV_32FC1, trainingData);  </span><br><span class="line">  </span><br><span class="line">    //设置支持向量机的参数  </span><br><span class="line">    CvSVMParams params;  </span><br><span class="line">    params.svm_type    = CvSVM::C_SVC;//SVM类型：使用C支持向量机  </span><br><span class="line">    params.kernel_type = CvSVM::LINEAR;//核函数类型：线性  </span><br><span class="line">    params.term_crit   = cvTermCriteria(CV_TERMCRIT_ITER, 100, 1e-6);//终止准则函数：当迭代次数达到最大值时终止  </span><br><span class="line">  </span><br><span class="line">    //训练SVM  </span><br><span class="line">    //建立一个SVM类的实例  </span><br><span class="line">    CvSVM SVM;  </span><br><span class="line">    //训练模型，参数为：输入数据、响应、XX、XX、参数（前面设置过）  </span><br><span class="line">    SVM.train(trainingDataMat, labelsMat, Mat(), Mat(), params);  </span><br><span class="line">      </span><br><span class="line">    Vec3b green(0,255,0), blue (255,0,0);  </span><br><span class="line">    //显示判决域  </span><br><span class="line">    for (int i = 0; i &lt; image.rows; ++i)  </span><br><span class="line">        for (int j = 0; j &lt; image.cols; ++j)  </span><br><span class="line">        &#123;  </span><br><span class="line">                        Mat sampleMat = (Mat_&lt;float&gt;(1,2) &lt;&lt; i,j);  </span><br><span class="line">            //predict是用来预测的，参数为：样本、返回值类型（如果值为ture而且是一个2类问题则返回判决函数值，否则返回类标签）、  </span><br><span class="line">            float response = SVM.predict(sampleMat);  </span><br><span class="line">  </span><br><span class="line">            if (response == 1)  </span><br><span class="line">                image.at&lt;Vec3b&gt;(j, i)  = green;  </span><br><span class="line">            else if (response == -1)   </span><br><span class="line">                 image.at&lt;Vec3b&gt;(j, i)  = blue;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    //画出训练数据  </span><br><span class="line">    int thickness = -1;  </span><br><span class="line">    int lineType = 8;  </span><br><span class="line">    circle( image, Point(501,  10), 5, Scalar(  0,   0,   0), thickness, lineType);//画圆  </span><br><span class="line">    circle( image, Point(255,  10), 5, Scalar(255, 255, 255), thickness, lineType);  </span><br><span class="line">    circle( image, Point(501, 255), 5, Scalar(255, 255, 255), thickness, lineType);  </span><br><span class="line">    circle( image, Point( 10, 501), 5, Scalar(255, 255, 255), thickness, lineType);  </span><br><span class="line">    circle(image, Point( 501, 128), 5, Scalar(0, 0, 0), thickness, lineType);  </span><br><span class="line">  </span><br><span class="line">    //显示支持向量  </span><br><span class="line">    thickness = 2;  </span><br><span class="line">    lineType  = 8;  </span><br><span class="line">    //获取支持向量的个数  </span><br><span class="line">    int c     = SVM.get_support_vector_count();  </span><br><span class="line">  </span><br><span class="line">    for (int i = 0; i &lt; c; ++i)  </span><br><span class="line">    &#123;  </span><br><span class="line">        //获取第i个支持向量  </span><br><span class="line">        const float* v = SVM.get_support_vector(i);  </span><br><span class="line">        //支持向量用到的样本点，用灰色进行标注  </span><br><span class="line">        circle( image,  Point( (int) v[0], (int) v[1]),   6,  Scalar(128, 128, 128), thickness, lineType);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    imwrite(&quot;result.png&quot;, image);        // save the image   </span><br><span class="line">  </span><br><span class="line">    imshow(&quot;SVM Simple Example&quot;, image); // show it to the user  </span><br><span class="line">    waitKey(0);  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-正则化-L1L2</title>
      <link href="/2018/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%AD%A3%E5%88%99%E5%8C%96-L1L2/"/>
      <url>/2018/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%AD%A3%E5%88%99%E5%8C%96-L1L2/</url>
      
        <content type="html"><![CDATA[<p>机器学习-正则化-L1L2</p><a id="more"></a><p>样本数据量大：经验⻛风险最⼩小化</p><p>样本数据量小：结构⻛风险最⼩小化==正则化</p><p>经验风险最⼩小化（empirical risk minimization）认为经验⻛风险最⼩小的模型是最优的模型，即求解最优化问题</p><script type="math/tex; mode=display">minf ∈ F(1/N)\sum_{i=1}^NL(y_i,f(x_i))</script><p>样本容量量⾜足够⼤大的时候，经验⻛风险最⼩小化学习效果良好</p><p>结构⻛风险=经验⻛风险+模型复杂度的正则化项（regularizer）或罚项（penalty term）</p><script type="math/tex; mode=display">minf ∈ F(1/N)\sum_{i=1}^NL(y_i,f(x_i))+\lambda{J(f)}</script><p>$J(f)$是模型的复杂度，模型$f$越复杂，复杂度$J(f)$越大。<br>$\lambda ≥ 0$是系数，⽤用以权衡经验⻛风险和模型复杂度。</p><blockquote><p>结构风险⼩需要1、经验风险和2、模型复杂度同时⼩</p></blockquote><h3 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h3><p>因为非负性：可以做损失函数，正则项</p><blockquote><p>损失函数通常是⼀个有下确界的函数</p></blockquote><p>常用范数：<br>L0</p><p>L1:绝对值</p><script type="math/tex; mode=display">||x||=\sum_{i=1}^{d}{|x_i|}</script><p>L2；平方再开根号</p><script type="math/tex; mode=display">||x||_2=(\sum_{i=1}^{d}{|x_i^2|})^{1/2}</script><p>Lp</p><script type="math/tex; mode=display">||x||_2=(\sum_{i=1}^{d}{|x_i^p|})^{1/p}</script><p>p=1,曼哈顿距离，L1范数，表示某个向量量中所有元素绝对值的和<br><br>p=2,欧式距离，L2范数</p><p>使用L1正则项，倾向于使参数稀疏化，使用L2正则项，使参数稠密的接近于0。<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/L1L21.png" alt=""><br>L1正则是菱形，参数的交点都落在坐标轴上，实现稀疏化。<br>L2是圆形，</p><blockquote><p>正则项是为了降低模型的复杂度，从而避免模型区过分拟合训练数据，包括噪声与异常点（outliers）。从另一个角度上来讲，正则化即是假设模型参数服从先验概率，即为模型参数添加先验，只是不同的正则化方式的先验分布是不一样的。这样就规定了参数的分布，使得模型的复杂度降低（试想一下，限定条件多了，是不是模型的复杂度降低了呢），这样模型对于噪声与异常点的抗干扰性的能力增强，从而提高模型的泛化能力。还有个解释便是，从贝叶斯学派来看：加了先验，在数据少的时候，先验知识可以防止过拟合；从频率学派来看：正则项限定了参数的取值，从而提高了模型的稳定性，而稳定性强的模型不会过拟合，即控制模型空间。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_分类_KNN_EM</title>
      <link href="/2018/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_KNN_EM/"/>
      <url>/2018/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_KNN_EM/</url>
      
        <content type="html"><![CDATA[<p>机器学习_分类_KNN_EM</p><a id="more"></a><h3 id="K最近邻-kNN，k-NearestNeighbor-分类算法"><a href="#K最近邻-kNN，k-NearestNeighbor-分类算法" class="headerlink" title="K最近邻(kNN，k-NearestNeighbor)分类算法"></a>K最近邻(kNN，k-NearestNeighbor)分类算法</h3><p>在KNN中，通过计算对象间距离来作为各个对象之间的非相似性指标，避免了对象之间的匹配问题，在这里距离一般使用欧氏距离或曼哈顿距离：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">步骤：</span><br><span class="line">其算法的描述为：</span><br><span class="line"></span><br><span class="line">1）计算测试数据与各个训练数据之间的距离；</span><br><span class="line"></span><br><span class="line">2）按照距离的递增关系进行排序；</span><br><span class="line"></span><br><span class="line">3）选取距离最小的K个点；</span><br><span class="line"></span><br><span class="line">4）确定前K个点所在类别的出现频率；</span><br><span class="line"></span><br><span class="line">5）返回前K个点中出现频率最高的类别作为测试数据的预测分类。</span><br></pre></td></tr></table></figure><p>KNN算法的优点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1）简单、有效。 </span><br><span class="line">2）重新训练的代价较低（类别体系的变化和训练集的变化，在Web环境和电子商务应用中是很常见的）。 </span><br><span class="line">3）计算时间和空间线性于训练集的规模（在一些场合不算太大）。 </span><br><span class="line">4）由于KNN方法主要靠周围有限的邻近的样本，而不是靠判别类域的方法来确定所属类别的，因此对于类域的交叉或重叠较多的待分样本集来说，KNN方法较其他方法更为适合。 </span><br><span class="line">5）该算法比较适用于样本容量比较大的类域的自动分类，而那些样本容量较小的类域采用这种算法比较容易产生误分。</span><br></pre></td></tr></table></figure></p><p>KNN算法缺点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1）KNN算法是懒散学习方法（lazy learning,基本上不学习），一些积极学习的算法要快很多。 </span><br><span class="line">2）类别评分不是规格化的（不像概率评分）。 </span><br><span class="line">3）输出的可解释性不强，例如决策树的可解释性较强。 </span><br><span class="line">4）该算法在分类时有个主要的不足是，当样本不平衡时，如一个类的样本容量很大，而其他类样本容量很小时，有可能导致当输入一个新样本时，该样本的K个邻居中大容量类的样本占多数。该算法只计算“最近的”邻居样本，某一类的样本数量很大，那么或者这类样本并不接近目标样本，或者这类样本很靠近目标样本。无论怎样，数量并不能影响运行结果。可以采用权值的方法（和该样本距离小的邻居权值大）来改进。 </span><br><span class="line">5）计算量较大。目前常用的解决方法是事先对已知样本点进行剪辑，事先去除对分类作用不大的样本。</span><br></pre></td></tr></table></figure><h3 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h3><p>EM的策略就是先随便给一个条件概率p1(x1|thera)，然后找到一个l(thera)的下界函数r(x1|thera),求r的最大值p2(x2|thera)，再找到经过p2点的下界函数r2(x2|thera)，重复该过程直到收敛到局部最大值。</p><p>灰度图分割：<a href="https://blog.csdn.net/u014612806/article/details/65442061" target="_blank" rel="noopener">参考</a></p><p>point.h文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#ifndef POINT_H</span><br><span class="line">#define POINT_H</span><br><span class="line">//point结构主要用来存储图像中节点的横坐标，纵坐标以及灰度值</span><br><span class="line">struct point</span><br><span class="line">&#123;</span><br><span class="line">    int row;</span><br><span class="line">    int col;</span><br><span class="line">    double pixVal;</span><br><span class="line">    point(int row, int col, double pixVal) :row(row),col(col),pixVal(pixVal) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>keams.h头文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line">#ifndef KMEANS_H</span><br><span class="line">#define KMEANS_H</span><br><span class="line"></span><br><span class="line">#include&lt;opencv2\opencv.hpp&gt;</span><br><span class="line">#include&lt;random&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&quot;point.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Kmeans&#123;</span><br><span class="line">private:</span><br><span class="line">    //存储所有点</span><br><span class="line">    vector&lt;point&gt; points;</span><br><span class="line">    //存储簇的中心点</span><br><span class="line">    vector&lt;point&gt; centers;</span><br><span class="line">    //存储每个点到相应的簇</span><br><span class="line">    vector&lt;point&gt;* clusters;</span><br><span class="line">    //向量的维数</span><br><span class="line">    int dimension;</span><br><span class="line">    //簇的个数</span><br><span class="line">    int k;</span><br><span class="line">public:</span><br><span class="line">    //构造函数</span><br><span class="line">    Kmeans(vector&lt;point&gt; points, vector&lt;point&gt; centers, int k, int dimension)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;points = points;</span><br><span class="line">        this-&gt;centers = centers;</span><br><span class="line">        this-&gt;dimension = dimension;</span><br><span class="line">        this-&gt;k = k;</span><br><span class="line">        clusters = new vector&lt;point&gt;[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //析构函数</span><br><span class="line">    ~Kmeans()</span><br><span class="line">    &#123;</span><br><span class="line">        delete clusters;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取簇</span><br><span class="line">    vector&lt;point&gt;* getClusters()</span><br><span class="line">    &#123;</span><br><span class="line">        return this-&gt;clusters;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //计算两个向量之间的欧式距离</span><br><span class="line">    double getDistanceBetweenTwoPoints(const point&amp; point1, const point&amp; point2)</span><br><span class="line">    &#123;</span><br><span class="line">        double sum = 0;</span><br><span class="line">        //double tmp;</span><br><span class="line">        //for (int i = 0; i &lt; dimension; i++)</span><br><span class="line">        //&#123;</span><br><span class="line">        //tmp = pow(point1.pixVal - point2.pixVal,2);</span><br><span class="line">        //sum += tmp;</span><br><span class="line">        //&#125;</span><br><span class="line">        sum = pow(point1.pixVal - point2.pixVal, 2);</span><br><span class="line">        return sqrt(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //计算每个点到离它最近的簇中心点，结果保存到vector中</span><br><span class="line">    vector&lt;int&gt; getClosetClusterCenterLabel()</span><br><span class="line">    &#123;</span><br><span class="line">        double min;</span><br><span class="line">        int label;</span><br><span class="line">        vector&lt;int&gt; labels;</span><br><span class="line">        for (int i = 0; i &lt; points.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            label = 0;</span><br><span class="line">            min = getDistanceBetweenTwoPoints(points[i], centers[0]);</span><br><span class="line">            for (int j = 1; j &lt; centers.size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                double tmp = getDistanceBetweenTwoPoints(points[i], centers[j]);</span><br><span class="line">                if (tmp &lt; min)</span><br><span class="line">                &#123;</span><br><span class="line">                    min = tmp;</span><br><span class="line">                    label = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            labels.push_back(label);</span><br><span class="line">        &#125;</span><br><span class="line">        return labels;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将每个点放入它离的最近的中心点对应的簇中</span><br><span class="line">    void computeClusters(const vector&lt;int&gt;&amp; labels)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            clusters[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; labels.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int label = labels[i];</span><br><span class="line">            clusters[label].push_back(points[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //重新计算所有簇的中心点的灰度值</span><br><span class="line">    void computeCenters()</span><br><span class="line">    &#123;</span><br><span class="line">        centers.clear();</span><br><span class="line">        for (int i = 0; i &lt; k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            double sum = 0;</span><br><span class="line">            for (int j = 0; j &lt; clusters[i].size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += clusters[i][j].pixVal;</span><br><span class="line">            &#125;</span><br><span class="line">            double meanVal = sum / clusters[i].size();</span><br><span class="line">            point cp(-1, -1, meanVal);</span><br><span class="line">            centers.push_back(cp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //确定新的中心点后重新计算一次cost</span><br><span class="line">    double computeCost()</span><br><span class="line">    &#123;</span><br><span class="line">        double sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;point&gt; tmpVec=clusters[i];</span><br><span class="line">            for (int j = 0; j &lt; tmpVec.size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += getDistanceBetweenTwoPoints(tmpVec[j], centers[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum / points.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //迭代执行k-means算法的步骤</span><br><span class="line">    void kmeans()</span><br><span class="line">    &#123;</span><br><span class="line">        double oldCost, newCost;</span><br><span class="line">        vector&lt;int&gt; labels=getClosetClusterCenterLabel();</span><br><span class="line">        computeClusters(labels);</span><br><span class="line">        newCost = computeCost();</span><br><span class="line"></span><br><span class="line">        computeCenters();</span><br><span class="line">        labels = getClosetClusterCenterLabel();</span><br><span class="line">        computeClusters(labels);</span><br><span class="line">        oldCost = newCost;</span><br><span class="line">        newCost = computeCost();</span><br><span class="line"></span><br><span class="line">        while (oldCost != newCost)</span><br><span class="line">        &#123;</span><br><span class="line">            oldCost = newCost;</span><br><span class="line">            computeCenters();</span><br><span class="line">            labels = getClosetClusterCenterLabel();</span><br><span class="line">            computeClusters(labels);</span><br><span class="line">            newCost = computeCost();</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt;&quot;Final Cost: &quot;&lt;&lt; newCost &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>测试的kmeans.cpp文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;kmeans.h&quot;</span><br><span class="line">//图片的存放位置</span><br><span class="line">const String imageFolder = &quot;F:\\&quot;;</span><br><span class="line">//簇的个数（即k的大小，根据自己需要调整）</span><br><span class="line">const int numOfCluster =4;</span><br><span class="line">//最大像素值</span><br><span class="line">const int MAX_PIX_VALUE = 255;</span><br><span class="line">//存放所有点</span><br><span class="line">vector&lt;point&gt; points;</span><br><span class="line">//存放所有簇中心</span><br><span class="line">vector&lt;point&gt; centers;</span><br><span class="line">//存放所有点颜色特征(i,j)-&gt;i*rows+j</span><br><span class="line">vector&lt;double&gt; pixVec;</span><br><span class="line"></span><br><span class="line">//读取图像</span><br><span class="line">Mat readImage(String imageName)</span><br><span class="line">&#123;</span><br><span class="line">    String imageLoc = imageFolder + imageName;</span><br><span class="line">    Mat image=imread(imageLoc);</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//初始化k-means聚类中心</span><br><span class="line">void initializeCenters(const Mat&amp; img)</span><br><span class="line">&#123;</span><br><span class="line">    srand((unsigned)time(NULL));</span><br><span class="line">    for (int i = 0; i &lt; numOfCluster; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int randomX = rand() % img.rows;</span><br><span class="line">        int randomY = rand() % img.cols;</span><br><span class="line">        uchar pixVal = img.at&lt;uchar&gt;(randomX, randomY);</span><br><span class="line">        point cp(randomX, randomY, (double)pixVal);</span><br><span class="line">        centers.push_back(cp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将图像中的所有点装入points中</span><br><span class="line">void initializePoints(const Mat&amp; img)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; img.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        const uchar* data = img.ptr&lt;uchar&gt;(i);</span><br><span class="line">        for (int j = 0; j &lt; img.cols; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            uchar pixVal = data[j];</span><br><span class="line">            point p(i,j, (double)pixVal);</span><br><span class="line">            points.push_back(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    String imageName = &quot;lena.jpg&quot;;</span><br><span class="line">    Mat img = readImage(imageName);</span><br><span class="line">    cvtColor(img, img, CV_RGB2GRAY);//转化为灰度图像</span><br><span class="line">    namedWindow(imageName,WINDOW_NORMAL);</span><br><span class="line">    imshow(imageName, img);</span><br><span class="line">    waitKey(0);</span><br><span class="line">    int rows = img.rows;</span><br><span class="line">    int cols = img.cols;</span><br><span class="line">    initializeCenters(img);</span><br><span class="line">    initializePoints(img);</span><br><span class="line">    Kmeans* km=new Kmeans(points, centers, numOfCluster, 1);</span><br><span class="line">    cout &lt;&lt; &quot;---------------k-means start-------------&quot; &lt;&lt; endl;</span><br><span class="line">    km-&gt;kmeans();</span><br><span class="line">    cout &lt;&lt; &quot;---------------k-means end---------------&quot; &lt;&lt;endl;</span><br><span class="line">    vector&lt;point&gt;* clusters = km-&gt;getClusters();</span><br><span class="line">    Mat res(img.rows,img.cols,img.type());</span><br><span class="line">    double div = MAX_PIX_VALUE / numOfCluster;</span><br><span class="line">    for (int i = 0; i &lt; numOfCluster; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;point&gt; tmpVec = clusters[i];</span><br><span class="line">        for (int j = 0; j &lt; tmpVec.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.at&lt;uchar&gt;(tmpVec[j].row, tmpVec[j].col) = i*div;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    namedWindow(&quot;kmeansResult&quot;,WINDOW_NORMAL);</span><br><span class="line">    imshow(&quot;kmeansResult&quot;, res);</span><br><span class="line">    waitKey(0);</span><br><span class="line">    imwrite(&quot;./segment_lena.jpg&quot;, res);</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>彩色图像分割：<a href="https://blog.csdn.net/owen7500/article/details/51604906" target="_blank" rel="noopener">参考</a></p><p>主函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;clusterImagePixels.hpp&quot;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Mat testImage = imread(&quot;E:\\testImage\\board.jpg&quot;);</span><br><span class="line">if (testImage.empty())</span><br><span class="line">&#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ClusterPixels clusterPix(testImage,3);</span><br><span class="line"> </span><br><span class="line">Mat colorResults = clusterPix.clusterColorImageByKmeans();</span><br><span class="line">Mat grayResult = clusterPix.clusterGrayImageByKmeans();</span><br><span class="line"> </span><br><span class="line">if (!colorResults.empty())</span><br><span class="line">&#123;</span><br><span class="line">hconcat(testImage, colorResults, colorResults);</span><br><span class="line">imshow(&quot;clusterImage&quot;, colorResults);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">if (!grayResult.empty())</span><br><span class="line">&#123;</span><br><span class="line">hconcat(testImage, grayResult, grayResult);</span><br><span class="line">imshow(&quot;grayCluster&quot;, grayResult);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">if (waitKey() == 27)</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;opencv.hpp&gt;</span><br><span class="line">using namespace cv;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Scalar colorTab[] =     //10个颜色</span><br><span class="line">&#123;</span><br><span class="line">Scalar(0, 0, 255),</span><br><span class="line">Scalar(0, 255, 0),</span><br><span class="line">Scalar(255, 100, 100),</span><br><span class="line">Scalar(255, 0, 255),</span><br><span class="line">Scalar(0, 255, 255),</span><br><span class="line">Scalar(255, 0, 0),</span><br><span class="line">Scalar(255, 255, 0),</span><br><span class="line">Scalar(255, 0, 100),</span><br><span class="line">Scalar(100, 100, 100),</span><br><span class="line">Scalar(50, 125, 125)</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">class ClusterPixels</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">Mat image;//待聚类图像</span><br><span class="line">Mat labels;//聚类后的标签</span><br><span class="line">int clusterCounts;//分类数,不得大于10，只是颜色定义只有10类，并不是算法限制</span><br><span class="line"> </span><br><span class="line">public:</span><br><span class="line">ClusterPixels() :clusterCounts(0)&#123;&#125;</span><br><span class="line">ClusterPixels(const Mat&amp; src, int clusters = 5) :clusterCounts(clusters)&#123; image = src.clone(); &#125;</span><br><span class="line"> </span><br><span class="line">void setImage(const Mat&amp; src)&#123; image = src.clone(); &#125;;</span><br><span class="line">void setClusters(int clusters)&#123; clusterCounts = clusters; &#125;</span><br><span class="line"> </span><br><span class="line">Mat getLabels()&#123;return labels;&#125;;//返回聚类后的标签</span><br><span class="line"> </span><br><span class="line">Mat clusterGrayImageByKmeans()</span><br><span class="line">&#123;</span><br><span class="line">//转换成灰度图</span><br><span class="line">if (image.channels() != 1)</span><br><span class="line">cvtColor(image, image, COLOR_BGR2GRAY);</span><br><span class="line"> </span><br><span class="line">int rows = image.rows;</span><br><span class="line">int cols = image.cols;</span><br><span class="line"></span><br><span class="line">//保存聚类后的图片</span><br><span class="line">Mat clusteredMat(rows, cols, CV_8UC3);</span><br><span class="line">clusteredMat.setTo(Scalar::all(0));</span><br><span class="line"> </span><br><span class="line">Mat pixels(rows*cols, 1, CV_32FC1);//pixels用于保存所有的灰度像素</span><br><span class="line"> </span><br><span class="line">for (int i = 0; i &lt; rows;++i)</span><br><span class="line">&#123;</span><br><span class="line">const uchar *idata = image.ptr&lt;uchar&gt;(i);</span><br><span class="line">float *pdata = pixels.ptr&lt;float&gt;(0);</span><br><span class="line">for (int j = 0; j &lt; cols;++j)</span><br><span class="line">&#123;</span><br><span class="line">pdata[i*cols + j] = idata[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">kmeans(pixels, clusterCounts, labels, TermCriteria(TermCriteria::EPS + TermCriteria::MAX_ITER, 10, 0), 5, KMEANS_PP_CENTERS);</span><br><span class="line"> </span><br><span class="line">for (int i = 0; i &lt; rows;++i)</span><br><span class="line">&#123;</span><br><span class="line">for (int j = 0; j &lt; cols;++j)</span><br><span class="line">&#123;</span><br><span class="line">circle(clusteredMat, Point(j,i), 1, colorTab[labels.at&lt;int&gt;(i*cols + j)]);//标记像素点的类别，颜色区分</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">return clusteredMat;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Mat clusterColorImageByKmeans()</span><br><span class="line">&#123;</span><br><span class="line">assert(image.channels() != 1);</span><br><span class="line"> </span><br><span class="line">int rows = image.rows;</span><br><span class="line">int cols = image.cols;</span><br><span class="line">int channels = image.channels();</span><br><span class="line"> </span><br><span class="line">//保存聚类后的图片</span><br><span class="line">Mat clusteredMat(rows, cols, CV_8UC3);</span><br><span class="line">clusteredMat.setTo(Scalar::all(0));</span><br><span class="line"> </span><br><span class="line">Mat pixels(rows*cols, 1, CV_32FC3);//pixels用于保存所有的灰度像素</span><br><span class="line">pixels.setTo(Scalar::all(0));</span><br><span class="line"> </span><br><span class="line">for (int i = 0; i &lt; rows; ++i)</span><br><span class="line">&#123;</span><br><span class="line">const uchar *idata = image.ptr&lt;uchar&gt;(i);</span><br><span class="line">float *pdata = pixels.ptr&lt;float&gt;(0);</span><br><span class="line"> </span><br><span class="line">for (int j = 0; j &lt; cols*channels; ++j)</span><br><span class="line">&#123;</span><br><span class="line">pdata[i*cols*channels + j] = saturate_cast&lt;float&gt;(idata[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">kmeans(pixels, clusterCounts, labels, TermCriteria(CV_TERMCRIT_EPS + CV_TERMCRIT_ITER, 10, 0), 5, KMEANS_PP_CENTERS);</span><br><span class="line"> </span><br><span class="line">for (int i = 0; i &lt; rows; ++i)</span><br><span class="line">&#123;</span><br><span class="line">for (int j = 0; j &lt; cols*channels; j += channels)</span><br><span class="line">&#123;</span><br><span class="line">circle(clusteredMat, Point(j/channels,i), 1, colorTab[labels.at&lt;int&gt;(i*cols + (j/channels))]);//标记像素点的类别，颜色区分</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">return clusteredMat;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>opencv3代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;opencv2\opencv.hpp&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace cv::ml;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Mat img = imread(&quot;E:/opencv/opencv/sources/samples/data/digits.png&quot;);</span><br><span class="line">    Mat gray;</span><br><span class="line">    cvtColor(img, gray, CV_BGR2GRAY);</span><br><span class="line">    int b = 20;</span><br><span class="line">    int m = gray.rows / b;   //原图为1000*2000</span><br><span class="line">    int n = gray.cols / b;   //裁剪为5000个20*20的小图块</span><br><span class="line">    Mat data,labels;   //特征矩阵</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int offsetCol = i*b; //列上的偏移量</span><br><span class="line">        for (int j = 0; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            int offsetRow = j*b;  //行上的偏移量</span><br><span class="line">            //截取20*20的小块</span><br><span class="line">            Mat tmp;</span><br><span class="line">            gray(Range(offsetRow, offsetRow + b), Range(offsetCol, offsetCol + b)).copyTo(tmp);</span><br><span class="line">            data.push_back(tmp.reshape(0,1));  //序列化后放入特征矩阵</span><br><span class="line">            labels.push_back((int)j / 5);  //对应的标注</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    data.convertTo(data, CV_32F); //uchar型转换为cv_32f</span><br><span class="line">    int samplesNum = data.rows;</span><br><span class="line">    int trainNum = 3000;</span><br><span class="line">    Mat trainData, trainLabels;</span><br><span class="line">    trainData = data(Range(0, trainNum), Range::all());   //前3000个样本为训练数据</span><br><span class="line">    trainLabels = labels(Range(0, trainNum), Range::all());</span><br><span class="line"></span><br><span class="line">    //使用KNN算法</span><br><span class="line">    int K = 5;</span><br><span class="line">    Ptr&lt;TrainData&gt; tData = TrainData::create(trainData, ROW_SAMPLE, trainLabels);</span><br><span class="line">    Ptr&lt;KNearest&gt; model = KNearest::create();</span><br><span class="line">    model-&gt;setDefaultK(K);</span><br><span class="line">    model-&gt;setIsClassifier(true);</span><br><span class="line">    model-&gt;train(tData);</span><br><span class="line"></span><br><span class="line">    //预测分类</span><br><span class="line">    double train_hr = 0, test_hr = 0;</span><br><span class="line">    Mat response;</span><br><span class="line">    // compute prediction error on train and test data</span><br><span class="line">    for (int i = 0; i &lt; samplesNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Mat sample = data.row(i);</span><br><span class="line">        float r = model-&gt;predict(sample);   //对所有行进行预测</span><br><span class="line">        //预测结果与原结果相比，相等为1，不等为0</span><br><span class="line">        r = std::abs(r - labels.at&lt;int&gt;(i)) &lt;= FLT_EPSILON ? 1.f : 0.f;          </span><br><span class="line"></span><br><span class="line">        if (i &lt; trainNum)</span><br><span class="line">            train_hr += r;  //累积正确数</span><br><span class="line">        else</span><br><span class="line">            test_hr += r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    test_hr /= samplesNum - trainNum;</span><br><span class="line">    train_hr = trainNum &gt; 0 ? train_hr / trainNum : 1.;</span><br><span class="line"></span><br><span class="line">    printf(&quot;accuracy: train = %.1f%%, test = %.1f%%\n&quot;,</span><br><span class="line">        train_hr*100., test_hr*100.);</span><br><span class="line">    waitKey(0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++图像处理程序</title>
      <link href="/2018/07/19/CImageProcess1/"/>
      <url>/2018/07/19/CImageProcess1/</url>
      
        <content type="html"><![CDATA[<p>C++图像处理程序</p><a id="more"></a><p>C++开源项目：</p><blockquote><p>Boost.GIL：通用图像库<br>CImg ：用于图像处理的小型开源C++工具包<br>CxImage ：用于加载，保存，显示和转换的图像处理和转换库，可以处理的图片格式包括 BMP, JPEG, GIF, PNG, TIFF, MNG, ICO, PCX, TGA, WMF, WBMP, JBG, J2K。<br>FreeImage ：开源库，支持现在多媒体应用所需的通用图片格式和其他格式。<br>GDCM：Grassroots DICOM 库<br>ITK：跨平台的开源图像分析系统<br>Magick++：ImageMagick程序的C++接口<br>MagickWnd：ImageMagick程序的C++接口<br>OpenCV ： 开源计算机视觉类库<br>tesseract-ocr：OCR引擎<br>VIGRA ：用于图像分析通用C++计算机视觉库<br>VTK ：用于3D计算机图形学，图像处理和可视化的开源免费软件系统。</p></blockquote><h2 id="MakegGray-彩色转灰度"><a href="#MakegGray-彩色转灰度" class="headerlink" title="MakegGray 彩色转灰度"></a>MakegGray 彩色转灰度</h2><p>函数名称：MakegGray()<br>函数类型：void<br>功能：真彩色转化成256色灰度图像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::MakegGray()    //灰度变化</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();   //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line"> for(int j=0;j&lt;height;j++) // 每行</span><br><span class="line">  for(int i=0;i&lt;DibWidth;i+=3) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">   BYTE* pbyBlue = p_data++;   //得到蓝色值</span><br><span class="line">   BYTE* pbyGreen = p_data++;  //得到绿色值</span><br><span class="line">   BYTE* pbyRed = p_data++;    //得到红色值</span><br><span class="line">   BYTE r = *pbyRed;</span><br><span class="line">   BYTE g = *pbyGreen;</span><br><span class="line">   BYTE b = *pbyBlue;</span><br><span class="line">   //取到原r,g,b中的最大值作为像素三分量值的新值</span><br><span class="line">   int gray=0;</span><br><span class="line">   if(r&gt;g)</span><br><span class="line">    gray=r;</span><br><span class="line">   else </span><br><span class="line">    gray=g;</span><br><span class="line">   if(gray&lt;b)</span><br><span class="line">    gray=b;   </span><br><span class="line">         *pbyBlue = gray;     //将取到的最大值赋给像素的蓝分量</span><br><span class="line">   *pbyGreen = gray;    //将取到的最大值赋给像素的绿分量</span><br><span class="line">   *pbyRed = gray;      //将取到的最大值赋给像素的红分量</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="LightAlter-亮度调整"><a href="#LightAlter-亮度调整" class="headerlink" title="LightAlter 亮度调整"></a>LightAlter 亮度调整</h2><p>函数名称：LightAlter(int m_Light)<br>函数类型：void<br>参数：int m_Light，用户给定的阈值<br>功能：对图像使用阈值法进行亮度调整</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::LightAlter(int m_Light)    //亮度调整</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();    //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line"> for(int j=0;j&lt;height;j++) // 每行</span><br><span class="line"> for(int i=0;i&lt;DibWidth;i++) // 每列</span><br><span class="line"> &#123;   </span><br><span class="line">  int a=0;</span><br><span class="line">  a=int(*p_data*m_Light/100);   //调整当前点的亮度</span><br><span class="line">  *p_data=a;</span><br><span class="line">  //判断范围，取得合理的值</span><br><span class="line">  if(a&lt;0) </span><br><span class="line">   *p_data=0;  </span><br><span class="line">     if(a&gt;255)</span><br><span class="line">   *p_data=255;</span><br><span class="line">        p_data++;   //指向下一指针</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="LightReverse-亮度取反"><a href="#LightReverse-亮度取反" class="headerlink" title="LightReverse 亮度取反"></a>LightReverse 亮度取反</h2><p>函数名称：LightReverse()<br>函数类型：void<br>功能：图像的亮度取反。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::LightReverse()    //亮度取反</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line"> for(int j=0;j&lt;height;j++) // 每行</span><br><span class="line">  for(int i=0;i&lt;DibWidth;i++) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">   int a=*p_data;   //取得当前点的值</span><br><span class="line">   *p_data=255-a;    //取反</span><br><span class="line">   p_data++;  //指向下一指针  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ContrastAlter-调整对比度（阈值法）"><a href="#ContrastAlter-调整对比度（阈值法）" class="headerlink" title="ContrastAlter 调整对比度（阈值法）"></a>ContrastAlter 调整对比度（阈值法）</h2><p>函数名称：ContrastAlter(int m_Increment)<br>函数类型：void<br>参数：int m_Increment，用户给定的阈值<br>功能：对图像使用阈值法调整对比度处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::ContrastAlter(int m_Increment)   ///对比度处理</span><br><span class="line">&#123;</span><br><span class="line"> int nHigh = 255 - m_Increment;</span><br><span class="line"> //对于极端情况加以处理</span><br><span class="line"> if(nHigh &lt; m_Increment)</span><br><span class="line"> &#123;</span><br><span class="line">  nHigh = 127;</span><br><span class="line">  m_Increment = 120;</span><br><span class="line"> &#125;</span><br><span class="line"> if(m_Increment &lt; -127)</span><br><span class="line">  m_Increment = -120;</span><br><span class="line"> //扩展或压缩区间的长度</span><br><span class="line"> int nStretch = 255;</span><br><span class="line"> if(m_Increment &gt;= 0)</span><br><span class="line">  nStretch = 255 - 2 * m_Increment;</span><br><span class="line"> else</span><br><span class="line">  nStretch = 255 + 2 * m_Increment;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line"> if(m_Increment &gt;= 0)   // m_Increment&gt;=0时</span><br><span class="line"> &#123;</span><br><span class="line">  for(int j=0;j&lt;height;j++) // 每行</span><br><span class="line">   for(int i=0;i&lt;DibWidth-3;i+=3) // 每列</span><br><span class="line">   &#123;   </span><br><span class="line">    //取得当前点（蓝色）的值，调整</span><br><span class="line">    BYTE* pbyBlue = p_data++;    </span><br><span class="line">    if(*pbyBlue&lt;=m_Increment)</span><br><span class="line">     *pbyBlue=0;</span><br><span class="line">    else if(*pbyBlue&gt;nHigh)</span><br><span class="line">     *pbyBlue=255;</span><br><span class="line">    else</span><br><span class="line">     *pbyBlue=(BYTE)((((int)*pbyBlue - m_Increment) * 255) / nStretch );</span><br><span class="line">    //取得当前点（绿色）的值，调整</span><br><span class="line">    BYTE* pbyGreen = p_data++;</span><br><span class="line">    if(*pbyGreen&lt;=m_Increment)</span><br><span class="line">     *pbyGreen=0;</span><br><span class="line">    else if(*pbyGreen&gt;nHigh)</span><br><span class="line">     *pbyGreen=255;</span><br><span class="line">    else</span><br><span class="line">     *pbyGreen=(BYTE)((((int)*pbyGreen - m_Increment) * 255) / nStretch );</span><br><span class="line">    //取得当前点（红色）的值，调整</span><br><span class="line">    BYTE* pbyRed = p_data++;</span><br><span class="line">    if(*pbyRed&lt;=m_Increment)</span><br><span class="line">     *pbyRed=0;</span><br><span class="line">    else if(*pbyRed&gt;nHigh)</span><br><span class="line">     *pbyRed=255;</span><br><span class="line">    else</span><br><span class="line">     *pbyRed=(BYTE)((((int)*pbyRed - m_Increment) * 255) / nStretch );</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"> &#125;</span><br><span class="line"> else  // m_Increment &lt; 0 时</span><br><span class="line"> &#123;</span><br><span class="line">  for(int j=0;j&lt;height;j++)</span><br><span class="line">   for(int i=0;i&lt;DibWidth-3;i+=3)</span><br><span class="line">   &#123; //取得当前点（蓝色）的值，调整</span><br><span class="line">    BYTE* pbyBlue = p_data++;</span><br><span class="line">    *pbyBlue = (BYTE)((((int)(*pbyBlue) * nStretch) / 255) - m_Increment);</span><br><span class="line">    //取得当前点（红色）的值，调整</span><br><span class="line">    BYTE* pbyGreen = p_data++;</span><br><span class="line">    *pbyGreen = (BYTE)((((int)(*pbyGreen) * nStretch) / 255) - m_Increment);</span><br><span class="line">    //取得当前点（红色）的值，调整</span><br><span class="line">    BYTE* pbyRed = p_data++;</span><br><span class="line">    *pbyRed = (BYTE)((((int)(*pbyRed) * nStretch) / 255) - m_Increment);    </span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Exposal-曝光处理"><a href="#Exposal-曝光处理" class="headerlink" title="Exposal 曝光处理"></a>Exposal 曝光处理</h2><p>函数名称：Exposal()<br>函数类型：void<br>功能：图像曝光处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::Exposal() //曝光处理</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line"> for(int j=0;j&lt;height;j++) // 每行</span><br><span class="line">  for(int i=0;i&lt;DibWidth;i++) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">   BYTE* pbydata = p_data++;  //取得当前点的值</span><br><span class="line">   BYTE a=*pbydata;   //传给临时变量</span><br><span class="line">   *pbydata=(a&gt;128)?a:(255-a);   //调整</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="PaintColor-着色处理（阈值法）"><a href="#PaintColor-着色处理（阈值法）" class="headerlink" title="PaintColor 着色处理（阈值法）"></a>PaintColor 着色处理（阈值法）</h2><p>函数名称：PaintColor(int m_Red,int m_Green,int m_Blue)<br>函数类型：void<br>参数：int m_Red、m_Green、m_Blue，用户给定的红绿蓝值<br>功能：对图像使用阈值法进行着色处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::PaintColor(int m_Red,int m_Green,int m_Blue) //着色处理</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line"> for(int j=0;j&lt;height;j++) // 每行</span><br><span class="line">  for(int i=0;i&lt;DibWidth;i+=3) // 每列</span><br><span class="line">  &#123;   </span><br><span class="line">   BYTE* pbyBlue = p_data++; //取得当前点（蓝色）的值     </span><br><span class="line">   BYTE* pbyGreen = p_data++;  //取得当前点（绿色）的值</span><br><span class="line">   BYTE* pbyRed = p_data++;    //取得当前点（红色）的值</span><br><span class="line">   BYTE r = *pbyRed;</span><br><span class="line">   BYTE g = *pbyGreen;</span><br><span class="line">   BYTE b = *pbyBlue;</span><br><span class="line">      BYTE gray=(BYTE)(((WORD)r * 59 + (WORD)g * 30 + (WORD)b * 11) / 100);</span><br><span class="line">   *pbyBlue = (BYTE)((m_Blue * gray) / 255);  </span><br><span class="line">   *pbyGreen = (BYTE)((m_Green * gray) / 255);</span><br><span class="line">   *pbyRed = (BYTE)((m_Red * gray) / 255);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="NeonLight-霓虹处理"><a href="#NeonLight-霓虹处理" class="headerlink" title="NeonLight 霓虹处理"></a>NeonLight 霓虹处理</h2><p>函数名称：NeonLight()<br>函数类型：void<br>功能：使图像产生霓虹处理效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::NeonLight()   //霓虹处理</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line">    BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像</span><br><span class="line"> for(int j=0;j&lt;height-4;j++) // 每行</span><br><span class="line"> &#123;</span><br><span class="line">  for(int i=0;i&lt;DibWidth-1;i++) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">    int pby_pt=0;</span><br><span class="line">    //对像素执行算法</span><br><span class="line">    pby_pt=(*(p_data+(height-j-1)*DibWidth+i)-*(p_data+(height-j-1)*DibWidth+i+3))</span><br><span class="line">       *(*(p_data+(height-j-1)*DibWidth+i)-*(p_data+(height-j-1)*DibWidth+i+3))</span><br><span class="line">       +(*(p_data+(height-j-1)*DibWidth+i)-*(p_data+(height-j-2)*DibWidth+i))</span><br><span class="line">       *(*(p_data+(height-j-1)*DibWidth+i)-*(p_data+(height-j-2)*DibWidth+i));</span><br><span class="line">   *(p_temp+(height-j-1)*DibWidth+i)=2*int(sqrt(pby_pt));</span><br><span class="line">   //判断合法性</span><br><span class="line">   if(*(p_temp+(height-j-1)*DibWidth+i)&lt;0)</span><br><span class="line">     *(p_temp+(height-j-1)*DibWidth+i)=0;</span><br><span class="line">   if(*(p_temp+(height-j-1)*DibWidth+i)&gt;255)</span><br><span class="line">     *(p_temp+(height-j-1)*DibWidth+i)=255;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    memcpy(p_data,p_temp,height*DibWidth);  // 复制处理后的图像</span><br><span class="line">    delete []p_temp;   //删除暂时分配内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Smoothness-平滑处理"><a href="#Smoothness-平滑处理" class="headerlink" title="Smoothness 平滑处理"></a>Smoothness 平滑处理</h2><p>函数名称：Smoothness()<br>函数类型：void<br>功能：使图像平滑处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::Smoothness()   //平滑处理</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line">    int h[3][3];////定义(3x3)矩阵</span><br><span class="line"> h[0][0] = 1;  h[0][1] = 1; h[0][2] = 1;</span><br><span class="line"> h[1][0] = 1;  h[1][1] = 1; h[1][2] = 1;</span><br><span class="line"> h[2][0] = 1;  h[2][1] = 1; h[2][2] = 1;</span><br><span class="line">    BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像</span><br><span class="line"> for(int j=0;j&lt;height-2;j++) // 每行</span><br><span class="line"> &#123;</span><br><span class="line">  for(int i=0;i&lt;DibWidth-8;i++) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">         double pby_pt=0;</span><br><span class="line">                    //对应的第0行的值乘以矩阵对应值，再相加</span><br><span class="line">       pby_pt= h[0][0]*(*(p_data+(height-j-1)*DibWidth+i))</span><br><span class="line">        +h[0][1]*(*(p_data+(height-j-1)*DibWidth+i+3))</span><br><span class="line">        +h[0][2]*(*(p_data+(height-j-1)*DibWidth+i+6))</span><br><span class="line">                    //对应的第1行的值乘以矩阵对应值，再相加</span><br><span class="line">        +h[1][0]*(*(p_data+(height-j-2)*DibWidth+i))</span><br><span class="line">        +h[1][1]*(*(p_data+(height-j-2)*DibWidth+i+3))</span><br><span class="line">        +h[1][2]*(*(p_data+(height-j-2)*DibWidth+i+6))</span><br><span class="line">                    //对应的第2行的值乘以矩阵对应值，再相加</span><br><span class="line">              +h[2][0]*(*(p_data+(height-j-3)*DibWidth+i))</span><br><span class="line">     +h[2][1]*(*(p_data+(height-j-3)*DibWidth+i+3))</span><br><span class="line">     +h[2][2]*(*(p_data+(height-j-3)*DibWidth+i+6));</span><br><span class="line">   *(p_temp+(height-j-2)*DibWidth+i+3)=abs(int(pby_pt/9));//取总和的的平均值</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    memcpy(p_data,p_temp,height*DibWidth);  // 复制处理后的图像</span><br><span class="line">    delete []p_temp;//删除暂时分配内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Embossment-浮雕处理"><a href="#Embossment-浮雕处理" class="headerlink" title="Embossment 浮雕处理"></a>Embossment 浮雕处理</h2><p>函数名称：Embossment()<br>函数类型：void<br>功能：产生图像浮雕处理效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::Embossment()   //浮雕处理</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line">    BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像</span><br><span class="line"> for(int j=0;j&lt;height;j++) // 每行</span><br><span class="line"> &#123;</span><br><span class="line">  for(int i=0;i&lt;DibWidth-4;i++) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">    int pby_pt=0;</span><br><span class="line">    //对像素得每个分量执行算法</span><br><span class="line">    pby_pt=*(p_data+(height-j-1)*DibWidth+i)</span><br><span class="line">       -*(p_data+(height-j-1)*DibWidth+i+3)+128;</span><br><span class="line">    *(p_temp+(height-j-1)*DibWidth+i+3)=pby_pt;</span><br><span class="line">   //检验合法性</span><br><span class="line">   if(*(p_temp+(height-j-1)*DibWidth+i+3)&lt;0)</span><br><span class="line">    *(p_temp+(height-j-1)*DibWidth+i+3)=0;</span><br><span class="line">   else if(*(p_temp+(height-j-1)*DibWidth+i+3)&gt;255)</span><br><span class="line">    *(p_temp+(height-j-1)*DibWidth+i+3)=255;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    memcpy(p_data,p_temp,height*DibWidth);  // 复制处理后的图像</span><br><span class="line">    delete []p_temp;   //删除暂时分配内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Spread-图像扩散"><a href="#Spread-图像扩散" class="headerlink" title="Spread 图像扩散"></a>Spread 图像扩散</h2><p>函数名称：Spread()<br>函数类型：void<br>功能：图像扩散处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::Spread()   //扩散处理</span><br><span class="line">&#123; </span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line">    BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像</span><br><span class="line"> for(int j=0;j&lt;height-4;j++) // 每行</span><br><span class="line"> &#123;</span><br><span class="line">  for(int i=0;i&lt;DibWidth-14;i++) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">    int m=0,n=0;</span><br><span class="line">    m=rand()%5; //取得行随机数</span><br><span class="line">    n=rand()%5; //取得列随机数</span><br><span class="line">    int pby_pt=0; </span><br><span class="line">    pby_pt=*(p_data+(height-j-1-m)*DibWidth+i+3*n);//得到对应随机像素值</span><br><span class="line">    *(p_temp+(height-j-3)*DibWidth+i+6)=pby_pt;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    memcpy(p_data,p_temp,height*DibWidth);  // 复制处理后的图像</span><br><span class="line">    delete []p_temp;   //删除暂时分配内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Sharp-锐化"><a href="#Sharp-锐化" class="headerlink" title="Sharp 锐化"></a>Sharp 锐化</h2><p>函数名称：Sharp()<br>函数类型：void<br>功能：图像锐化处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::Sharp()   //图像锐化</span><br><span class="line">&#123;</span><br><span class="line">  BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line">    BYTE *p_temp=new BYTE[height*DibWidth];</span><br><span class="line"> for(int j=0;j&lt;height-1;j++) // 每行</span><br><span class="line"> &#123;</span><br><span class="line">  for(int i=0;i&lt;DibWidth-5;i++) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">         int pby_pt=0; </span><br><span class="line">   pby_pt= *(p_data+(height-j-2)*DibWidth+i+3)</span><br><span class="line">          -*(p_data+(height-j-1)*DibWidth+i);</span><br><span class="line">   *(p_temp+(height-j-2)*DibWidth+i+3)=*(p_data+(height-j-2)*DibWidth+i+3)</span><br><span class="line">                                     +abs(int(pby_pt/4));</span><br><span class="line">   if(*(p_temp+(height-j-2)*DibWidth+i+3)&gt;255)</span><br><span class="line">      *(p_temp+(height-j-2)*DibWidth+i+3)=255;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    memcpy(p_data,p_temp,height*DibWidth);  // 复制处理后的图像</span><br><span class="line">    delete []p_temp;  //删除暂时分配内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="HighLVBO-阈值法进行高通滤波"><a href="#HighLVBO-阈值法进行高通滤波" class="headerlink" title="HighLVBO 阈值法进行高通滤波"></a>HighLVBO 阈值法进行高通滤波</h2><p>函数名称：HighLVBO(int m_GaoTong)<br>函数类型：void<br>参数：int m_GaoTong，用户给定的阈值来选择矩阵<br>功能：对图像使用阈值法进行高通滤波。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::HighLVBO(int m_GaoTong)   //高通滤波</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line"> int h[3][3];  ////定义(3x3)矩阵</span><br><span class="line"> if(m_GaoTong==1)</span><br><span class="line"> &#123;   //矩阵1（基本高通）</span><br><span class="line">  h[0][0] =1;   h[0][1] =-2;  h[0][2] =1;</span><br><span class="line">  h[1][0] =-2;  h[1][1] =5;   h[1][2] =-2;</span><br><span class="line">  h[2][0] =1;   h[2][1] =-2;  h[2][2] =1;</span><br><span class="line"> &#125;</span><br><span class="line"> else if(m_GaoTong==2)</span><br><span class="line"> &#123;   //矩阵2（中等高通）</span><br><span class="line">  h[0][0] = 0;   h[0][1] = -1; h[0][2] = 0;</span><br><span class="line">  h[1][0] = -1;  h[1][1] =  5; h[1][2] = -1;</span><br><span class="line">  h[2][0] = 0;   h[2][1] = -1; h[2][2] = 0;</span><br><span class="line"> &#125;</span><br><span class="line"> else</span><br><span class="line"> &#123;   //矩阵3（过量高通）</span><br><span class="line">  h[0][0] = -1;  h[0][1] = -1; h[0][2] = -1;</span><br><span class="line">  h[1][0] = -1;  h[1][1] =  9; h[1][2] = -1;</span><br><span class="line">  h[2][0] = -1;  h[2][1] = -1; h[2][2] = -1;</span><br><span class="line"> &#125;</span><br><span class="line">    BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像</span><br><span class="line"> for(int j=0;j&lt;height-2;j++) // 每行</span><br><span class="line"> &#123;</span><br><span class="line">  for(int i=0;i&lt;DibWidth-8;i++) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">   int pby_pt=0;</span><br><span class="line">   //对应的第0行的值乘以矩阵对应值，再相加</span><br><span class="line">   pby_pt=  h[0][0]*(*(p_data+(height-j-1)*DibWidth+i))</span><br><span class="line">    +h[0][1]*(*(p_data+(height-j-1)*DibWidth+i+3))</span><br><span class="line">    +h[0][2]*(*(p_data+(height-j-1)*DibWidth+i+6))</span><br><span class="line">    //对应的第1行的值乘以矩阵对应值，再相加</span><br><span class="line">    +h[1][0]*(*(p_data+(height-j-2)*DibWidth+i))</span><br><span class="line">    +h[1][1]*(*(p_data+(height-j-2)*DibWidth+i+3))</span><br><span class="line">    +h[1][2]*(*(p_data+(height-j-2)*DibWidth+i+6))</span><br><span class="line">    //对应的第2行的值乘以矩阵对应值，再相加</span><br><span class="line">    +h[2][0]*(*(p_data+(height-j-3)*DibWidth+i))</span><br><span class="line">    +h[2][1]*(*(p_data+(height-j-3)*DibWidth+i+3))</span><br><span class="line">    +h[2][2]*(*(p_data+(height-j-3)*DibWidth+i+6));</span><br><span class="line">   *(p_temp+(height-j-2)*DibWidth+i+3)=abs(pby_pt);</span><br><span class="line">   if(pby_pt&gt;255) //判断是否越界</span><br><span class="line">    *(p_temp+(height-j-2)*DibWidth+i+3)=255;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    memcpy(p_data,p_temp,height*DibWidth);  // 复制处理后的图像</span><br><span class="line">    delete []p_temp;  //删除暂时分配内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="LowLVBO-图像低通滤波"><a href="#LowLVBO-图像低通滤波" class="headerlink" title="LowLVBO 图像低通滤波"></a>LowLVBO 图像低通滤波</h2><p>函数名称：LowLVBO()<br>函数类型：void<br>功能：实现图像低通滤波(3x3)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::LowLVBO()   //低通滤波(3x3)</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line">    double h[3][3];////定义(3x3)矩阵</span><br><span class="line"> h[0][0] = 0.1;  h[0][1] = 0.1; h[0][2] = 0.1;</span><br><span class="line"> h[1][0] = 0.1;  h[1][1] = 0.2; h[1][2] = 0.1;</span><br><span class="line"> h[2][0] = 0.1;  h[2][1] = 0.1; h[2][2] = 0.1;</span><br><span class="line"> BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像</span><br><span class="line"> for(int j=0;j&lt;height-2;j++) // 每行</span><br><span class="line"> &#123;</span><br><span class="line">  for(int i=0;i&lt;DibWidth-8;i++) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">   double pby_pt=0;</span><br><span class="line">            //对应的第0行的值乘以矩阵对应值，再相加 </span><br><span class="line">   pby_pt=  h[0][0]*(*(p_data+(height-j-1)*DibWidth+i))</span><br><span class="line">    +h[0][1]*(*(p_data+(height-j-1)*DibWidth+i+3))</span><br><span class="line">    +h[0][2]*(*(p_data+(height-j-1)*DibWidth+i+6))</span><br><span class="line">    //对应的第0行的值乘以矩阵对应值，再相加</span><br><span class="line">    +h[1][0]*(*(p_data+(height-j-2)*DibWidth+i))</span><br><span class="line">    +h[1][1]*(*(p_data+(height-j-2)*DibWidth+i+3))</span><br><span class="line">    +h[1][2]*(*(p_data+(height-j-2)*DibWidth+i+6))</span><br><span class="line">    //对应的第0行的值乘以矩阵对应值，再相加</span><br><span class="line">    +h[2][0]*(*(p_data+(height-j-3)*DibWidth+i))</span><br><span class="line">    +h[2][1]*(*(p_data+(height-j-3)*DibWidth+i+3))</span><br><span class="line">    +h[2][2]*(*(p_data+(height-j-3)*DibWidth+i+6));</span><br><span class="line">   *(p_temp+(height-j-2)*DibWidth+i+3)=abs(int(pby_pt));</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> memcpy(p_data,p_temp,height*DibWidth);  // 复制处理后的图像</span><br><span class="line"> delete []p_temp;  //删除暂时分配内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="LowVBObig-低通滤波"><a href="#LowVBObig-低通滤波" class="headerlink" title="LowVBObig 低通滤波"></a>LowVBObig 低通滤波</h2><p>函数名称：LowVBObig()<br> 函数类型：void<br> 功能：实现函数低通滤波(5*5)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::LowLVBObig()   //低通滤波(5x5)</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line"> int h[5][5];//定义(5x5)矩阵</span><br><span class="line"> h[0][0] = 1;  h[0][1] = 1; h[0][2] = 1; h[0][3] = 1; h[0][4] = 1;</span><br><span class="line"> h[1][0] = 1;  h[1][1] = 2; h[1][2] = 2; h[1][3] = 2; h[1][4] = 1;</span><br><span class="line"> h[2][0] = 1;  h[2][1] = 2; h[2][2] = 3; h[2][3] = 2; h[2][4] = 1;</span><br><span class="line"> h[3][0] = 1;  h[3][1] = 2; h[3][2] = 2; h[3][3] = 2; h[3][4] = 1;</span><br><span class="line"> h[4][0] = 1;  h[4][1] = 1; h[4][2] = 1; h[4][3] = 1; h[4][4] = 1;</span><br><span class="line"> BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像</span><br><span class="line"> for(int j=0;j&lt;height-4;j++) // 每行</span><br><span class="line"> &#123;</span><br><span class="line">  for(int i=0;i&lt;DibWidth-14;i++) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">         int pby_pt=0;</span><br><span class="line">         //对应的第0行的值乘以矩阵对应值，再相加</span><br><span class="line">   pby_pt=h[0][0]*(*(p_data+(height-j-1)*DibWidth+i))</span><br><span class="line">      +h[0][1]*(*(p_data+(height-j-1)*DibWidth+i+3))</span><br><span class="line">      +h[0][2]*(*(p_data+(height-j-1)*DibWidth+i+6))</span><br><span class="line">         +h[0][3]*(*(p_data+(height-j-1)*DibWidth+i+9))</span><br><span class="line">      +h[0][4]*(*(p_data+(height-j-1)*DibWidth+i+12))</span><br><span class="line">                  //对应的第1行的值乘以矩阵对应值，再相加</span><br><span class="line">         +h[1][0]*(*(p_data+(height-j-2)*DibWidth+i))</span><br><span class="line">         +h[1][1]*(*(p_data+(height-j-2)*DibWidth+i+3))</span><br><span class="line">      +h[1][2]*(*(p_data+(height-j-2)*DibWidth+i+6))</span><br><span class="line">      +h[1][3]*(*(p_data+(height-j-2)*DibWidth+i+9))</span><br><span class="line">      +h[1][4]*(*(p_data+(height-j-2)*DibWidth+i+12))</span><br><span class="line">                  //对应的第2行的值乘以矩阵对应值，再相加</span><br><span class="line">         +h[2][0]*(*(p_data+(height-j-3)*DibWidth+i))</span><br><span class="line">      +h[2][1]*(*(p_data+(height-j-3)*DibWidth+i+3))</span><br><span class="line">      +h[2][2]*(*(p_data+(height-j-3)*DibWidth+i+6))</span><br><span class="line">      +h[2][3]*(*(p_data+(height-j-3)*DibWidth+i+9))</span><br><span class="line">      +h[2][4]*(*(p_data+(height-j-3)*DibWidth+i+12))</span><br><span class="line">                  //对应的第3行的值乘以矩阵对应值，再相加</span><br><span class="line">         +h[3][0]*(*(p_data+(height-j-4)*DibWidth+i))</span><br><span class="line">         +h[3][1]*(*(p_data+(height-j-4)*DibWidth+i+3))</span><br><span class="line">      +h[3][2]*(*(p_data+(height-j-4)*DibWidth+i+6))</span><br><span class="line">      +h[3][3]*(*(p_data+(height-j-4)*DibWidth+i+9))</span><br><span class="line">      +h[3][4]*(*(p_data+(height-j-4)*DibWidth+i+12))</span><br><span class="line">                  //对应的第4行的值乘以矩阵对应值，再相加</span><br><span class="line">         +h[4][0]*(*(p_data+(height-j-5)*DibWidth+i))</span><br><span class="line">      +h[4][1]*(*(p_data+(height-j-5)*DibWidth+i+3))</span><br><span class="line">      +h[4][2]*(*(p_data+(height-j-5)*DibWidth+i+6))</span><br><span class="line">      +h[4][3]*(*(p_data+(height-j-5)*DibWidth+i+9))</span><br><span class="line">      +h[4][4]*(*(p_data+(height-j-5)*DibWidth+i+12));</span><br><span class="line">                  //为了计算方便我们把除以35（矩阵权和）放在求总和之后</span><br><span class="line">   *(p_temp+(height-j-3)*DibWidth+i+6)=abs(int(pby_pt/35));</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> memcpy(p_data,p_temp,height*DibWidth);  // 复制处理后的图像</span><br><span class="line"> delete []p_temp;  //删除暂时分配内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ShuiPingGROW-水平增强"><a href="#ShuiPingGROW-水平增强" class="headerlink" title="ShuiPingGROW 水平增强"></a>ShuiPingGROW 水平增强</h2><p>函数名称：ShuiPingGROW()<br>函数类型：void<br>功能：使图像水平增强。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::ShuiPingGROW()   //水平增强</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line"> int h[3][1];//定义(3x1)矩阵</span><br><span class="line"> h[0][0] = -1;  </span><br><span class="line"> h[1][0] = 2; </span><br><span class="line"> h[2][0] = -1;</span><br><span class="line"> BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像</span><br><span class="line"> for(int j=0;j&lt;height-2;j++) // 每行</span><br><span class="line"> &#123;</span><br><span class="line">  for(int i=0;i&lt;DibWidth-8;i++) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">   int pby_pt=0;</span><br><span class="line">   //对应的3行的值乘分别以矩阵对应值，再相加</span><br><span class="line">   pby_pt= h[0][0]*(*(p_data+(height-j-1)*DibWidth+i))</span><br><span class="line">    +h[1][0]*(*(p_data+(height-j-2)*DibWidth+i))</span><br><span class="line">    +h[2][0]*(*(p_data+(height-j-3)*DibWidth+i));</span><br><span class="line">   if(pby_pt&gt;20)</span><br><span class="line">    *(p_temp+(height-j-2)*DibWidth+i)=abs(pby_pt)+100;</span><br><span class="line">   else</span><br><span class="line">    *(p_temp+(height-j-2)*DibWidth+i)=abs(pby_pt);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> memcpy(p_data,p_temp,height*DibWidth);  // 复制处理后的图像</span><br><span class="line">    delete []p_temp;  //删除暂时分配内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ChuiZhiGROW-垂直增强"><a href="#ChuiZhiGROW-垂直增强" class="headerlink" title="ChuiZhiGROW 垂直增强"></a>ChuiZhiGROW 垂直增强</h2><p>函数名称：ChuiZhiGROW()<br>函数类型：void<br>功能：使图像垂直增强。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::ChuiZhiGROW()   //垂直增强</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line"> int h[1][3];//定义(1x3)矩阵</span><br><span class="line"> h[0][0] = -1; </span><br><span class="line"> h[0][1] = 2;</span><br><span class="line"> h[0][2] = -1;</span><br><span class="line"> BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像</span><br><span class="line"> for(int j=0;j&lt;height-2;j++) // 每行</span><br><span class="line"> &#123;</span><br><span class="line">  for(int i=0;i&lt;DibWidth-8;i++) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">   int pby_pt=0;</span><br><span class="line">   //对应的第0行的值乘以矩阵对应值，再相加</span><br><span class="line">   pby_pt= h[0][0]*(*(p_data+(height-j-1)*DibWidth+i))</span><br><span class="line">    +h[0][1]*(*(p_data+(height-j-1)*DibWidth+i+3))</span><br><span class="line">    +h[0][2]*(*(p_data+(height-j-1)*DibWidth+i+6));</span><br><span class="line">   if(pby_pt&gt;20)</span><br><span class="line">    *(p_temp+(height-j-2)*DibWidth+i)=abs(pby_pt)+100;</span><br><span class="line">   else</span><br><span class="line">    *(p_temp+(height-j-2)*DibWidth+i)=abs(pby_pt);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> memcpy(p_data,p_temp,height*DibWidth);  // 复制处理后的图像</span><br><span class="line"> delete []p_temp;  //删除暂时分配内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ShuangXiangGROW-双向增强"><a href="#ShuangXiangGROW-双向增强" class="headerlink" title="ShuangXiangGROW 双向增强"></a>ShuangXiangGROW 双向增强</h2><p>函数名称：ShuangXiangGROW()<br>函数类型：void<br>功能：使图像双向增强。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::ShuangXiangGROW()    //双向增强</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line"> int h[3][3];//定义(3x3)矩阵</span><br><span class="line"> h[0][0] = -1;  h[0][1] = -1; h[0][2] = -1;</span><br><span class="line"> h[1][0] = -1;  h[1][1] =  8; h[1][2] = -1;</span><br><span class="line"> h[2][0] = -1;  h[2][1] = -1; h[2][2] = -1; </span><br><span class="line"> BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像</span><br><span class="line"> for(int j=0;j&lt;height-2;j++) // 每行</span><br><span class="line"> &#123; </span><br><span class="line">  for(int i=0;i&lt;DibWidth-8;i++) // 每列</span><br><span class="line">  &#123;</span><br><span class="line">   int pby_pt=0;</span><br><span class="line">   //对应的第0行的值乘以矩阵对应值，再相加</span><br><span class="line">   pby_pt= h[0][0]*(*(p_data+(height-j-1)*DibWidth+i))</span><br><span class="line">    +h[0][1]*(*(p_data+(height-j-1)*DibWidth+i+3))</span><br><span class="line">    +h[0][2]*(*(p_data+(height-j-1)*DibWidth+i+6))</span><br><span class="line">    //对应的第1行的值乘以矩阵对应值，再相加</span><br><span class="line">    +h[1][0]*(*(p_data+(height-j-2)*DibWidth+i))</span><br><span class="line">    +h[1][1]*(*(p_data+(height-j-2)*DibWidth+i+3))</span><br><span class="line">    +h[1][2]*(*(p_data+(height-j-2)*DibWidth+i+6))</span><br><span class="line">    //对应的第2行的值乘以矩阵对应值，再相加</span><br><span class="line">    +h[2][0]*(*(p_data+(height-j-3)*DibWidth+i))</span><br><span class="line">    +h[2][1]*(*(p_data+(height-j-3)*DibWidth+i+3))</span><br><span class="line">    +h[2][2]*(*(p_data+(height-j-3)*DibWidth+i+6));</span><br><span class="line">   if(pby_pt&gt;20)</span><br><span class="line">    *(p_temp+(height-j-2)*DibWidth+i)=abs(pby_pt)+100;</span><br><span class="line">   else</span><br><span class="line">    *(p_temp+(height-j-2)*DibWidth+i)=abs(pby_pt);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125; </span><br><span class="line"> memcpy(p_data,p_temp,height*DibWidth);  // 复制处理后的图像</span><br><span class="line"> delete []p_temp;  //删除暂时分配内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Mosaic-马塞克"><a href="#Mosaic-马塞克" class="headerlink" title="Mosaic 马塞克"></a>Mosaic 马塞克</h2><p>函数名称：Mosaic()<br>函数类型：void<br>功能：使图像产生马赛克效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">void MakeColorDib::Mosaic()    //马赛克</span><br><span class="line">&#123;</span><br><span class="line"> BYTE *p_data;     //原图数据区指针</span><br><span class="line"> int wide,height,DibWidth;    //原图长、宽、字节宽</span><br><span class="line"> p_data=this-&gt;GetData ();   //取得原图的数据区指针</span><br><span class="line">    wide=this-&gt;GetWidth ();  //取得原图的数据区宽度</span><br><span class="line">    height=this-&gt;GetHeight ();   //取得原图的数据区高度</span><br><span class="line"> DibWidth=this-&gt;GetDibWidthBytes();   //取得原图的每行字节数</span><br><span class="line"> BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像</span><br><span class="line"> for(int j=0;j&lt;height-4;j+=5) // 每行</span><br><span class="line"> &#123; </span><br><span class="line">     for(int i=0;i&lt;DibWidth-14;i+=15) // 每列</span><br><span class="line">  &#123;   //对应周围(5x5)矩阵蓝色值求和平均</span><br><span class="line">   int pby_pt=0;</span><br><span class="line">   for(int m=0;m&lt;5;m++)</span><br><span class="line">    for(int n=0;n&lt;15;n+=3)</span><br><span class="line">    &#123;   </span><br><span class="line">     pby_pt+=*(p_data+(height-j-1-m)*DibWidth+i+n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   for(m=0;m&lt;5;m++)</span><br><span class="line">    for(int n=0;n&lt;14;n+=3)</span><br><span class="line">    &#123;</span><br><span class="line">     *(p_temp+(height-j-1-m)*DibWidth+i+n)=int(pby_pt/25);</span><br><span class="line">    &#125; </span><br><span class="line">            //对应周围(5x5)矩阵绿色值求和平均</span><br><span class="line">   pby_pt=0;</span><br><span class="line">   for(m=0;m&lt;5;m++)</span><br><span class="line">    for(int n=0;n&lt;15;n+=3)</span><br><span class="line">    &#123;</span><br><span class="line">     pby_pt+=*(p_data+(height-j-1-m)*DibWidth+i+n+1);</span><br><span class="line">    &#125;</span><br><span class="line">   for(m=0;m&lt;5;m++)</span><br><span class="line">    for(int n=0;n&lt;14;n+=3)</span><br><span class="line">    &#123;</span><br><span class="line">     *(p_temp+(height-j-1-m)*DibWidth+i+n+1)=int(pby_pt/25);</span><br><span class="line">    &#125;</span><br><span class="line">            //对应周围(5x5)矩阵红色值求和平均</span><br><span class="line">   pby_pt=0;</span><br><span class="line">   for(m=0;m&lt;5;m++)</span><br><span class="line">    for(int n=0;n&lt;15;n+=3)</span><br><span class="line">    &#123;</span><br><span class="line">     pby_pt+=*(p_data+(height-j-1-m)*DibWidth+i+n+2);</span><br><span class="line">    &#125;</span><br><span class="line">   for(m=0;m&lt;5;m++)</span><br><span class="line">    for(int n=0;n&lt;14;n+=3)</span><br><span class="line">    &#123;</span><br><span class="line">     *(p_temp+(height-j-1-m)*DibWidth+i+n+2)=int(pby_pt/25);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;   </span><br><span class="line"> &#125;</span><br><span class="line"> memcpy(p_data,p_temp,height*DibWidth);  // 复制处理后的图像</span><br><span class="line"> delete []p_temp;  //删除暂时分配内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构_二叉树</title>
      <link href="/2018/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2018/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>数据结构_二叉树</p><a id="more"></a><p>树的遍历顺序大体分为三种：前序遍历（先根遍历、先序遍历），中序遍历（中根遍历），后序遍历（后根遍历）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">二叉树：</span><br><span class="line">      A</span><br><span class="line">     /  \</span><br><span class="line">   B     C</span><br><span class="line">  /\    /</span><br><span class="line"> D  E  F</span><br></pre></td></tr></table></figure><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>前序遍历可以记为根左右。<br><br>前序遍历的规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）访问根节点</span><br><span class="line">（2）前序遍历左子树</span><br><span class="line">（3）前序遍历右子树</span><br></pre></td></tr></table></figure></p><p>前序遍历的输出结果：ABDECF</p><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>中序遍历可以记为左根右<br><br>中序遍历的规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）中序遍历左子树</span><br><span class="line">（2）访问根节点</span><br><span class="line">（3）中序遍历右子树</span><br></pre></td></tr></table></figure></p><p>中序遍历的输出结果：DBEAFC</p><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>后序遍历可以记为左右根<br><br>后序遍历二叉树的规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）后序遍历左子树</span><br><span class="line">（2）后序遍历右子树</span><br><span class="line">（3）访问根节点</span><br></pre></td></tr></table></figure></p><p>后序遍历的输出顺序：DEBFCA</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特征提取_图像矩阵变换</title>
      <link href="/2018/07/19/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E5%9B%BE%E5%83%8F%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2/"/>
      <url>/2018/07/19/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E5%9B%BE%E5%83%8F%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>特征提取_图像矩阵变换</p><a id="more"></a><p>基本的二维变换可包括缩放、旋转、扭曲，和平移四种<br></p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/juzhen_1.png" alt=""></p><p>几何运算则可以转换为一些基本的矩阵运算<br></p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/juzhen_2.png" alt=""></p><p>平移运算不是线性的,使用矩阵乘法再使用矩阵加法来完成此操作<br><br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/juzhen_3.png" alt=""></p><p>综合这几种基本运算，数学家们将其统一为一个3*3矩阵，存储形式<br><br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/juzhen_4.png" alt=""></p><p>仿射变换的矩阵的第三列总是（0，0，1），在存储矩阵的时候，大多只存成一个2*3的数组。</p><blockquote><p>复合变换是有顺序的，一般说来，先旋转、再缩放、然后平移</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 特征提取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习推荐书</title>
      <link href="/2018/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8E%A8%E8%8D%90%E4%B9%A6/"/>
      <url>/2018/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8E%A8%E8%8D%90%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<p>机器学习推荐书</p><a id="more"></a><p>5本深度学习书籍资源推荐</p><p>深度学习（Deep Learning）byIan Goodfellow and Yoshua Bengio and Aaron Courville</p><p>中文版下载地址：<a href="https://github.com/exacity/deeplearningbook-chinese" target="_blank" rel="noopener">https://github.com/exacity/deeplearningbook-chinese</a></p><p>R语言深度学习实践指南（Deep Learning Made Easy with R）by Dr. N.D. Lewis</p><p>下载地址：<a href="http://download.csdn.net/detail/oscer2016/9829915" target="_blank" rel="noopener">http://download.csdn.net/detail/oscer2016/9829915</a></p><p>深度学习基础（Fundamentals of Deep Learning）by Nikhil Buduma</p><p>下载地址：<a href="http://www.taodocs.com/p-32598980.html" target="_blank" rel="noopener">http://www.taodocs.com/p-32598980.html</a></p><p>神经网络和统计学习（Neural networks and statistical learning） by K.-L. Du and M.N.s. Swamy</p><p>下载地址：<a href="http://download.csdn.net/detail/oscer2016/9829919" target="_blank" rel="noopener">http://download.csdn.net/detail/oscer2016/9829919</a></p><p>神经网络和深度学习（Neural Networks and Deep Learning） by Michael Niels</p><p>下载地址：<a href="http://download.csdn.net/download/newhotter/9651111" target="_blank" rel="noopener">http://download.csdn.net/download/newhotter/9651111</a></p><p>10本机器学习书籍资源推荐</p><p>机器学习、神经网络和统计分类（Machine Learning, Neural Networks, and Statistical Classification）by</p><p>D. Michie, D.J. Spiegelhalter, C.C. Taylor</p><p>下载地址：<a href="http://www1.maths.leeds.ac.uk/~charles/statlog/" target="_blank" rel="noopener">http://www1.maths.leeds.ac.uk/~charles/statlog/</a></p><p>贝叶斯推理和机器学习（Bayesian Reasoning and Machine Learning）by David Barber</p><p>下载地址：<a href="http://web4.cs.ucl.ac.uk/staff/D.Barber/pmwiki/pmwiki.php?n=Brml.Online" target="_blank" rel="noopener">http://web4.cs.ucl.ac.uk/staff/D.Barber/pmwiki/pmwiki.php?n=Brml.Online</a></p><p>机器学习的高斯过程（Gaussian Processes for Machine Learning） by Carl Edward Rasmussen and Christopher K. I. Williams，The MIT Press</p><p>下载地址：<a href="http://www.gaussianprocess.org/gpml/" target="_blank" rel="noopener">http://www.gaussianprocess.org/gpml/</a></p><p>信息理论、推理和学习算法（Information Theory, Inference, and Learning Algorithms） by David J.C. MacKay</p><p>下载地址：<a href="http://www.inference.phy.cam.ac.uk/mackay/itprnn/book.html" target="_blank" rel="noopener">http://www.inference.phy.cam.ac.uk/mackay/itprnn/book.html</a></p><p>统计学习元素（The Elements of Statistical Learning）by Trevor Hastie, Robert Tibshirani, Jerome Friedman</p><p>下载地址：<a href="http://statweb.stanford.edu/~tibs/ElemStatLearn/printings/ESLII_print10.pdf" target="_blank" rel="noopener">http://statweb.stanford.edu/~tibs/ElemStatLearn/printings/ESLII_print10.pdf</a></p><p>机器学习课程（A Course in Machine Learning）by Hal Daumé III</p><p>下载地址：<a href="http://ciml.info/" target="_blank" rel="noopener">http://ciml.info/</a></p><p>机器学习导论（Introduction to Machine Learning）by Amnon Shashua，Cornell University</p><p>下载地址：<a href="https://arxiv.org/abs/0904.3664v1" target="_blank" rel="noopener">https://arxiv.org/abs/0904.3664v1</a></p><p>强化学习（Reinforcement Learning）</p><p>下载地址：<a href="https://www.intechopen.com/books/reinforcement_learning" target="_blank" rel="noopener">https://www.intechopen.com/books/reinforcement_learning</a></p><p>机器学习导论（Introduction to Machine Learning）- By Nils Nilsson</p><p>下载地址：<a href="http://ai.stanford.edu/~nilsson/mlbook.html" target="_blank" rel="noopener">http://ai.stanford.edu/~nilsson/mlbook.html</a></p><p>强化学习（Reinforcement Learning）- MIT Press</p><p>下载地址：<a href="http://webdocs.cs.ualberta.ca/~sutton/book/the-book.html" target="_blank" rel="noopener">http://webdocs.cs.ualberta.ca/~sutton/book/the-book.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习常见算法总结</title>
      <link href="/2018/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2018/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>机器学习常见算法总结</p><a id="more"></a><div class="table-container"><table><thead><tr><th>学习方式</th><th>概念</th></tr></thead><tbody><tr><td>监督式学习</td><td>从给定的训练数据集中学习出一个函数，当新的数据到来时，可以根据此函数预测结果。训练数据集中的目标由人标注的。常见的算法有回归分析和统计分类</td></tr><tr><td>非监督式学习</td><td>与监督式学习相比，训练集没有人为标注的结果，常见的算法有聚类</td></tr><tr><td>半监督式学习</td><td>训练集部分被标识，部分没有被标识。常见的算法有SVM</td></tr><tr><td>强化学习</td><td>输入数据作为模型的反馈，模型对此作出调整。常见的算法有时间差学习</td></tr></tbody></table></div><p><br><br><br>|机器学习算法分类|概念|<br>|—————-|—-|<br>|决策树算法|根据数据属性，采用树状结构建立决策模型。常用来解决分类和回归问题。<br>常见算法：CART(Classification And Regression Tree)，ID3，C4.5，随机森林等|<br>|回归算法|对连续值预测，如逻辑回归LR等|<br>|分类算法|对离散值预测，事前已经知道分类，如k-近邻算法|<br>|聚类算法|对离散值预测，事前对分类未知，如k-means算法|<br>|神经网络|模拟生物神经网络，可以用来解决分类和回归问题<br>感知器神经网络(Perceptron Neural Network) ，反向传递(Back Propagation)和深度学习（DL）|<br>|集成算法 |集成几种学习模型进行学习，将最终预测结果进行汇总<br>Boosting、Bagging、AdaBoost、随机森林 (Random Forest) 等|</p><h3 id="机器学习算法分类"><a href="#机器学习算法分类" class="headerlink" title="机器学习算法分类"></a>机器学习算法分类</h3><p>决策树算法<br>根据数据属性，采用树状结构建立决策模型。常用来解决分类和回归问题。<br>常见算法：CART(Classification And Regression Tree)，ID3，C4.5，随机森林等<br>回归算法<br>对连续值预测，如逻辑回归LR等<br>分类算法<br>对离散值预测，事前已经知道分类，如k-近邻算法<br>聚类算法<br>对离散值预测，事前对分类未知，如k-means算法<br>神经网络<br>模拟生物神经网络，可以用来解决分类和回归问题<br>感知器神经网络(Perceptron Neural Network) ，反向传递(Back Propagation)和深度学习（DL）<br>集成算法<br>集成几种学习模型进行学习，将最终预测结果进行汇总<br>Boosting、Bagging、AdaBoost、随机森林 (Random Forest) 等</p><h3 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h3><p>1、SVM不太容易过拟合：松弛因子+损失函数形式</p><p>SVM的求解方法叫拉格朗日乘子法</p><p><img src="https://upload-images.jianshu.io/upload_images/1996593-3c55ea30ea545a2f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/678" alt=""></p><p>有时候如果你非要很明确地分类，那么结果就会像右边的一样 —— 过拟合。明显左边的两个都比过拟合好多了，可是这样就要求允许一些样本不在正确的类上.</p><blockquote><p>目标：找出总损失值最小并且能大概分类的超平面</p></blockquote><p>2、方法选择<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、如果Feature的数量很大，跟样本数量差不多，这时候选用LR或者是Linear Kernel的SVM</span><br><span class="line">2、如果Feature的数量比较小，样本数量一般，不算大也不算小，选用SVM+Gaussian Kernel</span><br><span class="line">3、如果Feature的数量比较小，而样本数量很多，需要手工添加一些feature变成第一种情况</span><br></pre></td></tr></table></figure></p><p>3、数据维度<br>如果数据特征维度高，svm要使用<strong>核函数</strong>来求解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Note：拉格朗日对偶没有改变最优解，但改变了算法复杂度：原问题—样本维度；对偶问题–样本数量。</span><br><span class="line">线性分类            样本维度&lt;样本数量：原问题求解（liblinear默认）； </span><br><span class="line">非线性–升维—一般导致 样本维度&gt;样本数量：对偶问题求解</span><br></pre></td></tr></table></figure></p><h3 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h3><p>朴素贝叶斯的优点：<br>对小规模的数据表现很好，适合多分类任务，适合增量式训练。<br>缺点：<br>对输入数据的表达形式很敏感（离散、连续，值极大极小之类的）</p><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><p>线性回归试图学得一个线性模型以尽可能准确地预测实值输出标记。均方误差是回归任务中最常用的性能度量，基于均方误差最小化来进行模型求解的方法成为最小二乘法。在线性回归中，最小二乘法就是试图找到一条直线，使得所有样本到直线上的欧式距离之和最小。这个想法和分类问题是正好相反的，分类问题是找到一个分界面离所有样本尽可能远。</p><p>优化方法</p><p>当x矩阵是列满秩的时候，可以用最小二乘法，但是求矩阵的逆比较慢</p><h2 id="机器学习算法选择"><a href="#机器学习算法选择" class="headerlink" title="机器学习算法选择"></a>机器学习算法选择</h2><blockquote><p>没有最好的分类器，只有最合适的分类器。</p></blockquote><p>数据维度越高，随机森林就比AdaBoost强越多，但是整体不及SVM。</p><p>数据量越大，神经网络就越强。</p><h3 id="1、K近邻"><a href="#1、K近邻" class="headerlink" title="1、K近邻"></a>1、K近邻</h3><p>典型KNN，它的思路就是——对于待判断的点，找到离它最近的几个数据点，根据它们的类型决定待判断点的类型。<br>它的特点是完全跟着数据走，没有数学模型可言。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">适用情景：</span><br><span class="line">需要一个特别容易解释的模型的时候。</span><br><span class="line">比如需要向用户解释原因的推荐算法。</span><br></pre></td></tr></table></figure></p><h3 id="2、贝叶斯"><a href="#2、贝叶斯" class="headerlink" title="2、贝叶斯"></a>2、贝叶斯</h3><p>典型的例子是Naive Bayes，核心思路是根据条件概率计算待判断点的类型。是相对容易理解的一个模型，至今依然被垃圾邮件过滤器使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">适用情景：</span><br><span class="line"></span><br><span class="line">需要一个比较容易解释，而且不同维度之间相关性较小的模型的时候。</span><br><span class="line"></span><br><span class="line">可以高效处理高维数据，虽然结果可能不尽如人意。</span><br></pre></td></tr></table></figure></p><h3 id="3、决策树-Decision-tree"><a href="#3、决策树-Decision-tree" class="headerlink" title="3、决策树 (Decision tree)"></a>3、决策树 (Decision tree)</h3><p>决策树的特点是它总是在沿着特征做切分。随着层层递进，这个划分会越来越细。<br>举个简单的例子，当我们预测一个孩子的身高的时候，决策树的第一层可能是这个孩子的性别。男生走左边的树进行进一步预测，女生则走右边的树。这就说明性别对身高有很强的影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">适用情景：</span><br><span class="line">同时它也是相对容易被攻击的分类器。这里的攻击是指人为的改变一些特征，使得分类器判断错误。常见于垃圾邮件躲避检测中。因为决策树最终在底层判断是基于单个条件的，攻击者往往只需要改变很少的特征就可以逃过监测。受限于它的简单性，决策树更大的用处是作为一些更有用的算法的基石。</span><br></pre></td></tr></table></figure><h4 id="随机森林-Random-forest"><a href="#随机森林-Random-forest" class="headerlink" title="随机森林 (Random forest)"></a>随机森林 (Random forest)</h4><p>随机森林其实算是一种集成算法。它首先随机选取不同的特征(feature)和训练样本(training sample)，生成大量的决策树，然后综合这些决策树的结果来进行最终的分类。</p><p>它相对于决策树，在准确性上有了很大的提升，同时一定程度上改善了决策树容易被攻击的特点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">适用情景：</span><br><span class="line"></span><br><span class="line">数据维度相对低（几十维），同时对准确性有较高要求时。</span><br><span class="line"></span><br><span class="line">因为不需要很多参数调整就可以达到不错的效果，基本上不知道用什么方法的时候都可以先试一下随机森林。</span><br></pre></td></tr></table></figure><h3 id="优化问题的求解方法"><a href="#优化问题的求解方法" class="headerlink" title="优化问题的求解方法"></a>优化问题的求解方法</h3><p>大部分的机器学习算法的本质都是建立优化模型，通过最优化方法对目标函数（或损失函数）进行优化，从而训练出最好的模型。常见的最优化方法有梯度下降法、牛顿法和拟牛顿法、共轭梯度法等等。</p><p>1、梯度下降法</p><p>优化思想<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当目标函数是凸函数时，梯度下降法的解是全局解。一般情况下，其解不保证是全局最优解，梯度下降法的速度也未必是最快的。梯度下降法的优化思想是用当前位置负梯度方向作为搜索方向，因为该方向为当前位置的最快下降方向，所以也被称为是”最速下降法“。最速下降法越接近目标值，步长越小，前进越慢。</span><br></pre></td></tr></table></figure></p><p>缺点<br>梯度下降法的最大问题就是会陷入局部最优，靠近极小值时收敛速度减慢。</p><p>2、批量梯度下降法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最小化所有训练样本的损失函数，使得最终求解的是全局的最优解，即求解的参数是使得风险函数最小，但是对于大规模样本问题效率低下。</span><br></pre></td></tr></table></figure></p><p>3、随机梯度下降法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最小化每条样本的损失函数，虽然不是每次迭代得到的损失函数都向着全局最优方向， 但是大的整体的方向是向全局最优解的，最终的结果往往是在全局最优解附近，适用于大规模训练样本情况。</span><br></pre></td></tr></table></figure></p><p>随机梯度下降是通过每个样本来迭代更新一次，如果样本量很大的情况（例如几十万），那么可能只用其中几万条或者几千条的样本，就已经将theta迭代到最优解了，对比上面的批量梯度下降，迭代一次需要用到十几万训练样本，一次迭代不可能最优，如果迭代10次的话就需要遍历训练样本10次。但是，SGD伴随的一个问题是噪音较BGD要多，使得SGD并不是每次迭代都向着整体最优化方向。</p><p>4、牛顿法</p><p>牛顿法是一种在实数域和复数域上近似求解方程的方法。方法使用函数f (x)的泰勒级数的前面几项来寻找方程f (x) = 0的根。牛顿法最大的特点就在于它的收敛速度很快。</p><p>牛顿法比梯度下降法快</p><p>牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快。如果更通俗地说的话，比如你想找一条最短的路径走到一个盆地的最底部，梯度下降法每次只从你当前所处位置选一个坡度最大的方向走一步，牛顿法在选择方向时，不仅会考虑坡度是否够大，还会考虑你走了一步之后，坡度是否会变得更大。所以，可以说牛顿法比梯度下降法看得更远一点，能更快地走到最底部。</p><p>但是牛顿法要算hessian矩阵的逆，比较费时间。</p><p>5、拟牛顿法</p><p>拟牛顿法的本质思想是改善牛顿法每次需要求解复杂的Hessian矩阵的逆矩阵的缺陷，它使用正定矩阵来近似Hessian矩阵的逆，从而简化了运算的复杂度。拟牛顿法和最速下降法一样只要求每一步迭代时知道目标函数的梯度。通过测量梯度的变化，构造一个目标函数的模型使之足以产生超线性收敛性。这类方法大大优于最速下降法，尤其对于困难的问题。另外，因为拟牛顿法不需要二阶导数的信息，所以有时比牛顿法更为有效。</p><p>6、拉格朗日法</p><p>拉格朗日乘数法</p><p>拉格朗日乘子法主要用于解决约束优化问题，它的基本思想就是通过引入拉格朗日乘子来将含有n个变量和k个约束条件的约束优化问题转化为含有（n+k）个变量的无约束优化问题。拉格朗日乘子背后的数学意义是其为约束方程梯度线性组合中每个向量的系数。</p><p>通过引入拉格朗日乘子建立极值条件，对n个变量分别求偏导对应了n个方程，然后加上k个约束条件（对应k个拉格朗日乘子）一起构成包含了（n+k）变量的（n+k）个方程的方程组问题，这样就能根据求方程组的方法对其进行求解</p><p>过拟合：</p><blockquote><p>如果一味的去提高训练数据的预测能力，所选模型的复杂度往往会很高，这种现象称为过拟合。所表现的就是模型训练时候的误差很小，但在测试的时候误差很大。</p></blockquote><p>训练模型很好用，测试时候误差较大</p><p><a href="http://kubicode.me/2015/08/16/Machine%20Learning/Algorithm-Summary-for-Interview/#" target="_blank" rel="noopener">参考</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv图像分割</title>
      <link href="/2018/07/19/opencv_imgseg/"/>
      <url>/2018/07/19/opencv_imgseg/</url>
      
        <content type="html"><![CDATA[<p>Opencv图像分割</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *</span><br><span class="line"> * 功能：通过灰度图做简单的图像分割,再使用findContours去掉多余的轮廓</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"> </span><br><span class="line">#include &lt;opencv2/core/core.hpp&gt;</span><br><span class="line">#include &lt;opencv2/highgui/highgui.hpp&gt;</span><br><span class="line">#include &lt;opencv2/imgproc/imgproc.hpp&gt;</span><br><span class="line"> </span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">void contours();</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    contours();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void contours()</span><br><span class="line">&#123;</span><br><span class="line">    //--1.读入图片</span><br><span class="line">    Mat image = imread(&quot;horse_hw.jpg&quot;);</span><br><span class="line"> </span><br><span class="line">    Mat gray;//mat类型数据存放图片，opencv特有</span><br><span class="line">  </span><br><span class="line">    cvtColor(image,gray,CV_RGB2GRAY);</span><br><span class="line"> </span><br><span class="line">    Mat binary;</span><br><span class="line">    threshold(gray,binary,60,255,THRESH_BINARY_INV);</span><br><span class="line"> </span><br><span class="line">    vector&lt;vector&lt;Point&gt; &gt; contours;</span><br><span class="line">    Mat binary_copy; //因为findcontours函数会改变输入的图像，所以复制一个图像作为函数的输入</span><br><span class="line">    binary.copyTo(binary_copy);</span><br><span class="line">    findContours(binary_copy,contours,CV_RETR_EXTERNAL/*获取外轮廓*/,CV_CHAIN_APPROX_NONE/*获取每个轮廓的每个像素*/);</span><br><span class="line"> </span><br><span class="line">    //遍历每一个轮廓，把多余的轮廓去掉</span><br><span class="line">    vector&lt;vector&lt;Point&gt; &gt;::const_iterator it=contours.begin();</span><br><span class="line">    while(it!=contours.end())</span><br><span class="line">    &#123;</span><br><span class="line">        if(it-&gt;size()&lt;500)</span><br><span class="line">            it = contours.erase(it);</span><br><span class="line">        else</span><br><span class="line">            ++it;</span><br><span class="line">    &#125;</span><br><span class="line">    Mat dst(image.size(),CV_8U,Scalar(0));</span><br><span class="line">    drawContours(dst,contours,-1/*绘制所有轮廓*/,Scalar(255)/*绘制为白色*/,CV_FILLED/*轮廓全部填充*/);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    //--4.显示结果(原图和结果图显示在一起)</span><br><span class="line">    const int width  = image.cols;</span><br><span class="line">    const int height = image.rows;</span><br><span class="line">    Mat show_image(Size(3*width,height),CV_8UC3);</span><br><span class="line">    //将image拷贝到显示图片指定位置</span><br><span class="line">    image.copyTo(show_image(Rect(0,0,width,height)));</span><br><span class="line">    //将binary,dst转换为3通道，使得show_image和dst通道数一致，或者使用convertTo()函数做操作</span><br><span class="line">    cvtColor(binary,binary,CV_GRAY2RGB);</span><br><span class="line">    cvtColor(dst,dst,CV_GRAY2RGB);</span><br><span class="line">    //将binary,dst拷贝image指定位置</span><br><span class="line">    binary.copyTo(show_image(Rect(width,0,width,height)));</span><br><span class="line">    dst.copyTo(show_image(Rect(2*width,0,width,height)));</span><br><span class="line">    //显示</span><br><span class="line">    imshow(&quot;show&quot;,show_image);</span><br><span class="line">    waitKey(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> Opencv </tag>
            
            <tag> 图像分割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++入门</title>
      <link href="/2018/07/19/C++%E5%85%A5%E9%97%A8/"/>
      <url>/2018/07/19/C++%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>C++入门</p><a id="more"></a><h3 id="指针入门"><a href="#指针入门" class="headerlink" title="指针入门"></a>指针入门</h3><blockquote><p>指针作用：  引用类型，传递地址，减少内存消耗<br>案例<br>int p &gt;定义变量p<br>int* p &gt;定义指针变量p<br>使用指针，先要定义指针变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int *p;     //int* p &gt;定义指针变量p</span><br><span class="line">    int a=3; </span><br><span class="line">    p=&amp;a;   //&amp;a是把a的地址赋给指针p，&amp;：取址符a</span><br><span class="line">    printf(&quot;%d\n&quot;,*p)   //输出为3</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp; 取变量的地址 &amp;(变量名)</span><br><span class="line">* 指针运算符（取值运算） *(变量名)</span><br><span class="line">&amp; *互为逆运算 *(&amp;(int i =6))=6</span><br></pre></td></tr></table></figure><p>指针变量是存储地址的变量，随机分配<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int *p1;</span><br><span class="line">char *name</span><br><span class="line"></span><br><span class="line">int x;int *p; p=&amp;x;</span><br><span class="line">答：*P=3;</span><br><span class="line">p是x的地址，*p是x的值</span><br></pre></td></tr></table></figure></p><p>常用错误：<br>1、指针不能直接复制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">错误：</span><br><span class="line">int *p; </span><br><span class="line">p =100;//错误</span><br><span class="line"></span><br><span class="line">正确：</span><br><span class="line">int i, *p, *t;</span><br><span class="line">p=&amp;i;</span><br><span class="line">t=p;</span><br><span class="line">*p *t是指针，把i的地址赋给pt指针（元素地址）</span><br></pre></td></tr></table></figure></p><p>2、不能直接给指针赋值(不能直接变量取值)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x= 20;</span><br><span class="line">printf(&quot;%d,&amp;(*x));</span><br></pre></td></tr></table></figure></p><p>Scanf函数:函数后的参数应该传入指针，不应该是值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int score;</span><br><span class="line">printf(&quot;shuru :\n&quot;);</span><br><span class="line">scanf(&quot;%d&quot;,score);</span><br></pre></td></tr></table></figure></p><p>Swap函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void swap(int *x, int *y)</span><br><span class="line">&#123;</span><br><span class="line">    int temp;//中间变量</span><br><span class="line">    temp=*x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = temp;</span><br><span class="line"></span><br><span class="line">    printf(&quot;x=%d, y=%d \n&quot;, *x, *y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    int i =13, j =45;</span><br><span class="line">    swap(&amp;i, &amp;j);</span><br><span class="line">    printf(&quot;i=%d, j=%d\n&quot;,i ,j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出： x=45,y=13    i=45,j=13</span><br></pre></td></tr></table></figure></p><h3 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h3><blockquote><p>C语言的参数传递都是值传递，当传传递一个指针给函数的时，其实质上还是值传递，除非使用双指针。<br>只有一个<em>号的时候，我们叫它一级指针。*</em> 两个星号的叫二级指针。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void  </span><br><span class="line">swap ( int *a, int *b )&#123;  </span><br><span class="line">    int c;  </span><br><span class="line">    c = *a;  </span><br><span class="line">    *a = *b;  </span><br><span class="line">    *b = c;  </span><br><span class="line">&#125;  </span><br><span class="line">int  </span><br><span class="line">main(int argc, char **argv)&#123;  </span><br><span class="line">    int a,b;  </span><br><span class="line">    a = 16;  </span><br><span class="line">    b = 32;  </span><br><span class="line">    swap( &amp;a, &amp;b);  </span><br><span class="line">    return ( a - b );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>段代码编译成汇编语言之后，除了会有代码段，数据段，堆栈，那么在调用的时候，会把main函数的参数变量压入main函数的栈帧，然后接着会压入swap函数的局部变量和参数</p><p><img src="http://hi.csdn.net/attachment/201002/9/4758664_12657012034TT4.jpg" alt=""></p><p>我们申明 **a之后，其实双指针变量a其实已经存在,内存效果如下<br><img src="http://hi.csdn.net/attachment/201002/9/4758664_1265703222WluB.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p中放的是中间桥梁bridge的地址&amp;bridge</span><br><span class="line">*p就是中间桥梁bridge的内容(即是目标操作数的地址&amp;income)，</span><br><span class="line">**p就是目标操作数</span><br><span class="line"></span><br><span class="line">中间的bridge是桥梁，中间件使用的，过度吧</span><br></pre></td></tr></table></figure></p><blockquote><p>双指针主要用在但我们想向一个A函数传递参数的时候，但是我们希望在A内部对参数做任何修改都能保存起来，那么就是用双指针吧。</p></blockquote><h3 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h3><p>IO库：<br>|头文件|类型|||<br>|-|-|-|-|<br>|iostream|istream,wistream 从流读取数据|ostream, wostream向流写入数据|iostream. wiostream读写流|<br>|fstream|ifstream, wifstream从文件读取数据|ofstream, wofstream向文件写入数据|fstream, wfstream读写文件|<br>|sstream|istringstream. wistringstream string 读取数据|ostringstream, wostringstream string 写入数据|stringstream, wstringstream string 读写string|</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型ifsream和istringstream都继承自istream;</span><br><span class="line">类型ofsream和ostringstream都继承自ostream;</span><br><span class="line">类型fsream和stringstream都继承自iostream;</span><br></pre></td></tr></table></figure><p>1、创建使用文件流对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ifstream in(ifile);//构造一个ifstream并打开给定文件</span><br><span class="line">ofstream out;//构造输出文件流，未关联任何文件</span><br><span class="line"></span><br><span class="line">in.close();//关闭文件</span><br><span class="line">in.open(ifile + &quot;2&quot;);//打开另一个文件</span><br></pre></td></tr></table></figure></p><p>ifstream,ofstream和fstream是实现文件读写操作的类型</p><p>案例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                                                                                                                                </span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">   char buffer[256];</span><br><span class="line">   ifstream in(&quot;input.txt&quot;);//文件不存在会返回错误</span><br><span class="line">   if (! in.is_open())&#123;</span><br><span class="line">       cout &lt;&lt; &quot;Error opening file&quot;&lt;&lt;endl;</span><br><span class="line">       exit (1);</span><br><span class="line">   &#125;</span><br><span class="line">   vector&lt;string&gt; a;</span><br><span class="line">   while (!in.eof())&#123;</span><br><span class="line">       in.getline (buffer,100);</span><br><span class="line">       //cout &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">       a.push_back(buffer);</span><br><span class="line">    &#125;   </span><br><span class="line">   for(unsigned int i=0;i&lt;a.size();i++)</span><br><span class="line">       cout&lt;&lt;a[i]&lt;&lt;endl;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="resize-reserve"><a href="#resize-reserve" class="headerlink" title="resize(),reserve()"></a>resize(),reserve()</h3><p>resize()，设置大小（size）;<br>reserve()，设置容量（capacity）;<br>size()是分配容器的内存大小，而capacity()只是设置容器容量大小，但并没有真正分配内存。</p><h3 id="ifstream"><a href="#ifstream" class="headerlink" title="ifstream"></a>ifstream</h3><p><a href="https://blog.csdn.net/kingstar158/article/details/6859379" target="_blank" rel="noopener">cankao</a><br><br>1、文件打开<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifstream infile(fname,ios::in);</span><br></pre></td></tr></table></figure></p><p>定义ifstream的对象infile,打开文件faname,ios::in是读取</p><div class="table-container"><table><thead><tr><th>打开文件的方式在ios类(所以流式I/O的基类)中定义</th><th></th></tr></thead><tbody><tr><td>IO流的定义</td><td>含义</td></tr><tr><td>ios::in</td><td>为输入(读)而打开文件</td></tr><tr><td>ios::out</td><td>为输出(写)而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>所有输出附加在文件末尾</td></tr><tr><td>ios::trunc</td><td>如果文件已存在则先删除该文件</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table></div><p>2、关闭文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infile.close</span><br></pre></td></tr></table></figure></p><p>3、文本文件的读写</p><p>类ofstream, ifstream 和fstream 是分别从ostream, istream 和iostream 中引申而来的。这就是为什么 fstream 的对象可以使用其父类的成员来访问数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">写入内容：</span><br><span class="line">#include &lt;fiostream.h&gt;</span><br><span class="line">    int main () &#123;</span><br><span class="line">        ofstream out(&quot;out.txt&quot;);</span><br><span class="line">        if (out.is_open()) </span><br><span class="line">       &#123;</span><br><span class="line">            out &lt;&lt; &quot;This is a line.\n&quot;;</span><br><span class="line">            out &lt;&lt; &quot;This is another line.\n&quot;;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">   //结果: 在out.txt中写入：</span><br><span class="line">   This is a line.</span><br><span class="line">   This is another line</span><br><span class="line"></span><br><span class="line">读取内容：</span><br><span class="line">// reading a text file</span><br><span class="line">    #include &lt;iostream.h&gt;</span><br><span class="line">    #include &lt;fstream.h&gt;</span><br><span class="line">    #include &lt;stdlib.h&gt;</span><br><span class="line">    </span><br><span class="line">    int main () &#123;</span><br><span class="line">        char buffer[256];</span><br><span class="line">        ifstream in(&quot;test.txt&quot;);</span><br><span class="line">        if (! in.is_open())</span><br><span class="line">        &#123; cout &lt;&lt; &quot;Error opening file&quot;; exit (1); &#125;</span><br><span class="line">        while (!in.eof() )</span><br><span class="line">        &#123;</span><br><span class="line">            in.getline (buffer,100);</span><br><span class="line">            cout &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    //结果 在屏幕上输出</span><br><span class="line">     This is a line.</span><br><span class="line">     This is another line</span><br><span class="line">```</span><br><span class="line">状态标识符</span><br></pre></td></tr></table></figure></p><p>bad()<br>如果在读写过程中出错，返回 true 。例如：当我们要对一个不是打开为写状态的文件进行写入时，或者我们要写入的设备没有剩余空间的时候。</p><p>fail()<br>除了与bad() 同样的情况下会返回 true 以外，加上格式错误时也返回true ，例如当想要读入一个整数，而获得了一个字母的时候。</p><p>eof()<br>如果读文件到达文件末尾，返回true。</p><p>good()<br>这是最通用的：如果调用以上任何一个函数返回true 的话，此函数返回 false 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">要想重置以上成员函数所检查的状态标志，你可以使用成员函数clear()，没有参数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### sizeof</span><br><span class="line">sizeof 求对象或者类型的大小`sizeof(array)`&lt;br&gt;</span><br><span class="line">[cankao](https://blog.csdn.net/tao20dage/article/details/52372604)</span><br></pre></td></tr></table></figure></p><p>特性0：sizeof是运算符，不是函数<br>特性1：sizeof不能求得void类型的长度<br>特性2：sizeof能求得void类型的指针的长度<br>特性3：sizeof能求得静态分配内存的数组的长度!<br>特性4：sizeof不能求得动态分配的内存的大小!<br>特性5：sizeof不能对不完整的数组求长度！<br>特性6：当表达式作为sizeof的操作数时，它返回表达式的计算结果的类型大小，但是它不对表达式求值！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### new(std::nothrow)</span><br><span class="line"> 顾名思义，即不抛出异常，当new一个对象失败时，默认设置该对象为NULL，这样可以方便的通过if(p == NULL) 来判断new操作是否成功</span><br><span class="line"> 建议在c++代码中，凡是涉及到new操作，都采用new(std::nothrow)，然后if(p==NULL)的方式进行判断</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">### vector</span><br><span class="line">[cankao](https://blog.csdn.net/duan19920101/article/details/50617190/)&lt;br&gt;</span><br><span class="line">在c++中，vector是一个十分有用的容器。</span><br><span class="line">作用：它能够像容器一样存放各种类型的对象，简单地说，vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。&lt;br&gt;</span><br><span class="line">&gt;1、如果你要表示的向量长度较长（需要为向量内部保存很多数），容易导致内存泄漏，而且效率会很低；&lt;br&gt;</span><br><span class="line">2、Vector作为函数的参数或者返回值时，需要注意它的写法：</span><br><span class="line">   double Distance(vector&lt;int&gt;&amp;a, vector&lt;int&gt;&amp;b) 其中的“&amp;”绝对不能少！！！</span><br><span class="line"></span><br><span class="line">   c++基本操作</span><br></pre></td></tr></table></figure></p><p>   1 、基本操作</p><p>(1)头文件#include<vector>.<br>(2)创建vector对象，vector<int> vec;<br>(3)尾部插入数字：vec.push_back(a);<br>(4)使用下标访问元素，cout&lt;<vec[0]<<endl;记住下标是从0开始的。 (5)使用迭代器访问元素.="" vector<int="">::iterator it;<br>for(it=vec.begin();it!=vec.end();it++)<br>    cout&lt;&lt;*it&lt;<endl; (6)插入元素：="" vec.insert(vec.begin()+i,a);在第i+1个元素前面插入a;="" (7)删除元素：="" vec.erase(vec.begin()+2);删除第3个元素="" vec.erase(vec.begin()+i,vec.end()+j);删除区间[i,j-1];区间从0开始="" (8)向量大小:vec.size();="" (9)清空:vec.clear();="" <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### 二维数组</span><br></pre></td></tr></table></endl;></vec[0]<<endl;记住下标是从0开始的。></int></vector></p><h1 id="include-“stdafx-h”"><a href="#include-“stdafx-h”" class="headerlink" title="include “stdafx.h”"></a>include “stdafx.h”</h1><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <cv.h></cv.h></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <vector></vector></h1><h1 id="include-2"><a href="#include-2" class="headerlink" title="include "></a>include <iostream></iostream></h1><p>using namespace std;<br>int main()<br>{<br>    using namespace std;<br>    int out[3][2] = { 1, 2,<br>             3, 4,<br>            5, 6 };<br>    vector <int*> v1;</int*></p><pre><code>v1.push_back(out[0]);v1.push_back(out[1]);v1.push_back(out[2]);cout &lt;&lt; v1[0][0] &lt;&lt; endl;//1cout &lt;&lt; v1[0][1] &lt;&lt; endl;//2cout &lt;&lt; v1[1][0] &lt;&lt; endl;//3cout &lt;&lt; v1[1][1] &lt;&lt; endl;//4cout &lt;&lt; v1[2][0] &lt;&lt; endl;//5cout &lt;&lt; v1[2][1] &lt;&lt; endl;//6return 0;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 随机数</span><br><span class="line">RAND_MAX是C中stdlib.h中宏定义的一个字符常量：</span><br><span class="line">`#define RAND_MAX Ox7FFF`</span><br><span class="line">其值最小为32767,最大为2147483647</span><br></pre></td></tr></table></figure><p>(double)rand() / RAND_MAX;//生成随机数<br>```</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大佬终极面经</title>
      <link href="/2018/07/19/%E5%A4%A7%E4%BD%AC%E7%BB%88%E6%9E%81%E9%9D%A2%E7%BB%8F/"/>
      <url>/2018/07/19/%E5%A4%A7%E4%BD%AC%E7%BB%88%E6%9E%81%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<p>大佬终极面经</p><a id="more"></a><p>作者：非理性的猫<br>链接：<a href="https://www.nowcoder.com/discuss/92930" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/92930</a><br>来源：牛客网</p><p>去年秋招在准备求职算法岗的过程中，经过一整个秋招的努力，拿了蚂蚁金服、滴滴、宜信大数据、美图几个厂的算法offer，这中间我参考了牛客网很多大神的经验，自己总结了一些经验，写成这篇文章。</p><p>一个完整的机器学习工程师的面试过程主要有以下这些环节：自我介绍、项目介绍、算法推导和解释、数据结构与算法题（写代码）。</p><p>关于自我介绍，主要就是简单介绍下自己的教育背景，在校期间的研究方向和所做的项目以及在项目中所充当的角色等等，为之后的面试做个铺垫，让面试官从中捕捉点来问。</p><p>项目介绍是最为重要的，这也是体现你综合实力的地方，对项目背景、项目实现的方案，项目所实现的东西都要了如指掌，做机器学习的，必然需要准备一到两个重点的机器学习项目，可以是比赛，也可以是实验室项目，关键是项目中间的技术细节都要了如指掌，比如你用了树模型，就得知道所有树模型相关的推导和原理，决不能含糊，一旦你说不太清楚，面试官就会对项目的真实性存疑。参加比赛应该是没有实验室项目的同学最佳的积累经验的途径，比较好的比赛平台有Kaggle、天池大数据、datacastle等</p><p>接下来就是机器学习算法原理和推导，这也是要重点去准备的，在面试前得达到，给你一张白纸，你可以把推导的每一步写的清清楚楚的，推导的话面试常考逻辑回归和SVM的推导，关于原理面试官常会问你几个树模型之间的对比等等等，其他的算法比如LR、SVM、EM、Adaboost、PageRank、 FFM、决策树，随机森林， GBDT ， XGBoost 、推荐算法、聚类、CNN、RNN、LSTM、Word2Vec等等，以及他们的适用场景，再如一些机器学习的理论，非平衡问题、过拟合问题，交叉验证问题，模型选择问题，模型融合问题。这一部分我会在文末贴出一个问题集锦，大家按照这个去准备就行。还有必看的书李航的《统计学习方法》、周志华的《机器学习》、项亮的《推荐系统实践》</p><p>最后就是写代码了，很多非计算机出身的大都会栽在这个地方，代码写得少，训练不到位，就会导致当场思路不清晰，不知从哪写起，但目前市面上已经有很多专门为这块总结的一些书籍，推荐使用《剑指offer》、《王道程序员求职宝典》等等，有时间的话再刷一下leetcode。排序算法、查找算法、二叉树遍历这些最基本的一定要很顺溜的写下来，其他的就看自己去拓展了，同样的，我也总结了一些笔记供大家参考，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">机器学习</span><br><span class="line">机器学习算法系列（40）：机器学习中的数据清洗与特征处理综述</span><br><span class="line">机器学习算法系列（39）：实例详解机器学习如何解决问题</span><br><span class="line">机器学习算法系列（38）：外卖订单量预测异常报警模型实践</span><br><span class="line">机器学习算法系列（37）：外卖O2O的用户画像实践</span><br><span class="line">机器学习算法系列（36）：GBDT算法原理深入解析</span><br><span class="line">机器学习算法系列（35）：使用Sklearn进行集成学习（实践）</span><br><span class="line">机器学习算法系列（34）：使用Sklearn进行集成学习（理论）</span><br><span class="line">机器学习算法系列（33）：特征处理（Feature Processing）</span><br><span class="line">机器学习算法系列（32）：MapReduce执行流程详解</span><br><span class="line">机器学习算法系列（31）：在线最优化求解（online Optimization）</span><br><span class="line">机器学习算法系列（30）：Scikit-Learn总结</span><br><span class="line">机器学习算法系列（29）：Sparsity and Some Basics of L1 Regularization</span><br><span class="line">机器学习算法系列（28）：L1、L2正则化</span><br><span class="line">机器学习算法系列（27）：Isolation Forest</span><br><span class="line">机器学习算法系列（26）：因子分解机（FM）与场感知分解机（FFM）</span><br><span class="line">机器学习算法系列（24）：机器学习中的损失函数</span><br><span class="line">机器学习算法系列（25）：最速下降法、牛顿法、拟牛顿法</span><br><span class="line">机器学习算法系列（23）：TF-IDF与余弦相似度</span><br><span class="line">机器学习算法系列（22）：主成分分析</span><br><span class="line">机器学习算法系列（21）：SVD</span><br><span class="line">机器学习算法系列（20）：机器学习模型优化四要素</span><br><span class="line">机器学习算法系列（19）：机器学习性能评价指标</span><br><span class="line">机器学习算法系列（18）：方差偏差权衡（Bias-Variance Tradeoff）</span><br><span class="line">机器学习算法系列（17）：非平衡数据处理</span><br><span class="line">机器学习算法系列（16）：统计学习概论</span><br><span class="line">机器学习算法系列（15）：EM算法</span><br><span class="line">机器学习算法系列（14）：关联分析</span><br><span class="line">机器学习算法系列（13）：推荐系统（3）—矩阵分解技术</span><br><span class="line">机器学习算法系列（13）：推荐系统（2）—基于领域的协同过滤</span><br><span class="line">机器学习算法系列（13）：推荐系统（1）—简介</span><br><span class="line">机器学习算法系列（12）：SVM（4）—SMO</span><br><span class="line">机器学习算法系列（12）：SVM（3）—非线性支持向量机</span><br><span class="line">机器学习算法系列（12）：SVM（2）—线性支持向量机</span><br><span class="line">机器学习算法系列（12）：SVM（1）—线性可分支持向量机</span><br><span class="line">机器学习算法系列（11）：聚类（4）—密度最大值聚类</span><br><span class="line">机器学习算法系列（11）：聚类（3）—DBSCAN</span><br><span class="line">机器学习算法系列（11）：聚类（2）—Kmeans</span><br><span class="line">机器学习算法系列（11）：聚类（1）—简介</span><br><span class="line">机器学习算法系列（10）：朴素贝叶斯</span><br><span class="line">机器学习算法系列（9）：感知机</span><br><span class="line">机器学习算法系列（8）：XgBoost</span><br><span class="line">机器学习算法系列（7）：GBDT</span><br><span class="line">机器学习算法系列（6）：AdaBoost</span><br><span class="line">机器学习算法系列（5）：随机森林</span><br><span class="line">机器学习算法系列（4）：决策树</span><br><span class="line">机器学习算法系列（3）：逻辑斯谛回归</span><br><span class="line">机器学习算法系列（2）：线性回归</span><br><span class="line">机器学习算法系列（1）：K近邻</span><br><span class="line"></span><br><span class="line">自然语言处理</span><br><span class="line">自然语言处理系列（10）：自然语言处理的发展与趋势</span><br><span class="line">自然语言处理系列（9）：DCNN</span><br><span class="line">自然语言处理系列（8）：RCNN</span><br><span class="line">自然语言处理系列（7）：TextCNN调参技巧</span><br><span class="line">自然语言处理系列（6）：TextCNN</span><br><span class="line">自然语言处理系列（5）：FastText</span><br><span class="line">自然语言处理系列（4）：深度学习解决大规模文本分类问题</span><br><span class="line">自然语言处理系列（3）：中文维基语料词向量训练</span><br><span class="line">自然语言处理系列（2）：Word2Vec</span><br><span class="line">自然语言处理系列（1）：词向量和语言模型</span><br><span class="line"></span><br><span class="line">深度学习</span><br><span class="line">深度学习系列（12）：pytorch实现卷积神经网络</span><br><span class="line">深度学习系列（11）：神经网络防止过拟合的方法</span><br><span class="line">深度学习系列（10）：DMC—卷积神经网络分享</span><br><span class="line">深度学习系列（9）：Batch Normalization</span><br><span class="line">深度学习系列（8）：激活函数</span><br><span class="line">深度学习系列（7）：神经网络的优化方法</span><br><span class="line">深度学习系列（6）：递归神经网络</span><br><span class="line">深度学习系列（5）：长短时记忆网络（LSTM）</span><br><span class="line">深度学习系列（4）：循环神经网络（RNN）</span><br><span class="line">深度学习系列（3）：卷积神经网络（CNN）</span><br><span class="line">深度学习系列（2）：神经网络MNIST实战</span><br><span class="line">深度学习系列（1）：神经网络与反向传播算法</span><br><span class="line"></span><br><span class="line">数据结构与算法</span><br><span class="line">数据结构与算法题解（11）：最长回文子串</span><br><span class="line">数据结构与算法题解（10）：0-1背包问题与部分背包问题</span><br><span class="line">数据结构与算法题解（9）：最长公共子序列和最长公共子串</span><br><span class="line">数据结构与算法题解（8）：KMP算法</span><br><span class="line">数据结构与算法题解（7）：最短编辑距离</span><br><span class="line">数据结构与算法题解（6）：重点掌握</span><br><span class="line">数据结构与算法题解（5）：剑指offer解题报告</span><br><span class="line">数据结构与算法题解（4）：二叉树题解</span><br><span class="line">数据结构与算法题解（3）：字符串题解</span><br><span class="line">数据结构与算法题解（2）：数组题解</span><br><span class="line">数据结构与算法题解（1）：链表题解</span><br><span class="line"></span><br><span class="line">数据结构与算法（19）：海量数据处理</span><br><span class="line">数据结构与算法（18）：倒排索引</span><br><span class="line">数据结构与算法（17）：simhash</span><br><span class="line">数据结构与算法（16）：一致性哈希</span><br><span class="line">数据结构与算法（15）：布隆过滤器</span><br><span class="line">数据结构与算法（14）：最短路算法</span><br><span class="line">数据结构与算法（13）：深度优先搜索和广度优先搜索</span><br><span class="line">数据结构与算法（12）：排序</span><br><span class="line">数据结构与算法（11）：哈希表</span><br><span class="line">数据结构与算法（10）：查找</span><br><span class="line">数据结构与算法（9）：Trie树</span><br><span class="line">数据结构与算法（8）：红黑树</span><br><span class="line">数据结构与算法（7）：数据库索引原理及优化</span><br><span class="line">数据结构与算法（6）：B树、B+树</span><br><span class="line">数据结构与算法（5）：AVL树</span><br><span class="line">数据结构与算法（4）：二叉查找树</span><br><span class="line">数据结构与算法（3）：二叉树</span><br><span class="line">数据结构与算法（2）：栈与队列</span><br><span class="line">数据结构与算法（1）：数组与链表</span><br><span class="line"></span><br><span class="line">Java</span><br><span class="line">Java学习笔记（12）：单例模式</span><br><span class="line">Java学习笔记（11）：进程与线程</span><br><span class="line">Java学习笔记（10）：QA</span><br><span class="line">Java学习笔记（9）：内部类、抽象类、接口</span><br><span class="line">Java学习笔记（8）：常用库类、向量与哈希</span><br><span class="line">Java学习笔记（7）：深入理解java异常处理机制</span><br><span class="line">Java学习笔记（6）：异常处理</span><br><span class="line">Java学习笔记（5）：static、final关键字和Object类</span><br><span class="line">Java学习笔记（4）：多态</span><br><span class="line">Java学习笔记（3）：继承、覆盖、重载</span><br><span class="line">Java学习笔记（2）：类与对象</span><br><span class="line">Java学习笔记（1）：语法基础</span><br><span class="line"></span><br><span class="line">Java集合学习手册（11）：Java HashMap源码全剖析</span><br><span class="line">Java集合学习手册（10）：hashCode方法与equal方法</span><br><span class="line">Java集合学习手册（9）：Java 集合对比</span><br><span class="line">Java集合学习手册（8）：Java 集合框架</span><br><span class="line">Java集合学习手册（7）：Java LinkedList</span><br><span class="line">Java集合学习手册（6）：Java ArrayList</span><br><span class="line">Java集合学习手册（5）：Java LinkedHashSet</span><br><span class="line">Java集合学习手册（4）：Java LinkedHashMap</span><br><span class="line">Java集合学习手册（3）：Java HashTable</span><br><span class="line">Java集合学习手册（2）：Java HashSet</span><br><span class="line">Java集合学习手册（1）：Java HashMap</span><br></pre></td></tr></table></figure><p>以下是我总结的机器学习提问集锦，大家可以在把所有算法过了一遍的基础上把一个个问题都仔细揣摩一遍，加强对算法的理解和延伸。</p><h3 id="SVM："><a href="#SVM：" class="headerlink" title="SVM："></a>SVM：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">简单介绍SVM（详细原理）：从分类平面，到求两类间的最大间隔，到转化为求间隔分之一，等优化问题，然后就是优化问题的解决办法，首先是用拉格拉日乘子把约束优化转化为无约束优化，对各个变量求导令其为零，得到的式子带入拉格朗日式子从而转化为对偶问题， 最后再利用SMO（序列最小优化）来解决这个对偶问题。svm里面的c有啥用</span><br><span class="line">SVM的推导，解释原问题和对偶问题，SVM原问题和对偶问题的关系，KKT限制条件，KKT条件用哪些，完整描述；软间隔问题，解释支持向量、核函数（哪个地方引入、画图解释高维映射，高斯核可以升到多少维，如何选择核函数），引入拉格朗日的优化方法的原因，最大的特点，损失函数解释，</span><br><span class="line">SVM与LR最大区别，LR和SVM对于outlier的敏感程度分析，逻辑回归与SVM的区别</span><br><span class="line">为什么要把原问题转换为对偶问题？因为原问题是凸二次规划问题，转换为对偶问题更加高效。为什么求解对偶问题更加高效？因为只用求解alpha系数，而alpha系数只有支持向量才非0，其他全部为0.alpha系数有多少个？样本点的个数</span><br><span class="line">加大训练数据量一定能提高SVM准确率吗？</span><br><span class="line">与感知器的联系和优缺点比较</span><br><span class="line">如何解决多分类问题、可以做回归吗，怎么做</span><br><span class="line">它与其他分类器对比的优缺点，它的速度</span><br><span class="line">机器学习有很多关于核函数的说法，核函数的定义和作用是什么？https://www.zhihu.com/question/24627666</span><br><span class="line">支持向量机(SVM)是否适合大规模数据？https://www.zhihu.com/question/19591450</span><br><span class="line">SVM和逻辑斯特回归对同一样本A进行训练，如果某类中增加一些数据点，那么原来的决策边界分别会怎么变化？https://www.zhihu.com/question/30123068</span><br><span class="line">各种机器学习的应用场景分别是什么？例如，k近邻,贝叶斯，决策树，svm，逻辑斯蒂回归和最大熵模型。https://www.zhihu.com/question/26726794</span><br><span class="line">Linear SVM 和 LR 有什么异同？https://www.zhihu.com/question/26768865</span><br></pre></td></tr></table></figure><h3 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LR推导（伯努利过程，极大似然，损失函数，梯度下降）有没有最优解？</span><br><span class="line">LR可以用核么？可以怎么用？l1和l2正则项是啥？lr加l1还是l2好？加哪个可以用核（加l2正则项，和svm类似，加l2正则项可以用核方便处理）</span><br><span class="line">LR可以用来处理非线性问题么？（还是lr啊 只不过是加了核的lr 这里加核是显式地把特征映射到高维 然后再做lr）怎么做？可以像SVM那样么？为什么？</span><br><span class="line">为什么LR需要归一化或者取对数，为什么LR把特征离散化后效果更好，为什么把特征组合之后还能提升，反正这些基本都是增强了特征的表达能力，或者说更容易线性可分吧</span><br><span class="line">美团技术团队《Logistic Regression 模型简介》https://tech.meituan.com/intro_to_logistic_regression.html</span><br><span class="line">SVM和logistic回归分别在什么情况下使用？https://www.zhihu.com/question/21704547</span><br><span class="line">逻辑斯蒂回归能否解决非线性分类问题？https://www.zhihu.com/question/29385169</span><br><span class="line">为什么LR可以用来做CTR预估？https://www.zhihu.com/question/23652394</span><br><span class="line">逻辑回归估计参数时的目标函数 （就是极大似然估计那部分），逻辑回归估计参数时的目标函数 （呵呵，第二次） 逻辑回归估计参数时的目标函数 如果加上一个先验的服从高斯分布的假设，会是什么样（天啦。我不知道，其实就是在后面乘一个东西，取log后就变成加一个东西，实际就变成一个正则项）</span><br><span class="line">逻辑回归估计参数时的目标函数逻辑回归的值表示概率吗？（值越大可能性越高，但不能说是概率）</span><br><span class="line">手推逻辑回归目标函数，正类是1，反类是-1，这里挖了个小坑，一般都是正例是1，反例是0的，他写的时候我就注意到这个坑了，然而写的太快又给忘了，衰，后来他提醒了一下，改了过来，就是极大似然函数的指数不一样，然后说我这里的面试就到这了。</span><br><span class="line">看没看过scikit-learn源码LR的实现？（回头看了一下是调用的liblinear，囧）</span><br><span class="line">为什么LR需要归一化或者取对数，为什么LR把特征离散化后效果更好，为什么把特征组合之后还能提升，反正这些基本都是增强了特征的表达能力，或者说更容易线性可分吧</span><br><span class="line">naive bayes和logistic regression的区别http://m.blog.csdn.net/blog/muye5/19409615</span><br><span class="line">LR为什么用sigmoid函数。这个函数有什么优点和缺点？为什么不用其他函数？sigmoid函数由那个指数族分布，加上二项分布导出来的。损失函数是由最大似然估计求出的。</span><br><span class="line">了解其他的分类模型吗，问LR缺点，LR怎么推导（当时我真没准备好，写不出来）写LR目标函数，目标函数怎么求最优解（也不会）讲讲LR的梯度下降，梯度下降有哪几种，逻辑函数是啥</span><br></pre></td></tr></table></figure><h3 id="L1和L2"><a href="#L1和L2" class="headerlink" title="L1和L2"></a>L1和L2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">L2正则化，为什么L2正则化可以防止过拟合？L1正则化是啥？</span><br><span class="line">深度学习里面怎么防止过拟合？（data aug；dropout；multi-task learning）如何防止过拟合，我跟他列举了4中主要防止过拟合方法：Early Stopping、数据集扩充、正则化法以及dropout，还详细跟他说了每种方法原理及使用的场景，并解释我在哪些项目里具体用到了这些方法，</span><br><span class="line">机器学习中使用「正则化来防止过拟合」到底是一个什么原理？为什么正则化项就可以防止过拟合？https://www.zhihu.com/question/20700829</span><br><span class="line">机器学习中常常提到的正则化到底是什么意思？https://www.zhihu.com/question/20924039</span><br><span class="line">什么是正则项，L1范式，L2范式区别是什么，各自用在什么地方？L1 与 L2 的区别以及如何解决 L1 求导困难；</span><br><span class="line">L1正则为什么能让系数变为0？L1正则怎么处理0点不可导的情形？（这个谁会？近端梯度下降）</span><br><span class="line">L0，L1，L2正则化(如果能推导绝对是加分项，一般人最多能画个等高线，L0是NP问题)其实上面的这些问题基本都能在《李航：统计学习方法》《周志华：机器学习》里面找到，能翻个4，5遍基本就无压力了</span><br><span class="line">避免过拟合策略、如何提高模型泛化能力、L1与L2正则区别，优缺点、生成式，判别式模型、深度学习这块了解多少、</span><br><span class="line">如何克服过拟合，欠拟合</span><br><span class="line">L1 与 L2 的区别以及如何解决 L1 求导困难；</span><br><span class="line">L1正则为什么可以把系数压缩成0，坐标下降法的具体实现细节</span><br><span class="line">为什么L1正则可以实现参数稀疏，而L2正则不可以？为什么L1很多系数可以被压缩为0，L2是被压缩至接近于0？</span><br><span class="line">树模型</span><br></pre></td></tr></table></figure><h3 id="决策树："><a href="#决策树：" class="headerlink" title="决策树："></a>决策树：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">rf ， gbdt 的区别； gbdt ， xgboost 的区别（烂大街的问题最好从底层原理去分析回答）</span><br><span class="line">介绍决策树，谈了3种决策树及其区别和适应场景</span><br><span class="line">决策树处理连续值的方法；简单介绍决策树几种算法，有什么区别？</span><br><span class="line">决策树基本模型介绍？决策树算法中缺失值怎么处理？决策树算法在应用中有什么值得注意的地方。SVM、LR、决策树的对比？GBDT 和 决策森林 的区别？决策树的特性？（3 ）决策树处理连续值的方法；</span><br><span class="line">解释下随机森林和gbdt的区别。gbdt的boosting体现在哪里。解释下随机森林节点的分裂策略，以及它和gbdt做分类有什么区别？哪个效果更好些？为什么？哪个更容易过拟合？为什么？ 问了随机森林的损失函数，和lr的优缺点对比， adaboost和随机森林的比较，为了防止随机森林过拟合可以怎么做，是否用过随机森林，怎么用的。</span><br><span class="line">随机森林和GBDT的区别？CART（回归树用平方误差最小化准则，分类树用基尼指数最小化准则）</span><br><span class="line">GBDT（利用损失函数的负梯度在当前模型的值作为回归问题提升树算法中的残差的近似值，拟合一个回归树）</span><br><span class="line">随机森林（Bagging+CART）</span><br><span class="line">SVM与随机森林比较</span><br><span class="line">改变随机森林的训练样本数据量，是否会影响到随机森林学习到的模型的复杂度</span><br><span class="line">Logistics与随机森林比较</span><br><span class="line">GBDT与随机森林比较随机森林的学习过程；随机森林中的每一棵树是如何学习的；随机森林学习算法中CART树的基尼指数是什么？</span><br><span class="line">RF 与 GBDT 区别，原理优缺点适用场景分析，哪个具备交叉验证功能等</span><br><span class="line">接着写一下信息增益的公式。之后就是问机器学习相关算法，说了一下bagging跟boosting，之后问了GBDT（没做过，只能说说大体思路）。（2 ） rf ， gbdt 的区别； gbdt ， xgboost 的区别；</span><br><span class="line">说说xgboost、gbdt区别、Tree-based Model如何处理连续型特征。</span><br><span class="line">让我把一个完整的数据挖掘流程讲一下，从预处理，特征工程，到模型融合。介绍常用的算法，gbdt和xgboost区别，具体怎么做预处理，特征工程，模型融合常用方式，融合一定会提升吗？</span><br><span class="line">gbdt树根据什么分裂（瞎扯的梯度近似残差、梯度下降方向，其实还是信息增益这种东西）</span><br><span class="line">gbdt怎么并发（特征选择层面，树层面不能并发）</span><br><span class="line">介绍LR、RF、GBDT ，分析它们的优缺点，是否写过它们的分布式代码</span><br><span class="line">XGB和GBDT区别与联系也会经常问到：https://www.zhihu.com/question/41354392/answer/128008021?group_id=773629156532445184</span><br><span class="line">CART（回归树用平方误差最小化准则，分类树用基尼指数最小化准则）、Logistics（推导）、GBDT（利用损失函数的负梯度在当前模型的值作为回归问题提升树算法中的残差的近似值，拟合一个回归树）</span><br><span class="line">在面试过程中主动引导面试官提问，比如面试官让你讲解 gbdt 原理时，这会你可以跟他说，一般说起 gbdt ，我们都会跟 rf 以及 xgboost 一块讲，然后你就可以主动地向面试官输出你的知识；面试并不是死板地你问我答，而是一种沟通交流，所以尽可能地把面试转化成聊天式的对话，多输出自己一些有价值的观点而不是仅仅为了回答面试官的问题；</span><br><span class="line">几种树模型的原理和对比，</span><br><span class="line">特征选取怎么选？ 为什么信息增益可以用来选特征？</span><br><span class="line">信息熵和基尼指数的关系(信息熵在x=1处一阶泰勒展开就是基尼指数)</span><br><span class="line">介绍xgboost一下。写下xgboost目标函数。（因为我提到xgboost在目标函数里显式地加入了正则项..血雪崩）怎么调整XGB参数；xgboost原理</span><br></pre></td></tr></table></figure><h3 id="K-means"><a href="#K-means" class="headerlink" title="K-means"></a>K-means</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">k-means 聚类的原理以及缺点及对应的改进；kmeans 算法的优缺点。。。。</span><br><span class="line">kmeans 的原理，优缺点以及改进；</span><br><span class="line">em 与 kmeans 的关系；</span><br><span class="line">kmeans 代码；</span><br><span class="line">说说 Kmeans 算法， Kmeans 算法 K 怎么设置、适用什么样数据集、怎么评价 Kmeans 聚类结果、 Kmeans 有什么优缺点？你的项目中使用 Kmeans 遇到哪些问题，怎么解决的 ?</span><br><span class="line">用 EM 算法推导解释 Kmeans。</span><br><span class="line">KMeans的算法伪代码</span><br><span class="line">如何判断自己实现的 LR、Kmeans 算法是否正确？</span><br><span class="line">如何优化kmeans算法</span><br><span class="line">如何用hadoop实现k-means</span><br><span class="line">手写k-means的伪代码（就6行）</span><br></pre></td></tr></table></figure><h3 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bagging和boosting是怎么做的和他们的比较</span><br><span class="line">详细讨论了样本采样和bagging的问题</span><br><span class="line">聊的比较多的是如何知道一个特征的重要性，如何做ensemble哪些方法比较好。聊了聊计算广告方面FM，embedding。</span><br><span class="line">常见融合框架原理，优缺点，bagging，stacking，boosting，为什么融合能提升效果</span><br><span class="line">是否了解线性加权、bagging、boosting、cascade等模型融合方式</span><br><span class="line">K-means起始点http://www.cnki.com.cn/Article/CJFDTotal-DNZS200832067.htm</span><br></pre></td></tr></table></figure><h3 id="贝叶斯"><a href="#贝叶斯" class="headerlink" title="贝叶斯"></a>贝叶斯</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">朴素贝叶斯分类器原理以及公式，出现估计概率值为 0 怎么处理（拉普拉斯平滑），缺点；</span><br><span class="line">解释贝叶斯公式和朴素贝叶斯分类。</span><br><span class="line">贝叶斯分类，这是一类分类方法，主要代表是朴素贝叶斯，朴素贝叶斯的原理，重点在假设各个属性类条件独立。然后能根据贝叶斯公式具体推导。考察给你一个问题，如何利用朴素贝叶斯分类去分类，比如：给你一个人的特征，判断是男是女，比如身高，体重，头发长度等特征的的数据，那么你要能推到这个过程。给出最后的分类器公式。</span><br><span class="line">那你说说贝叶斯怎么分类啊？比如说看看今天天气怎么样？我：blabla，，，利用天气的历史数据，可以知道天气类型的先验分布，以及每种类型下特征数据（比如天气数据的特征：温度啊，湿度啊）的条件分布，这样我们根据贝叶斯公式就能求得天气类型的后验分布了。。。。面试官：en（估计也比较满意吧）那你了解关于求解模型的优化方法吗？一般用什么优化方法来解？</span><br><span class="line">贝叶斯分类器的优化和特殊情况的处理</span><br></pre></td></tr></table></figure><h3 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">解释一下CNN、介绍CNN、卷积公式，以及特点，假设面试官什么都不懂，详细解释 CNN 的原理；问CNN的细节特点，哪些特点使得CNN这么好用，哪些场景用CNN可以，抽象一下这些场景的特征，可以降采样但仍能保持主要信息；局部连接可以保证获取局部信息；权值共享保证高效，DNN和CNN相比有哪些区别，用过RNN么？画一下RNN的图，你在深度学习过程中遇到过哪些问题？如果出现过拟合你怎么办？dropout是什么？它有什么用？你会怎么用它？当全连接跟dropout连着用需要注意什么？你之前过拟合怎么解决的？如果本身training loss就很大你怎么办？如果数据不变，怎么调整网络结构解决这个问题？（batch normalization）梯度消失知道么？为什么会出现梯度消失？dnn和rnn中的梯度消失原理一样么？dnn中是哪个部分导致梯度消失？（激活层如sigmoid）rnn中怎么解决梯度消失问题？（lstm的结构相对普通RNN多了加和，为避免梯度消散提供了可能。线性自连接的memory是关键。）讲一下CNN吧，有哪些重要的特点？CNN可以处理哪些场景？为什么CNN要用权值共享？（每个卷积核相当于一个特征提取器，它的任务是匹配局部图像中的特征，权值共享后，匹配的特征方式都是一样的，提取若干特征后就知道学习的是啥了）CNN里面哪些层？讲一下卷积。卷积的形式是啥样？给定一个输入，算输出的feature map大小。卷积有啥用？池化有啥用？有哪些池化方式？池化除了降采样还有啥用？（就不知道了）还有哪些层你用过？讲讲dropout。dropout内部是怎么实现只让部分信号通过并不更新其余部分对于输入的权值的？讲讲BN（BatchNormalization）为什么好？全连接有什么用处？知道RNN么？讲讲RNN大致的实现思路。知道梯度消失么？为什么会出现梯度消失？RNN里的梯度消失一般怎么处理？细讲下lstm的结构，这样设计为什么好？（门关闭，当前信息不需要，只有历史依赖；门打开，历史和当前加权平均）你觉得梯度消失靠引入一些新的激活层可以完全解决么？为什么？</span><br><span class="line">问了做的比赛里面使用tensorflow的细节，LSTM里调参的细节</span><br><span class="line">用过哪些库或者工具，mkl，cuda这些会用吗？</span><br><span class="line">有一个弱分类器和大量未被标记过的图像数据，如何人工标记图像来对分类器进行提升</span><br><span class="line">介绍下RNN和它的优缺点</span><br><span class="line">让我推导BP反向传播、随机梯度下降法权重更新公式</span><br><span class="line">卷积神经网络结构特点、各参数对模型结果影响、项目进展遇到的难题、推导BP神经网络参数更新方式、随机梯度下降法（SGD）优化函数存在的缺点以及拟牛顿法在优化函数使用上更有优势、修改Caffe开源框架、开源社区代码贡献量就跟我聊了很多行业发展趋势及问题，知道目前深度学习的一个趋势，也了解到最新行业发展动态，改进相机智能化程度，也聊到了美颜相机美颜效果以及小米相机人脸分类、年龄检测等等不足之处，了解到新兴行业大佬商汤科技和旷视科技（face++脸草）在研究的热门方向</span><br><span class="line">看到有deep learning相关的项目，就问了deep learning 相关问题：如何减少参数（权值共享、VGG的感受野、GoogLeNet的inception ），激活函数的选择（sigmoid-&gt;ReLu-&gt;LReLU-&gt;PReLU ），为什么之前没有深度网络出现（数据量不够+机器性能），由数据引申到数据不平衡怎么处理（10W正例，1W负例，牛客上有原题），</span><br><span class="line">后面问了下DNN原理，应用，瞎扯一通……</span><br><span class="line">你了解神经网络吗？我：了解一些，讲感知机，然后是BP网络。简单讲了一下原理。</span><br><span class="line">图像处理题：如何找相似图片。我说用感知哈希算法，计算汉明距离，他说这种方法精度不行；我说那就用SIFT算法吧，他说SIFT效果还可以，但计算有点繁重，有没有轻量级的方法？我想起来去年在美图秀秀实习时，曾经做过一种图像滤波算法，有一步是把像素点用K-means聚类。我就说先把图片灰度化，然后用K-means聚类，把聚类后的各个中心点作为一张图片的特征向量如果两张图片的特征向量相近则说明这两张图片相似。貌似我这个答案有点出乎他的意料，他意味深长地说了个“行吧~~~~”（个人觉得颜色直方图匹配是个他期待的常规回答）</span><br><span class="line">介绍卷积神经网络，和 DBN 有什么区别？</span><br><span class="line">Deep CNN, Deep RNN, RBM的典型应用与局限，看Hinton讲义和Paper去吧</span><br><span class="line">神经网络,plsi的推导</span><br><span class="line">验证码图片的去噪和提取字符</span><br><span class="line">有限状态自动机,然后要我画状态转移图.</span><br></pre></td></tr></table></figure><h3 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用过哪些聚类算法，解释密度聚类算法。</span><br><span class="line">聚类算法中的距离度量有哪些？</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">梯度下降的优缺点；主要问最优化方面的知识，梯度下降法的原理以及各个变种（批量梯度下降，随机梯度下降法， mini 梯度下降法），以及这几个方法会不会有局部最优问题，牛顿法原理和适用场景，有什么缺点，如何改进（拟牛顿法）</span><br><span class="line">常用优化算法：1.梯度下降法：又有随机梯度下降和负梯度下降，2.牛顿法 主要是问了各自的优缺点，速度，能不能得到全局最优解，牛顿法的二次收敛等</span><br><span class="line">问你如果有若干个极小值点，如何避免陷入局部最优解。</span><br><span class="line">它们间的牛顿学习法、SGD如何训练，</span><br><span class="line">如何判断函数凸或非凸？</span><br><span class="line">线性回归的梯度下降和牛顿法求解公式的推导</span><br><span class="line">最速下降法和共轭梯度法 wolfe条件 最速下降法和共轭梯度法的收敛速度如何判断</span><br><span class="line">深刻理解常用的优化方法：梯度下降、牛顿法、各种随机搜索算法（基因、蚁群等等），深刻理解的意思是你要知道梯度下降是用平面来逼近局部，牛顿法是用曲面逼近局部等等。</span><br></pre></td></tr></table></figure><h3 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">介绍SVD、SVD++</span><br><span class="line">推荐系统的冷启动问题如何解决</span><br><span class="line">深度学习在推荐系统上可能有怎样的发挥？</span><br><span class="line">推荐系统的算法中最近邻和矩阵分解各自适用场景</span><br><span class="line">白板写SVD/SVD++公式，SGD迭代更新p，q矩阵公式，SVD/SVD++优化方法</span><br><span class="line">对推荐算法的未来看法；</span><br><span class="line">用过什么算法？最好是在项目/实习的大数据场景里用过，比如推荐里用过 CF、LR，</span><br><span class="line">我面的推荐，问了各类协同过滤的好与坏。</span><br><span class="line">问了一个很有意思的问题，现实应用中的Top-N推荐问题和学术研究中的评分预测问题之间有什么不同。问我ItemCF的工程实现，面对大数据如何实现，又追问了有没有什么工程优化算法。这个问题我没答好，一开始我说了一个MapReduce模型，他问能不能更快一点，我就卡那了。。。最后面试官告诉我，不能只从算法角度分析，要从系统设计分析，利用内存来减小MapReduce的吞吐量。（当然也许从MapReduce那一刻开始我就输了也不一定）</span><br><span class="line">推荐系统的算法中最近邻和矩阵分解各自适用场景http://www.doc88.com/p-3961053026557.html</span><br></pre></td></tr></table></figure><h3 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">那你对pca了解吗？我：了解啊，面试官：那讲一下pca是用来干嘛的？我：pca啊，可以用来分析主方向啊，降维啊，特征筛选啊，具体方法是用svd分解得到特征值矩阵和特征向量矩阵，然后根据不同的任务对选择特征值或向量进行计算。</span><br></pre></td></tr></table></figure><p>EM<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">采用 EM 算法求解的模型有哪些，为什么不用牛顿法或梯度下降法？</span><br></pre></td></tr></table></figure></p><h3 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用过哪些 NLP 算法项目中用过哪些机器学习算法。</span><br><span class="line">海量的 item 算文本相似度的优化方法；</span><br><span class="line">解释 word2vec 的原理以及哈夫曼树的改进；word2vec的原理</span><br><span class="line">二面面试官主要跟我聊简历上的几个项目，他好像不能理解词向量的形式，反复解释了很多遍，问的问题都比较简单，有TF-IDF,余弦相似度，分词工具等等。</span><br><span class="line">然后我说我做过LDA，问我，Dirichlet Distribution的定义和性质，并问我，为什么它和multinomial distribution是共轭的，顺便问了我啥叫共轭分布。</span><br></pre></td></tr></table></figure><h3 id="关联分析："><a href="#关联分析：" class="headerlink" title="关联分析："></a>关联分析：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目中涉及到频繁模式挖掘，于是问了一下如何实现的？ 用的是 Apriori算法，描述他的原理过程，关键字眼：支持度，支持度计数，k项候选频繁项集，怎么从k项到k+1项等，连接剪枝过程。</span><br></pre></td></tr></table></figure><h3 id="hadoop"><a href="#hadoop" class="headerlink" title="hadoop"></a>hadoop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">简单介绍 MapReduce 原理，有没有看过源码，说说 Map 阶段怎么实现的,</span><br><span class="line">MapReduce 实现统计出现次数最多的前 100 个访问 IP.</span><br><span class="line">MapReduce 实现统计不重复用户 ID,MapReduce 实现两个数据集求交集。</span><br><span class="line">HBase 行健怎么设计,spark 性能一般优化方法,spark streaming 和 storm 区别.给了一张笔试题， 10 道选择，一道大题。选择题是 java 基础知识，大题一个有三问：根据场景写出 Hive 建表语句； Hsql 从表中查询；</span><br><span class="line">用MapReduce写好友推荐，在一堆单词里面找出现次数最多的k个</span><br><span class="line">用分布式的方法做采样怎么保证采样结果完全符合预期？</span><br><span class="line">后面又问了Hadoop,Spark,storm下面的产品，原理，适用场景，</span><br><span class="line">写一个 Hadoop 版本的 wordcount。</span><br></pre></td></tr></table></figure><h3 id="HMM"><a href="#HMM" class="headerlink" title="HMM"></a>HMM</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">实现 hmm 的状态转移代码；</span><br><span class="line">机器学习理论</span><br><span class="line">讲机器学习中常用的损失函数有哪些？交叉熵有什么好处？（凸优化问题）</span><br><span class="line">判别模型与生成模型的本质区别是什么</span><br><span class="line">分类模型和回归模型的区别，分类模型可以做回归分析吗？反过来可以吗？（我回答是分类不可以做回归，回归倒是可以做分类，不知道对不对）</span><br><span class="line">k折交叉验证 中k取值多少有什么关系 （我不知道，随便答，然后面试官后面问我知道bias和variance吗？估计是和这两个东西有关， 知乎上有个问题讨论了k值大小与bias和variance的关系）</span><br><span class="line">解释局部相关性</span><br><span class="line">特征选择的方法；</span><br><span class="line">在模型的训练迭代中，怎么评估效果；</span><br><span class="line">特征选择方法有哪些(能说出来10种以上加分)，之后和面试官仔细聊了一下特征选择的问题，我介绍了了解的几种基本的特征选择思路（错误率选择、基于熵的选择、类内类间距离的选择）；</span><br><span class="line">有没有接触过机器学习的前沿，深度学习看过paper没有？（并没有）</span><br><span class="line">如何用尽可能少的样本训练模型同时又保证模型的性能；</span><br><span class="line">你读哪些期刊会议的论文？你遇到的比较有意思的算法？</span><br><span class="line">生成模型，判别模型</span><br><span class="line">线性分类和非线性分类各有哪些模型</span><br><span class="line">比较各个模型的Loss function，</span><br><span class="line">设计一个结构存取稀疏矩阵 （面试官最后告诉我了一个极度压缩的存法，相同行或列存偏差，我当时没听懂，还不懂装懂，最后还是没记住）</span><br><span class="line">PageRank原理，怎么用模型来查找异常用户，我讲了一大堆我的理解，然后面试官一句你怎么不用规则把我噎到了……</span><br><span class="line">无监督和有监督算法的区别？</span><br><span class="line">经典算法推导(加分项)，原理，各个损失函数之间区别，使用场景，如何并行化，有哪些关键参数</span><br><span class="line">什么叫判别模型什么叫生成模型。</span><br><span class="line">先针对项目十分细致地询问了各种细节，然后就问我如何处理数据中的噪声点、数据清洗算法（正好自己做了一个算法）、如何选择特征等。</span><br><span class="line">校招TST内推，面过了2面，还是跟之前那个有点类似的游戏开发的安全部门，因为我也玩LOL，又问到怎么来判断玩家有没有作弊之类的问题，这次我小心翼翼的说用模型怎么做，用规则怎么做，感觉这次聊的都挺开心的。</span><br><span class="line">是否了解A/B Test以及A/B Test结果的置信度特征工程经验是否了解mutual infomation、chi-square、LR前后向、树模型等特征选择方式</span><br><span class="line">深刻理解各种算法对应采用的数据结构和对应的搜索方法。比如KNN对应的KD树、如何给图结构设计数据结构？如何将算法map-red化</span><br><span class="line">矩阵的各种变换，尤其是特征值相关的知识。分布式的矩阵向量乘的算法</span><br><span class="line">线性分类器与非线性分类器的区别及优劣；特征比数据量还大时，选择什么样的分类器？对于维度很高的特征，你是选择线性还是非线性分类器？对于维度极低的特征，你是选择线性还是非线性分类器？如何解决过拟合问题？L1和L2正则的区别，如何选择L1和L2正则？</span><br><span class="line">项目中的数据是否会归一化处理，哪个机器学习算法不需要归一化处理</span><br><span class="line">并行计算、压缩算法LDA http://www.doc88.com/p-1621945750499.html</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 笔面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-线性回归</title>
      <link href="/2018/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
      <url>/2018/07/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>机器学习-线性回归 </p><a id="more"></a><h3 id="LR模型"><a href="#LR模型" class="headerlink" title="LR模型"></a>LR模型</h3><p>每个特征变量可以首先映射到⼀一个函数，然后再参与线性计算,模型如下：</p><script type="math/tex; mode=display">y = \theta_0 + \theta_1x_1 + \theta_2x_2 + · · · + \theta_nx_n</script><p>其中$ x_1,x_2,…,x_n$表示自变量（特征分量），$y$表示因变量，$\theta$是权重，$\theta_0$是偏移项（截距）;$\theta_i$越大，说明$x_i$对$y$结果的影响越⼤<br>输入空间映射到特征空间(映射函数$\phi(x)$)，建模.为</p><script type="math/tex; mode=display">h_\theta(x)=\theta^T\phi(x)</script><p>特征映射相关技术，包括特征哈希、特征学习、Kernel等</p><h3 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h3><p>预测值$ h_\theta(x)$与真实值$y$之差越小越好，加入损失函数(<strong>平方损失函数</strong>):</p><script type="math/tex; mode=display">J(\theta)={0.5}\sum_{i=1}^{n}{(h_\theta(x^i)-y^i)^2}</script><p>求$min{J(\theta)}$<br>损失函数就是$x^i$的预测值$h_\theta(x^i)$与真实值$y^i$之差的平方和</p><blockquote><p>回归模型（尤其是线性回归类）的⽬目标函数通常⽤用平⽅方损失函数来作为优化的⽬目标函数<br></p></blockquote><p>为什么用<strong>误差平方和</strong>作为目标函数：</p><blockquote><p>根据中⼼心极限定理理，把那些对结果影响⽐比较⼩小的变量量（假设独⽴立同分布）之和认为服从正态分布是合理理的</p></blockquote><p>如果数据是<strong>高斯分布</strong>的，输入值$x^i$，预测值$\theta^Tx^i$，真实值$y^i$，误差$\epsilon^{i}$，线性模型为，</p><script type="math/tex; mode=display">y^i=\theta^Tx^i+\epsilon^{i}</script><p>根据中心极限定理，认为变量之和服从高斯分布,即</p><script type="math/tex; mode=display">e^{i} = y^i-\theta^Tx^i</script><p>则，x,y的条件概率为</p><script type="math/tex; mode=display">p(y^i|x^i;\theta) = \frac{1}{\sqrt{2\pi}\sigma}exp(-\frac{(y^i-\theta^Tx^i)^2}{2\sigma^2})</script><p>$p(y^i|x^i;\theta)$越大，证明越接近真实值，还要考虑拟合过度以及模型的泛化能力问题</p><p>优化目标函数：使目标函数最小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">最小二乘法</span><br><span class="line">梯度下降法</span><br><span class="line">    批量梯度下降法</span><br><span class="line">    随机梯度下降法</span><br><span class="line">拉格朗日乘子法</span><br></pre></td></tr></table></figure></p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/min2cheng.png" alt=""></p><p>例子</p><script type="math/tex; mode=display">\begin{bmatrix}{a_{11}}&{a_{12}}&{\cdots}&{a_{1n}}\\{a_{21}}&{a_{22}}&{\cdots}&{a_{2n}}\\{\vdots}&{\vdots}&{\ddots}&{\vdots}\\{a_{m1}}&{a_{m2}}&{\cdots}&{a_{mn}}\\\end{bmatrix}</script><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_分类_决策树</title>
      <link href="/2018/07/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_%E5%86%B3%E7%AD%96%E6%A0%91/"/>
      <url>/2018/07/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_%E5%86%B3%E7%AD%96%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>机器学习<em>分类</em>决策树</p><a id="more"></a><p>决策树算法是借助于树的分支结构实现分类。</p><p>叶子节点：存放决策结果<br>非叶子节点：特征属性，及其对应输出，按照输出选择分支<br>决策过程：从根节点出发，根据数据的各个属性，计算结果，选择对应的输出分支，直到到达叶子节点，得到结果</p><p>决策树使用自顶向下递归分治法，并采用不回溯的贪心策略。分裂属性的选择算法很多，这里介绍3种常用的算法：信息增益（Information gain）、增益比率（gain ratio）、基尼指数（Gini index）。<br></p><blockquote><p>我们通过<strong>基尼不纯度</strong>或者<strong>熵</strong>来对一个集合进行的有序程度进行量化，然后引入<strong>信息增益</strong>概念对一次拆分进行量化评价</p></blockquote><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/tree_1.png" alt=""></p><h3 id="基尼不纯度"><a href="#基尼不纯度" class="headerlink" title="基尼不纯度"></a>基尼不纯度</h3><p>基尼不纯度是指将来自集合中的某种结果随机应用于集合中某一数据项的预期误差率。该值越高，说明拆分的越不理想，如果该值为 0，说明完美拆分。</p><script type="math/tex; mode=display">Gini(D)=1−∑_i=(1^m)p_i^2</script><h3 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h3><p>用来表示集合的无序程度，熵越大表示集合越混乱<br></p><script type="math/tex; mode=display">E = -P * log2P</script><blockquote><p>基尼不纯度与熵对比<br><br>两者主要区别在于，熵到达峰值的过程相对慢一些。因此熵对混乱集合的「判罚」往往更重一些。通常情况下，熵的使用更加频繁。</p></blockquote><h3 id="信息增益（Information-Gain）"><a href="#信息增益（Information-Gain）" class="headerlink" title="信息增益（Information Gain）"></a>信息增益（Information Gain）</h3><p>基于香浓的信息论，<strong>信息熵</strong>表示不确定度，均匀分布时，不确定度最大，此时熵就最大。<br>当选择某个特征对数据集进行分类时，数据集分类后的信息熵会比分类前的小，其差值即为信息增益。<br><strong>信息增益</strong>可以衡量某个特征对分类结果的影响大小，<strong>越大越好</strong>。</p><blockquote><p>信息增益=abs(信息熵（分类后）-信息熵（分类前）)</p><script type="math/tex; mode=display">Gain(R)=Info(D)−InfoR(D)</script></blockquote><h3 id="决策树降剪枝"><a href="#决策树降剪枝" class="headerlink" title="决策树降剪枝"></a>决策树降剪枝</h3><blockquote><p>为什么要剪枝<br>训练出得决策树存在过度拟合现象——决策树过于针对训练的数据，专门针对训练集创建出来的分支，其熵值可能会比真实情况有所降低。</p><p>如何剪枝<br>人工设置一个信息增益的阀值，自下而上遍历决策树，将信息增益低于该阀值的拆分进行合并</p></blockquote><h3 id="处理缺失数据"><a href="#处理缺失数据" class="headerlink" title="处理缺失数据"></a>处理缺失数据</h3><blockquote><p>决策树模型还有一个很大的优势，就是可以容忍缺失数据。如果决策树中某个条件缺失，可以按一定的权重分配继续往以后的分支走，最终的结果可能有多个，每个结果又一定的概率，即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最终结果=某个分支的结果 x 该分支的权重(该分支下的结果数/总结果数)</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="生成算法：ID3和C4-5。"><a href="#生成算法：ID3和C4-5。" class="headerlink" title="生成算法：ID3和C4.5。"></a>生成算法：ID3和C4.5。</h3><h4 id="1、ID3算法"><a href="#1、ID3算法" class="headerlink" title="1、ID3算法"></a>1、ID3算法</h4><p>ID3算法可用于划分标称型数据集，没有剪枝的过程，为了去除过度数据匹配的问题，可通过裁剪合并相邻的无法产生大量信息增益的叶子节点（例如设置信息增益阀值）。<br>考虑某个特征后，信息熵减小的多，这个特征就是好的特征(在每层分裂时，选择使得Gain(R)最大的属性作为分裂属性)<br>ID3算法中根据信息增益评估和选择特征，每次选择信息增益最大的特征作为判断模块建立子结点</p><blockquote><p>缺点：1、此公式偏向数据量多的属性，如果样本分布不均，则会导致过拟合。<br>2、不能处理连续分布的数据特征</p></blockquote><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/tree_ID3.png" alt=""></p><h4 id="2、C4-5算法"><a href="#2、C4-5算法" class="headerlink" title="2、C4.5算法"></a>2、C4.5算法</h4><p>C4.5算法用<strong>信息增益率</strong>来选择属性，继承了ID3算法的优点<br>优点：</p><blockquote><p>1、克服了用信息增益选择属性时偏向选择取值多的属性的不足；<br>2、在树构造过程中进行剪枝；<br>3、能够完成对连续属性的离散化处理；<br>4、能够对不完整数据进行处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C4.5算法产生的分类规则易于理解、准确率较高；但效率低，因树构造过程中，需要对数据集进行多次的顺序扫描和排序C4.5算法在结构与递归上与ID3完全相同，区别只在于选取决决策特征时的决策依据不同，二者都有贪心性质：即通过局部最优构造全局最优</span><br></pre></td></tr></table></figure></p></blockquote><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/tree_C4.5.png" alt=""></p><p>svm:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">模型在真实世界中也应用场景 </span><br><span class="line">支撑向量机用于文本和超文本的分类；</span><br><span class="line">用于图像分类；</span><br><span class="line">用于手写体识别；</span><br><span class="line"></span><br><span class="line">这个模型的优势是什么？</span><br><span class="line"></span><br><span class="line">分类效果好；</span><br><span class="line">可以有效地处理高维空间的数据；</span><br><span class="line">可以有效地处理变量个数大于样本个数的数据；</span><br><span class="line">只是使用了一部分子集来进行训练模型，所以SVM模型不需要太大的内存；</span><br><span class="line">可以提高泛化能力；</span><br><span class="line">无局部极小值问题；</span><br><span class="line">他什么情况下表现最好？</span><br><span class="line"></span><br><span class="line">数据的维度较高；</span><br><span class="line">需要模型具有非常强的泛化能力；</span><br><span class="line">样本数据量较小时；</span><br><span class="line">解决非线性问题；</span><br><span class="line">这个模型的缺点是什么？</span><br><span class="line"></span><br><span class="line">无法处理大规模的数据集，因为该算法需要较长的训练时间；</span><br><span class="line">无法有效地处理包含噪声太多的数据集；</span><br><span class="line">SVM模型没有直接给出概率的估计值，而是利用交叉验证的方式估计，这种方式耗时较长；</span><br><span class="line">对缺失数据非常敏感；</span><br><span class="line">对于非线性问题，有时很难找到一个合适的核函数。</span><br><span class="line">什么条件下它表现很差？</span><br><span class="line"></span><br><span class="line">数据集的数据量过大；</span><br><span class="line">数据集中的含有噪声；</span><br><span class="line">数据集中的缺失较多的数据；</span><br><span class="line">对算法的训练效率要求较高；</span><br><span class="line">根据我们当前数据集的特点，为什么这个模型适合这个问题。 </span><br><span class="line">该项目所提供的样本数据相对较少；</span><br><span class="line">该问题是属于非线性问题；</span><br><span class="line">数据集经过“独热编码”后，维度较高</span><br></pre></td></tr></table></figure></p><p>决策树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">这个模型的优势是什么？</span><br><span class="line"></span><br><span class="line">决策树易于实现和理解；</span><br><span class="line">对于决策树，数据的准备工作一般比较简单；</span><br><span class="line">能够同时处理多种数据类型</span><br><span class="line">给定一个决策树模型，可以根据产生的决策树推出相应的逻辑表达式；</span><br><span class="line">通过静态测试来对模型的表现进行评价；</span><br><span class="line">在相对较短的时间内可以对大量的数据做出非常好的结果；</span><br><span class="line">决策树可以很好地扩展到大型数据中，同时决策树的大小独立于数据库的大小；</span><br><span class="line">计算复杂度相对较低，结果的输出易于理解，对部分的数据缺失不敏感。</span><br><span class="line">他什么情况下表现最好？</span><br><span class="line"></span><br><span class="line">实例是由“属性-值”对表示的；</span><br><span class="line">目标函数具有离散的输出值；</span><br><span class="line">训练数据集包含部分错误(决策树对错误有适应性)；</span><br><span class="line">训练数据缺少少量属性的实例。</span><br><span class="line">这个模型的缺点是什么？</span><br><span class="line"></span><br><span class="line">易于出现过拟合问题；</span><br><span class="line">忽略了数据集中属性之间的相关性；</span><br><span class="line">对于类比不一致的样本，决策树的信息增益倾向于那些数据值较多的特征</span><br><span class="line">什么条件下它表现很差？</span><br><span class="line"></span><br><span class="line">决策树匹配的数据过多时；</span><br><span class="line">分类的类别过于复杂；</span><br><span class="line">数据的属性之间具有非常强的关联。</span><br><span class="line">根据我们当前数据集的特点，为什么这个模型适合这个问题。</span><br><span class="line"></span><br><span class="line">不需要准备太多的训练数据，不需要对数据过多的处理如删除空白值等；</span><br><span class="line">易于编码；</span><br><span class="line">该问题是非线性问题，决策树能够很好地解决非线性问题；</span><br><span class="line">算法的执行效率高，对机器的要求较小。</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阈值分割_大津法_分水岭</title>
      <link href="/2018/07/16/%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2_%E5%A4%A7%E6%B4%A5%E6%B3%95_%E5%88%86%E6%B0%B4%E5%B2%AD/"/>
      <url>/2018/07/16/%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2_%E5%A4%A7%E6%B4%A5%E6%B3%95_%E5%88%86%E6%B0%B4%E5%B2%AD/</url>
      
        <content type="html"><![CDATA[<p>阈值分割<em>大津法</em>分水岭<br><a id="more"></a></p><h3 id="大津法-最大类间方差法-Otsu"><a href="#大津法-最大类间方差法-Otsu" class="headerlink" title="大津法(最大类间方差法,Otsu)"></a>大津法(最大类间方差法,Otsu)</h3><p>一种基于全局的二值化算法，它是根据图像的灰度特性,将图像分为前景和背景两个部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;cv.h&quot;</span><br><span class="line">#include &quot;highgui.h&quot;</span><br><span class="line">#include &quot;Math.h&quot;</span><br><span class="line"></span><br><span class="line">int Otsu(IplImage* src);</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    IplImage* img = cvLoadImage(&quot;lena.jpg&quot;,0); //获取灰度图像img</span><br><span class="line">    IplImage* dst = cvCreateImage(cvGetSize(img), 8, 1);</span><br><span class="line">    int threshold = Otsu(img); //调用大津法求出最佳阈值</span><br><span class="line">    printf(&quot;otsu threshold = %d\n&quot;, threshold);</span><br><span class="line">    cvThreshold(img, dst, threshold, 255, CV_THRESH_BINARY); //用otsu的阈值二值化</span><br><span class="line"></span><br><span class="line">    cvNamedWindow( &quot;img&quot;, 1 );</span><br><span class="line">    cvNamedWindow( &quot;dst&quot;, 1 );</span><br><span class="line">    cvShowImage(&quot;img&quot;, img);</span><br><span class="line">    cvShowImage(&quot;dst&quot;, dst);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cvWaitKey(-1);</span><br><span class="line"></span><br><span class="line">    cvReleaseImage(&amp;img);</span><br><span class="line">    cvReleaseImage(&amp;dst);</span><br><span class="line"></span><br><span class="line">    cvDestroyWindow( &quot;img&quot; );</span><br><span class="line">    cvDestroyWindow( &quot;dst&quot; );</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Otsu(IplImage* src)  </span><br><span class="line">&#123;  </span><br><span class="line">    int height=src-&gt;height;  </span><br><span class="line">    int width=src-&gt;width;      </span><br><span class="line"></span><br><span class="line">    //histogram  </span><br><span class="line">    float histogram[256] = &#123;0&#125;;  </span><br><span class="line">    for(int i=0; i &lt; height; i++)</span><br><span class="line">    &#123;  </span><br><span class="line">        unsigned char* p=(unsigned char*)src-&gt;imageData + src-&gt;widthStep * i;  </span><br><span class="line">        for(int j = 0; j &lt; width; j++) </span><br><span class="line">        &#123;  </span><br><span class="line">            histogram[*p++]++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    //normalize histogram &amp; average pixel value </span><br><span class="line">    int size = height * width;  </span><br><span class="line">    float u =0;</span><br><span class="line">    for(int i = 0; i &lt; 256; i++)</span><br><span class="line">    &#123;  </span><br><span class="line">        histogram[i] = histogram[i] / size;  </span><br><span class="line">        u += i * histogram[i];  //整幅图像的平均灰度</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    int threshold;    </span><br><span class="line">    float maxVariance=0;  </span><br><span class="line">    float w0 = 0, avgValue  = 0;</span><br><span class="line">    for(int i = 0; i &lt; 256; i++) </span><br><span class="line">    &#123;  </span><br><span class="line">        w0 += histogram[i];  //假设当前灰度i为阈值, 0~i 灰度像素所占整幅图像的比例即前景比例</span><br><span class="line">        avgValue  += i * histogram[i]; //avgValue/w0 = u0</span><br><span class="line"></span><br><span class="line">        float t = avgValue/w0 - u;  //t=u0-u</span><br><span class="line">        float variance = t * t * w0 /(1 - w0);  </span><br><span class="line">        if(variance &gt; maxVariance) </span><br><span class="line">        &#123;  </span><br><span class="line">            maxVariance = variance;  </span><br><span class="line">            threshold = i;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    return threshold;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理_图像增强</title>
      <link href="/2018/07/16/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/"/>
      <url>/2018/07/16/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/</url>
      
        <content type="html"><![CDATA[<p>图像处理_图像增强</p><a id="more"></a><h2 id="图像增强前期知识"><a href="#图像增强前期知识" class="headerlink" title="图像增强前期知识"></a>图像增强前期知识</h2><p>图像增强是图像模式识别中非常重要的图像预处理过程。<br>图像增强的目的是通过对图像中的信息进行处理，使得有利于模式识别的信息得到增强，不利于模式识别的信息被抑制，扩大图像中不同物体特征之间的差别，为图像的信息提取及其识别奠定良好的基础。图像增强按实现方法不同可分为点增强、空域增强和频域增强。</p><p>1、点增强<br>点增强主要指图像灰度变换和几何变换。图像的灰度变换也称为点运算、对比度增强或对比度拉伸，它是图像数字化软件和图像显示软件的重要组成部分。灰度变换是一种既简单又重要的技术，它能让用户改变图像数据占据的灰度范围。一幅输入图像经过灰度变换后将产生一幅新的输出图像，由输入像素点的灰度值决定相应的输出像素点的灰度值。灰度变换不会改变图像内的空间关系。图像的几何变换是图像处理中的另一种基本变换。它通常包括图像的平移、图像的镜像变换、图像的缩放和图像的旋转。通过图像的几何变换可以实现图像的最基本的坐标变换及缩放功能。</p><p>2、空域增强<br>图像的空间信息可以反映图像中物体的位置 、形状、大小等特征，而这些特征可以通过一定的物理模式来描述。例如，物体的边缘轮廓由于灰度值变化剧烈一般出现高频率特征，而一个比较平滑的物体内部由于灰度值比较均一则呈现低频率特征。因此，根据需要可以分别增强图像的高频和低频特征。对图像的高频增强可以突出物体的边缘轮廓，从而起到锐化图像的作用。例如，对于人脸的比对查询，就需要通过高频增强技术来突出五宫的轮廓。相应地，对图像的低频部分进行增强可以对图像进行平滑处理，一般用于图像的噪声消除。</p><p>3、频域增强<br>图像的空域增强一般只是对数字图像进行局部增强，而图像的频域增强可以对图像进行全局增强。频域增强技术是在数字图像的频率域空间对图像进行滤波，因此需要将图像从空间域变换到频率域，一般通过傅里叶变换实现。在频率域空间的滤波与空域滤波一样可以通过卷积实现，因此傅里叶变换和和卷积理论是频域滤波技术的基础。</p><h3 id="图像增强的方法分类："><a href="#图像增强的方法分类：" class="headerlink" title="图像增强的方法分类："></a>图像增强的方法分类：</h3><div class="table-container"><table><thead><tr><th>图像增强方法</th><th>实现方法</th></tr></thead><tbody><tr><td>处理对象</td><td>灰度图</td></tr><tr><td></td><td>（伪）彩色图</td></tr><tr><td>-</td><td>-</td></tr><tr><td>处理策略</td><td>全局处理</td></tr><tr><td></td><td>局部处理（ROI ROI，Region of Interest Interest）</td></tr><tr><td>-</td><td>-</td></tr><tr><td>处理方法</td><td>空间域（点域运算，即灰度变换）</td></tr><tr><td></td><td>空间域（邻域方法，即空域滤波）</td></tr><tr><td></td><td>频域方法</td></tr><tr><td>-</td><td>-</td></tr><tr><td>处理目的</td><td>图像锐化</td></tr><tr><td></td><td>平滑去噪</td></tr><tr><td></td><td>灰度调整（对比度增强）</td></tr></tbody></table></div><h3 id="图像增强的方法之对比度增强"><a href="#图像增强的方法之对比度增强" class="headerlink" title="图像增强的方法之对比度增强"></a>图像增强的方法之对比度增强</h3><div class="table-container"><table><thead><tr><th>图像增强方法</th><th>实现方法</th></tr></thead><tbody><tr><td>灰度变换法</td><td>线性变换（已实现）</td></tr><tr><td></td><td>对数变换（已实现）</td></tr><tr><td></td><td>指数变换（已实现）</td></tr><tr><td>-</td><td>-</td></tr><tr><td>直方图调整法</td><td>直方图均衡化（已实现）</td></tr><tr><td></td><td>直方图匹配（未实现）</td></tr></tbody></table></div><p>图像对比度增强</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>图像对比度增强</td><td>直接</td><td></td></tr><tr><td></td><td>间接</td><td>直方图拉伸</td></tr><tr><td></td><td></td><td>直方图均衡化</td></tr><tr><td></td><td></td></tr></tbody></table></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">直方图拉伸</span><br><span class="line">    是通过对比度拉伸对直方图进行调整，从而“扩大”前景和背景灰度的差别，以达到增强对比度的目的，这种方法可以利用线性或非线性的方法来实现;直方图均衡化则通过使用累积函数对灰度值进行“调整”以实现对比度的增强。</span><br><span class="line">直方图均衡化处理</span><br><span class="line">    “中心思想”是把原始图像的灰度直方图从比较集中的某个灰度区间变成在全部灰度范围内的均匀分布。直方图均衡化就是对图像进行非线性拉伸，重新分配图像像素值，使一定灰度范围内的像素数量大致相同。直方图均衡化就是把给定图像的直方图分布改变成“均匀”分布直方图分布。</span><br></pre></td></tr></table></figure><h2 id="常用图像增强"><a href="#常用图像增强" class="headerlink" title="常用图像增强"></a>常用图像增强</h2><h3 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h3><div class="table-container"><table><thead><tr><th>直方图均衡化</th><th></th></tr></thead><tbody><tr><td>优点</td><td>处理过亮过暗图像很有效(曝光过度或者曝光不足),刻画更多细节</td></tr><tr><td></td><td>是一个相当直观的技术并且是可逆操作，如果已知均衡化函数，那么就可以恢复原始的直方图，并且计算量也不大</td></tr><tr><td>-</td><td>-</td></tr><tr><td>缺点</td><td>处理数据随机，可能会降低信噪比(会增加背景噪声对比度，降低有用信号对比度)</td></tr></tbody></table></div><p>c语言代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;fftw3.h&quot;</span><br><span class="line">#include &quot;string&quot;</span><br><span class="line">#include &quot;vector&quot;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;opencv2/legacy/legacy.hpp&gt;</span><br><span class="line">#include &lt;opencv2/nonfree/nonfree.hpp&gt;//opencv_nonfree模块：包含一些拥有专利的算法，如SIFT、SURF函数源码。 </span><br><span class="line">#include &quot;opencv2/core/core.hpp&quot;</span><br><span class="line">#include &quot;opencv2/features2d/features2d.hpp&quot;</span><br><span class="line">#include &quot;opencv2/highgui/highgui.hpp&quot;</span><br><span class="line">#include &lt;opencv2/nonfree/features2d.hpp&gt;</span><br><span class="line"> </span><br><span class="line">using namespace cv;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">class hisEqt</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">hisEqt::hisEqt();</span><br><span class="line">hisEqt::~hisEqt();</span><br><span class="line">public:</span><br><span class="line">int w;</span><br><span class="line">int h;</span><br><span class="line">int nlen;</span><br><span class="line"> </span><br><span class="line">int *pHis;</span><br><span class="line">float *pdf;</span><br><span class="line"> </span><br><span class="line">//=====求像素分布概率密度====  </span><br><span class="line">void  getPdf();</span><br><span class="line"> </span><br><span class="line">//======统计像素个数=======  </span><br><span class="line">void getHis(unsigned char*imgdata);</span><br><span class="line"> </span><br><span class="line">//==========画统计分布直方图===============  </span><br><span class="line">void drawHistogram(const float*pdf,Mat &amp;hist1);  </span><br><span class="line"> </span><br><span class="line">//===========直方图均衡化==========  </span><br><span class="line">void hisBal();</span><br><span class="line"> </span><br><span class="line">//====直方图均衡化后的图像===  </span><br><span class="line">void imgBal(unsigned char* img);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">hisEqt::hisEqt() :nlen(0)&#123;</span><br><span class="line">pHis = new int[256 * sizeof(int)];</span><br><span class="line">memset(pHis, 0, 256 * sizeof(int));</span><br><span class="line">pdf = new float[255 * sizeof(float)];</span><br><span class="line">memset(pdf, 0, 255 * sizeof(float));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">hisEqt::~hisEqt()&#123;</span><br><span class="line">delete[]pHis;</span><br><span class="line">delete[]pdf;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//======统计像素个数=======  </span><br><span class="line">void hisEqt::getHis(unsigned char*imgdata)&#123;</span><br><span class="line">for (int i = 0; i&lt;nlen; i++)</span><br><span class="line">&#123;</span><br><span class="line">pHis[imgdata[i]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//=====求像素分布概率密度====  </span><br><span class="line">void hisEqt::getPdf()&#123;</span><br><span class="line">for (int k = 0; k&lt;256; k++)</span><br><span class="line">&#123;</span><br><span class="line">pdf[k] = pHis[k] / float(nlen);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//===========直方图均衡化==========  </span><br><span class="line">void hisEqt::hisBal()&#123;</span><br><span class="line">for (int k = 1; k&lt;256; k++)</span><br><span class="line">&#123;</span><br><span class="line">pdf[k] += pdf[k - 1];</span><br><span class="line">&#125;</span><br><span class="line">for (int k = 0; k&lt;256; k++)</span><br><span class="line">&#123;</span><br><span class="line">pHis[k] = 255 * pdf[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//====直方图均衡化  </span><br><span class="line">void hisEqt::imgBal(unsigned char* img)&#123;</span><br><span class="line">for (int i = 0; i&lt;nlen; i++)</span><br><span class="line">&#123;</span><br><span class="line">img[i] = pHis[img[i]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">void hisEqt::drawHistogram(const float *pdf, Mat&amp; hist1)&#123;</span><br><span class="line">for (int k = 0; k&lt;256; k++)</span><br><span class="line">&#123;</span><br><span class="line">if (k % 2 == 0)</span><br><span class="line">&#123;</span><br><span class="line">Point a(k, 255), b(k, 255 - pdf[k] * 2550);</span><br><span class="line">line(hist1,</span><br><span class="line">a,</span><br><span class="line">b,</span><br><span class="line">Scalar(0, 0, 255),</span><br><span class="line">1);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">Point a(k, 255), b(k, 255 - pdf[k] * 2550);</span><br><span class="line">line(hist1,</span><br><span class="line">a,</span><br><span class="line">b,</span><br><span class="line">Scalar(0, 255, 0),</span><br><span class="line">1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Mat image = imread(&quot;Fig0651(a)(flower_no_compression).tif&quot;);</span><br><span class="line">if (!image.data)</span><br><span class="line">return -1;</span><br><span class="line"> </span><br><span class="line">Mat hist2(256, 256, CV_8UC3, Scalar(0, 0, 0));</span><br><span class="line">Mat hist1(256, 256, CV_8UC3, Scalar(0, 0, 0));</span><br><span class="line"> </span><br><span class="line">Mat imgOut = Mat(image.rows, image.cols, CV_8UC3, Scalar(0, 0, 0));</span><br><span class="line">vector&lt;Mat&gt; planes;</span><br><span class="line">int chn = image.channels();</span><br><span class="line">if (chn == 3)</span><br><span class="line">&#123;</span><br><span class="line">split(image, planes);</span><br><span class="line">&#125;</span><br><span class="line">while (chn)</span><br><span class="line">&#123;</span><br><span class="line">chn--;</span><br><span class="line">unsigned char* imageData = new unsigned char[sizeof(unsigned char)*(image.cols*image.rows)];</span><br><span class="line">memcpy(imageData, planes[chn].data, planes[chn].cols*planes[chn].rows);</span><br><span class="line">hisEqt his;//自定义的类</span><br><span class="line">his.nlen = image.rows*image.cols;</span><br><span class="line">his.getHis(imageData);</span><br><span class="line">his.getPdf();</span><br><span class="line"> </span><br><span class="line">//  //======画原图直方图并保存============  </span><br><span class="line">his.drawHistogram(his.pdf, hist1);</span><br><span class="line">string pic_name = &quot;hisline&quot;;</span><br><span class="line">pic_name = pic_name + to_string(chn);</span><br><span class="line">pic_name=pic_name+&quot;.jpg&quot;;</span><br><span class="line">imwrite(pic_name, hist1);</span><br><span class="line"> </span><br><span class="line">his.hisBal();</span><br><span class="line">his.getPdf();</span><br><span class="line">//  //======画均衡化后直方图并保存============  </span><br><span class="line">his.drawHistogram(his.pdf, hist2);</span><br><span class="line">string pic_name0 = &quot;his_balanceline&quot;;</span><br><span class="line">pic_name0 = pic_name0 + to_string(chn);</span><br><span class="line">pic_name0 = pic_name0 + &quot;.jpg&quot;;</span><br><span class="line">imwrite(pic_name0, hist2);</span><br><span class="line"> </span><br><span class="line">//  //=====图像均衡化===  </span><br><span class="line">his.imgBal(imageData);</span><br><span class="line">memcpy(planes[chn].data, imageData, planes[chn].cols*planes[chn].rows);</span><br><span class="line">delete[] imageData;</span><br><span class="line">imageData = NULL;</span><br><span class="line">&#125;</span><br><span class="line">merge(planes, imgOut);//单通道合并</span><br><span class="line">imwrite(&quot;result.jpg&quot;, imgOut);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="指数变换"><a href="#指数变换" class="headerlink" title="指数变换"></a>指数变换</h3><blockquote><p>先做归一化，再指数变换，最后反归一化</p></blockquote><script type="math/tex; mode=display">S=c*R^r</script><p>通过合理的选择c和r可以压缩灰度范围，算法以c=1.0/255.0, r=2实现</p><p><img src="https://img-blog.csdn.net/20161229163907449?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRWJvd1Rhbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><p>Opencv代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void ExpEnhance(IplImage* img, IplImage* dst)</span><br><span class="line">&#123;</span><br><span class="line">// 由于oldPixel:[1,256],则可以先保存一个查找表</span><br><span class="line">uchar lut[256] =&#123;0&#125;;</span><br><span class="line"> </span><br><span class="line">double temp = 1.0/255.0;</span><br><span class="line"> </span><br><span class="line">for ( int i =0; i&lt;255; i++)</span><br><span class="line">&#123;</span><br><span class="line">lut[i] = (uchar)(temp*i*i+0.5);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">for( int row =0; row &lt;img-&gt;height; row++)</span><br><span class="line">&#123;</span><br><span class="line">uchar *data = (uchar*)img-&gt;imageData+ row* img-&gt;widthStep;</span><br><span class="line">uchar *dstData = (uchar*)dst-&gt;imageData+ row* dst-&gt;widthStep;</span><br><span class="line"> </span><br><span class="line">for ( int col = 0; col&lt;img-&gt;width; col++)</span><br><span class="line">&#123;</span><br><span class="line">for( int k=0; k&lt;img-&gt;nChannels; k++)</span><br><span class="line">&#123;</span><br><span class="line">uchar t1 = data[col*img-&gt;nChannels+k];</span><br><span class="line">dstData[col*img-&gt;nChannels+k] = lut[t1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="对数变换"><a href="#对数变换" class="headerlink" title="对数变换"></a>对数变换</h3><blockquote><p>低灰度值部分扩展，高灰度值部分压缩,来强调图像低灰度部分</p></blockquote><script type="math/tex; mode=display">s=c*log_{v+1}(1+v*r)</script><p>底数为（v+1），实际输入范围为归一化的【0-1】，其输出也为【0-1】。底数越大，对低灰度部分的强调就越强，对高灰度部分的压缩也就越强</p><p><img src="https://img-blog.csdn.net/20131014153326875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGhuaDE2OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>matlab代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function dst_img=myLogEnhance(src_img,v)   </span><br><span class="line">c=1.0;  </span><br><span class="line">src_img = mat2gray(src_img,[0 255]);  </span><br><span class="line">g =c*log2(1 + v*src_img)/log2(v+1);  </span><br><span class="line">%反归一化  </span><br><span class="line">max=255;  </span><br><span class="line">min=0;  </span><br><span class="line">dst_img=uint8(g*(max-min)+min);</span><br></pre></td></tr></table></figure></p><h3 id="灰度拉伸"><a href="#灰度拉伸" class="headerlink" title="灰度拉伸"></a>灰度拉伸</h3><blockquote><p>灰度拉升可以改善图像的动态范围</p></blockquote><script type="math/tex; mode=display">s=\frac{1}{1+\frac{m}{r+eps}^E}</script><p>输入r为【0-1】，其输出s也为【0-1】</p><h3 id="线性拉伸"><a href="#线性拉伸" class="headerlink" title="线性拉伸"></a>线性拉伸</h3><p>三段线性变换</p><blockquote><p>突出感兴趣的目标或者灰度区间，相对抑制那些不感兴趣的灰度区域</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">范围吧</span><br><span class="line">%横轴</span><br><span class="line">fa=20; fb=80;</span><br><span class="line">%纵轴</span><br><span class="line">ga=50; gb=230;</span><br><span class="line"></span><br><span class="line">function dst_img=myLinearEnhance(src_img,fa,fb,ga,gb)  </span><br><span class="line"> </span><br><span class="line">[height,width] = size(src_img);</span><br><span class="line">dst_img=uint8(zeros(height,width));</span><br><span class="line"> </span><br><span class="line">src_img=double(src_img);</span><br><span class="line"> </span><br><span class="line">%三段斜率</span><br><span class="line">k1=ga/fa; </span><br><span class="line">k2=(gb- ga)/(fb- fa);</span><br><span class="line">k3=(255- gb)/(255- fb);</span><br><span class="line">for i=1:height</span><br><span class="line">    for j=1:width</span><br><span class="line">            if src_img(i,j) &lt;= fa</span><br><span class="line">                dst_img(i,j)= k1*src_img(i,j);</span><br><span class="line">            elseif fa &lt; src_img(i,j) &amp;&amp; src_img(i,j) &lt;= fb</span><br><span class="line">                dst_img(i,j)= k2*( src_img(i,j)- fa)+ ga;</span><br><span class="line">            else</span><br><span class="line">                dst_img(i,j)= k3*( src_img(i,j)- fb)+ gb;</span><br><span class="line">            end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">dst_img=uint8(dst_img);</span><br></pre></td></tr></table></figure><h2 id="频率域图像增强"><a href="#频率域图像增强" class="headerlink" title="频率域图像增强"></a>频率域图像增强</h2><blockquote><p>傅里叶变换提供了一种从空间域到频域的转换手段，且用傅里叶反变换可以实现从频域到空间域的无损转换，不丢失任何信息</p></blockquote><div class="table-container"><table><thead><tr><th>频域图像增强</th><th>类型</th></tr></thead><tbody><tr><td>高通滤波器</td><td>突出图像的边界</td></tr><tr><td>低通滤波器</td><td>抑制图像噪声，改善图像质量</td></tr></tbody></table></div><h3 id="分析频谱图"><a href="#分析频谱图" class="headerlink" title="分析频谱图"></a>分析频谱图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">clc;  %清空命令行</span><br><span class="line">clear;%清空变量</span><br><span class="line"> </span><br><span class="line">I1=imread(&apos;beauty.jpg&apos;);</span><br><span class="line">subplot(1,2,1);</span><br><span class="line">imshow(I1);</span><br><span class="line">title(&apos;beauty.jpg&apos;);</span><br><span class="line"> </span><br><span class="line">I2=fft2(I1);%计算二维FFT</span><br><span class="line">spectrum =fftshift(I2);%将零点移到中心</span><br><span class="line">temp= log(1+ abs(spectrum) ); %对幅值做 对数变换 以压缩动态范围</span><br><span class="line">subplot(1,2,2);</span><br><span class="line">imshow(temp,[]);</span><br><span class="line">title(&apos;FFT&apos;);</span><br></pre></td></tr></table></figure><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/img_fft.png" alt=""></p><blockquote><p>低频分量:主要对整副图像的强度的综合度量.灰度变化缓慢的特性<br>高频分量:主要是对图像边缘和轮廓的度量.灰度变化快的特性</p></blockquote><p>幅度图，看图像的频率分布，哪里亮那里暗，低频一般在图像中央<br>如果只保留图像的中心点，则图像的细节会丢失，大致轮廓还在，不同区域好友不同的灰度<br>如果保留远离中心的点，而去掉中心的幅度，则保留着图像的细节，而不同区域的灰度一样</p><h3 id="频域低通滤波"><a href="#频域低通滤波" class="headerlink" title="频域低通滤波"></a>频域低通滤波</h3><h4 id="理想低通滤波器"><a href="#理想低通滤波器" class="headerlink" title="理想低通滤波器"></a>理想低通滤波器</h4><p>理想低通滤波器并不能很好的兼顾 滤除噪声 与 保留细节 这两个方面</p><p>理想低通滤波器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">% 频域低通滤波器 imidealflpf.m</span><br><span class="line">%&#123;</span><br><span class="line">函数：    function ff=imidealflpf(I,freq)</span><br><span class="line">函数说明：构造理想的频域低通滤波器（即 滤镜）</span><br><span class="line">参数说明：I：为输入原图像</span><br><span class="line">         freq:为截止频率</span><br><span class="line">返回值： 与I等大的频域滤镜</span><br><span class="line"> %&#125;</span><br><span class="line"> </span><br><span class="line"> function ff=imidealflpf(I,freq)</span><br><span class="line"> </span><br><span class="line"> [M,N]=size(I);</span><br><span class="line"> ff=ones(M,N);</span><br><span class="line"> for i=1:M</span><br><span class="line">     for j=1:N</span><br><span class="line">         if (sqrt ((i-M/2)^2+ (j-N/2)^2 ) &gt;freq)  ff(i,j)=0; %高于截止频率 设为0</span><br><span class="line">         end</span><br><span class="line">     end</span><br><span class="line"> end</span><br></pre></td></tr></table></figure></p><p>不同截止频率的滤波结果：<br><img src="https://img-blog.csdn.net/20180515114639532?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI2Nzk3MDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><h4 id="高斯低通滤波器"><a href="#高斯低通滤波器" class="headerlink" title="高斯低通滤波器"></a>高斯低通滤波器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">%高斯低通滤波器滤镜 imgaussflpf.m</span><br><span class="line">%&#123;</span><br><span class="line">函数： function ff=imgaussflpf(I,sigma)</span><br><span class="line">函数说明：构造高斯低通滤镜</span><br><span class="line">参数说明：I：输入图像</span><br><span class="line">         sigma：标准差</span><br><span class="line">返回值：与原图像等大的高斯低通滤镜</span><br><span class="line"> </span><br><span class="line">%&#125;</span><br><span class="line">  </span><br><span class="line">function ff=imgaussflpf(I,sigma)</span><br><span class="line">[M,N]=size(I);</span><br><span class="line"> ff=ones(M,N);</span><br><span class="line"> for i=1:M</span><br><span class="line">     for j=1:N</span><br><span class="line">         ff(i,j)= exp( -((i-M/2)^2+(j-N/2)^2) /2/(sigma^2) ); %高斯函数</span><br><span class="line">        </span><br><span class="line">     end</span><br><span class="line"> end</span><br></pre></td></tr></table></figure><p>高斯滤波结果：<br><img src="https://img-blog.csdn.net/20180515114758843?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI2Nzk3MDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><blockquote><p>高斯相比于低通滤波，在有效抑制噪声的同时，图像的模糊程度更低</p></blockquote><p><a href="https://blog.csdn.net/u012679707/article/details/78236474" target="_blank" rel="noopener">cankao</a></p><h3 id="频域高通滤波器"><a href="#频域高通滤波器" class="headerlink" title="频域高通滤波器"></a>频域高通滤波器</h3><blockquote><p>图像锐化可以通过衰减频域中的低频信号来实现</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">%高斯高通滤波器滤镜 imgaussfhpf.m</span><br><span class="line">%&#123;</span><br><span class="line">函数： function ff=imgaussfhpf(I,sigma)</span><br><span class="line">函数说明：构造高斯高通滤镜</span><br><span class="line">参数说明：I：输入图像</span><br><span class="line">         sigma：标准差</span><br><span class="line">返回值：与原图像等大的高斯高通滤镜</span><br><span class="line"> </span><br><span class="line">%&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">function ff=imgaussfhpf(I,sigma)</span><br><span class="line">[M,N]=size(I);</span><br><span class="line"> ff=ones(M,N);</span><br><span class="line"> for i=1:M</span><br><span class="line">     for j=1:N</span><br><span class="line">         ff(i,j)= 1-exp( -((i-M/2)^2+(j-N/2)^2) /2/(sigma^2) ); %  1-(gauss)</span><br><span class="line">        </span><br><span class="line">     end</span><br><span class="line"> end</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180515114917692?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI2Nzk3MDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><blockquote><p>1、高斯高通滤波器可以较好的提取边缘信息；<br>2、sigma越小，Gauss高通的截止频率越低，通过的低频成分越多，边缘提取越不精确，会包含更多的非边缘信息；（要求太低，多了浑水摸鱼者）<br>3、sigma越大，边缘提取越精确，但可能包含不完整的边缘信息。（要求太高，有了漏网之鱼）</p></blockquote><h3 id="拉普拉斯滤波器"><a href="#拉普拉斯滤波器" class="headerlink" title="拉普拉斯滤波器"></a>拉普拉斯滤波器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">%laplace滤波器滤镜 imlapf.m</span><br><span class="line">%&#123;</span><br><span class="line">函数： function ff=imlapf(I)</span><br><span class="line">函数说明：构造laplace滤镜</span><br><span class="line">参数说明：I：输入图像</span><br><span class="line">       </span><br><span class="line">返回值：与原图像等大的laplace滤镜</span><br><span class="line"> </span><br><span class="line">%&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">function ff=imlapf(I)</span><br><span class="line">[M,N]=size(I);</span><br><span class="line"> ff=ones(M,N);</span><br><span class="line"> for i=1:M</span><br><span class="line">     for j=1:N</span><br><span class="line">         ff(i,j)= -((i-M/2)^2+(j-N/2)^2)  % </span><br><span class="line">        </span><br><span class="line">     end</span><br><span class="line"> end</span><br></pre></td></tr></table></figure><h2 id="图像处理评价指标"><a href="#图像处理评价指标" class="headerlink" title="图像处理评价指标"></a>图像处理评价指标</h2><h3 id="基于误差灵敏度评价算法："><a href="#基于误差灵敏度评价算法：" class="headerlink" title="基于误差灵敏度评价算法："></a>基于误差灵敏度评价算法：</h3><p>最简单的质量评价算法就是均方差(Mean Squared Error, MSE)和峰值信噪比(Peak Signal- Noise Ratio, PSNR)。MSE 和 PSNR 计算复杂度小，易于实现，在图像处理领域中广泛应用。但缺点是它们给出的数值与图像的感知质量之间没有必然联系。</p><h4 id="峰值信噪比-PSNR"><a href="#峰值信噪比-PSNR" class="headerlink" title="峰值信噪比-PSNR"></a>峰值信噪比-PSNR</h4><p>图像压缩等领域信号重建质量的评价</p><p><img src="https://img-blog.csdn.net/20171029101506855?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcGlhb3h1ZXpob25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p><p>MSE为当前图像 X 和参考图像 Y 的均方误差,H、W 分别表示图像的高和宽；n为每像素的比特数，一般取8，即像素灰阶数为256。PSNR的单位是dB，数值越大表示失真越小。</p><p>matlab代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function pnsr_result = psnr(img_ref,img_in)       </span><br><span class="line">    %   img_ref is a high reference quality image   </span><br><span class="line">    %   img_in is the denoise image    </span><br><span class="line">    %   pnsr_result is the PSNR of the denoise image    </span><br><span class="line">    width = size(img_ref,2);    </span><br><span class="line">    heigh = size(img_ref,1);    </span><br><span class="line">    if( width ~= size(img_in,2) || heigh ~= size(img_in,1) )    </span><br><span class="line">        disp(&apos;Please check whether the input image and reference image have same size&apos;);    </span><br><span class="line">        return    </span><br><span class="line">    end    </span><br><span class="line">    [a,b]=size(img_ref);      </span><br><span class="line">    XX=double(img_ref) - double(img_in);      </span><br><span class="line">    mse_value = sum(sum( XX.^2 ))/(a*b);      </span><br><span class="line">    pnsr_result = 10*log10( 255*255 / mse_value );   </span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><h4 id="SSIM"><a href="#SSIM" class="headerlink" title="SSIM"></a>SSIM</h4><h4 id="信噪比（SNR）"><a href="#信噪比（SNR）" class="headerlink" title="信噪比（SNR）"></a>信噪比（SNR）</h4><p>信噪比就是有用信号与噪声信号的比值</p><script type="math/tex; mode=display">snr=10*log_{10}\frac{sigma(I2)}{sigma(I2-I1)}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function snr=SNR2(I,In)</span><br><span class="line">% 计算噪声比</span><br><span class="line">% I :original signal</span><br><span class="line">% In:noisy signal</span><br><span class="line">% snr=10*log10(sigma2(I2)/sigma2(I2-I1))</span><br><span class="line"> </span><br><span class="line">[~,~,nchannel]=size(I);</span><br><span class="line">snr=0;</span><br><span class="line">I=double(I);</span><br><span class="line">In=double(In);</span><br><span class="line">if nchannel==1</span><br><span class="line">    Ps=sum(sum((I-mean(mean(I))).^2));%signal power</span><br><span class="line">    Pn=sum(sum((I-In).^2));%noise power</span><br><span class="line">    snr=10*log10(Ps/Pn);</span><br><span class="line">elseif nchannel==3</span><br><span class="line">    for i=1:3</span><br><span class="line">        Ps=sum(sum((I(:,:,i)-mean(mean(I(:,:,i)))).^2));%signal power</span><br><span class="line">        Pn=sum(sum((I(:,:,i)-In(:,:,i)).^2));%noise power</span><br><span class="line">        snr=snr+10*log10(Ps/Pn);</span><br><span class="line">    end</span><br><span class="line">    snr=snr/3;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="基于结构相似度评价算法"><a href="#基于结构相似度评价算法" class="headerlink" title="基于结构相似度评价算法"></a>基于结构相似度评价算法</h3><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="曝光过度问题处理"><a href="#曝光过度问题处理" class="headerlink" title="曝光过度问题处理"></a>曝光过度问题处理</h3><p>计算当前图像的反相（255-image)，然后取当前图像和反相图像的较小者为当前像素位置的值。</p><script type="math/tex; mode=display">min(image,(255-image))</script><h3 id="加Masaic算法"><a href="#加Masaic算法" class="headerlink" title="加Masaic算法"></a>加Masaic算法</h3><p>原理：用中心像素来表示邻域像素<br>Opencv代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">uchar getPixel( IplImage* img, int row, int col, int k)</span><br><span class="line">&#123;</span><br><span class="line">return ((uchar*)img-&gt;imageData + row* img-&gt;widthStep)[col*img-&gt;nChannels +k];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void setPixel( IplImage* img, int row, int col, int k, uchar val)</span><br><span class="line">&#123;</span><br><span class="line">((uchar*)img-&gt;imageData + row* img-&gt;widthStep)[col*img-&gt;nChannels +k] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--</span><br><span class="line"></span><br><span class="line">// nSize:为尺寸大小，奇数</span><br><span class="line">// 将邻域的值用中心像素的值替换</span><br><span class="line">void Masic(IplImage* img, IplImage* dst, int nSize)</span><br><span class="line">&#123;</span><br><span class="line">int offset = (nSize-1)/2;</span><br><span class="line">for ( int row = offset; row &lt;img-&gt;height - offset; row= row+offset)</span><br><span class="line">&#123;</span><br><span class="line">for( int col= offset; col&lt;img-&gt;width - offset; col = col+offset)</span><br><span class="line">&#123;</span><br><span class="line">int val0 = getPixel(img, row, col, 0);</span><br><span class="line">int val1 = getPixel(img, row, col, 1);</span><br><span class="line">int val2 = getPixel(img, row, col, 2);</span><br><span class="line">for ( int m= -offset; m&lt;offset; m++)</span><br><span class="line">&#123;</span><br><span class="line">for ( int n=-offset; n&lt;offset; n++)</span><br><span class="line">&#123;</span><br><span class="line">setPixel(dst, row+m, col+n, 0, val0);</span><br><span class="line">setPixel(dst, row+m, col+n, 1, val1);</span><br><span class="line">setPixel(dst, row+m, col+n, 2, val2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特征提取——纹理特征</title>
      <link href="/2018/07/16/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E7%BA%B9%E7%90%86%E7%89%B9%E5%BE%81/"/>
      <url>/2018/07/16/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E7%BA%B9%E7%90%86%E7%89%B9%E5%BE%81/</url>
      
        <content type="html"><![CDATA[<p>特征提取——纹理特征<br><a id="more"></a></p><h3 id="LBP图像特征"><a href="#LBP图像特征" class="headerlink" title="LBP图像特征"></a>LBP图像特征</h3><p>图像处理之特征提取（二）之LBP特征简单梳理<br><br><a href="https://blog.csdn.net/coming_is_winter/article/details/72859957" target="_blank" rel="noopener">https://blog.csdn.net/coming_is_winter/article/details/72859957</a><br><br><a href="https://blog.csdn.net/zouxy09/article/details/7929531" target="_blank" rel="noopener">https://blog.csdn.net/zouxy09/article/details/7929531</a><br><br>LBP特征理解。<br><br><a href="http://blog.csdn.net/hqh45/article/details/24501097" target="_blank" rel="noopener">http://blog.csdn.net/hqh45/article/details/24501097</a><br>LBP（Local Binary Pattern，局部二值模式）是一种用来描述图像局部纹理特征的算子；它具有旋转不变性和灰度不变性等显著的优点。它是首先由T. Ojala, M.Pietikäinen, 和 D. Harwood 在1994年提出，用于纹理特征提取。而且，提取的特征是图像的局部的纹理特征；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lbp理论：</span><br><span class="line">原始的LBP算子定义为在3*3的窗口内，以窗口中心像素为阈值，将相邻的8个像素的灰度值与其进行比较，若周围像素值大于中心像素值，则该像素点的位置被标记为1，否则为0。这样，3*3邻域内的8个点经比较可产生8位二进制数（通常转换为十进制数即LBP码，共256种），即得到该窗口中心像素点的LBP值，并用这个值来反映该区域的纹理信息。</span><br></pre></td></tr></table></figure></p><p>圆形LBP算子： 半径为R<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本的 LBP算子的最大缺陷在于它只覆盖了一个固定半径范围内的小区域，这显然不能满足不同尺寸和频率纹理的需要。为了适应不同尺度的纹理特征，并达到灰度和旋转不变性的要求，Ojala等对 LBP 算子进行了改进，将 3×3邻域扩展到任意邻域，并用圆形邻域代替了正方形邻域，改进后的 LBP 算子允许在半径为 R 的圆形邻域内有任意多个像素点。从而得到了诸如半径为R的圆形区域内含有P个采样点的LBP算子；</span><br></pre></td></tr></table></figure></p><p>即不断旋转圆形邻域得到一系列初始定义的 LBP值，取其最小值作为该邻域的 LBP 值。</p><h3 id="灰度共生矩阵（GLCM，Gray-Level-Co-occurrence-Matrix）"><a href="#灰度共生矩阵（GLCM，Gray-Level-Co-occurrence-Matrix）" class="headerlink" title="灰度共生矩阵（GLCM，Gray-Level Co-occurrence Matrix）"></a>灰度共生矩阵（GLCM，Gray-Level Co-occurrence Matrix）</h3><p>概念：</p><blockquote><p>灰度共生矩阵是涉及像素距离和角度的矩阵函数，它通过计算图像中一定距离和一定方向的两点灰度之间的相关性，来反映图像在<font color="red">方向、间隔、变化幅度及快慢</font>上的综合信息。<br><br>灰度直方图是对图像上单个像素具有某个灰度进行统计的结果，而<font color="red">灰度共生矩阵是对图像上保持某距离的两像素分别具有某灰度的状况进行统计得到的。</font></p></blockquote><p>含义：<br>以（1，1）点为例，GLCM（1，1）值为1说明左侧原图只有一对灰度为1的像素水平相邻。GLCM（1，2）值为2，是因为原图有两对灰度为1和2的像素水平相邻。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">矩阵</span><br><span class="line">|1 2 1|</span><br><span class="line">|2 2 2| </span><br><span class="line">|1 2 2|</span><br><span class="line">对应GLMC矩阵（最大是2，所以是2*2矩阵）</span><br><span class="line"></span><br><span class="line">GLCM矩阵:</span><br><span class="line">  1 2</span><br><span class="line">1|0 2| </span><br><span class="line">2|1 6|</span><br><span class="line">0(1,1)相邻， 2(1,2)水平相邻， 2(2,1)垂直相邻， 6(2,2)相邻</span><br></pre></td></tr></table></figure><p>灰度共生矩阵的特征</p><p>1) 角二阶矩（Angular Second Moment, ASM)<br><br>公式：$ASM = sum(p(i,j)^2)$，其中  $p(i,j) $表示归一后的灰度共生矩阵<br>意义：角二阶矩是图像灰度分布均匀程度和纹理粗细的一个度量，当图像纹理绞细致、灰度分布均匀时，能量值较大，反之，较小。<br></p><font color="red">结论：值大，灰度分布均匀</font><p>2) 熵（Entropy, ENT)<br><br>公式：$ENT=sum[-p(i,j)log(p(i,j))] $<br>意义：描述图像具有的信息量的度量，表明图像的复杂程度，当复杂程度高时，熵值较大，反之则较小。<br></p><font color="red">结论：值大，复杂程度高</font><p>3) 反差分矩阵（Inverse Differential Moment, IDM)<br>公式：$IDM=sum[p(i,j)/(1+(i-j)^2)]$<br>意义：反映了纹理的清晰程度和规则程度，纹理清晰、规律性较强、易于描述的，值较大；杂乱无章的，难于描述的，值较小。</p><font color="red">结论：值大，纹理清晰、规律性较强</font><h3 id="Gabor小波"><a href="#Gabor小波" class="headerlink" title="Gabor小波"></a>Gabor小波</h3><p>Gabor函数是一个用于边缘提取的线性滤波器</p><p>作用：<br>Gabor小波可以方便的提取图像在<font color="red">各个尺度和方向上的纹理信息</font>，同时在一定程度上降低了图像中光照变化和噪声的影响。<br>提取目标的<font color="red">局部空间和频率域信息</font>方面具有良好的特性。<br><br>特点：<br>1、Gabor小波对于图像的边缘敏感<br>2、对光照不敏感<br>3、对图像旋转有一定适应性</p><h5 id="灰度共生矩阵opencv代码："><a href="#灰度共生矩阵opencv代码：" class="headerlink" title="灰度共生矩阵opencv代码："></a>灰度共生矩阵opencv代码：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">// 0°灰度共生矩阵</span><br><span class="line">void getGLCM0(Mat&amp; src, Mat&amp; dst, int gray_level)// 0度灰度共生矩阵</span><br><span class="line">&#123;</span><br><span class="line">CV_Assert(1 == src.channels());</span><br><span class="line"> </span><br><span class="line">int height = src.rows;</span><br><span class="line">int width = src.cols;</span><br><span class="line"> </span><br><span class="line">dst.create(gray_level, gray_level, CV_32SC1);</span><br><span class="line">dst = Scalar::all(0);</span><br><span class="line"> </span><br><span class="line">for (int i = 0; i &lt; height; i++)</span><br><span class="line">&#123;</span><br><span class="line">int*srcdata = src.ptr&lt;int&gt;(i);</span><br><span class="line">for (int j = 0; j &lt; width - 1; j++)</span><br><span class="line">&#123;</span><br><span class="line">// 同样的像素对，水平相邻</span><br><span class="line">int rows = srcdata[j];</span><br><span class="line">int cols = srcdata[j + 1];</span><br><span class="line">dst.ptr&lt;int&gt;(rows)[cols]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 90°灰度共生矩阵</span><br><span class="line">void getGLCM90(Mat&amp; src, Mat&amp; dst, int gray_level)</span><br><span class="line">&#123;</span><br><span class="line">CV_Assert(1 == src.channels());</span><br><span class="line"> </span><br><span class="line">int height = src.rows;</span><br><span class="line">int width = src.cols;</span><br><span class="line"> </span><br><span class="line">dst = Mat(gray_level, gray_level, CV_32SC1, Scalar(0));</span><br><span class="line"> </span><br><span class="line">for (int i = 0; i &lt; height - 1; i++)</span><br><span class="line">&#123;</span><br><span class="line">int*srcdata = src.ptr&lt;int&gt;(i);</span><br><span class="line">int*srcdata1 = src.ptr&lt;int&gt;(i + 1);</span><br><span class="line">for (int j = 0; j &lt; width; j++)</span><br><span class="line">&#123;</span><br><span class="line">// 同样的像素对，垂直相邻</span><br><span class="line">int rows = srcdata[j];</span><br><span class="line">int cols = srcdata1[j];</span><br><span class="line">dst.ptr&lt;int&gt;(rows)[cols]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 45°灰度共生矩阵</span><br><span class="line">void getGLCM45(Mat&amp; src, Mat&amp; dst, int gray_level)</span><br><span class="line">&#123;</span><br><span class="line">CV_Assert(1 == src.channels());</span><br><span class="line"> </span><br><span class="line">int height = src.rows;</span><br><span class="line">int width = src.cols;</span><br><span class="line"> </span><br><span class="line">dst = Mat(gray_level, gray_level, CV_32SC1, Scalar(0));</span><br><span class="line"> </span><br><span class="line">for (int i = 0; i &lt; height - 1; i++)</span><br><span class="line">&#123;</span><br><span class="line">int*srcdata = src.ptr&lt;int&gt;(i);</span><br><span class="line">int*srcdata1 = src.ptr&lt;int&gt;(i + 1);</span><br><span class="line">for (int j = 0; j &lt; width - 1; j++)</span><br><span class="line">&#123;</span><br><span class="line">// 同样的像素对，45°相邻</span><br><span class="line">int rows = srcdata[j];</span><br><span class="line">int cols = srcdata1[j + 1];</span><br><span class="line">dst.ptr&lt;int&gt;(rows)[cols]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 135°灰度共生矩阵</span><br><span class="line">void getGLCM135(Mat&amp; src, Mat&amp; dst, int gray_level)</span><br><span class="line">&#123;</span><br><span class="line">CV_Assert(1 == src.channels());</span><br><span class="line"> </span><br><span class="line">int height = src.rows;</span><br><span class="line">int width = src.cols;</span><br><span class="line"> </span><br><span class="line">dst = Mat(gray_level, gray_level, CV_32SC1, Scalar(0));</span><br><span class="line"> </span><br><span class="line">for (int i = 0; i &lt; height - 1; i++)</span><br><span class="line">&#123;</span><br><span class="line">int*srcdata = src.ptr&lt;int&gt;(i);</span><br><span class="line">int*srcdata1 = src.ptr&lt;int&gt;(i + 1);</span><br><span class="line">for (int j = 1; j &lt; width; j++)</span><br><span class="line">&#123;</span><br><span class="line">// 同样的像素对，135°相邻</span><br><span class="line">int rows = srcdata[j];</span><br><span class="line">int cols = srcdata1[j - 1];</span><br><span class="line">dst.ptr&lt;int&gt;(rows)[cols]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 计算特征值</span><br><span class="line">void featureGLCM(Mat&amp;src, double&amp; Asm, double&amp; Ent, double&amp; Con, double&amp; Idm)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">CV_Assert(src.channels() == 1);</span><br><span class="line"></span><br><span class="line">int height = src.rows;</span><br><span class="line">int width = src.cols;</span><br><span class="line">int total = 0;</span><br><span class="line"> </span><br><span class="line">//求图像所有像素的灰度值的和</span><br><span class="line">for (int i = 0; i &lt; height; i++)</span><br><span class="line">&#123;</span><br><span class="line">int*srcdata = src.ptr&lt;int&gt;(i);</span><br><span class="line">for (int j = 0; j &lt; width; j++)</span><br><span class="line">&#123;</span><br><span class="line">total += srcdata[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//图像每一个像素的的值除以像素总和</span><br><span class="line">Mat mean;</span><br><span class="line">mean.create(height, width, CV_64FC1);</span><br><span class="line">for (int i = 0; i &lt; height; i++)</span><br><span class="line">&#123;</span><br><span class="line">int*srcdata = src.ptr&lt;int&gt;(i);</span><br><span class="line">double*copydata = mean.ptr&lt;double&gt;(i);</span><br><span class="line">for (int j = 0; j &lt; width; j++)</span><br><span class="line">&#123;</span><br><span class="line">copydata[j] = (double)srcdata[j] / (double)total;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">for (int i = 0; i &lt; height; i++)</span><br><span class="line">&#123;</span><br><span class="line">double*srcdata = mean.ptr&lt;double&gt;(i);</span><br><span class="line">for (int j = 0; j &lt; width; j++)</span><br><span class="line">&#123;</span><br><span class="line">// 能量</span><br><span class="line">Asm += srcdata[j] * srcdata[j];</span><br><span class="line"> </span><br><span class="line">// 熵(Entropy) </span><br><span class="line">if (srcdata[j]&gt;0)</span><br><span class="line">Ent -= srcdata[j] * log(srcdata[j]);</span><br><span class="line"> </span><br><span class="line">// 对比度</span><br><span class="line">Con += (double)(i - j)*(double)(i - j)*srcdata[j];</span><br><span class="line"> </span><br><span class="line">// 逆差矩</span><br><span class="line">Idm += srcdata[j] / (1 + (double)(i - j)*(double)(i - j));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> 特征提取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_最优化</title>
      <link href="/2018/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%9C%80%E4%BC%98%E5%8C%96/"/>
      <url>/2018/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%9C%80%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>机器学习-最优化-梯度下降-牛顿法等(梯度消失爆炸))</p><a id="more"></a><h3 id="铺垫"><a href="#铺垫" class="headerlink" title="铺垫"></a>铺垫</h3><p>微分意义<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、函数图像中，某点的切线的斜率</span><br><span class="line">2、函数的变化率</span><br></pre></td></tr></table></figure></p><p>梯度意义<br></p><blockquote><p>梯度就是分别对每个变量进行微分，然后用逗号分割开，梯度是用&lt;&gt;包括起来，说明梯度其实一个向量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、在单变量的函数中，梯度其实就是函数的微分，代表着函数在某个给定点的切线的斜率</span><br><span class="line">2、在多变量函数中，梯度是一个向量，向量有方向，梯度的方向就指出了函数在给定点的上升最快的方向</span><br></pre></td></tr></table></figure></p><p>梯度的方向实际就是函数在此点上升最快的方向！而我们需要朝着下降最快的方向走，自然就是负的梯度的方向，所以此处需要加上负号</p></blockquote><h3 id="梯度下降法（Gradient-Descent）"><a href="#梯度下降法（Gradient-Descent）" class="headerlink" title="梯度下降法（Gradient Descent）"></a>梯度下降法（Gradient Descent）</h3><blockquote><p>梯度下降法的优化思想是用当前位置负梯度方向作为搜索方向，因为该方向为当前位置的最快下降方向，所以也被称为是”最速下降法“。最速下降法越接近目标值，步长越小，前进越慢</p></blockquote><p>梯度下降法的缺点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）靠近极小值时收敛速度减慢，；</span><br><span class="line"></span><br><span class="line">（2）直线搜索时可能会产生一些问题；</span><br><span class="line"></span><br><span class="line">（3）可能会“之字形”地下降。</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">\theta^1=\theta^0 - \alpha\nabla(j(\theta)</script><p>是关于Θ的一个函数，我们当前所处的位置为Θ0点，要从这个点走到J的最小值点<br>$\nabla$ 是梯度,$\alpha$是学习率或者步长</p><h4 id="批量梯度下降法"><a href="#批量梯度下降法" class="headerlink" title="批量梯度下降法"></a>批量梯度下降法</h4><p>将$j(\theta)$对$\theta$求偏导，得到每个$\theta$对应的的梯度：每个参数$\theta$的梯度负方向，来更新每个$\theta$</p><blockquote><p>优点：它得到的是一个全局最优解<br>缺点：数据量大，计算缓慢</p></blockquote><h4 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h4><p>随机梯度下降是通过每个样本来迭代更新一次，如果样本量很大的情况（例如几十万），那么可能只用其中几万条或者几千条的样本</p><blockquote><p>优点：只用部分数据继续优化，运算量小<br>缺点：损失一部分进度，增加迭代次数</p></blockquote><p>两者关系：</p><blockquote><p>随机梯度下降方法以损失很小的一部分精确度和增加一定数量的迭代次数为代价，换取了总体的优化效率的提升。增加的迭代次数远远小于样本的数量。</p></blockquote><p>总结：</p><blockquote><p><em>批量梯度下降</em>—最小化所有训练样本的损失函数，使得最终求解的是<strong>全局的最优解</strong>，即求解的参数是使得风险函数最小，但是对于大规模样本问题效率低下。</p><p><em>随机梯度下降</em>—最小化每条样本的损失函数，虽然不是每次迭代得到的损失函数都向着全局最优方向， 但是大的整体的方向是向全局最优解的，最终的结果往往是在全局最优解附近，适用于<strong>大规模训练样本</strong>情况。</p></blockquote><h3 id="牛顿法和拟牛顿法"><a href="#牛顿法和拟牛顿法" class="headerlink" title="牛顿法和拟牛顿法"></a>牛顿法和拟牛顿法</h3><p>牛顿法是一种在实数域和复数域上近似求解方程的方法。牛顿法最大的特点就在于它的<strong>收敛速度很快</strong>。</p><h4 id="单变量"><a href="#单变量" class="headerlink" title="单变量"></a>单变量</h4><p>例如：方法使用函数$f(x)$的泰勒级数的前面几项来寻找方程$f(x)= 0$的根。</p><p>1、选择一个接近函数$ f (x)$零点的 $x_0$，计算相应的$ f (x_0)$ 和切线斜率$f  ‘ (x_0)$（这里$f ‘ $表示函数$ f $ 的导数）。然后我们计算穿过点$(x_0,  f  (x_0))$ 并且斜率为$f ‘(x_0)$的直线和 $x $轴的交点的$x$坐标，也就是求如下方程的解：</p><script type="math/tex; mode=display">x*f'(x_0)+f(x_0)-x_0*f'(x_0)=0</script><p>求得新的$x$坐标$x_1$,$x_1$比$x_0$更加接近收敛值的解，也就是使得$f(x)=0$，单变量迭代公式：</p><script type="math/tex; mode=display">x_n+1=x_n-f(x_n)/f'(x_n)</script><blockquote><p>如果$f ‘$ 是连续的，牛顿法必定收敛</p></blockquote><h4 id="多变量的话，需要用到雅可比矩阵和海森矩阵。"><a href="#多变量的话，需要用到雅可比矩阵和海森矩阵。" class="headerlink" title="多变量的话，需要用到雅可比矩阵和海森矩阵。"></a>多变量的话，需要用到雅可比矩阵和海森矩阵。</h4><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/zyh_haise.png" alt="海森矩阵"></p><p>总结：</p><blockquote><p>牛顿法的优缺点<br>优点：二阶收敛，收敛速度快；<br>缺点：牛顿法是一种迭代算法，每一步都需要求解目标函数的Hessian矩阵的逆矩阵，计算比较复杂。</p></blockquote><h3 id="牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快"><a href="#牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快" class="headerlink" title="牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快"></a><font color="red">牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快</font></h3><blockquote><p>牛顿法就是用一个二次曲面去拟合你当前所处位置的局部曲面，而梯度下降法是用一个平面去拟合当前的局部曲面，通常情况下，二次曲面的拟合会比平面更好，所以牛顿法选择的下降路径会更符合真实的最优下降路径。</p><p>Hessian 矩阵非正定（非凸）导致无法收敛；<br>Hessian 矩阵维度过大带来巨大的计算量。</p></blockquote><h3 id="拟牛顿法（Quasi-Newton-Methods）"><a href="#拟牛顿法（Quasi-Newton-Methods）" class="headerlink" title="拟牛顿法（Quasi-Newton Methods）"></a>拟牛顿法（Quasi-Newton Methods）</h3><p>拟牛顿法是求解非线性优化问题最有效的方法之一。</p><p>拟牛顿法的本质思想是改善牛顿法每次需要求解复杂的Hessian矩阵的逆矩阵的缺陷，它使用<font color="red">正定矩阵来近似Hessian矩阵的逆</font>，从而简化了运算的复杂度。只需要用到一阶导数，不需要计算Hessian矩阵 以及逆矩阵，因此能够更快收敛</p><p>正定矩阵：<br>如果$X^TAX&gt;0$<br>判定定理1：对称阵A为正定的充分必要条件是：A的特征值全为正。 　<br>判定定理2：对称阵A为正定的充分必要条件是：A的各阶顺序主子式都为正。 　<br>判定定理3：任意阵A为正定的充分必要条件是：A合同于单位阵。</p><h3 id="拉格朗日乘子法"><a href="#拉格朗日乘子法" class="headerlink" title="拉格朗日乘子法"></a>拉格朗日乘子法</h3><p>作为一种优化算法，拉格朗日乘子法主要用于解决约束优化问题，它的基本思想就是通过引入拉格朗日乘子来将含有n个变量和k个约束条件的约束优化问题转化为含有（n+k）个变量的无约束优化问题。拉格朗日乘子背后的数学意义是其为约束方程梯度线性组合中每个向量的系数。</p><p>典型：<br>求函数$z=f(x,y)$在满足$b(x,y)=0$下的条件极值<br><br>转化为函数$F(x,y,\alpha)=f(x,y)+\alpha b(x,y)$的无条件极值问题</p><p>列题：<br>给定椭球：$x^2/a^2+y^2/b^2+z^2/c^2=1$(约束条件),求内接长方体最大体积，求极值问题，求$f(x,y,z)=8xyz$的最大值<br>用拉格朗日乘子法：转化为</p><script type="math/tex; mode=display">F(x,y,z,\alpha)=f(x,y,z)+\alpha b(x,y,z)</script><script type="math/tex; mode=display">=8xyz+\alpha(x^2/a^2+y^2/b^2+z^2/c^2-1)</script><p>对<script type="math/tex">F(x,y,z,\alpha)</script>求偏导得<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/lagelangri1.png" alt=""><br>然后联立三个方程的$bx=ay,az=cx$，带入第四个方程解<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/lagelangri2png.png" alt=""><br>解为：<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/lagelangri3.png" alt=""></p><h3 id="共轭梯度法"><a href="#共轭梯度法" class="headerlink" title="共轭梯度法"></a>共轭梯度法</h3><p>共轭梯度法是介于最速下降法与牛顿法之间的一个方法，它仅需利用一阶导数信息，但克服了最速下降法收敛慢的缺点，又避免了牛顿法需要存储和计算Hesse矩阵并求逆的缺点，共轭梯度法不仅是解决大型线性方程组最有用的方法之一，也是解大型非线性最优化最有效的算法之一。 在各种优化算法中，共轭梯度法是非常重要的一种。其优点是所需存储量小，具有步收敛性，稳定性高，而且不需要任何外来参数。</p><p><a href="http://www.cnblogs.com/maybe2030/p/4946256.html" target="_blank" rel="noopener">参考文章</a><br><a href="https://www.cnblogs.com/shixiangwan/p/7532830.html" target="_blank" rel="noopener">参考文章</a></p><h3 id="梯度不稳定"><a href="#梯度不稳定" class="headerlink" title="梯度不稳定"></a>梯度不稳定</h3><p>什么是梯度不稳定问题：深度神经网络中的梯度不稳定性，前面层中的梯度或会消失，或会爆炸。</p><p>原因：前面层上的梯度是来自于后面层上梯度的乘乘积。当存在过多的层次时，就出现了内在本质上的不稳定场景，如梯度消失和梯度爆炸。</p><p>后果：训练很难进行，不收敛了<br>1、loss过早地不再下降<br>2、精确度过早地不在提高</p><h4 id="梯度消失"><a href="#梯度消失" class="headerlink" title="梯度消失"></a>梯度消失</h4><p>梯度消失：<br>一是在深层网络中；<br>二是采用了不合适的损失函数，比如sigmoid。sigmoid导数最大为1/4，故只有当abs(w)&gt;4时才可能出现。先前传递误差就很小，前端网络w几乎没什么变化，等于这一层没能学习什么东西，网络层数越多就浪费了</p><p>解决方法：<br>1、初始化一个合适的w<br>2、选合适的激励函数</p><blockquote><p>relu、leakrelu、elu等激活函数</p></blockquote><p>relu函数：目前使用最多的激活函数</p><script type="math/tex; mode=display">Relu(x)=max(x,0)</script><p>函数图像：<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/imgrelu.png" alt=""></p><blockquote><p>relu的主要贡献在于：<br><br>优点：<br><br>1、— 解决了梯度消失、爆炸的问题<br><br>2、— 计算方便，计算速度快<br><br>3、— 加速了网络的训练<br><br>缺点：<br><br>1、由于负数部分恒为0，会导致一些神经元无法激活（可通过设置小学习率部分解决）<br><br>2、输出不是以0为中心的<br></p></blockquote><p>leakrelu:leakrelu就是为了解决relu的0区间带来的影响</p><script type="math/tex; mode=display">leakrelu=max(k*x,x)</script><p>函数图像：<br><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/imgrelu_leak.png" alt=""></p><h4 id="爆炸问题"><a href="#爆炸问题" class="headerlink" title="爆炸问题"></a>爆炸问题</h4><p>梯度爆炸：<br><br>一般出现在深层网络和权值初始化值太大的情况下。当权值过大，前面层比后面层梯度变化更快，会引起梯度爆炸问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 最优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形态学滤波</title>
      <link href="/2018/07/16/%E5%BD%A2%E6%80%81%E5%AD%A6%E6%BB%A4%E6%B3%A2_leitao%E8%AE%BA%E6%96%87/"/>
      <url>/2018/07/16/%E5%BD%A2%E6%80%81%E5%AD%A6%E6%BB%A4%E6%B3%A2_leitao%E8%AE%BA%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p>形态学滤波</p><a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> Matlab </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_分类_随机森林</title>
      <link href="/2018/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/"/>
      <url>/2018/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/</url>
      
        <content type="html"><![CDATA[<p>机器学习<em>分类</em>随机森林</p><a id="more"></a><p>它也是最常用的算法之一，随机森林建立了多个决策树，并将它们合并在一起以获得更准确和稳定的预测。随机森林的一大优势在于它既可用于分类，也可用于回归问题</p><p>随机森林的主要限制在于使用大量的树会使算法变得很慢，并且无法做到实时预测。一般而言，这些算法训练速度很快，预测十分缓慢。越准确的预测需要越多的树，这将导致模型越慢。在大多数现实世界的应用中，随机森林算法已经足够快，但肯定会遇到实时性要求很高的情况，那就只能首选其他方法。</p><h3 id="随机森林和Adaboost，以及区别："><a href="#随机森林和Adaboost，以及区别：" class="headerlink" title="随机森林和Adaboost，以及区别："></a>随机森林和Adaboost，以及区别：</h3><p>bagging 随机森林，不同的分类器是通过串行训练而获得的，每个新分<br>类器都根据已训练出的分类器的性能来进行训练<br>分类器权重相等.</p><p>boost ：— §是通过集中关注被已有分类器错分的那些数据来获得新的分类器。<br>匕0081丨明分类的结果是基于所有分类器的加权求和结果的，分类器权重并不相等，每个权重代表的是其对应分类器在上一轮迭代中的成功度</p><p>说一下GBDT和Adaboost，以及区别</p><p>Bagging + 决策树 = 随机森林</p><p>2）AdaBoost + 决策树 = 提升树</p><p>3）Gradient Boosting + 决策树 = GBDT</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_分类_数据聚类</title>
      <link href="/2018/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_%E6%95%B0%E6%8D%AE%E8%81%9A%E7%B1%BB/"/>
      <url>/2018/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_%E6%95%B0%E6%8D%AE%E8%81%9A%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>机器学习<em>分类</em>数据聚类</p><a id="more"></a><h3 id="K-Means（k-平均或k-均值）"><a href="#K-Means（k-平均或k-均值）" class="headerlink" title="K-Means（k-平均或k-均值）"></a>K-Means（k-平均或k-均值）</h3><p>可以称的上是知名度最高的一种聚类算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">首先，我们确定要几个的聚类（cluster，也称簇），并为它们随机初始化一个各自的聚类质心点（cluster centroids），它在上图中被表示为“X”。要确定聚类的数量，我们可以先快速看一看已有的数据点，并从中分辨出一些独特的数据。</span><br><span class="line">其次，我们计算每个数据点到质心的距离来进行分类，它跟哪个聚类的质心更近，它就被分类到该聚类。</span><br><span class="line">需要注意的是，初始质心并不是真正的质心，质心应满足聚类里每个点到它的欧式距离平方和最小这个条件。因此根据这些被初步分类完毕的数据点，我们再重新计算每一聚类中所有向量的平均值，并确定出新的质心。</span><br><span class="line">最后，重复上述步骤，进行一定次数的迭代，直到质心的位置不再发生太大变化。当然你也可以在第一步时多初始化几次，然后选取一个看起来更合理的点节约时间。</span><br><span class="line">K-Means的优点是速度非常快，因为我们所做的只是计算数据点和质心点之间的距离，涉及到的计算量非常少！因此它的算法时间复杂度只有O(n)。</span><br><span class="line"></span><br><span class="line">另一方面，K-Means有两个缺点。一是你必须一开始就决定数据集中包含多少个聚类。这个缺点并不总是微不足道的，理想情况下，我们的目标其实是用一种算法来分类这些数据，并从结果中观察出一些规律，而不是限制几个条件强行聚类。二是一开始质心点的选取是随机的，算法可能会初始化出差异巨大的点。这个缺点导致的结果是质心点的位置不可重复且缺乏一致性。</span><br><span class="line"></span><br><span class="line">K-Medians是与K-Means相关的另一种聚类算法，不同之处在于它使用簇的中值向量来重新计算质心点。该方法对异常值不敏感（因为使用中值），但在较大数据集上运行时速度会慢很多，因为每次计算中值向量，我们都要重新排序。</span><br></pre></td></tr></table></figure><h3 id="Mean-Shift聚类"><a href="#Mean-Shift聚类" class="headerlink" title="Mean-Shift聚类"></a>Mean-Shift聚类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Mean shift算法，又称均值漂移算法，这是一种基于核密度估计的爬山算法，可用于聚类、图像分割、跟踪等。它的工作原理基于质心，这意味着它的目标是定位每个簇/类的质心，即先算出当前点的偏移均值，将该点移动到此偏移均值，然后以此为新的起始点，继续移动，直到满足最终的条件（找出最密集的区域）。</span><br><span class="line"></span><br><span class="line">1、为了理解均值漂移，我们可以像上图一样想象二维空间中的一组数据点，然后先随机选择一个点C，以它为圆心画一个半径为r的圆开始移动。之前提到了，这是个爬山算法，它的核函数会随着迭代次数增加逐渐向高密度区域靠近。</span><br><span class="line">2、在每轮迭代中，算法会不断计算圆心到质心的偏移均值，然后整体向质心靠近。漂移圆圈内的密度与数据点数成正比。到达质心后，算法会更新质心位置，并继续让圆圈向更高密度的区域靠近。</span><br><span class="line">3、当圆圈到达目标质心后，它发现自己无论朝哪个方向漂移都找不到更多的数据点，这时我们就认为它已经处于最密集的区域。</span><br><span class="line">4、这时，算法满足了最终的条件，即退出。</span><br><span class="line"></span><br><span class="line">Mean-Shift不需要实现定义聚类数量，因为这些都可以在计算偏移均值时得出。这是一个巨大的优势。同时，算法推动聚类中心在向密度最大区域靠近的效果也非常令人满意，这一过程符合数据驱动型任务的需要，而且十分自然直观。如果要说Mean-Shift有什么缺点，那就是对高维球区域的半径r的定义，不同选择可能会产生高度不同的影响。</span><br></pre></td></tr></table></figure><h3 id="EM聚类"><a href="#EM聚类" class="headerlink" title="EM聚类"></a>EM聚类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">均值→质心，方差→椭圆聚类，权重→聚类大小。</span><br><span class="line">K-Means算法的主要缺点之一是它直接用了距离质心的平均值。</span><br><span class="line"></span><br><span class="line">1、首先，我们确定聚类的数量（如K-Means），并随机初始化每个聚类的高斯分布参数。你也可以尝试通过快速查看数据来为初始参数提供更好的猜测，但从上图可以看出，这其实不是很必要，因为算法会很快进行优化。</span><br><span class="line">2、其次，根据每个聚类的高斯分布，计算数据点属于特定聚类的概率。如果数据点越接近高斯质心，那它属于该聚类的概率就越高。这很直观，因为对于高斯分布，我们一般假设大部分数据更靠近聚类质心。</span><br><span class="line">3、在这些概率的基础上，我们为高斯分布计算一组新的参数，使聚类内数据点的概率最大化。我们用数据点位置的加权和来计算这些新参数，其中权重就是数据点属于聚类的概率。为了可视化这个过程，我们可以看看上面的图片，特别是黄色的聚类。第一次迭代中，它是随机的，大多数黄点都集中在该聚类的右侧。当我们按概率计算加权和后，虽然聚类的中部出现一些点，但右侧的比重依然很高。随着迭代次数增加，黄点在聚类中的位置也完成了“右下→左下”的移动。因此，标准差的变化调整着聚类的形状，以使它能更适合数据点的分布。</span><br><span class="line">4、迭代步骤2和步骤3，直至收敛。</span><br><span class="line"></span><br><span class="line">GMM有两个关键优势。首先它比K-Means更灵活，由于标准差的引入，最后聚类的形状不再局限于圆形，它还可以是大小形状不一的椭圆形——K均值实际上是GMM的一个特例，其中每个聚类的协方差在所有维上都接近0。其次，权重的引入为同一点属于多个聚类找到了解决方案。如果一个数据点位于两个聚类的重叠区域，那我们就可以简单为它定义一个聚类，或者计算它属于X聚类的百分比是多少，属于Y聚类的百分比是多少。简而言之，GMM支持混合“成员”。</span><br><span class="line"></span><br><span class="line">谈及缺点，和K-Means相比，GMM每一步迭代的计算量比较大。另外，它的求解办法基于EM算法，因此有可能陷入局部极值，需要经过多次迭代。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv_ocr</title>
      <link href="/2018/07/16/opencv_ocr/"/>
      <url>/2018/07/16/opencv_ocr/</url>
      
        <content type="html"><![CDATA[<p>opencv_ocr</p><a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> Opencv </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_最优化_数学</title>
      <link href="/2018/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%9C%80%E4%BC%98%E5%8C%96_%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%9C%80%E4%BC%98%E5%8C%96_%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>机器学习<em>最优化</em>数学</p><a id="more"></a><h3 id="泰勒展开式"><a href="#泰勒展开式" class="headerlink" title="泰勒展开式"></a>泰勒展开式</h3><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/taylor1.png" alt=""></p><h3 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h3><p>概率加权下的平均值<br>离散型：$E(x)=\sum<em>ix_ip_i$<br><br>连续型：$E(x)=\int</em>{-\infty}^{\infty}xf(x)dx$</p><h3 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h3><p>取对数：$lnL(\theta<em>1,\theta_2,…,\theta_k=\sum</em>{i=1}^nlnf(x,\theta_1,\theta_2,…,\theta_k))$<br>求驻点：$\partial{lnL(\theta)}/\partial{\theta_i}=0,i=1,2,…k$</p><h1 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h1><h4 id="中心极限定理："><a href="#中心极限定理：" class="headerlink" title="中心极限定理："></a>中心极限定理：</h4><p>设n个随机变量$X_1,X_2,…,X_n$相互独立，均具有相同的数学期望与方差，即<br>$E(X_i)=\mu;D(X_i)=\sigma^2$,</p><script type="math/tex; mode=display">Y_n=X_1+X_2+...+X_n</script><script type="math/tex; mode=display">Z_n=\frac{Y_n-E(Y_n)}{\sqrt{D(Y_n)}}=\frac{Y_n-n\mu}{\sqrt{n}\sigma}→N(0,1)</script><p>随机变量$Z_n$为n个随机变量$X_1,X_2,…,X_n$的规范和<br>设从均值为$\mu$、方差为$\sigma^2$（有限）的任意一个总体中抽取样本量为$n$的样本，当$n$充分⼤大时，样本均值的抽样分布$\frac{Y_n}{n}$近似服从于均值为$\mu$、方差为$\sigma^2$的正态分布。</p><blockquote><p>中心极限定理，把那些对结果影响⽐比较小的变量（假设独⽴立同分布）之和认为服从正态分布是合理理的。</p></blockquote><h4 id="高斯分布"><a href="#高斯分布" class="headerlink" title="高斯分布"></a>高斯分布</h4><p>输入值$x^i$，预测值$\theta^Tx^i$，真实值$y^i$，误差$\epsilon^{i}$</p><script type="math/tex; mode=display">y^i=\theta^Tx^i+\epsilon^{i}</script><p>根据中心极限定理，认为变量之和服从高斯分布,即</p><script type="math/tex; mode=display">\epsilon^{i} = y^i-\theta^Tx^i</script><p>则，x,y的条件概率为</p><script type="math/tex; mode=display">p(y^i|x^i;\theta) = \frac{1}{\sqrt{2\pi}\sigma}exp(-\frac{(y^i-\theta^Tx^i)^2}{2\sigma^2})</script><h1 id="矩阵论"><a href="#矩阵论" class="headerlink" title="矩阵论"></a>矩阵论</h1><h1 id="最优化"><a href="#最优化" class="headerlink" title="最优化"></a>最优化</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 最优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特征提取——局部特征</title>
      <link href="/2018/07/16/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E5%B1%80%E9%83%A8%E7%89%B9%E5%BE%81/"/>
      <url>/2018/07/16/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E5%B1%80%E9%83%A8%E7%89%B9%E5%BE%81/</url>
      
        <content type="html"><![CDATA[<p>特征提取——局部特征</p><a id="more"></a><p>LOG,HOG,DOG微分算子在近圆的斑点检测方面效果很好</p><h3 id="HOG特征"><a href="#HOG特征" class="headerlink" title="HOG特征"></a>HOG特征</h3><p><a href="https://blog.csdn.net/coming_is_winter/article/details/72850511" target="_blank" rel="noopener">https://blog.csdn.net/coming_is_winter/article/details/72850511</a><br><a href="https://blog.csdn.net/zouxy09/article/details/7929348/" target="_blank" rel="noopener">https://blog.csdn.net/zouxy09/article/details/7929348/</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">总结：Dalal提出的Hog特征提取的过程：把样本图像分割为若干个像素的单元（cell），把梯度方向平均划分为9个区间（bin），在每个单元里面对所有像素的梯度方向在各个方向区间进行直方图统计，得到一个9维的特征向量，每相邻的4个单元构成一个块（block），把一个块内的特征向量联起来得到36维的特征向量，用块对样本图像进行扫描，扫描步长为一个单元。最后将所有块的特征串联起来，就得到了人体的特征。</span><br><span class="line"></span><br><span class="line">例如，对于64*128的图像而言，每16*16的像素组成一个cell，每2*2个cell组成一个块，因为每个cell有9个特征，所以每个块内有4*9=36个特征，以8个像素为步长，那么，水平方向将有7个扫描窗口，垂直方向将有15个扫描窗口。也就是说，64*128的图片，总共有36*7*15=3780个特征。</span><br><span class="line"></span><br><span class="line">特征总数： 一个cell有9个特征（9个梯度方向），每个特征cell块里有 num*9个特征，步长像素规格：（列像素数-步长）/步长*（行像素数-步长）/步长，</span><br><span class="line">总特征数:（列像素数-步长）/步长*（行像素数-步长）/步长*num*9</span><br></pre></td></tr></table></figure></p><h3 id="LOG特征"><a href="#LOG特征" class="headerlink" title="LOG特征"></a>LOG特征</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图像与某一个二维函数进行卷积运算实际就是求取图像与这一函数的相似性。同理，图像与高斯拉普拉斯函数的卷积实际就是求取图像与高斯拉普拉斯函数的相似性。当图像中的斑点尺寸与高斯拉普拉斯函数的形状趋近一致时，图像的拉普拉斯响应达到最大。</span><br></pre></td></tr></table></figure><p>Laplace可以用来检测图像中的局部极值点，但是对噪声敏感，所以在我们对图像进行Laplace卷积之前，我们用一个高斯低通滤波对图像进行卷积，目标是去除图像中的噪声点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">先对图像f(x,y)用方差为σ的高斯核进行高斯滤波，去除图像中的噪点。</span><br><span class="line"></span><br><span class="line">L(x,y;σ)=f(x,y)∗G(x,y;σ)</span><br><span class="line">G(x,y;σ)高斯核</span><br><span class="line">然后对图像的拉普拉斯图像则为：</span><br><span class="line"></span><br><span class="line">∇^2=(∂^2L/∂^x2)+(∂^2L/∂y^2)</span><br><span class="line">而实际上有下面等式：</span><br><span class="line"></span><br><span class="line">∇^2[G(x,y)∗f(x,y)]=∇^2[G(x,y)]∗f(x,y)</span><br><span class="line"></span><br><span class="line">我们可以先求高斯核的拉普拉斯算子，再对图像进行卷积</span><br></pre></td></tr></table></figure></p><blockquote><p>使用LoG虽然能较好的检测到图像中的特征点，但是其运算量过大，通常可使用DoG（差分高斯，Difference of Gaussina）来近似计算LoG</p></blockquote><h3 id="Haar特征"><a href="#Haar特征" class="headerlink" title="Haar特征"></a>Haar特征</h3><p>Haar特征分为三类：边缘特征、线性特征、中心特征和对角线特征，组合成特征模板。特征模板内有白色和黑色两种矩形，并定义该模板的特征值为</p><h3>白色矩形像素和减去黑色矩形像素和</h3><p></p><h3 id="Haar-like特征"><a href="#Haar-like特征" class="headerlink" title="Haar-like特征"></a>Haar-like特征</h3><p><a href="https://blog.csdn.net/zouxy09/article/details/7929570" target="_blank" rel="noopener">https://blog.csdn.net/zouxy09/article/details/7929570</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">积分图就是只遍历一次图像就可以求出图像中所有区域像素和的快速算法，大大的提高了图像特征值计算的效率。</span><br><span class="line"></span><br><span class="line">       积分图主要的思想是将图像从起点开始到各个点所形成的矩形区域像素之和作为一个数组的元素保存在内存中，当要计算某个区域的像素和时可以直接索引数组的元素，不用重新计算这个区域的像素和，从而加快了计算（这有个相应的称呼，叫做动态规划算法）。积分图能够在多种尺度下，使用相同的时间（常数时间）来计算不同的特征，因此大大提高了检测速度。</span><br><span class="line"></span><br><span class="line">       我们来看看它是怎么做到的。</span><br><span class="line"></span><br><span class="line">       积分图是一种能够描述全局信息的矩阵表示方法。积分图的构造方式是位置（i,j）处的值ii(i,j)是原图像(i,j)左上角方向所有像素的和：</span><br></pre></td></tr></table></figure><p>归一化图像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i¯(x,y)=(i(x,y)−μ)/cσ</span><br><span class="line">公式中i¯(x,y)表示归一化之后的图像，而i(x,y)表示原始的图像，其中μ表示图像的均值，而σ表示图像的标准差</span><br><span class="line">σ2=(1/N)∑x2−μ2   2是平方</span><br></pre></td></tr></table></figure></p><h3 id="SIFT特征"><a href="#SIFT特征" class="headerlink" title="SIFT特征"></a>SIFT特征</h3><p>SIFT的全称是Scale Invariant Feature Transform，尺度不变特征变换(物体怎么转，人都能识别)。SIFT特征对旋转、尺度缩放、亮度变化等保持不变性，是一种非常稳定的局部特征。</p><p>有4个主要步骤</p><p>1、尺度空间的极值检测 搜索所有尺度空间上的图像，通过高斯微分函数来识别潜在的对尺度和选择不变的兴趣点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$$$L(x,y,σ)=G(x,y,σ)∗I(x,y)$</span><br><span class="line"></span><br><span class="line">为了有效的在尺度空间检测到稳定的关键点，提出了高斯差分尺度空间（DOG scale-space）。利用不同尺度的高斯差分核与图像卷积生成。构造高斯差分尺度空间(DOG scale-space): </span><br><span class="line">$$D(x,y,σ)=(G(x,y,kσ)−G(x,y,σ))∗I(x,y)=L(x,y,kσ)−L(x,y,σ)$$</span><br><span class="line"></span><br><span class="line">σ 是尺度坐标。σ大小决定图像的平滑程度，大尺度对应图像的概貌特征，小尺度对应图像的细节特征。大的σ值对应粗糙尺度(低分辨率)，反之，对应精细尺度(高分辨率)。</span><br><span class="line"></span><br><span class="line">对于一幅图像I，建立其在不同尺度(scale)的图像,后面每个采样都是原图的1/4倍。</span><br><span class="line"></span><br><span class="line">每个点都要与邻域的点，上下相邻尺度的点做比较（9+8+9）26个点作比较（以确保在尺度空间和二维图像空间都检测到极值点）。一个点如果在DOG尺度空间本层以及上下两层的26个领域中是最大或最小值时，就认为该点是图像在该尺度下的一个特征点</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.csdn.net/20160411162902180" alt=""></p><p>2、特征点定位 在每个候选的位置上，通过一个拟合精细模型来确定位置尺度，关键点的选取依据他们的稳定程度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">拟和三维二次函数以精确确定关键点的位置和尺度，同时去除低对比度的关键点和不稳定的边缘响应点(因为DoG算子会产生较强的边缘响应)，以增强匹配稳定性、提高抗噪声能力</span><br></pre></td></tr></table></figure></p><p>用Harris Corner检测<br><a href="https://blog.csdn.net/ws_20100/article/details/51122322" target="_blank" rel="noopener">参考文章</a></p><p>3、特征方向赋值 基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向，后续的所有操作都是对于关键点的方向、尺度和位置进行变换，从而提供这些特征的不变性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个特征点计算一个方向，依照这个方向做进一步的计算， *利用关键点邻域像素的梯度方向分布特性为每个关键点指定方向参数，使算子具备旋转不变性。</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">m(x,y)=(L(x+1,y)−L(x−1,y))2+(L(x,y+1)−L(x,y−1))2</script><script type="math/tex; mode=display">√θ(x,y)=atan2(L(x,y+1)−L(x,y−1)L(x+1,y)−L(x−1,y)</script><p>每个关键点有三个信息：位置、所处尺度、方向。由此可以确定一个SIFT特征区域。<br><img src="https://img-blog.csdn.net/20160413110610471" alt="直方图"><br>4、特征点描述 在每个特征点周围的邻域内，在选定的尺度上测量图像的局部梯度，这些梯度被变换成一种表示，这种表示允许比较大的局部形状的变形和光照变换。</p><blockquote><p>高斯函数是唯一可行的尺度空间核</p></blockquote><h3 id="尺度空间"><a href="#尺度空间" class="headerlink" title="尺度空间"></a>尺度空间</h3><p>多分辨率图像金字塔:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、对原始图像进行平滑</span><br><span class="line">2、对处理后的图像进行降采样（通常是水平、垂直方向的1/2）降采样后得到一系列不断尺寸缩小的图像。显然，一个传统的金字塔中，每一层的图像是其上一层图像长、高的各一半。多分辨率的图像金字塔虽然生成简单，但其本质是降采样，图像的局部特征则难以保持，也就是无法保持特征的尺度不变性。</span><br></pre></td></tr></table></figure></p><p>高斯尺度空间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">图像的模糊程度来模拟人在距离物体由远到近时物体在视网膜上成像过程，距离物体越近其尺寸越大图像也越模糊，这就是高斯尺度空间，使用不同的参数模糊图像（分辨率不变）</span><br><span class="line"></span><br><span class="line">图像和高斯函数进行卷积运算，图像模糊，使用不同的“高斯核”可得到不同模糊程度的图像</span><br><span class="line"></span><br><span class="line">L(x,y,σ)=G(x,y,σ)∗I(x,y)</span><br><span class="line"></span><br><span class="line">其中G(x,y,σ)是高斯核函数</span><br><span class="line">G(x,y,σ)=（1/2Πσ^2）e^((x^2+y^2)/(2σ^2))</span><br></pre></td></tr></table></figure></p><p>构建尺度空间的目的是为了检测出在不同的尺度下都存在的特征点，而检测特征点较好的算子是Δ^2G(高斯拉普拉斯,LoG）</p><h3 id="DoG特征"><a href="#DoG特征" class="headerlink" title="DoG特征"></a>DoG特征</h3><p>使用LoG虽然能较好的检测到图像中的特征点，但是其运算量过大，通常可使用DoG（差分高斯，Difference of Gaussina）来近似计算LoG。</p><p>DOG可以看作为LOG的一个近似，但是它比LOG的效率更高。<br>设k为相邻两个高斯尺度空间的比例因子，则DoG的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D(x,y,σ)=[G(x,y,kσ)−G(x,y,σ)]∗I(x,y)=L(x,y,kσ)−L(x,y,σ)</span><br></pre></td></tr></table></figure><p>L(x,y,σ) 是图像的高斯尺度空间<br>将相邻的两个高斯空间的图像相减就得到了DoG的响应图像</p><h3 id="Harris角点特征提取"><a href="#Harris角点特征提取" class="headerlink" title="Harris角点特征提取"></a>Harris角点特征提取</h3><font color="red">Harris角点检测是一种基于图像灰度的一阶导数矩阵检测方法。检测器的主要思想是局部自相似性/自相关性，即在某个局部窗口内图像块与在各个方向微小移动后的窗口内图像块的相似性。</font><blockquote><p>1、角点可以是两个边缘的角点；&lt;/br&gt;<br>2、角点是邻域内具有两个主方向的特征点；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">人眼对角点的识别通常是在一个局部的小区域或小窗口完成的。如果在各个方向上移动这个特征的小窗口，窗口内区域的灰度发生了较大的变化，那么就认为在窗口内遇到了角点。如果这个特定的窗口在图像各个方向上移动时，窗口内图像的灰度没有发生变化，那么窗口内就不存在角点；如果窗口在某一个方向移动时，窗口内图像的灰度发生了较大的变化，而在另一些方向上没有发生变化，那么，窗口内的图像可能就是一条直线的线段。</span><br></pre></td></tr></table></figure></p></blockquote><script type="math/tex; mode=display">x^{y^z}=(1+{\rm e}^x)^{-2xy^w}</script><script type="math/tex; mode=display">sqrt()</script><blockquote><p>结论：1、增大α的值，将减小角点响应值R，降低角点检测的灵性，减少被检测角点的数量；减小α值，将增大角点响应值R，增加角点检测的灵敏性，增加被检测角点的数量。&lt;/br&gt;<br>2、Harris角点检测算子对亮度和对比度的变化不敏感&lt;/br&gt;<br>3、Harris角点检测算子具有旋转不变性&lt;/br&gt;<br>4、Harris角点检测算子不具有尺度不变性&lt;/br&gt;</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> 特征提取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理_边缘检测</title>
      <link href="/2018/07/16/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/"/>
      <url>/2018/07/16/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<p>图像处理_边缘检测</p><a id="more"></a><p>边缘检测：<br><a href="https://blog.csdn.net/tigerda/article/details/61192943" target="_blank" rel="noopener">https://blog.csdn.net/tigerda/article/details/61192943</a></p><p>常见边缘检测算子：Roberts 、Sobel 、Prewitt、Laplacian、Log/Marr、Canny、Kirsch、Nevitia&lt;/br&gt;</p><p>一阶微分算子：Roberts 、Sobel 、Prewitt&lt;/br&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">模板：</span><br><span class="line">Roberts  </span><br><span class="line">|1, 0|</span><br><span class="line">|0,-1|</span><br><span class="line"></span><br><span class="line">sobel算子</span><br><span class="line">|1, 0 , 1|</span><br><span class="line">|1, 0 , 1|</span><br><span class="line">|1, 0 , 1|</span><br><span class="line"></span><br><span class="line">prewitt算子</span><br><span class="line">|1, 0 , 1|</span><br><span class="line">|1, 0 , 1|</span><br><span class="line">|1, 0 , 1|</span><br><span class="line"></span><br><span class="line">Sobel各向同性算子:</span><br><span class="line"></span><br><span class="line">   |-1  ,0,  1|     |-1,-跟2,-1|</span><br><span class="line">Gx=|-跟2,0,跟2| ,Gx=| 0,   0, 0|</span><br><span class="line">   |-1  ,0,  1|     | 1, 跟2, 1|</span><br></pre></td></tr></table></figure></p><p>Sobel各向同性算子的权值比普通Sobel算子的权值更准确。为什么？模板的权值是离中心位置越远则权值（看绝对值）影响越小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">计算边缘幅值与方向？以Sobel算子为例。3*3Sobel两个方向的算子在图像上滑动，模板与其覆盖的图像3*3区域9个像素进行卷积，求和后得到此方向的边缘检测幅值。</span><br><span class="line"></span><br><span class="line">   |-1,0,1|            |-1,-2,-1|</span><br><span class="line">Gx=|-2,0,2|*f(x,y) ,Gx=| 0, 0, 0|*f(x,y)</span><br><span class="line">   |-1,0,1|            | 1, 2, 1|</span><br><span class="line"></span><br><span class="line">G^2=Gx^2+Gy^2</span><br><span class="line"></span><br><span class="line">P=arctan(Gx/Gy)</span><br><span class="line"></span><br><span class="line">f(x,y)为图像，Gx和Gy分别是水平和竖直方向算子的卷积结果，G则是最终得到的边缘幅值，θ值则是边缘方向。当然G的计算有时简化为</span><br><span class="line">G=|Gx|+|Gy| 或者 G=max(|Gx|,|Gy|)</span><br></pre></td></tr></table></figure></p><p>二阶微分算子：Laplacian、Log/Marr<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Laplacian算子</span><br><span class="line">   |-1,-1,-1|      </span><br><span class="line">Gx=|-1, 8,-1|</span><br><span class="line">   |-1,-1,-1|</span><br><span class="line"></span><br><span class="line">   | 0,-1, 0|      </span><br><span class="line">Gx=|-1, 4,-1|</span><br><span class="line">   | 0,-1, 0|</span><br><span class="line"></span><br><span class="line">   |-2,-4,-4,-4,-2|</span><br><span class="line">   |-4, 0, 8, 0,-4|      </span><br><span class="line">Gx=|-4, 8,24, 8,-4|</span><br><span class="line">   |-4, 0, 8, 0,-4|</span><br><span class="line">   |-2,-4,-4,-4,-2|</span><br><span class="line">Log边缘检测则是先进行高斯滤波再进行拉普拉斯算子检测</span><br></pre></td></tr></table></figure></p><p>非微分边缘检测算子：Canny</p><div class="table-container"><table><thead><tr><th>算 子</th><th>优缺点比较</th></tr></thead><tbody><tr><td>Roberts</td><td>对具有陡峭的低噪声的图像处理效果较好，但利用 Roberts算子提取边缘的结果是边缘比较粗，因此边缘定位不是很准确。</td></tr><tr><td>Sobel</td><td>对灰度渐变和噪声较多的图像处理效果比较好， Sobel算子对边缘定位比较准确。</td></tr><tr><td>Kirsch</td><td>对灰度渐变和噪声较多的图像处理效果较好。</td></tr><tr><td>Prewitt</td><td>对灰度渐变和噪声较多的图像处理效果较好。</td></tr><tr><td>aplacian</td><td>对图像中的阶跃性边缘点定位准确，对噪声非常敏感，丢失一部分边缘的方向信息，造成一些不连续的检测边缘。</td></tr><tr><td>LoG</td><td>算 子 经 常 出 现 双 边 缘 像 素 边 界 ， 而 且 该 检 测 方 法 对 噪 声 比铰 敏 感 ， 所 以 很 少 用 LoG算 子 检 测 边 缘 ， 而 是 用 来 判 断 边 缘 像素是位于图像的明区还是暗区。</td></tr><tr><td>Canny</td><td>此方法不容易受噪声的干扰，能够检测到真正的弱边缘。在edge函数中，最有效的边缘检测方法是 Canny方法。该方法的优点在于使用两种不同的阈值分别检测强边缘和弱边缘，并且汉当弱边缘与强边缘相连时，才将弱边缘包含在输出图像中。因此，这种方法不容易被噪声“填充”，跟容易检测出真正的弱边缘。</td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv_斑点检测</title>
      <link href="/2018/07/16/opencv_%E6%96%91%E7%82%B9%E6%A3%80%E6%B5%8B/"/>
      <url>/2018/07/16/opencv_%E6%96%91%E7%82%B9%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<p>Opencv_斑点检测</p><a id="more"></a><h3 id="opencv中检测Blobs的类为SimpleBlobDetector"><a href="#opencv中检测Blobs的类为SimpleBlobDetector" class="headerlink" title="opencv中检测Blobs的类为SimpleBlobDetector"></a>opencv中检测Blobs的类为SimpleBlobDetector</h3><p>这个类在opencv中的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class SimpleBlobDetector : public FeatureDetector</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">struct Params</span><br><span class="line">&#123;</span><br><span class="line">    Params();</span><br><span class="line">    float thresholdStep;</span><br><span class="line">    float minThreshold;</span><br><span class="line">    float maxThreshold;</span><br><span class="line">    size_t minRepeatability;</span><br><span class="line">    float minDistBetweenBlobs;</span><br><span class="line"></span><br><span class="line">    bool filterByColor;</span><br><span class="line">    uchar blobColor;</span><br><span class="line"></span><br><span class="line">    bool filterByArea;</span><br><span class="line">    float minArea, maxArea;</span><br><span class="line"></span><br><span class="line">    bool filterByCircularity;</span><br><span class="line">    float minCircularity, maxCircularity;</span><br><span class="line"></span><br><span class="line">    bool filterByInertia;</span><br><span class="line">    float minInertiaRatio, maxInertiaRatio;</span><br><span class="line"></span><br><span class="line">    bool filterByConvexity;</span><br><span class="line">    float minConvexity, maxConvexity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SimpleBlobDetector(const SimpleBlobDetector::Params &amp;parameters = SimpleBlobDetector::Params());</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>算法的大致步骤如下：</p><p>对[minThreshold,maxThreshold)区间，以thresholdStep为间隔，做多次二值化。<br>对每张二值图片，使用findContours()提取连通域并计算每一个连通域的中心。<br>根据2得到的中心，全部放在一起。一些很接近的点［由theminDistBetweenBlobs控制多少才算接近］被归为一个group,对应一个bolb特征..<br>从3得到的那些点,估计最后的blob特征和相应半径，并以key points返回。<br>同时该支持提取特征的方法，一共有5个选项，这里就不多加描述了，默认是提取黑色圆形的Blob特征。下面是一个示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char** argv) </span><br><span class="line">&#123; </span><br><span class="line">    Mat image = imread(argv[1]); </span><br><span class="line">    vector&lt;KeyPoint&gt; keyPoints; </span><br><span class="line">    SimpleBlobDetector::Params params;</span><br><span class="line"></span><br><span class="line">    SimpleBlobDetector blobDetect(params); </span><br><span class="line">    blobDetect.create(&quot;SimpleBlob&quot;); </span><br><span class="line">    blobDetect.detect(image, keyPoints); </span><br><span class="line">    cout &lt;&lt; keyPoints.size() &lt;&lt; endl; </span><br><span class="line">    drawKeypoints(image, keyPoints, image, Scalar(255,0,0));</span><br><span class="line"></span><br><span class="line">    namedWindow(&quot;blobs&quot;); </span><br><span class="line">    imshow(&quot;blobs&quot;, image); </span><br><span class="line">    waitKey(); </span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总体来说，OpenCV的斑点检测效果还算不错，但是在有些图像的效果上明显不如LOG算子检测的检测效果</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> Opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理-图像去雾</title>
      <link href="/2018/07/16/%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE/"/>
      <url>/2018/07/16/%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>图像处理-图像去雾</p><a id="more"></a><h3 id="雾图模型"><a href="#雾图模型" class="headerlink" title="雾图模型"></a>雾图模型</h3><script type="math/tex; mode=display">I(x)=J(x)t(x)+A(1-t(x))</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I(x) ——待去雾的图像</span><br><span class="line">J(x)——无雾图像</span><br><span class="line">A——全球大气光成分</span><br><span class="line">t——折射率（大气传递系数）</span><br></pre></td></tr></table></figure><h3 id="暗通道先验"><a href="#暗通道先验" class="headerlink" title="暗通道先验"></a>暗通道先验</h3><p>在无雾图像中，每一个局部区域都很有可能会有阴影，或者是纯颜色的东西，又或者是黑色的东西。因此，每一个局部区域都很有可能有至少一个颜色通道会有很低的值。把这个统计规律叫做Dark Channel Prior。</p><p>首先求出每个像素RGB分量中的最小值，存入一副和原始图像大小相同的灰度图中，然后再对这幅灰度图进行最小值滤波(林宇中取最小值)</p><p>计算折射率</p><script type="math/tex; mode=display">t(x)=1-wmin(minI(y)/A)</script><p>估计大气光<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.选取暗通道图像暗通道最亮的0.1%的像素（一般来说，这些像素表示雾浓度最大的地方）</span><br><span class="line">2.取输入图像里面这些像素对应的像素里面最亮的作为大气光</span><br><span class="line">（暗图像最亮的0.1%的像素对应的原图最亮的为大气光）</span><br></pre></td></tr></table></figure></p><p>注：选中的像素未必是全图最亮的，而且要比选取全图最亮的方式鲁棒性更好。</p><h3 id="去雾"><a href="#去雾" class="headerlink" title="去雾"></a>去雾</h3><script type="math/tex; mode=display">J(x)=I(x)-A/max(t(x),t0) +A</script><p>t0=0.1</p><p>流程：<br>1.求图像暗通道</p><p>2.利用暗通道计算出折射率</p><p>3.利用暗通道估计大气光</p><p>4.代回雾图公式去雾</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特征提取——颜色特征</title>
      <link href="/2018/07/16/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E9%A2%9C%E8%89%B2%E7%89%B9%E5%BE%81/"/>
      <url>/2018/07/16/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E9%A2%9C%E8%89%B2%E7%89%B9%E5%BE%81/</url>
      
        <content type="html"><![CDATA[<p>特征提取——颜色特征<br><a id="more"></a></p><h3 id="颜色直方图"><a href="#颜色直方图" class="headerlink" title="颜色直方图"></a>颜色直方图</h3><p>OpenCV之颜色空间:</p><p>颜色空间RGB（Red 红色，Green 绿色，Blue 蓝色）</p><p>R的取值范围：0-255</p><p>G的取值范围：0-255</p><p>B的取值范围：0-255</p><p>颜色空间HSV （Hue 色相，Saturation 饱和度，intensity 亮度）</p><p>H的取值范围：0-179</p><p>S的取值范围：0-255</p><p>V的取值范围：0-255</p><p>颜色空间HLS (Hue 色相，lightness 亮度，Saturation 饱和度)</p><p>H的取值范围：0-179</p><p>L的取值范围：0-255</p><p>S的取值范围：0-255</p><h3 id="颜色矩"><a href="#颜色矩" class="headerlink" title="颜色矩"></a>颜色矩</h3><p>这种方法的数学基础在于图像中任何的颜色分布均可以用它的矩来表示。此外，由于颜色分布信息主要集中在低阶矩中，因此仅采用颜色的一阶矩（mean）、二阶矩（variance）和三阶矩（skewness）就足以表达图像的颜色分布。与颜色直方图相比，该方法的另一个好处在于无需对特征进行向量化。<br>图像的颜色矩一共只需要9个分量（3个颜色分量，每个分量上3个低阶矩）<br>颜色矩常和其它特征结合使用，而且一般在使用其它特征前起到过滤缩小范围（narrow down）的作用。 </p><p>一阶矩(均值,mean),反映图像明暗程度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u=(1/N)sum(Pij)</span><br></pre></td></tr></table></figure></p><p>二阶矩(方差,viarance),反映图像颜色分布范围<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=sqrt(((1/N)sum(Pij-u)^2),2)</span><br></pre></td></tr></table></figure></p><p>三阶矩(斜度,skewness),反映图像颜色分布对称性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=sqrt(((1/N)sum(Pij-u)^3),3)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
            <tag> 特征提取 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像处理_图像滤波</title>
      <link href="/2018/07/16/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2/"/>
      <url>/2018/07/16/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2/</url>
      
        <content type="html"><![CDATA[<p>图像滤波</p><a id="more"></a><h2 id="噪声"><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h2><p>加性噪声一般指热噪声、散弹噪声等，它们与信号的关系是相加，不管有没有信号，噪声都存在。 </p><blockquote><p>高斯白噪声包括热噪声和散粒噪声。在通信信道测试和建模中，高斯噪声被用作加性白噪声以产生加性白高斯噪声。</p><p>加性高斯白噪声只是白噪声的一种，另有泊松白噪声等,加性高斯白噪声在通信领域中指的是一种各频谱分量服从均匀分布（即白噪声），且幅度服从高斯分布的噪声信号。因其可加性、幅度服从高斯分布且为白噪声的一种而得名。</p></blockquote><p>而乘性噪声一般由信道不理想引起，它们与信号的关系是相乘，信号在它在，信号不在他也就不在。 </p><p>一般通信中把加性随机性看成是系统的背景噪声； </p><p>而乘性随机性看成系统的时变性（如衰落或者多普勒）或者非线性所造成的。</p><h2 id="空域滤波"><a href="#空域滤波" class="headerlink" title="空域滤波"></a>空域滤波</h2><p>空域滤波可以用于非线性滤波，但是频域滤波不能用于非线性滤波</p><div class="table-container"><table><thead><tr><th>图像滤波</th><th></th><th></th></tr></thead><tbody><tr><td>空域</td><td>线性滤波</td><td>均值滤波</td></tr><tr><td>-</td><td>-</td><td>-</td></tr><tr><td></td><td>非线性滤波</td><td>中值滤波</td></tr><tr><td></td><td></td><td>双边滤波</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table></div><h3 id="滤波模板"><a href="#滤波模板" class="headerlink" title="滤波模板"></a>滤波模板</h3><p>图像滤波 模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">线性平均滤波：</span><br><span class="line">1|0 1 0 |</span><br><span class="line">-|1 1 1 |</span><br><span class="line">5|0 1 0 |</span><br></pre></td></tr></table></figure></p><p>图像锐化 模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">锐化滤波：图像锐化一般是通过微分运算来实现的</span><br><span class="line"></span><br><span class="line">|-1  0  1|</span><br><span class="line">|-1  0  1|</span><br><span class="line">|-1  0  1|</span><br><span class="line"></span><br><span class="line">| 1  1  1|</span><br><span class="line">| 0  0  0|</span><br><span class="line">|-1 -1 -1|</span><br></pre></td></tr></table></figure></p><p>方向滤波器-sobel算子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x轴：</span><br><span class="line">|-1  0  1|</span><br><span class="line">|-2  0  2|</span><br><span class="line">|-1  0  1|</span><br><span class="line"></span><br><span class="line">y轴：</span><br><span class="line">|-1 -2 -1|</span><br><span class="line">| 0  0  0|</span><br><span class="line">| 1  2  1|</span><br></pre></td></tr></table></figure></p><p>Scharr算子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x轴：</span><br><span class="line">|-3  0  3|</span><br><span class="line">|-10 0 10|</span><br><span class="line">|-3  0  3|</span><br><span class="line"></span><br><span class="line">y轴：</span><br><span class="line">|-3 -10 -3|</span><br><span class="line">| 0  0   0|</span><br><span class="line">| 3  10  3|</span><br></pre></td></tr></table></figure></p><h3 id="线性空域滤波"><a href="#线性空域滤波" class="headerlink" title="线性空域滤波"></a>线性空域滤波</h3><p><code>线性空域滤波</code>指的是像素的输出值是计算该像素邻域内像素值的线性组合<br>线性滤波中滤波模板也称为<code>卷积模板</code></p><h4 id="模板卷积"><a href="#模板卷积" class="headerlink" title="模板卷积"></a>模板卷积</h4><p>模板卷积的主要步骤包括如下几个步骤，</p><p>1) 将模板在图像中进行遍历，将模板中心和各个像素位置重合；</p><p>2) 将模板的各个系数与模板对应像素值进行相乘；</p><p>3) 将所有的乘积相加，并将求和结果赋值于模板中心对应的像素</p><h4 id="延拓"><a href="#延拓" class="headerlink" title="延拓"></a>延拓</h4><p>模板的行或列就会超出图像之外，因此常常采用延拓的方式解决外边界问题。常用的方法有四种，分别是<code>补零</code>、<code>重复</code>、<code>对称</code>和<code>循环</code>方式。</p><blockquote><p>补零是指通过在图像边界外围补零来扩展图像；<br>重复是指在图像边界外围通过复制外边界的值来扩展图像；<br>对称是指在图像边界外围通过镜像反射外边界的值来扩展图像；<br>循环是在图像边界外围指将图像看成二维周期函数的一个周期来扩展。</p></blockquote><h4 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h4><h4 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h4><p>高斯滤波器宽度(决定着平滑程度)是由参数σ表征的，而且σ和平滑程度的关系是非常简单的．σ越大，高斯滤波器的频带就越宽，平滑程度就越好．通过调节平滑程度参数σ</p><p>高斯分布：$h(x,y)=e^-(\frac{x^2+y^2}{2a^2})$</p><h4 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h4><p>一种非线性的滤波方法，是结合图像的<code>空间邻近度</code>和<code>像素相似度</code>的的一种折中处理。它是一种<code>保持边缘</code>的非迭代平滑滤波方法。中心像素的距离和灰度差值的增大，邻域像素的权系数逐渐减小</p><blockquote><p>优点：保持边缘性能良好，对低频信息滤波良好<br>缺点：不能处理高频信息</p></blockquote><p>假设高斯函数表达式如下：</p><script type="math/tex; mode=display">W_ij=\frac{1}{K_i}e^-\frac{(x_j-x_i)^2}{σ^2_G}</script><p>K是归一化的常量，W是权重，权重只跟像素之间的空间距离有关系。</p><p>双边滤波器:</p><script type="math/tex; mode=display">W_ij=\frac{1}{K_i}e^-\frac{(x_j-x_i)^2}{σ^2_G}e^-\frac{(I_j-I_i)^2}{σ^2_r}</script><h4 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h4><p>中值滤波是统计排序滤波的一种，中值滤波对椒盐噪声效果好；滤波图像边缘信息好，边缘清晰<br>|统计排序滤波|||<br>|-|-|-|<br>|最大值滤波|有效地滤除椒噪声(黑色)|寻找最亮点，亮化图片|<br>|最小值滤波|有效地滤除盐噪声(白色)|寻找最暗点，暗化图片|<br>|自适应中值滤波|有效地滤除椒盐噪声|钝化图像、去除噪音|</p><p>操作步骤：</p><p>1) 将模板在图像中遍历</p><p>2) 将模板对应的邻域内像素的灰度值排序</p><p>3) 查找中间值，将其赋于模板中心对应的像素</p><h3 id="Matlab函数"><a href="#Matlab函数" class="headerlink" title="Matlab函数"></a>Matlab函数</h3><p>Matlab滤波相关函数主要有<code>imfilter()</code>和<code>fspecial()</code>。</p><blockquote><p><code>imfilter()</code>是滤波操作<br><code>fspecial()</code>是构建自定义的二维滤波器，供<code>imfilter()</code>函数使用</p></blockquote><h4 id="imfilter-函数"><a href="#imfilter-函数" class="headerlink" title="imfilter()函数"></a>imfilter()函数</h4><p>定义 <code>g = imfilter(f, w, option1, option2, ...)</code></p><blockquote><p>其中：<br>f:待滤波图像<br>w:滤波模板<br>option1, option2:可选项</p></blockquote><p>可选项分为：</p><p>（1） 边界项：遍历处理边界元素时，需要提前在图像边界周围补充元素<br>     参数：<code>X</code>—表示具体的数字，默认用<code>0</code>补充<br>      <code>symmetric</code>—镜像边界元素<br>      <code>replicate</code>—重复边界像素<br>      <code>circular</code>—周期性填充边界内容</p><p>（2） 尺寸项：处理图像前扩充了边界，比原图大一圈，此项输出图像大小<br>参数: <code>same</code>—输出图像输入图像尺寸相同<br><code>full</code>—输出图像与扩充边界的图像尺寸相同，即比原图大一圈<br>（3） 模式项：滤波过程选择<br>参数：<code>corr</code>—相关滤波过程<br><code>conv</code>—卷积相关过程<br>（4）</p><h4 id="fspecial-函数"><a href="#fspecial-函数" class="headerlink" title="fspecial()函数"></a>fspecial()函数</h4><p>定义 <code>h = fspecial(type, parameters)</code></p><blockquote><p>其中：<br>type:滤波类型</p></blockquote><p>参数：<code>average</code>—平均模板<br><code>disk</code>—圆形邻域平均模板<br><code>guassian</code>—高斯模板<br><code>laplacian</code>—拉普拉斯模板<br><code>log</code>—高斯-拉普拉斯模板<br><code>prewitt</code>—prewitt水平边缘检测算子<br><code>sobel</code>—Sobel水平边缘检测算子</p><hr><h2 id="频域滤波"><a href="#频域滤波" class="headerlink" title="频域滤波"></a>频域滤波</h2><p>可以用图像增强，首先把图像通过傅里叶变换将图像从空间域转换到频率域，频域处理，反傅里叶变换转到空间域</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></div><h3 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h3><h3 id="均值滤波-1"><a href="#均值滤波-1" class="headerlink" title="均值滤波"></a>均值滤波</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void meanFilter (unsigned char* corrupted, unsigned char* smooth, int width, int height)  </span><br><span class="line">&#123;  </span><br><span class="line">      </span><br><span class="line">    memcpy ( smooth, corrupted, width*height*sizeof(unsigned char) );  </span><br><span class="line">      </span><br><span class="line">    for (int j=1;j&lt;height-1;j++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        for (int i=1;i&lt;width-1;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            smooth [ j*width+i ] = (    corrupted [ (j-1)*width+(i-1) ] + corrupted [ (j-1)*width+i] + corrupted [ (j-1)*width+(i+1) ] +  </span><br><span class="line">                                        corrupted [ j*width+(i-1) ]     + corrupted [ j*width+i]     + corrupted [ j*width+(i+1) ] +  </span><br><span class="line">                                        corrupted [ (j+1)*width+(i-1) ] + corrupted [ (j+1)*width+i] + corrupted [ (j+1)*width+(i+1) ] ) / 9;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中值滤波-1"><a href="#中值滤波-1" class="headerlink" title="中值滤波"></a>中值滤波</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void medianFilter (unsigned char* corrupted, unsigned char* smooth, int width, int height)  </span><br><span class="line">&#123;  </span><br><span class="line">      </span><br><span class="line">    memcpy ( smooth, corrupted, width*height*sizeof(unsigned char) );  </span><br><span class="line">    for (int j=1;j&lt;height-1;j++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        for (int i=1;i&lt;width-1;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            int k = 0;  </span><br><span class="line">            unsigned char window[9];  </span><br><span class="line">            for (int jj = j - 1; jj &lt; j + 2; ++jj)  </span><br><span class="line">                for (int ii = i - 1; ii &lt; i + 2; ++ii)  </span><br><span class="line">                    window[k++] = corrupted[jj * width + ii];  </span><br><span class="line">            //   Order elements (only half of them)  </span><br><span class="line">            for (int m = 0; m &lt; 5; ++m)  </span><br><span class="line">            &#123;  </span><br><span class="line">                int min = m;  </span><br><span class="line">                for (int n = m + 1; n &lt; 9; ++n)  </span><br><span class="line">                    if (window[n] &lt; window[min])  </span><br><span class="line">                        min = n;  </span><br><span class="line">                //   Put found minimum element in its place  </span><br><span class="line">                unsigned char temp = window[m];  </span><br><span class="line">                window[m] = window[min];  </span><br><span class="line">                window[min] = temp;  </span><br><span class="line">            &#125;  </span><br><span class="line">            smooth[ j*width+i ] = window[4];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像分割-大津法</title>
      <link href="/2018/07/16/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2_%E5%A4%A7%E6%B4%A5%E6%B3%95/"/>
      <url>/2018/07/16/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2_%E5%A4%A7%E6%B4%A5%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>图像分割-大津法</p><a id="more"></a><h3 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h3><p>最大类间方差法是1979年由日本学者大津提出的，是一种自适应阈值确定的方法，又叫大津法，简称OTSU</p><p>算法公式</p><h3 id="代码-Opencv249-vs2010"><a href="#代码-Opencv249-vs2010" class="headerlink" title="代码 Opencv249 + vs2010"></a>代码 Opencv249 + vs2010</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;cv.h&quot;</span><br><span class="line">#include &quot;highgui.h&quot;</span><br><span class="line">#include &quot;Math.h&quot;</span><br><span class="line"></span><br><span class="line">int Otsu(IplImage* src);</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    IplImage* img = cvLoadImage(&quot;lena.jpg&quot;,0); //获取灰度图像img</span><br><span class="line">    IplImage* dst = cvCreateImage(cvGetSize(img), 8, 1);</span><br><span class="line">    int threshold = Otsu(img); //调用大津法求出最佳阈值</span><br><span class="line">    printf(&quot;otsu threshold = %d\n&quot;, threshold);</span><br><span class="line">    cvThreshold(img, dst, threshold, 255, CV_THRESH_BINARY); //用otsu的阈值二值化</span><br><span class="line"></span><br><span class="line">    cvNamedWindow( &quot;img&quot;, 1 );</span><br><span class="line">    cvNamedWindow( &quot;dst&quot;, 1 );</span><br><span class="line">    cvShowImage(&quot;img&quot;, img);</span><br><span class="line">    cvShowImage(&quot;dst&quot;, dst);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cvWaitKey(-1);</span><br><span class="line"></span><br><span class="line">    cvReleaseImage(&amp;img);</span><br><span class="line">    cvReleaseImage(&amp;dst);</span><br><span class="line"></span><br><span class="line">    cvDestroyWindow( &quot;img&quot; );</span><br><span class="line">    cvDestroyWindow( &quot;dst&quot; );</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Otsu(IplImage* src)  </span><br><span class="line">&#123;  </span><br><span class="line">    int height=src-&gt;height;  </span><br><span class="line">    int width=src-&gt;width;      </span><br><span class="line"></span><br><span class="line">    //histogram  </span><br><span class="line">    float histogram[256] = &#123;0&#125;;  </span><br><span class="line">    for(int i=0; i &lt; height; i++)</span><br><span class="line">    &#123;  </span><br><span class="line">        unsigned char* p=(unsigned char*)src-&gt;imageData + src-&gt;widthStep * i;  </span><br><span class="line">        for(int j = 0; j &lt; width; j++) </span><br><span class="line">        &#123;  </span><br><span class="line">            histogram[*p++]++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    //normalize histogram &amp; average pixel value </span><br><span class="line">    int size = height * width;  </span><br><span class="line">    float u =0;</span><br><span class="line">    for(int i = 0; i &lt; 256; i++)</span><br><span class="line">    &#123;  </span><br><span class="line">        histogram[i] = histogram[i] / size;  </span><br><span class="line">        u += i * histogram[i];  //整幅图像的平均灰度</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    int threshold;    </span><br><span class="line">    float maxVariance=0;  </span><br><span class="line">    float w0 = 0, avgValue  = 0;</span><br><span class="line">    for(int i = 0; i &lt; 256; i++) </span><br><span class="line">    &#123;  </span><br><span class="line">        w0 += histogram[i];  //假设当前灰度i为阈值, 0~i 灰度像素所占整幅图像的比例即前景比例</span><br><span class="line">        avgValue  += i * histogram[i]; //avgValue/w0 = u0</span><br><span class="line"></span><br><span class="line">        float t = avgValue/w0 - u;  //t=u0-u</span><br><span class="line">        float variance = t * t * w0 /(1 - w0);  </span><br><span class="line">        if(variance &gt; maxVariance) </span><br><span class="line">        &#123;  </span><br><span class="line">            maxVariance = variance;  </span><br><span class="line">            threshold = i;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    return threshold;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;opencv2/opencv.hpp&gt;  </span><br><span class="line">#include &lt;cv.h&gt;</span><br><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line">#include &lt;cxcore.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">using namespace cv;</span><br><span class="line"></span><br><span class="line">Mat otsuGray(const Mat src) &#123;</span><br><span class="line">    Mat img = src;</span><br><span class="line">    int c = img.cols; //图像列数</span><br><span class="line">    int r = img.rows; //图像行数</span><br><span class="line">    int T = 0; //阈值</span><br><span class="line">    uchar* data = img.data; //数据指针</span><br><span class="line">    int ftNum = 0; //前景像素个数</span><br><span class="line">    int bgNum = 0; //背景像素个数</span><br><span class="line">    int N = c*r; //总像素个数</span><br><span class="line">    int ftSum = 0; //前景总灰度值</span><br><span class="line">    int bgSum = 0; //背景总灰度值</span><br><span class="line">    int graySum = 0;</span><br><span class="line">    double w0 = 0; //前景像素个数占比</span><br><span class="line">    double w1 = 0; //背景像素个数占比</span><br><span class="line">    double u0 = 0; //前景平均灰度</span><br><span class="line">    double u1 = 0; //背景平均灰度</span><br><span class="line">    double Histogram[256] = &#123;0&#125;; //灰度直方图</span><br><span class="line">    double temp = 0; //临时类间方差</span><br><span class="line">    double g = 0; //类间方差</span><br><span class="line"></span><br><span class="line">    //灰度直方图</span><br><span class="line">    for(int i = 0; i &lt; r ; i ++) &#123;</span><br><span class="line">        for(int j = 0; j &lt;c; j ++) &#123;</span><br><span class="line">            Histogram[img.at&lt;uchar&gt;(i,j)]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //求总灰度值</span><br><span class="line">    for(int i = 0; i &lt; 256; i ++) &#123;</span><br><span class="line">        graySum += Histogram[i]*i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; 256; i ++) &#123;</span><br><span class="line">        ftNum += Histogram[i];  //阈值为i时前景个数</span><br><span class="line">        bgNum = N - ftNum;      //阈值为i时背景个数</span><br><span class="line">        w0 = (double)ftNum/N; //前景像素占总数比</span><br><span class="line">        w1 = (double)bgNum/N; //背景像素占总数比</span><br><span class="line">        if(ftNum == 0) continue;</span><br><span class="line">        if(bgNum == 0) break;</span><br><span class="line">        //前景平均灰度</span><br><span class="line">        ftSum += i*Histogram[i];</span><br><span class="line">        u0 = ftSum/ftNum;</span><br><span class="line"></span><br><span class="line">        //背景平均灰度</span><br><span class="line">        bgSum = graySum - ftSum;</span><br><span class="line">        u1 = bgSum/bgNum;</span><br><span class="line"></span><br><span class="line">        g = w0*w1*(u0-u1)*(u0-u1);</span><br><span class="line">        if(g &gt; temp) &#123;</span><br><span class="line">            temp = g;</span><br><span class="line">            T = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0; i&lt;img.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=0; j&lt;img.cols; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if((int)img.at&lt;uchar&gt;(i,j)&gt;T)</span><br><span class="line">                img.at&lt;uchar&gt;(i,j) = 255;</span><br><span class="line">            else</span><br><span class="line">                img.at&lt;uchar&gt;(i,j) = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return img;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特征提取——局部特征-SIFT算法尺度不变性的理解</title>
      <link href="/2018/07/16/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E5%B1%80%E9%83%A8%E7%89%B9%E5%BE%81_SIFT/"/>
      <url>/2018/07/16/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E5%B1%80%E9%83%A8%E7%89%B9%E5%BE%81_SIFT/</url>
      
        <content type="html"><![CDATA[<p>特征提取——局部特征</p><a id="more"></a><p><a href="https://blog.csdn.net/ws_20100/article/details/51122322" target="_blank" rel="noopener">参考这个就完事了</a></p><h3 id="局部特征"><a href="#局部特征" class="headerlink" title="局部特征"></a>局部特征</h3><p>不管原图尺度是多少，在包含了所有尺度的尺度空间下都能找到那些稳定的极值点，这样就做到了尺度不变！</p><blockquote><p>高斯函数是唯一可行的尺度空间核<br>比如说一张美女图片，想要框出帽子的信息，图像尺寸小时框要这么大，图像尺寸大时，框也要相应调大：</p></blockquote><p>尺度不变性：</p><script type="math/tex; mode=display">L(x,y,σ)=G(x,y,σ)*I(x,y)</script><p>为了有效的在尺度空间检测到稳定的关键点，提出了高斯差分尺度空间（DOG scale-space）。利用不同尺度的高斯差分核与图像卷积生成。构造高斯差分尺度空间(DOG scale-space): </p><script type="math/tex; mode=display">D(x,y,σ)=(G(x,y,kσ)-G(x,y,σ))*I(x,y)=L(x,y,kσ)-L(x,y,σ)</script><p>σ 是尺度坐标。σ大小决定图像的平滑程度，大尺度对应图像的概貌特征，小尺度对应图像的细节特征。大的σ值对应粗糙尺度(低分辨率)，反之，对应精细尺度(高分辨率)。</p><p>旋转不变性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lowe采用的方法是在生成描述子前将图片旋转到一个特定的方向上，这个方向是根据图片内容得到的，具体就是用在某个半径大小的圆内的像素的梯度信息。</span><br><span class="line">sigma取的是1.5*&lt;scale of key point&gt;,r取3*sigma</span><br><span class="line">将图片先旋转到主方向，这个方向由于是用相同的信息得到的，所以总是指向同一方。</span><br></pre></td></tr></table></figure></p><p>抵抗噪声：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DoG得到极值点后，去除低对比度的点的点舍弃,在确定主方向和生成描述子时都将梯度模值加进行加权，即是噪声影响了部分点，经过加权统计会抑制变化，不会对全局造成太大影响</span><br></pre></td></tr></table></figure></p><p><a href="https://blog.csdn.net/u014485485/article/details/78681086?locationNum=1&amp;fps=1" target="_blank" rel="noopener">参考文章</a></p><h3 id="OpenCV代码"><a href="#OpenCV代码" class="headerlink" title="OpenCV代码"></a>OpenCV代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">// opencv_empty_proj.cpp : 定义控制台应用程序的入口点。</span><br><span class="line">//</span><br><span class="line"> </span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &lt;opencv2/opencv.hpp&gt;</span><br><span class="line">#include &lt;opencv2/features2d/features2d.hpp&gt;</span><br><span class="line">#include&lt;opencv2/nonfree/nonfree.hpp&gt;</span><br><span class="line">#include&lt;opencv2/legacy/legacy.hpp&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using namespace cv;</span><br><span class="line"> </span><br><span class="line">int _tmain(int argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    const char* imagename = &quot;img.jpg&quot;;</span><br><span class="line">  </span><br><span class="line">    //从文件中读入图像</span><br><span class="line">    Mat img = imread(imagename);</span><br><span class="line">    Mat img2=imread(&quot;img2.jpg&quot;);</span><br><span class="line"> </span><br><span class="line">    //如果读入图像失败</span><br><span class="line">    if(img.empty())</span><br><span class="line">    &#123;</span><br><span class="line">            fprintf(stderr, &quot;Can not load image %s\n&quot;, imagename);</span><br><span class="line">            return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(img2.empty())</span><br><span class="line">    &#123;</span><br><span class="line">            fprintf(stderr, &quot;Can not load image %s\n&quot;, imagename);</span><br><span class="line">            return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    //显示图像</span><br><span class="line">    imshow(&quot;image before&quot;, img);</span><br><span class="line">    imshow(&quot;image2 before&quot;,img2);</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    //sift特征检测</span><br><span class="line">    SiftFeatureDetector  siftdtc;</span><br><span class="line">    vector&lt;KeyPoint&gt;kp1,kp2;</span><br><span class="line"> </span><br><span class="line">    siftdtc.detect(img,kp1);</span><br><span class="line">    Mat outimg1;</span><br><span class="line">    drawKeypoints(img,kp1,outimg1);</span><br><span class="line">    imshow(&quot;image1 keypoints&quot;,outimg1);</span><br><span class="line">    KeyPoint kp;</span><br><span class="line"> </span><br><span class="line">    vector&lt;KeyPoint&gt;::iterator itvc;</span><br><span class="line">    for(itvc=kp1.begin();itvc!=kp1.end();itvc++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;&quot;angle:&quot;&lt;&lt;itvc-&gt;angle&lt;&lt;&quot;\t&quot;&lt;&lt;itvc-&gt;class_id&lt;&lt;&quot;\t&quot;&lt;&lt;itvc-&gt;octave&lt;&lt;&quot;\t&quot;&lt;&lt;itvc-&gt;pt&lt;&lt;&quot;\t&quot;&lt;&lt;itvc-&gt;response&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    siftdtc.detect(img2,kp2);</span><br><span class="line">    Mat outimg2;</span><br><span class="line">    drawKeypoints(img2,kp2,outimg2);</span><br><span class="line">    imshow(&quot;image2 keypoints&quot;,outimg2);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    SiftDescriptorExtractor extractor;</span><br><span class="line">    Mat descriptor1,descriptor2;</span><br><span class="line">    BruteForceMatcher&lt;L2&lt;float&gt;&gt; matcher;</span><br><span class="line">    vector&lt;DMatch&gt; matches;</span><br><span class="line">    Mat img_matches;</span><br><span class="line">    extractor.compute(img,kp1,descriptor1);</span><br><span class="line">    extractor.compute(img2,kp2,descriptor2);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    imshow(&quot;desc&quot;,descriptor1);</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;descriptor1&lt;&lt;endl;</span><br><span class="line">    matcher.match(descriptor1,descriptor2,matches);</span><br><span class="line"> </span><br><span class="line">    drawMatches(img,kp1,img2,kp2,matches,img_matches);</span><br><span class="line">    imshow(&quot;matches&quot;,img_matches);</span><br><span class="line"> </span><br><span class="line">    //此函数等待按键，按键盘任意键就返回</span><br><span class="line">    waitKey();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习_概率论_数学基础</title>
      <link href="/2018/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%A6%82%E7%8E%87%E8%AE%BA_%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/07/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%A6%82%E7%8E%87%E8%AE%BA_%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>机器学习_概率论</p><a id="more"></a><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>先验概率：<br><br>A的边缘概率表示为P(A)，B的边缘概率表示为P(B)</p><p>联合概率:<br><br>表示两个事件共同发生的概率。A与B的联合概率表示为P(A∩B)或者P(A,B)。</p><p>条件概率（又称后验概率）：<br><br>事件A在另外一个事件B已经发生条件下的发生概率。条件概率表示为P(A|B)，读作“在B条件下A的概率”,。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">考虑一个问题：P(A|B)是在B发生的情况下A发生的可能性。</span><br><span class="line"></span><br><span class="line">首先，事件B发生之前，我们对事件A的发生有一个基本的概率判断，称为A的先验概率，用P(A)表示；</span><br><span class="line"></span><br><span class="line">其次，事件B发生之后，我们对事件A的发生概率重新评估，称为A的后验概率，用P(A|B)表示；</span><br><span class="line"></span><br><span class="line">类似的，事件A发生之前，我们对事件B的发生有一个基本的概率判断，称为B的先验概率，用P(B)表示；</span><br><span class="line"></span><br><span class="line">同样，事件A发生之后，我们对事件B的发生概率重新评估，称为B的后验概率，用P(B|A)表示。</span><br></pre></td></tr></table></figure><h3 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h3><p>贝叶斯定理</p><script type="math/tex; mode=display">P(B_i|A) = \frac{P(B_i)P(A|B_i)}{\sum_{j=1}^n{P(B_j)}{P(A|B_j)}}</script><p>贝叶斯公式</p><script type="math/tex; mode=display">P(A|B)=\frac{P(B|A)P(A)}{P(B)}</script><p>因为联合概率$P(A,B)$</p><script type="math/tex; mode=display">P(A,B)=P(A|B)*P(B)=P(B|A)*P(A)</script><p>假设B事件是由A1、A2事件导致的</p><script type="math/tex; mode=display">P(B)=P(B|A1)P(A1)+P(B|A2)P(A2)</script><p>理解：<br>P(规律|现象)=P(现象|规律)P(规律)/P(现象)</p><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p>假设有两个班级其中1班有男生30人，女生20人；2班有男生25人、女生25人。体育老师抓到一个抽烟的男生，该男生打死也不告诉体育老师是那个班的。问题来了体育老师怎么判断该男生来自那个班？</p><p>先将1班和2班标记为事件A1和事件A2，男生标记为事件B</p><p>那么我们所求的就是P(A1丨B)和P(A2丨B)</p><p>因为只有2个班那么我们先验概率P(A1)=P(A2)=50%；来自1班男生的概率P(B丨A1)=3/5：来自2班男生的概率P(B丨A2)=1/2</p><p>那么我们求出P(B)就可以代入公式得到结果:</p><p>P(B)=P(B丨A1)P(A1) P(B丨A2)P(A2)=0.55</p><p>P(A1丨B)=P(B丨A1)P(A1)/P(B)=0.6*0.5/0.55=55%</p><p>P(A2丨B)=P(B丨A2)P(A2)/P(B)=0.5*0.5/0.55=45%</p><p>由结果我们可以得出：该男生来自1班的概率从50%（先验概率）上升到55%（后验概率）</p><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p>一种癌症，得了这个癌症的人被检测出为阳性的几率为90%，未得这种癌症的人被检测出阴性的几率为90%，而人群中得这种癌症的几率为1%，一个人被检测出阳性，问这个人得癌症的几率为多少？</p><p>我们用 A 表示事件 “测出为阳性”, 用 $B_1$ 表示“得癌症”,  $B_2$ 表示“未得癌症”。</p><p>得到以下信息:<br>$P(A|B_1)=0.9$得癌症的人检测阳性 0.9<br>$P(A|B_2)=0.1$得癌症的人检测阴性 0.1<br>$P(B_1)=0.01$得癌症的概率       0.01<br>$P(B_2)=0.99$未得癌症的概率    0.99</p><p>计算：<br>人群中检测为阳性且得癌症的几率$P(B_1,A)$，联合概率</p><script type="math/tex; mode=display">P(B_1,A)=P(B_1)*P(A|B_1)=0.01*0.9=0.009</script><p>检测阳性并且未得癌症概率$P(B_2,A)$，联合概率</p><script type="math/tex; mode=display">P(B_2,A)=P(B_2)*P(A|B_2)=0.99*0.1=0.099</script><p>目前状态是已经检测除阳性，求患癌症概率$P(B_1|A)$<br>$P(B_1|A)=\frac{0.009}{0.099+0.009}=0.083$<br>未患癌症概率$P(B_2|A)$<br>$P(B_2|A)=\frac{0.099}{0.099+0.009}=0.917$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构相关_6_16</title>
      <link href="/2018/07/10/MavenPeizhi/"/>
      <url>/2018/07/10/MavenPeizhi/</url>
      
        <content type="html"><![CDATA[<p>Maven项目配置</p><a id="more"></a><p>pom.xml配置</p><h2 id="配置编码格式为UTF-8"><a href="#配置编码格式为UTF-8" class="headerlink" title="配置编码格式为UTF-8"></a>配置编码格式为UTF-8</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">&lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt;</span><br><span class="line">&lt;spring.version&gt;5.0.6.RELEASE&lt;/spring.version&gt;//配置统一版本号</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure><h2 id="配置编程环境版本-maven配置"><a href="#配置编程环境版本-maven配置" class="headerlink" title="配置编程环境版本 maven配置"></a>配置编程环境版本 maven配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">&lt;finalName&gt;pp&lt;/finalName&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">&lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Mysql </tag>
            
            <tag> Java </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习—聚类降维</title>
      <link href="/2018/07/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E9%99%8D%E7%BB%B4_GMM_KMEANS/"/>
      <url>/2018/07/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E9%99%8D%E7%BB%B4_GMM_KMEANS/</url>
      
        <content type="html"><![CDATA[<p>机器学习—聚类降维</p><a id="more"></a><h3 id="机器学习—Kmeans"><a href="#机器学习—Kmeans" class="headerlink" title="机器学习—Kmeans"></a>机器学习—Kmeans</h3><p>聚类属于无监督学习，朴素贝叶斯、SVM等都是有类别标签y的，即已经给出了样本的分类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、随机给K个聚类质心 v</span><br><span class="line">2、重复下面过程直到收敛</span><br><span class="line">2.1对于每一个样例i，计算其应该属于的类 </span><br><span class="line">隶属度 ：zi=argmin||xi−μj||^2</span><br><span class="line">求距离近的</span><br><span class="line">2.2 </span><br><span class="line">聚类中心 u=</span><br></pre></td></tr></table></figure><p>其聚类精度明显优于传统的随机选择种子的方法，且计算速度也比较快。而对于更大型的数据集，kmeans++需要进一步扩展，才能获取更好的表现，即kmeans是高度可扩展的。</p><h3 id="机器学习—GMM"><a href="#机器学习—GMM" class="headerlink" title="机器学习—GMM"></a>机器学习—GMM</h3><p>常用作聚类，可以运动目标检测。</p><p>高斯混合模型（Gaussian Mixed Model）指的是多个高斯分布函数的线性组合，理论上GMM可以拟合出任意类型的分布，通常用于解决同一集合下的数据包含多个不同的分布的情况（或者是同一类分布但参数不一样，或者是不同类型的分布，比如正态分布和伯努利分布）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">//  基于混合高斯模型的运动目标检测</span><br><span class="line">//  Author： http://blog.csdn.net/icvpr  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"> </span><br><span class="line">#include &lt;opencv2/opencv.hpp&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">std::string videoFile = &quot;../test.avi&quot;;</span><br><span class="line"> </span><br><span class="line">cv::VideoCapture capture;</span><br><span class="line">capture.open(videoFile);</span><br><span class="line"> </span><br><span class="line">if (!capture.isOpened())</span><br><span class="line">&#123;</span><br><span class="line">std::cout&lt;&lt;&quot;read video failure&quot;&lt;&lt;std::endl;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">cv::BackgroundSubtractorMOG2 mog;</span><br><span class="line"> </span><br><span class="line">cv::Mat foreground;</span><br><span class="line">cv::Mat background;</span><br><span class="line"> </span><br><span class="line">cv::Mat frame;</span><br><span class="line">long frameNo = 0;</span><br><span class="line">while (capture.read(frame))</span><br><span class="line">&#123;</span><br><span class="line">++frameNo;</span><br><span class="line"> </span><br><span class="line">std::cout&lt;&lt;frameNo&lt;&lt;std::endl;</span><br><span class="line"> </span><br><span class="line">// 运动前景检测，并更新背景</span><br><span class="line">mog(frame, foreground, 0.001);       </span><br><span class="line"></span><br><span class="line">// 腐蚀</span><br><span class="line">cv::erode(foreground, foreground, cv::Mat());</span><br><span class="line"></span><br><span class="line">// 膨胀</span><br><span class="line">cv::dilate(foreground, foreground, cv::Mat());</span><br><span class="line"> </span><br><span class="line">mog.getBackgroundImage(background);   // 返回当前背景图像</span><br><span class="line"> </span><br><span class="line">cv::imshow(&quot;video&quot;, foreground);</span><br><span class="line">cv::imshow(&quot;background&quot;, background);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">if (cv::waitKey(25) &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EM算法："><a href="#EM算法：" class="headerlink" title="EM算法："></a>EM算法：</h3><p>第一步先求出要估计参数的粗略值。<br>第二步使用第一步的值最大化似然函数。因此要先求出GMM的似然函数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Opencv </tag>
            
            <tag> C++ </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机视觉——</title>
      <link href="/2018/07/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
      <url>/2018/07/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/</url>
      
        <content type="html"><![CDATA[<p>计算机视觉</p><a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式_7_5</title>
      <link href="/2018/07/05/model_danli_7_5/"/>
      <url>/2018/07/05/model_danli_7_5/</url>
      
        <content type="html"><![CDATA[<p>设计模式—单例模式</p><a id="more"></a><p>单例模式是设计模式中比较简单的一种。适合于一个类只有一个实例的情况，比如窗口管理器，打印缓冲池和文件系统，它们都是原型的例子。典型的情况是，那些对象的类型被遍及一个软件系统的不同对象访问，因此需要一个全局的访问.</p><p>单例模式你可以： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一、确保一个类只有一个实例被建立 </span><br><span class="line">二、提供了一个对对象的全局访问指针 </span><br><span class="line">三、在不影响单例类的客户端的情况下允许将来有多个实例</span><br></pre></td></tr></table></figure><p>经典的单例模式有三种，懒汉式、饿汉式和 登记式。</p><p>懒汉式的特点是延迟加载，比如配置文件，采用懒汉式的方法，顾名思义，懒汉么，很懒的，配置文件的实例直到用到的时候才会加载。</p><p>饿汉式的特点是一开始就加载了，如果说懒汉式是“时间换空间”，那么饿汉式就是“空间换时间”，因为一开始就创建了实例。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Mysql </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown 基本用法(常用)</title>
      <link href="/2018/07/01/markdown/"/>
      <url>/2018/07/01/markdown/</url>
      
        <content type="html"><![CDATA[<p>markdown 基本用法<br><a id="more"></a></p><p><a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown" target="_blank" rel="noopener">在线markdown编辑器</a></p><h2 id="标题类别"><a href="#标题类别" class="headerlink" title="标题类别"></a>标题类别</h2><p></p><h1>一级标题</h1><br>用”<h数字>&lt;/h数字&gt;”或者多个”#”隔开<p></p><pre><code>&lt;h1&gt;一级标题&lt;/h1&gt;# 一级标题</code></pre><h2>二级标题</h2><pre><code>&lt;h2&gt;二级标题&lt;/h2&gt;## 二级标题</code></pre><p>以此类推</p><hr><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>四个空格后开始写代码<br>（空空空空zxcvbasdfgqwert）</p><p>或者用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><pre><code>AAA<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"> (四个空格两个字节)zxcvbasdfgqwert</span><br><span class="line"></span><br><span class="line">--- </span><br><span class="line">## 语句强调</span><br><span class="line">&lt;h3&gt;斜体&lt;/h3&gt;</span><br><span class="line">文字两端使用1个&quot;*&quot;或者&quot;_&quot;夹起来</span><br><span class="line"></span><br><span class="line">*a*</span><br><span class="line"></span><br><span class="line">    *a*</span><br><span class="line">    或者</span><br><span class="line">    _a_</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 粗体</span><br><span class="line">文字两端使用2个&quot;*&quot;或者&quot;_&quot;夹起来</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 分隔线</span><br><span class="line">三个&quot;*&quot;或者&quot;-&quot;</span><br><span class="line"></span><br><span class="line">    ***</span><br><span class="line">    ---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 无序列表</span><br><span class="line"></span><br><span class="line">使用加号&quot;+&quot;或是减号&quot;-&quot;作为列表标记：</span><br><span class="line"></span><br><span class="line">+ 可乐</span><br><span class="line">+ 雪碧</span><br><span class="line"></span><br><span class="line">    +（空格）可乐</span><br><span class="line">    +（空格）雪碧</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">## emoji表情</span><br><span class="line">Markdown文档支持文中插入emoji表情</span><br><span class="line"></span><br><span class="line">比如：&lt;br&gt;</span><br><span class="line"></span><br><span class="line">`:laughing:` 表示:laughing:</span><br><span class="line">`:heart:` 表示:heart:</span><br><span class="line">其他emoji的地址如下链接：</span><br><span class="line">[emoji地址](https://github.com/guodongxiaren/README/blob/master/emoji.md)</span><br><span class="line"></span><br><span class="line">## 引用</span><br><span class="line">`&gt;`表示引用 </span><br><span class="line">`&gt;&gt;` 表示引用中的引用</span><br><span class="line">效果展示:</span><br><span class="line"></span><br><span class="line">&gt;引用(一个小于号) </span><br><span class="line">&gt;&gt; 引用中的引用（两个小于号）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 1. 斜体和粗体</span><br><span class="line"></span><br><span class="line">使用 * 和 ** 表示斜体和粗体。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">这是 *斜体*，这是 **粗体**。</span><br><span class="line"></span><br><span class="line">### 2. 分级标题</span><br><span class="line"></span><br><span class="line">使用 === 表示一级标题，使用 --- 表示二级标题。</span><br><span class="line"></span><br><span class="line">示例：</span><br></pre></td></tr></table></figure></code></pre><h1 id="这是一个一级标题"><a href="#这是一个一级标题" class="headerlink" title="这是一个一级标题"></a>这是一个一级标题</h1><h2 id="这是一个二级标题"><a href="#这是一个二级标题" class="headerlink" title="这是一个二级标题"></a>这是一个二级标题</h2><h3 id="这是一个三级标题"><a href="#这是一个三级标题" class="headerlink" title="这是一个三级标题"></a>这是一个三级标题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。</span><br><span class="line"></span><br><span class="line">### 3. 外链接</span><br><span class="line"></span><br><span class="line">使用 \[描述](链接地址) 为文字增加外链接。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">这是去往 [本人博客](http://ghosertblog.github.com) 的链接。</span><br><span class="line"></span><br><span class="line">### 4. 无序列表</span><br><span class="line"></span><br><span class="line">使用 `*`，`+`或者`-` 表示无序列表。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">- 无序列表项 一</span><br><span class="line">- 无序列表项 二</span><br><span class="line">- 无序列表项 三</span><br><span class="line"></span><br><span class="line">### 5. 有序列表</span><br><span class="line"></span><br><span class="line">使用数字和点表示有序列表。`1.`</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">1. 有序列表项 一</span><br><span class="line">2. 有序列表项 二</span><br><span class="line">3. 有序列表项 三</span><br><span class="line"></span><br><span class="line">### 6. 文字引用</span><br><span class="line"></span><br><span class="line">使用 &gt; 表示文字引用。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">&gt; 野火烧不尽，春风吹又生。</span><br><span class="line"></span><br><span class="line">### 7. 行内代码块</span><br><span class="line"></span><br><span class="line">使用 上顿点\`代码` 表示行内代码块。</span><br><span class="line">&gt;`代码`</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">让我们聊聊 `html`。</span><br><span class="line"></span><br><span class="line">### 8.  代码块</span><br><span class="line"></span><br><span class="line">使用 四个缩进空格 或者上下三个上顿点 表示代码块。</span><br><span class="line">&gt;\`    上顿点前后各三个</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">    这是一个代码块，此行左侧有四个不可见的空格。</span><br><span class="line"></span><br><span class="line">### 9.  插入图像</span><br><span class="line"></span><br><span class="line">使用 \!\[描述](图片链接地址) 插入图像。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">[![kZq279.jpg](https://s2.ax1x.com/2019/01/24/kZq279.jpg)](https://imgchr.com/i/kZq279)</span><br><span class="line"></span><br><span class="line"># Cmd Markdown 高阶语法手册</span><br><span class="line"></span><br><span class="line">### 1. 内容目录</span><br><span class="line"></span><br><span class="line">在段落中填写 `[TOC]` 以显示全文内容的目录结构。</span><br><span class="line"></span><br><span class="line">[TOC]</span><br><span class="line"></span><br><span class="line">### 2. 标签分类</span><br><span class="line"></span><br><span class="line">在编辑区任意行的列首位置输入以下代码给文稿标签：</span><br><span class="line"></span><br><span class="line">标签： 数学 英语 Markdown</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">Tags： 数学 英语 Markdown</span><br><span class="line"></span><br><span class="line">### 3. 删除线</span><br><span class="line"></span><br><span class="line">使用 ~~ 表示删除线。</span><br><span class="line"></span><br><span class="line">~~这是一段错误的文本。~~</span><br><span class="line"></span><br><span class="line">### 4. 注脚</span><br><span class="line"></span><br><span class="line">使用 [^keyword] 表示注脚。</span><br><span class="line"></span><br><span class="line">这是一个注脚[^footnote]的样例。</span><br><span class="line"></span><br><span class="line">这是第二个注脚[^footnote2]的样例。</span><br><span class="line"></span><br><span class="line">### 5. LaTeX 公式</span><br><span class="line"></span><br><span class="line">$ 表示行内公式： </span><br><span class="line"></span><br><span class="line">质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</span><br><span class="line"></span><br><span class="line">$$ 表示整行公式：</span><br><span class="line"></span><br><span class="line">$$\sum_&#123;i=1&#125;^n a_i=0$$</span><br><span class="line"></span><br><span class="line">$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$</span><br><span class="line"></span><br><span class="line">$$\sum^&#123;j-1&#125;_&#123;k=0&#125;&#123;\widehat&#123;\gamma&#125;_&#123;kj&#125; z_k&#125;$$</span><br><span class="line"></span><br><span class="line">访问 [MathJax](http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference) 参考更多使用方法。</span><br><span class="line"></span><br><span class="line">### 6. 加强的代码块</span><br><span class="line"></span><br><span class="line">支持四十一种编程语言的语法高亮的显示，行号显示。</span><br><span class="line"></span><br><span class="line">非代码示例：</span><br></pre></td></tr></table></figure><p>$ sudo apt-get install vim-gnome<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Python 示例：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">@requires_authorization</span><br><span class="line">def somefunc(param1=&apos;&apos;, param2=0):</span><br><span class="line">    &apos;&apos;&apos;A docstring&apos;&apos;&apos;</span><br><span class="line">    if param1 &gt; param2: # interesting</span><br><span class="line">        print &apos;Greater&apos;</span><br><span class="line">    return (param2 - param1 + 1) or None</span><br><span class="line"></span><br><span class="line">class SomeClass:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; message = &apos;&apos;&apos;interpreter</span><br><span class="line">... prompt&apos;&apos;&apos;</span><br></pre></td></tr></table></figure></p><p>JavaScript 示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* nth element in the fibonacci series.</span></span><br><span class="line"><span class="comment">* @param n &gt;= 0</span></span><br><span class="line"><span class="comment">* @return the nth element, &gt;= 0.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> tmp;</span><br><span class="line">  <span class="keyword">while</span> (--n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    tmp = a;</span><br><span class="line">    a += b;</span><br><span class="line">    b = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(fib(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><h3 id="7-流程图"><a href="#7-流程图" class="headerlink" title="7. 流程图"></a>7. 流程图</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start:&gt;https://www.zybuluo.com</span><br><span class="line">io=&gt;inputoutput: verification</span><br><span class="line">op=&gt;operation: Your Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">sub=&gt;subroutine: Your Subroutine</span><br><span class="line">e=&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;io-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;sub-&gt;io</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：流程图语法参考"><a href="#更多语法参考：流程图语法参考" class="headerlink" title="更多语法参考：流程图语法参考"></a>更多语法参考：<a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">流程图语法参考</a></h4><h3 id="8-序列图"><a href="#8-序列图" class="headerlink" title="8. 序列图"></a>8. 序列图</h3><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Title: Here is a title</span><br><span class="line">A-&gt;B: Normal line</span><br><span class="line">B--&gt;C: Dashed line</span><br><span class="line">C-&gt;&gt;D: Open arrow</span><br><span class="line">D--&gt;&gt;A: Dashed open arrow</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：序列图语法参考"><a href="#更多语法参考：序列图语法参考" class="headerlink" title="更多语法参考：序列图语法参考"></a>更多语法参考：<a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">序列图语法参考</a></h4><h3 id="9-甘特图"><a href="#9-甘特图" class="headerlink" title="9. 甘特图"></a>9. 甘特图</h3><p>甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">title 项目开发流程</span><br><span class="line">section 项目确定</span><br><span class="line">    需求分析       :a1, 2016-06-22, 3d</span><br><span class="line">    可行性报告     :after a1, 5d</span><br><span class="line">    概念验证       : 5d</span><br><span class="line">section 项目实施</span><br><span class="line">    概要设计      :2016-07-05  , 5d</span><br><span class="line">    详细设计      :2016-07-08, 10d</span><br><span class="line">    编码          :2016-07-15, 10d</span><br><span class="line">    测试          :2016-07-22, 5d</span><br><span class="line">section 发布验收</span><br><span class="line">    发布: 2d</span><br><span class="line">    验收: 3d</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：甘特图语法参考"><a href="#更多语法参考：甘特图语法参考" class="headerlink" title="更多语法参考：甘特图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#gant-diagrams" target="_blank" rel="noopener">甘特图语法参考</a></h4><h3 id="10-Mermaid-流程图"><a href="#10-Mermaid-流程图" class="headerlink" title="10. Mermaid 流程图"></a>10. Mermaid 流程图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A[Hard edge] --&gt;|Link text| B(Round edge)</span><br><span class="line">B --&gt; C&#123;Decision&#125;</span><br><span class="line">C --&gt;|One| D[Result one]</span><br><span class="line">C --&gt;|Two| E[Result two]</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：Mermaid-流程图语法参考"><a href="#更多语法参考：Mermaid-流程图语法参考" class="headerlink" title="更多语法参考：Mermaid 流程图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#flowcharts-basic-syntax" target="_blank" rel="noopener">Mermaid 流程图语法参考</a></h4><h3 id="11-Mermaid-序列图"><a href="#11-Mermaid-序列图" class="headerlink" title="11. Mermaid 序列图"></a>11. Mermaid 序列图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;John: Hello John, how are you?</span><br><span class="line">loop every minute</span><br><span class="line">    John--&gt;Alice: Great!</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="更多语法参考：Mermaid-序列图语法参考"><a href="#更多语法参考：Mermaid-序列图语法参考" class="headerlink" title="更多语法参考：Mermaid 序列图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#sequence-diagrams" target="_blank" rel="noopener">Mermaid 序列图语法参考</a></h4><h3 id="12-表格支持"><a href="#12-表格支持" class="headerlink" title="12. 表格支持"></a>12. 表格支持</h3><div class="table-container"><table><thead><tr><th>项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td>计算机</td><td style="text-align:right">$1600</td><td style="text-align:center">5</td></tr><tr><td>手机</td><td style="text-align:right">$12</td><td style="text-align:center">12</td></tr><tr><td>管线</td><td style="text-align:right">$1</td><td style="text-align:center">234</td></tr></tbody></table></div><h3 id="13-定义型列表"><a href="#13-定义型列表" class="headerlink" title="13. 定义型列表"></a>13. 定义型列表</h3><p>名词 1<br>:   定义 1（左侧有一个可见的冒号和四个不可见的空格）</p><p>代码块 2<br>:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</p><pre><code>    代码块（左侧有八个不可见的空格）</code></pre><h3 id="14-Html-标签"><a href="#14-Html-标签" class="headerlink" title="14. Html 标签"></a>14. Html 标签</h3><p>本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格：</p><pre><code>&lt;table&gt;    &lt;tr&gt;        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;        &lt;th&gt;星期一&lt;/th&gt;        &lt;th&gt;星期二&lt;/th&gt;        &lt;th&gt;星期三&lt;/th&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;李强&lt;/td&gt;        &lt;td&gt;张明&lt;/td&gt;        &lt;td&gt;王平&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><table>    <tr>        <th rowspan="2">值班人员</th>        <th>星期一</th>        <th>星期二</th>        <th>星期三</th>    </tr>    <tr>        <td>李强</td>        <td>张明</td>        <td>王平</td>    </tr></table><h3 id="15-内嵌图标"><a href="#15-内嵌图标" class="headerlink" title="15. 内嵌图标"></a>15. 内嵌图标</h3><p>本站的图标系统对外开放，在文档中输入</p><pre><code>&lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt;</code></pre><p>即显示微博的图标： <i class="icon-weibo icon-2x"></i></p><p>替换 上述 <code>i 标签</code> 内的 <code>icon-weibo</code> 以显示不同的图标，例如：</p><pre><code>&lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt;</code></pre><p>即显示人人的图标： <i class="icon-renren icon-2x"></i></p><p>更多的图标和玩法可以参看 <a href="http://fortawesome.github.io/Font-Awesome/3.2.1/icons/" target="_blank" rel="noopener">font-awesome</a> 官方网站。</p><h3 id="16-待办事宜-Todo-列表"><a href="#16-待办事宜-Todo-列表" class="headerlink" title="16. 待办事宜 Todo 列表"></a>16. 待办事宜 Todo 列表</h3><p>使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：</p><pre><code>- [ ] **Cmd Markdown 开发**    - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率    - [ ] 支持以 PDF 格式导出文稿    - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)    - [x] 改进 LaTex 功能        - [x] 修复 LaTex 公式渲染问题        - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)- [ ] **七月旅行准备**    - [ ] 准备邮轮上需要携带的物品    - [ ] 浏览日本免税店的物品    - [x] 购买蓝宝石公主号七月一日的船票</code></pre><p>对应显示如下待办事宜 Todo 列表：</p><ul><li>[ ] <strong>Cmd Markdown 开发</strong><ul><li>[ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li><li>[ ] 支持以 PDF 格式导出文稿</li><li>[x] 新增Todo列表功能 <a href="https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments" target="_blank" rel="noopener">语法参考</a></li><li>[x] 改进 LaTex 功能<ul><li>[x] 修复 LaTex 公式渲染问题</li><li>[x] 新增 LaTex 公式编号功能 <a href="http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers" target="_blank" rel="noopener">语法参考</a></li></ul></li></ul></li><li>[ ] <strong>七月旅行准备</strong><ul><li>[ ] 准备邮轮上需要携带的物品</li><li>[ ] 浏览日本免税店的物品</li><li>[x] 购买蓝宝石公主号七月一日的船票</li></ul></li></ul><blockquote id="fn_footnote"><sup>footnote</sup>. 这是一个 <em>注脚</em> 的 <strong>文本</strong>。<a href="#reffn_footnote" title="Jump back to footnote [footnote] in the text."> &#8617;</a></blockquote><blockquote id="fn_footnote2"><sup>footnote2</sup>. 这是另一个 <em>注脚</em> 的 <strong>文本</strong>。<a href="#reffn_footnote2" title="Jump back to footnote [footnote2] in the text."> &#8617;</a></blockquote></h数字>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git上传文件到Github</title>
      <link href="/2018/07/01/git_git2github/"/>
      <url>/2018/07/01/git_git2github/</url>
      
        <content type="html"><![CDATA[<p>准备工作：</p><a id="more"></a><p>1、电脑装有Git<br>2、GitHub 已有仓库</p><p>1、克隆GitHub仓库，到本地</p><p>文件夹右键选择Git Bash Here，输入代码<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Git clone git@github.com:用户名/仓库名.git</span><br></pre></td></tr></table></figure><p>2、放置代码内容到第一步下载的文件夹里</p><p>3、执行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;情况说明&quot;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>4、上传成功</p><hr><h3 id="多电脑同步"><a href="#多电脑同步" class="headerlink" title="多电脑同步"></a>多电脑同步</h3><p>使用电脑搭建好博客后可能面临如下问题</p><p>1、是在家里私人电脑上搭建的，想在公司也可以愉快的写文章<br>2、换了一台新的电脑（挣钱了要换装备😂）<br>3、电脑系统崩了😭</p><p>关于多电脑同步解决方案1</p><p>gitHub分支管理，master分支存博客静态网页资源，Hexo分支存所有源文件（设置为默认分支）<br>每个电脑每次更新文章前需要正常的git同步操作<br>每个电脑每次更新文章后需要正常的git同步操作<br>但是个人感觉不安全，别人可能直接把你的Hexo分支拉取下来就等于获取了你的全部博客资源（虽然我的博客没什么有用的价值😂）<br>具体分支实现可参考利用分支同步<br>关于多电脑同步解决方案2</p><p>每次手动拷贝最新的文件夹替换另一台电脑旧文件夹（想想就麻烦）<br>通过云盘如Dropbox自动同步整个文件夹，使所有的电脑都可以同步到最新的<br>目标电脑获取到最新的博客文件后</p><p>如果是情形3可以考虑先把整个博客目录拷贝出来到新的系统博客目录下<br>GitHub添加配置新电脑的<code>SSH key</code> 和搭建时一样参考<code>Mac</code>搭建<code>Hexo</code>博客及<code>NexT</code>主题配置优化<br>配置运行环境，执行如下指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install node   // 安装Node.js</span><br><span class="line">npm install -g hexo // 安装hexo</span><br></pre></td></tr></table></figure></p><p>切换到博客目录下安装博客模块和插件 (具体参考之前安装过的插件)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line"> npm install hexo-deployer-git --save</span><br><span class="line"> npm install hexo-generator-feed --save</span><br><span class="line"> npm install hexo-generator-sitemap --save</span><br><span class="line"> npm install hexo-generator-feed --save</span><br><span class="line"> npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">npm install -g gulp </span><br><span class="line">    npm install gulp-minify-css --save</span><br><span class="line">    npm install gulp-uglify --save</span><br><span class="line">    npm install gulp-htmlmin --save</span><br><span class="line">    npm install gulp-htmlclean --save</span><br><span class="line">    npm install gulp-imagemin --save</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库相关_6_15</title>
      <link href="/2018/06/15/sql_6_16/"/>
      <url>/2018/06/15/sql_6_16/</url>
      
        <content type="html"><![CDATA[<p>数据库系统达到了数据独立性是因为采用了<strong>三级模式结构</strong><br><a id="more"></a></p><p>人们为数据库设计了一个严谨的体系结构，数据库领域公认的标准结构是三级模式结构，它包括<code>外模式、概念模式、内模式</code>，有效地组织、管理数据，提高了数据库的逻辑独立性和物理独立性。用户级对应外模式，概念级对应概念模式，物理级对应内模式，使不同级别的用户对数据库形成不同的视图。</p><div class="table-container"><table><thead><tr><th>级别</th><th style="text-align:right">模式</th></tr></thead><tbody><tr><td>用户级</td><td style="text-align:right">外模式</td></tr><tr><td>概念级</td><td style="text-align:right">概念模式</td></tr><tr><td>物理级</td><td style="text-align:right">内模式</td></tr></tbody></table></div><p>所谓视图，就是指观察、认识和理解数据的范围、角度和方法，是数据库在用户“眼中”的反映，很显然，不同层次（级别）用户所“看到”的数据库是不相同的。</p><hr><p>索引顺序查找又称为<code>分块查找</code>，是介于顺序查找和二分查找之间的一种查找方法</p><hr><p>MySQL有多种存储引擎，每种存储引擎有各自的优缺点，可以择优选择使用： </p><p>MyISAM、InnoDB、MERGE、MEMORY(HEAP)、BDB(BerkeleyDB)、EXAMPLE、FEDERATED、ARCHIVE、CSV、BLACKHOLE。</p><p><code>MySQL</code>支持数个存储引擎作为对不同表的类型的处理器。MySQL存储引擎包括处理事务安全表的引擎和处理非事务安全表的引擎： </p><p><code>MyISAM</code>管理非事务表。它提供高速存储和检索，以及全文搜索能力。MyISAM在所有MySQL配置里被支持，它是默认的存储引擎，除非你配置MySQL默认使用另外一个引擎。 </p><p><code>MEMORY</code>存储引擎提供“内存中”表。MERGE存储引擎允许集合将被处理同样的MyISAM表作为一个单独的表。就像MyISAM一样，MEMORY和MERGE存储引擎处理非事务表，这两个引擎也都被默认包含在MySQL中。 </p><p>注释：MEMORY存储引擎正式地被确定为HEAP引擎。 </p><p><code>InnoDB</code>和<code>BDB</code>存储引擎提供事务安全表。BDB被包含在为支持它的操作系统发布的MySQL-Max二进制分发版里。InnoDB也默认被包括在所 有MySQL 5.1二进制分发版里，你可以按照喜好通过配置MySQL来允许或禁止任一引擎。 </p><p><code>EXAMPLE</code>存储引擎是一个“存根”引擎，它不做什么。你可以用这个引擎创建表，但没有数据被存储于其中或从其中检索。这个引擎的目的是服务，在 MySQL源代码中的一个例子，它演示说明如何开始编写新存储引擎。同样，它的主要兴趣是对开发者。 </p><p><code>NDB Cluster</code>是被MySQL Cluster用来实现分割到多台计算机上的表的存储引擎。它在MySQL-Max 5.1二进制分发版里提供。这个存储引擎当前只被Linux, Solaris, 和Mac OS X 支持。在未来的MySQL分发版中，我们想要添加其它平台对这个引擎的支持，包括Windows。</p><p><code>ARCHIVE</code>存储引擎被用来无索引地，非常小地覆盖存储的大量数据。 </p><p><code>CSV</code>存储引擎把数据以逗号分隔的格式存储在文本文件中。 </p><p><code>BLACKHOLE</code>存储引擎接受但不存储数据，并且检索总是返回一个空集。 </p><p><code>FEDERATED</code>存储引擎把数据存在远程数据库中。在MySQL 5.1中，它只和MySQL一起工作，使用MySQL C Client API。在未来的分发版中，我们想要让它使用其它驱动器或客户端连接方法连接到另外的数据源。</p><h2 id="比较常用的是MyISAM和InnoBD"><a href="#比较常用的是MyISAM和InnoBD" class="headerlink" title="比较常用的是MyISAM和InnoBD"></a>比较常用的是MyISAM和InnoBD</h2>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Mysql </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java相关小知识_6_15</title>
      <link href="/2018/06/15/Java_6_16/"/>
      <url>/2018/06/15/Java_6_16/</url>
      
        <content type="html"><![CDATA[<p>实体完整性要求每个表都有唯一标识符，每一个表中的主键字段不能为空或者重复的值。<br><a id="more"></a></p><p>参照完整性要求关系中不允许引用不存在的实体。设定相应的更新删除插入规则来更新参考表。</p><p>Java语言使用的是<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">HashMap不能保证元素的顺序，HashMap能够将键设为null，也可以将值设为null，与之对应的是Hashtable，(注意大小写：不是HashTable)，Hashtable不能将键和值设为null，否则运行时会报空指针异常错误。&lt;br&gt;</span><br><span class="line">HashMap线程不安全，Hashtable线程安全</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">for循环的执行顺序：&lt;br&gt;</span><br><span class="line">for(条件1;条件2;条件3) &#123;</span><br><span class="line">    //语句</span><br><span class="line">&#125;</span><br><span class="line">执行顺序是条件1-&gt;条件2-&gt;语句-&gt;条件3-&gt;条件2-&gt;语句-&gt;条件3-&gt;条件2........</span><br><span class="line">如果条件2为true，则一直执行。如果条件2位false，则for循环结束</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">java1.8后，抽象类中的抽象方法和非抽象方法在不加修饰符的情况下，都是默认的default</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">substring    方法将返回一个包含从    start    到最后（不包含    end    ）的子字符串的字符串。（左闭右开）</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">### 在为传统面向对象语言的程序做单元测试的时候,经常用到mock对象。Mock对象通过反射数。请问反射最大程度破坏了面向对象的以下哪个特性？ ：封装性</span><br><span class="line"></span><br><span class="line">mock对象：也成为伪对象，在测试中的利用mock对象来代替真实对象，方便测试的进行。&lt;br&gt;</span><br><span class="line">java的封装性：指的是将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，通过该类提供的方法实现对内部信息的操作访问。&lt;br&gt;</span><br><span class="line">反射机制：在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法;对于任意一个对象，都能够调用它的任意一个方法和属性。&lt;br&gt;</span><br><span class="line">反射破坏代码的封装性，破坏原有的访问修饰符访问限制  </span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">### try-catch-finally执行顺序&lt;br&gt;</span><br><span class="line">&gt;博文try-catch-finally执行顺序详解：http://qing0991.blog.51cto.com/1640542/1387200</span><br><span class="line">try块中抛出异常，try、catch和finally中都有return语句</span><br></pre></td></tr></table></figure></p><p>public static int WithException(){</p><p>int i=10;</p><p>try{</p><p>System.out.println(“i in try block is ： “+i);</p><p>i = i/0;</p><p>return —i;</p><p>}</p><p>catch(Exception e){</p><p>System.out.println(“i in catch - form try block is ： “+i);</p><p>—i;</p><p>System.out.println(“i in catch block is ： “+i);</p><p>return —i;</p><p>}</p><p>finally{</p><p>System.out.println(“i in finally - from try or catch block is—“+i);</p><p>—i;</p><p>System.out.println(“i in finally block is—“+i);</p><p>return —i;</p><p>}</p><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行结果：</span><br></pre></td></tr></table></figure></p><p>============WithException==================</p><p>i in try block is ： 10</p><p>i in catch - form try block is ： 10</p><p>i in catch block is ： 9</p><p>i in finally - from try or catch block is—8</p><p>i in finally block is—7</p><p>6<br>```<br>===============================<br><br>执行顺序：</p><p>抛出异常后，执行catch块，在catch块的return的—i执行完后，并不直接返回而是执行finally，因finally中有return语句，所以，执行，返回结果6。</p><p>结论：</p><p>try块中抛出异常，try、catch和finally中都有return语句，返回值是finally中的return。</p><p>总体结论：</p><p>结论一：</p><p>return语句并不是函数的最终出口，如果有finally语句，这在return之后还会执行finally（return的值会暂存在栈里面，等待finally执行后再返回）<br>结论二：</p><p>finally里面不建议放return语句，根据需要，return语句可以放在try和catch里面和函数的最后。可行的做法有四：<br>（1）return语句只在函数最后出现一次。<br>（2）return语句仅在try和catch里面都出现。<br>（3）return语句仅在try和函数的最后都出现。<br>（4）return语句仅在catch和函数的最后都出现。<br>注意，除此之外的其他做法都是不可行的，编译器会报错</p><hr><p>Statement在JDBC中相当于SQL语句的载体<br><br>Statement—-是最基本的用法，采用字符串拼接的方式，存在注入漏洞<br><br>PreparedStatement—-对Statement中的SQL语句进行预编译，同时检查合法性，效率高<br><br>CallableStatement—接口扩展 PreparedStatement，用来调用存储过程,它提供了对输出和输入/输出参数的支持。CallableStatement 接口还具有对 PreparedStatement 接口提供的输入参数的支持。<br><br>BatchedStatement—不是标准的Statement类</p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Mysql </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库相关_6_15</title>
      <link href="/2018/06/15/sql_6_15/"/>
      <url>/2018/06/15/sql_6_15/</url>
      
        <content type="html"><![CDATA[<p>关系规范化中的删除操作异常是</p><h3>不该删除的数据被删除</h3><br><a id="more"></a><p></p><p>关系规范化中的删除操作失败是</p><h3>应该删除的数据未被删除</h3><p></p><hr><p>数据库中通常采用is NULL和is not NULL进行比较不用=等于号</p><p>插图<br>矩形框：表示实体，在框中记入实体名。<br>菱形框：表示联系，在框中记入联系名。<br>椭圆形框：表示实体或联系的属性，将属性名记入框中。对于主属性名，则在其名称下划一下划线。<br>连线：实体与属性之间；实体与联系之间；联系与属性之间用直线相连，并在直线上标注联系的类型。（对于一对一联系，要在两个实体连线方向各写1； 对于一对多联系，要在一的一方写1，多的一方写N；对于多对多关系，则要在两个实体连线方向各写N,M。)</p><hr><p>一个m：n联系转换为一个关系模式，关系的码为各实体码的组合；一个1：n联系转换为一个关系模式，关系的码为n端实体的码；一个1：1联系转换为一个关系模式，关系的码为任意一端实体的码。</p><p>满足最低程度要求的范式属于第一范式，简称1NF；在第一范式中进一步满足一些要求的关系属于第二范式，简称2NF，依次类推，还有3NF、BCNF、4NF、5NF，这些都是关系范式。对关系模式的属性间的函数依赖加以不同的限制就形成了不同的范式。这些范式是递进的，即如果是一个关系是1NF的，它比不是1NF的关系要好；同样，2NF的关系比1NF的关系要好等等，范式越高、规范化程度越高，关系模式就越好。<br>总而言之：<br>  满足第三范式（3NF）必须先满足第二范式（2NF）。满足第二范式（2NF）必须先满足第一范式（1NF）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Mysql </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库相关_6_8</title>
      <link href="/2018/06/08/sql_6_8/"/>
      <url>/2018/06/08/sql_6_8/</url>
      
        <content type="html"><![CDATA[<p>数据库的设计总体上分为6个阶段：</p><a id="more"></a><p></p><h2>1、 需求分析阶段</h2><br>    准确了解用户的需求，撰写需求说明<p></p><p></p><h2>2、概念设计阶段</h2><br>    它是整个数据库设计的关键，通过对用户需求进行综合，归纳与抽象，形成一个独立于具体DBMS的概念模型。E-R图的设计在此阶段。<p></p><p></p><h2>3、逻辑结构设计阶段</h2><br>   将概念结果转换为某个DBMS所支持的数据模型。也就是指E-R图和关系模型的转换，具体为将实体，实体的属性和实体之间的联系转换为关系模式。<p></p><p></p><h2>4、数据库物理设计阶段</h2><br>   为逻辑结果选取一个最适合应用环境的物理结构，包括存储结构和存取方法。<p></p><p></p><h2>5、数据库实施阶段</h2><br>  此阶段利用SQL语句实现逻辑结构设计和物理设计阶段的内容，包括建立数据库，编制与调试应用程序等。<p></p><p></p><h2>6、数据库运行和维护阶段</h2><br>  运行过程中不断的调整，修改和优化数据库系统。<p></p><hr><p></p><h2>聚集索引</h2><br>　　一种索引，该索引中键值的逻辑顺序决定了表中相应行的物理顺序。<br>　　聚集索引确定表中数据的物理顺序。聚集索引类似于电话簿，后者按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。　　<br>　　聚集索引对于那些经常要搜索范围值的列特别有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。聚簇索引的顺序就是数据的物理存储的顺序，叶子节点就是数据节点。物理排序只有一种，所以聚簇索引只有一种,当索引值唯一时，使用聚集索引查找特定的行也很有效率。<p></p><p></p><h2>非聚集索引</h2><br>　　一种索引，该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。<p></p><pre><code>索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块</code></pre><h3>下面的表总结了何时使用聚集索引或非聚集索引（很重要）：</h3><div class="table-container"><table><thead><tr><th>动作描述</th><th style="text-align:right">使用聚集索引</th><th style="text-align:center">使用非聚集索引</th></tr></thead><tbody><tr><td>列经常被分组排序</td><td style="text-align:right">应</td><td style="text-align:center">应</td></tr><tr><td>返回某范围内的数据</td><td style="text-align:right">应</td><td style="text-align:center">不应</td></tr><tr><td>一个或极少不同值</td><td style="text-align:right">不应</td><td style="text-align:center">不应</td></tr><tr><td>小数目的不同值</td><td style="text-align:right">应</td><td style="text-align:center">不应</td></tr><tr><td>大数目的不同值</td><td style="text-align:right">不应</td><td style="text-align:center">应</td><td></td></tr><tr><td>频繁更新的列</td><td style="text-align:right">不应</td><td style="text-align:center">应</td></tr><tr><td>外键列</td><td style="text-align:right">应</td><td style="text-align:center">应</td></tr><tr><td>主键列</td><td style="text-align:right">应</td><td style="text-align:center">应</td></tr><tr><td>频繁修改索引列</td><td style="text-align:right">不应</td><td style="text-align:center">应</td></tr></tbody></table></div><hr><p>对数据库的操作都是在事务中进行的。 </p><p></p><h2>事务</h2><br>事务是指一组相互依赖的操作行为。事务中的操作是不可分割的工作单元，由一组在业务逻辑上相互依赖的SQL语句组成，有ACID特征。 <p></p><p>Atomic（原子性）：事务中包含的操作被看做一个逻辑单元，这个逻辑单元中的操作要么全部成功，要么全部失败。 </p><p>Consistency（一致性）：只有合法的数据可以被写入数据库，否则事务应该将其回滚到最初状态。</p><p>Isolation（隔离性）：事务允许多个用户对同一个数据进行并发访问，而不破坏数据的正确性和完整性。同时，并行事务的修改必须与其他并行事务的修改相互独立。 </p><p>Durability（持久性）：事务结束后，事务处理的结果必须能够得到固化。 </p><p>数据库中有多个事务同时存在，就是事务并发，此时就不能保证事务隔离性，SQL-92定义了事务隔离级别，描述了给定事务的行为对其它并发执行事务的暴露程度，或者说是一个事务必须与其它事务进行隔离的程度。隔离级别由低到高为： </p><p>Read Uncommitted，Read Committed，Repeatable Read， Serializable<br>隔离级别越高，越能保证数据的完整性和一致性，但对并发性能的影响也越大</p><p></p><h2>DML（data manipulation language）</h2><br>       它们是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言<p></p><p></p><h2>DDL（data definition language）</h2><br>       DDL比DML要多，主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用<p></p><p></p><h2>DCL（Data Control Language）</h2><br>       是数据库控制功能。是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL<p></p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Mysql </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决连接MySQL，报错10061，系统错误5</title>
      <link href="/2018/06/04/database_3/"/>
      <url>/2018/06/04/database_3/</url>
      
        <content type="html"><![CDATA[<p>解决连接MySQL，报错10061，系统错误5</p><a id="more"></a><h2 id="解决连接MySQL，报错10061，系统错误5"><a href="#解决连接MySQL，报错10061，系统错误5" class="headerlink" title="解决连接MySQL，报错10061，系统错误5"></a>解决连接MySQL，报错10061，系统错误5</h2><p>mysql登录不上去，报错10061，百度后得，mysql服务未启动。。</p><h3 id="方法一、选择dos窗口命令行打开mysql"><a href="#方法一、选择dos窗口命令行打开mysql" class="headerlink" title="方法一、选择dos窗口命令行打开mysql"></a>方法一、选择dos窗口命令行打开mysql</h3><p>输入代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure><p>报错，如图所示。系统错误 5</p><p><a href="https://imgchr.com/i/kZHauQ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/01/24/kZHauQ.png" alt="kZHauQ.png"></a></p><hr><h3 id="方法二、手工启动"><a href="#方法二、手工启动" class="headerlink" title="方法二、手工启动"></a>方法二、手工启动</h3><p>计算机-&gt;右键-&gt;管理-&gt;计算机管理<br>找到mysql，右键启动</p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/mysql_error5_a.png" alt="这里写图片描述"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装mysql，和遇到的一些错误及解决方案</title>
      <link href="/2018/03/28/database_install/"/>
      <url>/2018/03/28/database_install/</url>
      
        <content type="html"><![CDATA[<p></p><h2>安装mysql</h2><br><a id="more"></a><p></p><p></p><h2>1、下载</h2><br>mysql-5.7.20是解压版免安装的，mysql-5.7.20下载地址：<a href="http://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">http://dev.mysql.com/downloads/mysql/</a><p></p><hr><p></p><h2>2、安装</h2><br>  解压在你喜欢的位置<p></p><hr><p></p><h2>3、配置</h2><br>  新建一个ini文件，并命名为my.ini，放置到mysql根目录下，文件内容如下<p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[mysql]  </span><br><span class="line"># 设置mysql客户端默认字符集  </span><br><span class="line">default-character-set=utf8  </span><br><span class="line">[mysqld]  </span><br><span class="line">#设置3306端口  </span><br><span class="line">port = 3306  </span><br><span class="line"># 设置mysql的安装目录  </span><br><span class="line">basedir=E:\program2\javaTool\mysql-5.7.20-winx64</span><br><span class="line"># 设置mysql数据库的数据的存放目录  </span><br><span class="line">datadir=E:\program2\javaTool\mysql-5.7.20-winx64\data</span><br><span class="line"># 允许最大连接数  </span><br><span class="line">max_connections=200  </span><br><span class="line"># 服务端使用的字符集默认为8比特编码的latin1字符集  </span><br><span class="line">character-set-server=utf8  </span><br><span class="line"># 创建新表时将使用的默认存储引擎  </span><br><span class="line">default-storage-engine=INNODB</span><br></pre></td></tr></table></figure><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/mysql_my_ini.png" alt="这里写图片描述"></p><p>注：<br>设置mysql的安装目录 basedir=<br>设置mysql数据库的数据的存放目录 datadir=<br>这两个参数改为你所解压后的文件夹的位置</p><hr><p></p><h2>4、安装mysql服务</h2><br>&lt;/h3&gt;4.1、管理员身份打开cmd.exe&lt;/h3&gt;<br>文件位置C:\Windows\System32\cmd.exe,找到右击选择管理员身份打开（重点），如果没有一管理员身份打开运行cmd.exe，会报错<p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install/Remove of the Service Denied! mysql</span><br></pre></td></tr></table></figure><p>将目录切换到你mysql安装目录的bin目录后，在cmd窗口输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld install</span><br></pre></td></tr></table></figure><p>回车运行即可。</p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/mysql_succ_insta.png" alt="这里写图片描述"></p><p></p><h3>4.2、创建data文件</h3><br>将目录切换到你mysql安装目录的bin目录后，再输入<p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --initialize -insecure --user=mysql</span><br></pre></td></tr></table></figure><p>在软件目录下生成data文件夹。mysql登录的用户名为root，密码为空</p><p>之前的my.ini中两个参数要改为自己的：<br>设置mysql的安装目录 basedir=软件安装目录<br>设置mysql数据库的数据的存放目录   datadir=软件安装目录\data<br>这两个参数改为你所解压后的文件夹的位置，否则会报错“无法初始化库文件等”如下图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld: Can&apos;t create/write to file</span><br></pre></td></tr></table></figure><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/mysql_not_craet_direc.png" alt="这里写图片描述"></p><p></p><h3>4.3 测试启动</h3><br>启动mysql服务：<p></p><p>将目录切换到你mysql安装目录的bin目录，输入 net start mysql 启动服务，OK成功。</p><p><em>4.3.1 报错</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Found option without preceding group in config file:XXX;</span><br><span class="line">Fatal error in defaults handling.</span><br></pre></td></tr></table></figure><p>原因：用记事本配置my.ini编码格式有问题，一般情况下是UTF-8编码格式，但是这里需要ANSI编码格式<br>用记事本打开my.ini文件，然后点击：文件—&gt;另存为—&gt;将编码修改为：ANSI—&gt;保存！</p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/mysql_my_ini_word.png" alt="这里写图片描述"></p><p>然后cmd窗口输入命令行启动mysql</p><p><em>4.3.2 报错</em></p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/mysql_error5.png" alt="这里写图片描述"></p><p>解决：以管理员身份来运行cmd程序来启动mysql。</p><p><em>4.3.3运行 net start mysql</em></p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/mysql_starting.png" alt="这里写图片描述"></p><p>报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务正在启动或停止中，请稍候片刻后再试一次。</span><br></pre></td></tr></table></figure></p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/mysql_start_and_stop.png" alt="这里写图片描述"></p><p>解决方法：打开任务管理器，把mysql进程关闭，再次启动mysql服务器</p><p>启动成功</p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/blog/mysql_suc_start.png" alt="这里写图片描述"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab的gui图像处理操作界面，实现重置和退出按钮功能</title>
      <link href="/2018/03/09/matlab_gui_exit/"/>
      <url>/2018/03/09/matlab_gui_exit/</url>
      
        <content type="html"><![CDATA[<p>axes控件实现了展示图片，动态txt控件实现了展示或者输入参数。<br><a id="more"></a></p><p>在gui界面右键点击“重置”pushbotton回到代码块callback，编写代码</p><p><img src="https://upload-images.jianshu.io/upload_images/6280966-2d2a35253cee4790.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/263/format/webp" alt="在这里插入图片描述"></p><p><img src="https://upload-images.jianshu.io/upload_images/6280966-6b3057eecc5c3401.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/357/format/webp" alt="在这里插入图片描述"></p><p>以下代码是实现图片和参数数字重置，是重置按钮（puttern）的功能实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function pushbutton1_Callback(hObject, eventdata, handles)</span><br><span class="line">% hObject    handle to pushbutton1 (see GCBO)</span><br><span class="line">% eventdata  reserved - to be defined in a future version of MATLAB</span><br><span class="line">% handles    structure with handles and user data (see GUIDATA)</span><br><span class="line">% 重置清空图片 美滋滋</span><br><span class="line">cla(handles.axes1,&apos;reset&apos;);</span><br><span class="line">cla(handles.axes2,&apos;reset&apos;);</span><br><span class="line">cla(handles.axes3,&apos;reset&apos;);</span><br><span class="line">cla(handles.axes4,&apos;reset&apos;);</span><br><span class="line">cla(handles.axes5,&apos;reset&apos;);</span><br><span class="line"></span><br><span class="line">% 重置清空动态txt的文字 美滋滋</span><br><span class="line">set(handles.edit1,&apos;string&apos;,&apos;&apos;)</span><br><span class="line">set(handles.edit2,&apos;string&apos;,&apos;&apos;)</span><br><span class="line">set(handles.edit3,&apos;string&apos;,&apos;&apos;)</span><br><span class="line">set(handles.edit4,&apos;string&apos;,&apos;&apos;)</span><br></pre></td></tr></table></figure></p><hr><p>退出按钮：<br>在gui界面右键点击“退出”pushbotton回到代码块callback，编写代码<br>即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Matlab </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eclipse在主题商城下载安装黑色主题</title>
      <link href="/2018/03/08/eclipse_black_theme/"/>
      <url>/2018/03/08/eclipse_black_theme/</url>
      
        <content type="html"><![CDATA[<p>eclipse在主题商城下载安装黑色主题<br><a id="more"></a></p><p>Eclipse配置黑色主题方法：</p><h2 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h2><p>借用国外一个Elipse主题网站分享的主题配置文件来配置一个黑色的主题.</p><p><a href="http://www.eclipsecolorthemes.org/?q=" target="_blank" rel="noopener">主题网址</a></p><p><img src="https://img-blog.nos-eastchina1.126.net/EC_theme1.png" alt=""></p><h2 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h2><p>在这个网站下载自己喜欢的主题,单击主题进入下载页面,建议大家选择EPF格式的进行下载.</p><p><img src="https://img-blog.nos-eastchina1.126.net/EC_theme2.png" alt=""></p><h2 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h2><p>下载好之后打开Eclipse,单击File菜单下的Import选项</p><p><img src="https://img-blog.nos-eastchina1.126.net/EC_theme3.png" alt=""></p><h2 id="4、"><a href="#4、" class="headerlink" title="4、"></a>4、</h2><p>在弹出的窗口中,点击General下面的Preferences选项,然后点击Next<br><img src="https://img-blog.nos-eastchina1.126.net/EC_theme4.png" alt=""></p><h2 id="5、"><a href="#5、" class="headerlink" title="5、"></a>5、</h2><p>单击Browse选择你下载的EPF配置文件,然后点击Finish</p><p><img src="https://img-blog.nos-eastchina1.126.net/EC_theme5.png" alt=""></p><h2 id="6、"><a href="#6、" class="headerlink" title="6、"></a>6、</h2><p>这个时候如果你如果之前选择的是Eclipse默认的主题的话,那么只有代码区变成了黑色,那么你就需要再单击windos下的Preferences选项,然后再打开General下面的Appearance,在Theme选择那个Dark主题,然后点确定就可以了.</p><p><img src="https://img-blog.nos-eastchina1.126.net/EC_theme6.png" alt=""></p><p><img src="https://img-blog.nos-eastchina1.126.net/EC_theme7.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Theme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客添加背景音乐和音乐歌单(举例网易云音乐)</title>
      <link href="/2018/03/08/hexo_music_list/"/>
      <url>/2018/03/08/hexo_music_list/</url>
      
        <content type="html"><![CDATA[<p>添加背景音乐<br><a id="more"></a></p><h3 id="1、-打开网易云音乐首页，然后搜索你要添加的背景音乐"><a href="#1、-打开网易云音乐首页，然后搜索你要添加的背景音乐" class="headerlink" title="1、 打开网易云音乐首页，然后搜索你要添加的背景音乐"></a>1、 打开网易云音乐首页，然后搜索你要添加的背景音乐</h3><pre><code>    http://music.163.com/</code></pre><p><img src="https://img-blog.nos-eastchina1.126.net/163music3.png" alt=""></p><h3 id="2、-搜索到歌曲点击生成外链播放器，进去下一个界面"><a href="#2、-搜索到歌曲点击生成外链播放器，进去下一个界面" class="headerlink" title="2、 搜索到歌曲点击生成外链播放器，进去下一个界面"></a>2、 搜索到歌曲点击生成外链播放器，进去下一个界面</h3><p><img src="https://img-blog.nos-eastchina1.126.net/163music2.png" alt=""></p><h3 id="3、-复制外链播放器的代码"><a href="#3、-复制外链播放器的代码" class="headerlink" title="3、 复制外链播放器的代码"></a>3、 复制外链播放器的代码</h3><p>打开yilia主题下的_partial文件夹下的left-col.ejs文件<br>        复制文件内容到最下端</p><p><img src="https://img-blog.nos-eastchina1.126.net/163music1.png" alt=""></p><p>红线内的iframe框为复制的外链播放器代码，如图红线内，把代码放在div框<br>        例如：</p><pre><code>&lt;div style=&quot;position:absolute; bottom:120px left:auto; width:85%&quot;&gt;    &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=260 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=422428548&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;    &lt;/div&gt;</code></pre><p>这样就可以了</p><p>注：调节播放器大小，改变外链播放器的代码块，长度宽度即可<br>        width=260 height=86</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> yilia </tag>
            
            <tag> Music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客cnzz网站访问量统计</title>
      <link href="/2018/03/08/hexo_cnzz/"/>
      <url>/2018/03/08/hexo_cnzz/</url>
      
        <content type="html"><![CDATA[<p>cnzz网站访问量统计<br><a id="more"></a></p><p>使用友盟第三方的统计插件，网址：<code>http://www.umeng.com/</code><br>进入网站先注册账号然后根据下列图片进入添加站点。<br><img src="https://img-blog.nos-eastchina1.126.net/blog_cnzz11.png" alt=""></p><p><img src="https://img-blog.nos-eastchina1.126.net/blog_cnzz12.png" alt=""></p><p><img src="https://img-blog.nos-eastchina1.126.net/blog_cnzz13.png" alt=""></p><p>添加站点，自己搭建的博客，需要统计访问量的网站(这里加入我的博客网站)，然后点击统计代码进入代码页</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog_cnzz14.png" alt=""></p><p>代码页有很多样式，我的是红框的演示，纯文字统计，简洁大方，选择其他样式也可以</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog_cnzz15.png" alt=""><br>选择样式，复制样式代码到<code>..\themes\yilia\layout\_partial</code>下的<br><code>footer.ejs</code>中加入如下代码块<code>&lt;div&gt;</code>和<code>&lt;/div&gt;</code>即可</p><p><img src="https://img-blog.nos-eastchina1.126.net/blog_cnzz16.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    里面是从CNZZ复制的代码</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>代码块<code>&lt;div&gt;</code>和<code>&lt;/div&gt;</code>一定要在<code>&lt;footer&gt;</code>和<code>&lt;/fotter&gt;</code>之间</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> yilia </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab2014a vs2015编译器解决方法</title>
      <link href="/2018/03/07/matlab_vs2015/"/>
      <url>/2018/03/07/matlab_vs2015/</url>
      
        <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><a id="more"></a><p>前提：<br>电脑已经安装<br>1、Matlab版本2014a<br>2、VS版本2015</p><p>目标：<br>结合Matlab和VS2015，实现Matlab的GUI文件和.m文件转化为.exe文件，然后可以单独运行.exe文件</p><p>首先在Matlab命令行输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mbuild -setup</span><br></pre></td></tr></table></figure></p><p>报错红色，显示没有选择项，此处没有截图不直观<br>我猜测可能是matlab2014a的破解不完全</p><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>下载资源链接：<a href="https://pan.b链aidu.com/s/1hoDxMKFU2l-3ZhTObFetCw" target="_blank" rel="noopener">https://pan.b链aidu.com/s/1hoDxMKFU2l-3ZhTObFetCw</a> </p><p>密码：vdlq</p><p>然后替换文件</p><p>附件下面的将<code>mexopts/</code>下的<code>msvc2015.xml</code>和<code>msvcpp2015.xml</code><br><br>复制到<code>Matlab</code>目录下的<code>bin/win64/mexopts</code>下就可以了</p><p>首先在Matlab命令行输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mbuild -setup</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.nos-eastchina1.126.net/VS2015_1.png" alt="原始效果"></p><p>然后输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mex -setup</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.nos-eastchina1.126.net/VS2015_2.png" alt="原始效果"></p><p>选项都选择C++的就哦了</p>]]></content>
      
      
      
        <tags>
            
            <tag> Matlab </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决方案matlab2014a破解不完全，报错Test checkout of feature &#39;Compiler&#39; failed</title>
      <link href="/2018/03/07/matlab_exe/"/>
      <url>/2018/03/07/matlab_exe/</url>
      
        <content type="html"><![CDATA[<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><a id="more"></a><p>报错情况： 目标是把<code>.m</code>文件转化为<code>.exe</code>文件，先运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mcc -m</span><br></pre></td></tr></table></figure><p>你的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">后缀</span><br><span class="line"></span><br><span class="line">如果报错</span><br></pre></td></tr></table></figure></p><p>Test checkout of feature ‘Compiler’ failed<br>``` <br>是因为你的matlab2014a破解不完全。<br>前提是你的电脑已经安装好了VS编译器</p><p>2014a的解决办法：<br><br>下载资源：ht链tps://pan.baidu.com/s/1KNZqVqxMx6f接IaxQULAIq_g<br><br>密码：cti0</p><p>下载后解压，把install.jar以及相应位数的三个文件（compiler.dll，mcc.exe，libmwservices.dll）复制到对应位置替换即可。<br><br>在matlab安装目录下搜索到文件然后替换，保险起见先把要替换的文件剪切出来，实际上我的操作是成功的，万一万一万一不成功还能复原回去</p><p>另外把license.lic改为与MATLAB\licenses文件夹下的那个lic文件同名，复制并替换之。<br><br>如图所示，我把需要替换的文件都拿了出来，其中license文件是绑定了你的电脑名称，所以需要把新文件改名</p><p><img src="http://p3qhnc0eg.bkt.clouddn.com/VSjietu.png" alt="原始效果"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Matlab </tag>
            
            <tag> GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库Mysql_约束</title>
      <link href="/2018/03/04/database_2/"/>
      <url>/2018/03/04/database_2/</url>
      
        <content type="html"><![CDATA[<p>数据库约束<br><a id="more"></a></p><h2 id="数据库约束"><a href="#数据库约束" class="headerlink" title="数据库约束"></a>数据库约束</h2><h3 id="1-1-默认值约束-default"><a href="#1-1-默认值约束-default" class="headerlink" title="1.1 默认值约束(default)"></a>1.1 默认值约束(default)</h3><h3 id="1-2-非空约束-not-null"><a href="#1-2-非空约束-not-null" class="headerlink" title="1.2 非空约束( not null )"></a>1.2 非空约束( not null )</h3><h3 id="1-3-唯一约束-unique"><a href="#1-3-唯一约束-unique" class="headerlink" title="1.3 唯一约束(unique)"></a>1.3 唯一约束(unique)</h3><pre><code>CREATE TABLE test(id INT  UNIQUE ,-- 唯一NAME VARCHAR(20) NOT NULL, -- 非空gender VARCHAR(2) DEFAULT &#39;男&#39; -- 默认值约束);</code></pre><h3 id="1-4-主键约束-primary-key-作用-非空-唯一约束"><a href="#1-4-主键约束-primary-key-作用-非空-唯一约束" class="headerlink" title="1.4 主键约束(primary key 作用:非空+唯一约束)"></a>1.4 主键约束(primary key 作用:非空+唯一约束)</h3><h3 id="1-5-自增长约束-auto-increment"><a href="#1-5-自增长约束-auto-increment" class="headerlink" title="1.5 自增长约束(auto_increment)"></a>1.5 自增长约束(auto_increment)</h3><pre><code>CREATE TABLE test2(    id INT  PRIMARY KEY AUTO_INCREMENT,-- 非空+唯一约束+自增长约束    NAME VARCHAR(20) ,    gender VARCHAR(2) ,);</code></pre><h3 id="1-6-外键约束-属于数据库中表的设计"><a href="#1-6-外键约束-属于数据库中表的设计" class="headerlink" title="1.6 外键约束(属于数据库中表的设计)"></a>1.6 外键约束(属于数据库中表的设计)</h3><h3 id="1-6-1-外键约束-约束两个或者两个以上的表的数据，一般情况有两种表-主表-副表"><a href="#1-6-1-外键约束-约束两个或者两个以上的表的数据，一般情况有两种表-主表-副表" class="headerlink" title="1.6.1 外键约束:约束两个或者两个以上的表的数据，一般情况有两种表(主表,副表)"></a>1.6.1 外键约束:约束两个或者两个以上的表的数据，一般情况有两种表(主表,副表)</h3><pre><code>DROP TABLE employee2DELETE FROM employee2SELECT * FROM employee2SELECT * FROM dept</code></pre><h3 id="1-6-2-员工表"><a href="#1-6-2-员工表" class="headerlink" title="1.6.2 员工表"></a>1.6.2 员工表</h3><pre><code>CREATE TABLE employee2(    id INT PRIMARY KEY AUTO_INCREMENT,    NAME VARCHAR(20),    deptId INT,    -- 添加外键约束    CONSTRAINT employee_dept_fk FOREIGN KEY (deptId) REFERENCES dept(id)--     声明         外键名称    外键    被约束的字段  关联     部门表中id的字段);INSERT INTO employee2 (NAME,deptId) VALUES(&#39;张三&#39;,1) ;INSERT INTO employee2 (NAME,deptId) VALUES(&#39;李四&#39;,2) ;INSERT INTO employee2 (NAME,deptId) VALUES(&#39;王五&#39;,1) ;INSERT INTO employee2 (NAME,deptId) VALUES(&#39;陈六&#39;,1) ;</code></pre><p>可以设计一个独立的表-部门表 专门用来存储部门名称,来解决数据冗余的问题</p><h3 id="1-6-3-部门表-主表-约束别人的表"><a href="#1-6-3-部门表-主表-约束别人的表" class="headerlink" title="1.6.3 部门表(主表,约束别人的表)"></a>1.6.3 部门表(主表,约束别人的表)</h3><pre><code>CREATE TABLE dept(    id INT PRIMARY KEY AUTO_INCREMENT ,    NAME VARCHAR(20) -- 部门名称);</code></pre><h4 id="插入几个部门名称"><a href="#插入几个部门名称" class="headerlink" title="插入几个部门名称"></a>插入几个部门名称</h4><pre><code>INSERT INTO dept (NAME) VALUES (&#39;软件开发部&#39;) ;INSERT INTO dept (NAME) VALUES (&#39;软件维护部&#39;) ;</code></pre><h4 id="给员工表中插入数据"><a href="#给员工表中插入数据" class="headerlink" title="给员工表中插入数据"></a>给员工表中插入数据</h4><pre><code>INSERT INTO employee2 (NAME,deptId) VALUES(&#39;王五&#39;,1) ;INSERT INTO employee2 (NAME,deptId) VALUES(&#39;陈六&#39;,1) ;INSERT INTO employee2 (NAME,deptId) VALUES(&#39;李四&#39;,2) ;</code></pre><h4 id="给部门表添加数据"><a href="#给部门表添加数据" class="headerlink" title="给部门表添加数据"></a>给部门表添加数据</h4><pre><code>INSERT INTO dept (id,NAME) VALUES(3,&#39;硬件开发部&#39;);</code></pre><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><pre><code>UPDATE employee2 SET deptId = 3 WHERE id = 3;</code></pre><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><pre><code>DELETE FROM employee2 WHERE id =2;</code></pre><h3 id="1-7-补充"><a href="#1-7-补充" class="headerlink" title="1.7 补充"></a>1.7 补充</h3><p>—常遇到字段类型:</p><h4 id="1-char-20-vs-varchar-20"><a href="#1-char-20-vs-varchar-20" class="headerlink" title="1)char(20) vs varchar(20)"></a>1)char(20) vs varchar(20)</h4><blockquote><p>char(20):是一个固定长度的字符串,存储字符串内容,一定是20个字符串。<br><br>varchar(20):可变的字符串长度,实际存储的时候是根据当前实际的字符串长度</p></blockquote><p>DROP TABLE test ;</p><h4 id="2-int-和int-4"><a href="#2-int-和int-4" class="headerlink" title="2) int 和int(4)"></a>2) int 和int(4)</h4><blockquote><p>int:默认的长度11位,再存储数值类型的时候,存储实际长度<br><br>int(4):固定长度</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>必备软件（电脑、手机）</title>
      <link href="/2018/03/04/SoftAPP/"/>
      <url>/2018/03/04/SoftAPP/</url>
      
        <content type="html"><![CDATA[<p>电脑必备软件<br><a id="more"></a><br>电脑软件</p><h2 id="安全及系统工具："><a href="#安全及系统工具：" class="headerlink" title="安全及系统工具："></a>安全及系统工具：</h2><h3 id="火绒安全"><a href="#火绒安全" class="headerlink" title="火绒安全"></a>火绒安全</h3><p><a href="https://www.huorong.cn/" target="_blank" rel="noopener">https://www.huorong.cn/</a><br>内存占用少，界面干净简洁，功能恰到好处</p><h3 id="桌面日历"><a href="#桌面日历" class="headerlink" title="桌面日历"></a>桌面日历</h3><p><a href="http://chs.desktopcal.com/chs/" target="_blank" rel="noopener">http://chs.desktopcal.com/chs/</a></p><p>在桌面上双击鼠标即可开始记录琐事。非常方便，非常实用。</p><h3 id="everything"><a href="#everything" class="headerlink" title="everything"></a>everything</h3><p><a href="https://www.voidtools.com/" target="_blank" rel="noopener">https://www.voidtools.com/</a><br>快速查找文件，受够了非常慢的微软自带的搜索</p><h3 id="Listary"><a href="#Listary" class="headerlink" title="Listary"></a>Listary</h3><p><a href="https://www.listary.com/" target="_blank" rel="noopener">https://www.listary.com/</a><br>只需要双击 Ctrl 键，即可调出搜索框，可以搜索文件或者快速打开软件</p><h3 id="f-lux"><a href="#f-lux" class="headerlink" title="f.lux"></a>f.lux</h3><p>电脑屏幕调节软件，当你看电脑时间过长，可以调整为护眼模式。还可以根据你所在的城市自动调节色亮度。现在win10自带护眼模式</p><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h3><p>界面非常干净，操作简单，谷歌账户可以同步书签。Chrome的核心功能——扩展程序，高效使用电脑，缺点是占内存偏大</p><h2 id="视频播放器"><a href="#视频播放器" class="headerlink" title="视频播放器"></a>视频播放器</h2><h3 id="PotPlayer"><a href="#PotPlayer" class="headerlink" title="PotPlayer"></a>PotPlayer</h3><p>启动速度快，占内存比大多数视频播放软件都小。功能还强大，支持逐帧播放，多倍数播放…等</p><hr><p>手机软件</p><h3 id="CS全能扫描王"><a href="#CS全能扫描王" class="headerlink" title="CS全能扫描王"></a>CS全能扫描王</h3><p>扫描纸质文件变身电子档，非常好用</p><h3 id="酷安市场"><a href="#酷安市场" class="headerlink" title="酷安市场"></a>酷安市场</h3><p>除了手机自带的手机应用商店，酷安常有一些比较新奇好玩的新软件</p><h3 id="讯飞输入法"><a href="#讯飞输入法" class="headerlink" title="讯飞输入法"></a>讯飞输入法</h3><p>平板手机都可以用，语音秒变文字，还可以识别方言</p><h3 id="微博国际版"><a href="#微博国际版" class="headerlink" title="微博国际版"></a>微博国际版</h3><p>少了很多广告，界面简介了不少</p>]]></content>
      
      
      
        <tags>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库Mysql_3_4</title>
      <link href="/2018/03/04/database_1/"/>
      <url>/2018/03/04/database_1/</url>
      
        <content type="html"><![CDATA[<p>mysql常用命令<br><a id="more"></a></p><h2 id="一、-mysql常用命令"><a href="#一、-mysql常用命令" class="headerlink" title="一、 mysql常用命令"></a>一、 mysql常用命令</h2><h3 id="1-1-管理"><a href="#1-1-管理" class="headerlink" title="1.1 管理"></a>1.1 管理</h3><pre><code>CREATE DATABASE Aoman_OS -- 创建数据库USE  Aoman_OS -- 使用数据库DROP DATABASE Aoman_OS  -- 删除数据库</code></pre><h3 id="1-2-数据库内容"><a href="#1-2-数据库内容" class="headerlink" title="1.2 数据库内容"></a>1.2 数据库内容</h3><pre><code>CREATE TABLE employee(  -- 创建数据库表格id INT,NAME VARCHAR(20),gender VARCHAR(2),title VARCHAR(10),email VARCHAR(20));SELECT * FROM employee -- 查看数据库表格</code></pre><h3 id="2-1-增加数据库内容"><a href="#2-1-增加数据库内容" class="headerlink" title="2.1 增加数据库内容"></a>2.1 增加数据库内容</h3><pre><code>INSERT INTO employee VALUES(1,&#39;依依&#39;,&#39;女&#39;,&#39;程序员鼓励师&#39;,&#39;123@163.com&#39;);INSERT INTO employee VALUES(2,&#39;尔尔&#39;,&#39;男&#39;,&#39;程序开发工程师&#39;,&#39;124@163.com&#39;);INSERT INTO employee VALUES(3,&#39;散散&#39;,&#39;男&#39;,&#39;程序维护工程师&#39;,&#39;125@163.com&#39;);</code></pre><h3 id="2-2-插入部分数据"><a href="#2-2-插入部分数据" class="headerlink" title="2.2 插入部分数据"></a>2.2 插入部分数据</h3><pre><code>    INSERT INTO employee (id,NAME) VALUES (4,&#39;思思&#39;);</code></pre><h3 id="2-3-修改数据"><a href="#2-3-修改数据" class="headerlink" title="2.3 修改数据"></a>2.3 修改数据</h3><pre><code>UPDATE employee SET gender=&#39;女&#39;,title=&#39;文秘&#39; WHERE id =4;</code></pre><h3 id="2-4-删除表中所有数据"><a href="#2-4-删除表中所有数据" class="headerlink" title="2.4 删除表中所有数据"></a>2.4 删除表中所有数据</h3><pre><code>DELETE     * FROM employee</code></pre><h3 id="2-5-删除数据表"><a href="#2-5-删除数据表" class="headerlink" title="2.5 删除数据表"></a>2.5 删除数据表</h3><pre><code>DROP FROM employee</code></pre><h3 id="3-1-查询"><a href="#3-1-查询" class="headerlink" title="3.1 查询"></a>3.1 查询</h3><pre><code>SELECT id AS &#39;1&#39; FROM employeeSELECT id AS &#39;1&#39; ，NAME AS &#39;尔尔&#39; FROM employee</code></pre><h3 id="3-2-不重复的查询"><a href="#3-2-不重复的查询" class="headerlink" title="3.2 不重复的查询"></a>3.2 不重复的查询</h3><pre><code>SELECT DISTINCT email FROM employee</code></pre><h3 id="3-3-条件查询"><a href="#3-3-条件查询" class="headerlink" title="3.3 条件查询"></a>3.3 条件查询</h3><pre><code>SELECT * FROM employee WHERE id=1 OR NAME = &#39;思思&#39; ; -- or 并集SELECT * FROM employee WHERE id=1 AND NAME = &#39;思思&#39; ; -- and 交集</code></pre><h3 id="3-4-判断查询"><a href="#3-4-判断查询" class="headerlink" title="3.4 判断查询"></a>3.4 判断查询</h3><pre><code>大于 &gt; ,小于 &lt; ,等于 = 不等于 ！= 或者 &lt;&gt;， 在什么之间 between 1 and 2，非空 isnot null 或者 不等于 &#39;&#39;</code></pre><h3 id="3-5-模糊查询"><a href="#3-5-模糊查询" class="headerlink" title="3.5 模糊查询"></a>3.5 模糊查询</h3><pre><code>SELECT * FROM studet WHERE NAME LIKE &#39;思%&#39;%代替任何字符，任何长度的字符-仅仅代替一个字符</code></pre><h3 id="3-6-asc-升序-desc-降序"><a href="#3-6-asc-升序-desc-降序" class="headerlink" title="3.6 asc 升序 desc 降序"></a>3.6 asc 升序 desc 降序</h3><pre><code>默认情况下:是按照插入顺序进行排序SELECT * FROM student ORDER BY id ASC ;需求:servlet成绩是一个降序排序SELECT * FROM student ORDER BY servlet DESC ;</code></pre><h2 id="二、小练习"><a href="#二、小练习" class="headerlink" title="二、小练习"></a>二、小练习</h2><pre><code>CREATE TABLE student2(    id INT,    NAME VARCHAR(20),    chinese FLOAT,    english FLOAT,    math FLOAT);INSERT INTO student2(id,NAME,chinese,english,math) VALUES(1,&#39;张小明&#39;,89,78,90);INSERT INTO student2(id,NAME,chinese,english,math) VALUES(2,&#39;李进&#39;,67,53,95);INSERT INTO student2(id,NAME,chinese,english,math) VALUES(3,&#39;王五&#39;,87,78,77);INSERT INTO student2(id,NAME,chinese,english,math) VALUES(4,&#39;李一&#39;,88,98,92);INSERT INTO student2(id,NAME,chinese,english,math) VALUES(5,&#39;李来财&#39;,82,84,67);INSERT INTO student2(id,NAME,chinese,english,math) VALUES(6,&#39;张进宝&#39;,55,85,45);INSERT INTO student2(id,NAME,chinese,english,math) VALUES(7,&#39;黄蓉&#39;,75,65,30)</code></pre><h4 id="查询操作练习-在学生表数据基础上：student-sql"><a href="#查询操作练习-在学生表数据基础上：student-sql" class="headerlink" title="查询操作练习(在学生表数据基础上：student.sql)"></a>查询操作练习(在学生表数据基础上：student.sql)</h4><p>—     查询表中所有学生的信息。</p><pre><code>SELECT * FROM student2 ;</code></pre><p>— 查询表中所有学生的姓名和对应的英语成绩。</p><pre><code>SELECT  NAME ,english FROM student2</code></pre><p>—     使用别名表示学生分数。</p><pre><code>SELECT id AS &#39;编号&#39;,NAME AS &#39;姓名&#39;,chinese AS &#39;语文&#39;,english AS &#39;英语&#39;,math AS &#39;数学&#39; FROM student2 ;</code></pre><p>—     查询姓名为李一的学生成绩</p><pre><code>SELECT * FROM student2 WHERE NAME = &#39;李一&#39;;</code></pre><p>—     查询英语成绩大于等于90分的同学</p><pre><code>SELECT * FROM student2 WHERE english &gt;=90</code></pre><p>—     查询总分大于200分的所有同学</p><pre><code>SELECT * FROM student2 WHERE (chinese+english+math)&gt;200;</code></pre><p>—     查询所有姓李的学生英语成绩。</p><pre><code>SELECT NAME,english FROM student2 WHERE NAME LIKE &#39;李%&#39;</code></pre><p>—     查询英语&gt;80或者总分&gt;200的同学</p><pre><code>SELECT * FROM student2 WHERE english &gt;80 OR (chinese+english+math)&gt;200;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提升生活品质、舒缓心情的小事</title>
      <link href="/2018/03/04/15things/"/>
      <url>/2018/03/04/15things/</url>
      
        <content type="html"><![CDATA[<p>提升生活品质、舒缓心情的小事<br><a id="more"></a></p><h2 id="1．扔掉用处不大且闲置很久鸡肋东西。"><a href="#1．扔掉用处不大且闲置很久鸡肋东西。" class="headerlink" title="1．扔掉用处不大且闲置很久鸡肋东西。"></a>1．扔掉用处不大且闲置很久鸡肋东西。</h2><p>很多东西我们都以为有一些用处，或者还能用，舍不得扔掉，但是它是食之无味弃之无用的“鸡肋东西”，这些东西占据着我们居住的空间，如果不能压箱底，还要碍事在眼前晃悠。</p><p>定期清理卫生，弃置一些鸡肋东西，提高居住空间大小，会使我们的心情愉悦，压力得到释放。重点在于清理卫生，一个干净的居住环境就像吃了一顿美味的午餐，轻松且愉悦，一周打扫至少3次。</p><p>打扫卫生的过程中会找到之前找不到的物件或者有惊喜发生。每次看到干净整洁的地板与桌面，真得心情大好。</p><p>2．认真地读一个故事。</p><p>我知道让很多人静下心来读完一本书挺难的，那么，就退而求其次，用心地读一个故事吧。</p><p>短篇集或散文集是个不错的选择。</p><p>我最近在读汪曾祺的短篇集，差不多一天读一个故事。</p><p>慢慢读，用心读，说实话，感觉汪曾祺的文字很有意思！</p><p>3．好好睡一觉。</p><p>别笑，我是认真的。据我所知，很多人每天都喊着要早睡要早睡，可就是抱着手机不肯放下。</p><p>那天晚上，我哄小朋友睡觉时，不知不觉把自己也哄睡了，小朋友一般十点左右睡。</p><p>通常他睡着后，我会爬起来再忙一会儿，码字、洗衣服或者看会儿书，通常会折腾到12点。</p><p>那天大概因为太困，我竟然一觉睡到天亮，早上起床时才发现自己睡了九个小时，那种感觉，真的很解乏。</p><p>4．买一束花。</p><p>老秦向来觉得，买花不如买肉夹馍。肉夹馍能吃，花却只能看，还没几天就枯萎了。</p><p>那天买了两枝向日葵，竟然开了好几天，那几天，只要看到那抹金黄色，我的心情就很灿烂！</p><p>15块钱一周的好心情，我是觉得超划算。（再次暴露了，我不太买花的事实）</p><p>5．经常整理房间！</p><p>有时候心情不好，可能是你的书桌或者你周围的环境太乱了。</p><p>这时候不妨停下工作，拿起抹布或拖把，大干一场吧。</p><p>连沙发底下、床底下等各种犄角旮旯都收拾一下。当窗明几净，屋内整整齐齐，心情也会亮堂起来。</p><p>6．听一首老歌。</p><p>不是每个人都能像赵医生一样欣赏古典音乐，那就听听老歌吧，张学友、黄小琥、蔡琴、周华健……</p><p>在悠扬的韵律中慢慢晃动身体，或者就是懒懒地窝在沙发上，心情真的会很好。</p><p>7．出一身臭汗。</p><p>跑步、跳绳、虐腹。疯狂地出一身汗，然后再美美地洗个澡，心情瞬间好到爆棚。</p><p>8．放下手机放下手机。</p><p>放下一会儿手机，真的不会错过什么。</p><p>晚一点回复消息，也不会错过八百万的生意。所以，不妨让手机和你都休息一会儿。</p><p>放下手机还有个好处，你会发现，突然多了很多时间。</p><p>一个经常打手游的朋友最近因为眼睛问题，不太玩手机了。</p><p>他说，忽然觉得时间多了起来。真的是忽然！！</p><p>用这些多出来的时间去做些有意义的事情吧。</p><p>9．偶尔叫个外卖。</p><p>天天在柴米油盐中烦不胜烦？</p><p>偶尔给自己放假，叫个外卖吧，或者去找一家不错的苍蝇馆子，美美地吃一通。</p><p>如果有小朋友，带上野餐垫去野餐，也是个超级棒的选择。</p><p>10．敷个面膜。</p><p>以最舒服的姿势躺在沙发上，打开爱听的音乐，或者什么音乐也不开，只是很放松地躺着。</p><p>敷完面膜后，皮肤好像真的好了一些噢。</p><p>不要以为是女士专享，这招男女通用。</p><p>11．策划一条旅游线路。</p><p>打开地图，找到你最想去的地方，做个标记，开始憧憬可以做些什么。</p><p>虽然一时半会儿可能无法变成现实，但是，看一看旅游攻略，提前策划一下，也是让心情愉悦的一种方式。</p><p>12．整理照片。</p><p>把照片分门别类，不好的删掉，好的留作纪念。</p><p>可以选一些比较美好的瞬间，洗出来，做一个照片墙，每次看到温馨瞬间，都会觉得很幸福。</p><p>13．养几条金鱼。</p><p>相对来说，猫和狗都是比较可爱的宠物。</p><p>狗粘人，猫呆萌，各有各的可爱，但也各有各的麻烦，狗需要每天遛，猫需要天天换猫砂。</p><p>懒人不妨养几条漂亮的金鱼，好几天不喂也没事，再放些水藻，心情美美哒。</p><p>14．自己美甲。</p><p>偶尔自己给自己做个美甲，心情也会变得美丽起来。</p><p>这是个需要耐心的“细活儿”，你会在慢慢涂指甲的过程中，让自己的心情变得沉静。</p><p>涂完后，静等它们变干的过程，也不错呢。</p><p>15．不妨试着搞一次捐赠。</p><p>久置的衣物、书籍甚至文具，如果在七成新以上，不妨给它们找个更好的归宿。</p><p>比方捐赠给更需要的人，衣服相对容易处理，因为很多小区都会有旧衣回收箱。</p><p>书籍的话，可以考虑在朋友圈进行捐赠，对方付邮或自己付都可以。</p><p>定期或不定期地进行处理，既能让自己的空间节省了下来，又让东西有了更好的归宿，何乐而不为呢？</p><p>16 每天拍几张照片</p><p>心理学家建议，每天用相机拍下一些身边的人和事，如窗外的树木、路边的小花、邻居家的孩子和朋友的婚礼。将这些随时可能被遗忘的片段记录起来，当你不定期整理照片时，你会觉得所有的细节都是美好回忆，没什么可抱怨的，于是人会很容易变得快乐起来。</p><p>17 在林间或者水边散步</p><p>有研究指出，因为在婴儿时期便置身于羊水，因此人与生俱来就是亲水的。在水边散步，能有效地帮助人放松身心，即使烦恼再多，在有绿树有流水的环境中，你也能暂时抛开一切，为自己“偷”得片刻悠闲。</p><p>6.偶尔吃一顿大餐</p><p>吃一顿大餐的美妙在于，不仅能享受到美味可口的食物，还能让你感觉自己受到了特别礼遇。人在受到与别人不同的照顾时，心情会不知不觉地变好。我们在小时侯都可能有类似这样的经历：当父母特意为你买了一只与其他孩子不一样的、漂亮的碗，你会高高兴兴地吃下比平时多的食物，即使不爱吃的食物也变得“可爱”起来。</p><p>7.参加集体活动</p><p>虽然独处也是调节心情的方法之一，但是不要吝啬自己的休息时间，分出一部分给集体活动。登山、郊游、野餐、party、歌友会……鼓励自己积极参加集体活动，你会在共同的玩乐中找到让自己坚强、平和的力量</p>]]></content>
      
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客yilia主题_缺失模块_解决方案</title>
      <link href="/2018/02/08/hexo_3/"/>
      <url>/2018/02/08/hexo_3/</url>
      
        <content type="html"><![CDATA[<p>hexo博客yilia主题<br><a id="more"></a><br>左侧栏目有一个全部文章的按钮，刚开始开始报错缺失模块，如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/6280966-d3fb28b5a1dcb69c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/335/format/webp" alt="这里写图片描述"></p><p>我解决了这个问题着实不容易饶了弯路，但是跟着提示步骤，其实很简单，走起：</p><hr><h2 id="1、查看node版本"><a href="#1、查看node版本" class="headerlink" title="1、查看node版本"></a>1、查看node版本</h2><figure class="highlight plain"><figcaption><span>打开命令控制台，输入代码  ```node -v``` 查看node版本，如下图：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![这里写图片描述](https://upload-images.jianshu.io/upload_images/6280966-e798155edf9d3c60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/303/format/webp)</span><br><span class="line"></span><br><span class="line">只要node的版本高于6.2就行</span><br><span class="line"></span><br><span class="line">## 2、运行命令行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">博客根目录下运行命令行 ```npm i  hexo-generator-json-content --save</span><br></pre></td></tr></table></figure><p>如果这个包已经存在，会报错，图忘了截了。</p><p>但是你需要在theme文件夹的yilia主题文件夹下，找到node—modules文件夹。如果hexo-generator-json-content 这个包是存在的就OK，可以进行第三步了，见下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/6280966-7bdc3639ca05cc64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/655/format/webp" alt="这里写图片描述"></p><h2 id="3、配置文件"><a href="#3、配置文件" class="headerlink" title="3、配置文件"></a>3、配置文件</h2><p>博客根目录下，找到_config.yml，打开找一个空白地方复制一下配置信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">jsonContent:</span><br><span class="line"></span><br><span class="line">  meta: false</span><br><span class="line"></span><br><span class="line">  pages: false</span><br><span class="line"></span><br><span class="line">  posts:</span><br><span class="line"></span><br><span class="line">    title: true</span><br><span class="line"></span><br><span class="line">    date: true</span><br><span class="line"></span><br><span class="line">    path: true</span><br><span class="line"></span><br><span class="line">    text: false</span><br><span class="line"></span><br><span class="line">    raw: false</span><br><span class="line"></span><br><span class="line">    content: false</span><br><span class="line"></span><br><span class="line">    slug: false</span><br><span class="line"></span><br><span class="line">    updated: false</span><br><span class="line"></span><br><span class="line">    comments: false</span><br><span class="line"></span><br><span class="line">    link: false</span><br><span class="line"></span><br><span class="line">    permalink: false</span><br><span class="line"></span><br><span class="line">    excerpt: false</span><br><span class="line"></span><br><span class="line">    categories: false</span><br><span class="line"></span><br><span class="line">    tags: true</span><br></pre></td></tr></table></figure><h3 id="注（重点）：细节处—复制的信息格式要调好"><a href="#注（重点）：细节处—复制的信息格式要调好" class="headerlink" title="注（重点）：细节处—复制的信息格式要调好"></a>注（重点）：细节处—复制的信息格式要调好</h3><p>1、配置文件内找空白处粘贴文件</p><p>2、第一行jsonContent: - 即下图46行前没有空格</p><p>下图47、48、49行前有一个空格</p><p>剩下的有两个空格</p><p>具体格式如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/6280966-30e468dd4732ea42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p><p>保存后同步文件在看你的博客，点全部文章按钮</p><p>应该是修复了缺失模块这个报错</p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> yilia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客yilia主题_more截断文章_多标签添加</title>
      <link href="/2018/02/08/hexo_2/"/>
      <url>/2018/02/08/hexo_2/</url>
      
        <content type="html"><![CDATA[<p>以下均为自己遇到的问题并加以修改或者纠正.</p><a id="more"></a><p>在文章下方可以使用more语句进行截断，这样博客首页只会出现文章的前面一小部分，看起来很清爽简约</p><blockquote><p>或者</p><p>anguage: zh-CN</p><figure class="highlight plain"><figcaption><span>```//在需要阶段的地方插入该代码语句</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;</span><br><span class="line">&gt; aa</span><br><span class="line"></span><br><span class="line">在这里，yilia主题会判断含有`&lt;!--more--&gt;`的位置，然后文章截断两部分，第一部分展示在博客首页，第二部分即上方的aa只能点开展开全文，才能继续阅读文章。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">截断效果如下图：</span><br><span class="line"></span><br><span class="line">![效果](http://upload-images.jianshu.io/upload_images/6280966-dff71bcc18df7583.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">在这里我对yilia主题做了修改</span><br><span class="line"></span><br><span class="line">原始效果为：</span><br><span class="line"></span><br><span class="line">![原始效果](http://upload-images.jianshu.io/upload_images/6280966-2bc7446857bc04e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">修改后为：去掉了more按钮，打开文章可以点击文章或者点击展开全文</span><br><span class="line"></span><br><span class="line">![修改效果](http://upload-images.jianshu.io/upload_images/6280966-51ea736ffd940d2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">做法很简单，进入theme目录，打开yilia目录下的_config.yml文件，修改excerpt_link参数：</span><br></pre></td></tr></table></figure></blockquote><p>excerpt_link：之后的more单词换成空格<br>注：‘excerpt_link： ’。其中：后有一个空格键<br>```</p><p>修改图如下图</p><p><img src="http://upload-images.jianshu.io/upload_images/6280966-c3ec0b215421bcee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p><p>如何给文章加多个标签：</p><p>修改如下图，格式为 [tag1, tag2]</p><p>注：逗号之后要有一个空格。[tag1, tag2]= [tag1+逗号+空格+tag2]</p><p>修改如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/6280966-62305c940fee2082.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
            <tag> yilia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-github博客首页菜单中文乱码两种解决方案</title>
      <link href="/2018/02/06/hexo_1/"/>
      <url>/2018/02/06/hexo_1/</url>
      
        <content type="html"><![CDATA[<p>hexo-github博客首页菜单中文乱码两种解决方案<br><a id="more"></a></p><h2 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h2><p>菜单设置成中文显示，编辑博客根目录下的<code>_config.yml</code>文件</p><p><img src="https://upload-images.jianshu.io/upload_images/6280966-ba05e4d7b005b886.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/704/format/webp" alt="在这里插入图片描述"></p><p>设置<code>language</code>字段如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language: zh-Hans</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language: zh-CN</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6280966-9d29614e5ae7bf3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/573/format/webp" alt="这里写图片描述"></p><h1 id="lt-lt-lt-lt-lt-lt-lt-HEAD"><a href="#lt-lt-lt-lt-lt-lt-lt-HEAD" class="headerlink" title="&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</h1><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>18775685f6f00718757e97d762a03862d8046aa8</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p>取决于你的主题theme目录下的language目录下有<code>zh-Hans.yml</code>还是<code>zh-CN.yml</code><img src="https://upload-images.jianshu.io/upload_images/6280966-5ba1bdb068d647a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/676/format/webp" alt="这里写图片描述"></p><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>取决于你的主题theme目录下的language目录下有<code>zh-Hans.yml</code>还是<code>zh-CN.yml</code><img src="https://upload-images.jianshu.io/upload_images/6280966-5ba1bdb068d647a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/676/format/webp" alt="这里写图片描述"></p><p>=======</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>18775685f6f00718757e97d762a03862d8046aa8</p><h2 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h2></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p>根目录下的配置文件是_config.yml文件</p><h1 id="lt-lt-lt-lt-lt-lt-lt-HEAD-1"><a href="#lt-lt-lt-lt-lt-lt-lt-HEAD-1" class="headerlink" title="&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD"></a>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</h1><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>18775685f6f00718757e97d762a03862d8046aa8<br><img src="https://upload-images.jianshu.io/upload_images/6280966-7bd69c77ce45ca98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/704/format/webp" alt="在这里插入图片描述"><br>我们需要打开此文件，然后编辑文字。</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p>但是保存之后的格式可能跟文件本身的格式编码不一样，所以会出现乱码问题。</p><p>推荐用<code>sublime</code>，<code>VScode</code>，<code>atom</code>等文本编辑器打开，这三款开源软件写代码也很便利。<br>此处用atom文本编辑器打开编辑，保存后不会出现乱码问题了</p><p>最后效果如下：<br><img src="https://upload-images.jianshu.io/upload_images/6280966-e7aa62b4bfa64413.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/573/format/webp" alt="这里写图片描述"></p>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>米pad记事本 0828刷好lineage系统</title>
      <link href="/2018/01/10/%E8%AE%B0%E4%BA%8B18_08_28/"/>
      <url>/2018/01/10/%E8%AE%B0%E4%BA%8B18_08_28/</url>
      
        <content type="html"><![CDATA[<p>记事本</p><a id="more"></a><h3 id="18-11-20"><a href="#18-11-20" class="headerlink" title="18-11-20"></a>18-11-20</h3><p>87还是不够简约，入手凯酷84，心情大好</p><h3 id="18-10-09"><a href="#18-10-09" class="headerlink" title="18-10-09"></a>18-10-09</h3><p>红轴 贼鸥 87 舒服</p><h3 id="18-10-09-1"><a href="#18-10-09-1" class="headerlink" title="18-10-09"></a>18-10-09</h3><p>贼鸥87键 机械键盘改装，改樱桃红轴，键帽换为PBT键帽，磨砂手感，很不错</p><p><img width="800" height="800" src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/keyboard_pcb1.jpg"><br><img width="800" height="800" src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/keyboard_pcb2.jpg"><br><img width="800" height="800" src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/keyboard_pcb3.jpg"><br><img width="800" height="800" src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/keyboard_pcb4.jpg"><br><!--<img width="800" height="800" src="http://p3qhnc0eg.bkt.clouddn.com/img/blog/shangluo1.jpg"/>--></p><h3 id="18-08-28"><a href="#18-08-28" class="headerlink" title="18-08-28"></a>18-08-28</h3><p>0828平板刷好lineage系统，奈斯，大夫</p><p>  魔趣系统bug有点多，无故重启，故刷入lineage系统0811版，运行完美<br><img width="800" height="800" src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/pad/pad%20%288%29.jpg"></p><h3 id="18-07-29"><a href="#18-07-29" class="headerlink" title="18-07-29"></a>18-07-29</h3><p>  入了一款小米平板，自带系统安卓4.4.4，系统太丑，找了第三方安装包魔趣7.1，升级到安卓7，比miui流畅多了，魔趣大法好<br><img width="800" height="800" src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/pad/pad%20%281%29.jpg"><br><img width="800" height="800" src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/pad/pad%20%282%29.jpg"><br><img width="800" height="800" src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/pad/pad%20%285%29.jpg"><br><img width="800" height="800" src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/pad/pad%20%286%29.jpg"><br><img width="800" height="800" src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/pad/pad%20%287%29.jpg"></p><p><img width="800" height="800" src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/pad/pad%20%289%29.jpg"></p><h3 id="18-07-20"><a href="#18-07-20" class="headerlink" title="18-07-20"></a>18-07-20</h3><p>纪念自己做的电容笔（右），虽然丑，用着还行，但是精确度比较差，还是买了一个10块的用用。</p><p>通过香烟盒里的锡纸连接手与屏幕导电，屏幕上的电极感应，然后确定操作点击屏幕。<br><img width="800" height="800" src="http://p3qhnc0eg.bkt.clouddn.com/blog/img/pad/pad%20%284%29.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
