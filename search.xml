<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Camera ISP与DSP的区别]]></title>
    <url>%2F2020%2F06%2F05%2FISP_DSP%2F</url>
    <content type="text"><![CDATA[Camera ISP与DSP的区别在介绍Camera ISP和DSP区别前，我们先看看Camera的工作流程 拍摄景物通过镜头，将生成的光学图像投射到传感器上，然后光学图像被转换成电信号，电信号再经过模数转换变为数字信号，数字信号经过DSP加工处理，再被送到电脑中进行处理，最终转换成手机屏幕上能够看到的图像。 数字信号处理器DSP(DIGITAL SIGNAL PROCESSING)功能：主要是通过一系列复杂的数学算法运算，对数字图像信号参数进行优化处理，并把处理后的信号通过USB等接口传到PC等设备。DSP结构框架:123ISP(image signal processor)(图像信号处理器)JPEG encoder(JPEG图像解码器)USB device controller(USB设备控制器) 文章目录1 名词解释2 功能解释3 手机摄像头ISP是独立好还是内置好 名词解释ISP 是Image Signal Processor 的简称，也就是图像信号处理器。DSP是Digital Signal Processor 的缩写，也就是数字信号处理器。功能解释ISP一般用来处理Image Sensor（图像传感器）的输出数据，如做AEC（自动曝光控制）、AGC（自动增益控制）、AWB（自动白平衡）、色彩校正、Lens Shading、Gamma 校正、祛除坏点、Auto Black Level、Auto White Level 等等功能的处理。DSP功能就比较多了，它可以做些拍照以及回显（JPEG的编解码）、录像以及回放（Video 的编解码）、H.264的编解码、还有很多其他方面的处理，总之是处理数字信号了。个人认为ISP是一类特殊的处理图像信号的DSP。手机摄像头ISP是独立好还是内置好ISP是独立还是内置，对最终拍照效果并没有决定性影响，并不像PC上的独立显卡与集成显卡有那么大差异。从性能上看，这一代高通处理器内置的ISP性能已经可以跟富士通的独立ISP媲美。而各家ISP的主要处理流程都是类似的，差异也只是在于部分模块有优劣之分，比如去噪、色彩增强等。进一步来说，即便用了独立ISP，它毕竟是一个外部组件，也有可能会因为调试过程复杂，开发周期过短，开发人员难以驾驭，使得最终效果并不特别理想。真正影响整个相机拍照效果的，还是调试，看工程师能否发挥出一块ISP真正实力。例如对ISP里面每个算法模块的优化，相关多个模块的配合等等。我们从产品上来看，有很多即便用了独立ISP，但成像效果也依然不尽人意的，也有很多虽然用了内置ISP，成像效果居然很不错的。所以这个问题，需要辩证的来看，而非依照参数配置论来粗暴的进行理解。 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鱼眼摄像机及鱼眼畸变矫正（挖坑）]]></title>
    <url>%2F2020%2F06%2F05%2FISP_FishEye%2F</url>
    <content type="text"><![CDATA[鱼眼摄像机及鱼眼畸变矫正(挖坑) 一、鱼眼摄像机鱼眼摄像机即是搭配了鱼眼镜头的摄像机，鱼眼镜头是一种超广角的特殊镜头，其构造仿照鱼类眼睛成像，是可以独立实现大范围无死角监控的摄像机。我们知道鱼类眼睛与人眼构造类似，但是其水晶体为圆球形，人眼为扁圆形，鱼类虽然只能看到较近处的物体，但是却拥有了更广阔的视角，其视角甚至可达180°；具备同样特性的鱼眼摄像机通过吸顶安装，可视范围可达到360°，可监控大范围场景中的所有物体，所以也被称为全景摄像机。 图1 鱼眼 图2 鱼眼镜头 二、鱼眼摄像机技术难点光学畸变严重：鱼眼摄像机具备超广角，可凭借少量的设备实现大范围场景全面监控。但相对的，过大的视角带来更加严重的光学畸变（画面甚至已呈圆形），图像失真较严重；需要设备对原始图像做矫正后，其效果才会被用户接受。 细节表现不足：大场景监控及较小的焦距及景深，导致鱼眼摄像机对远处场景看的不是很清楚。为此需要工程师们采用高分辨率传感器，保证目标物体有更多的像素来表现；同时尽可能的提升鱼眼镜头的性能，提供比传统摄像机更佳的景深范围，以提升较远处物体清晰度。 三、畸变矫正挖坑 [参考] http://www.tpy888.cn/news/201507/06/83029.html 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强光抑制算法研究]]></title>
    <url>%2F2020%2F05%2F16%2FISP_HLC%2F</url>
    <content type="text"><![CDATA[强光抑制算法研究 强光抑制功能 在夜间由于视线问题，视野范围大大减少，醉酒驾车、闯红灯问题时有发生，如何减少交通事故的发生，道路监控在这方面有着很大的帮助。但同样的问题，夜晚则是考验监控设备的时候，如何能更清楚的监控道路车辆，对于减少交通事故能够起到很大的帮助。 而强光抑制功能则是道路监控必不可少的功能之一，它的作用非常大，笔者简单介绍一些该技术。强光抑制技术能够有效抑制强光点直接照射造成的光晕偏大，视频图像模糊，自动分辨强光点，并对强光点附近区域进行补偿以获得更清晰的图像。其作用是有效抑制迎面的强光，在夜间监控道路车辆时，能较清晰的捕捉车辆车牌。适用于收费站、停车场出路口等区域。 可能单纯的概念不足以证实这个功能，下面让大家通过一组图片来了解一下，通过两幅图片的对比，大家能够清楚的认识到该功能的作用，对于漆黑的夜晚，具备这样功能的监控设备一样可以很少的处理灯光问题，保证视频画面的清晰度。 强光抑制功能对比 强光抑制算法研究在收费站、停车场等路口区域，夜晚车灯开启后，要获取更好的车辆信息，就需要对强光抑制。夜间明亮区域会曝光过度，较暗的区域会曝光不足，整幅图像在一个较窄的动态范围内，强光抑制算法是采用 DSP 技术，把强光部分弱化，使暗光部分变亮，达到光线平衡。强光抑制技术可以有效抑制强光点直接照射造成的光晕偏大，视频图像模糊，分辨出强光点并对强光附近的区域进行补偿，获得更清晰的图像。 一个好的强光抑制滤波处理芯片关键部分是强光抑制处理算法，常用的强光抑制处理算法有，背光补偿方式，白峰反转方式和扩展动态范围方式。 背光补偿方式：在图像预处理阶段进行背光补偿处理，保证每次都能正确的曝光，通过检测子区域的平均讯号确定 AGC 电路的增益值，改善视场的可视性。 白峰反转方式：拍摄避光状态或拍摄亮度值差较大的对象时，舍弃高亮度部分画面的情况，这种方式不能获取整幅场景的细节。 扩展动态范围的方式：动态范围是一个信号系统的最大值与最小值之间的比例，对一个实际场景来说，动态范围是这个场景中最亮的光辐射度和最暗的光辐射度之比 动态范围指摄像机色彩正好饱和的亮度同背景噪声提高一个标准差的亮度的比值，在摄影领域里面动态范围就是两个亮度的比值。 图像传感器的动态范围定义为： a=20lg(I_min/I_max)$I_min$和 $I_max$ 是 CCD 线性检测到的入射光的最小和最大光强，单位流明(lm)，若用光照度表示动态范围，可定义为： a=20lg(E_min/E_max)$$ (5.18) $E$ 为图像传感器像素的光照度，单位勒克斯 (lx) ，控制图像效果的曝光量EV(Exposure Value)与光强、光照度之间的关系为： (5.19) 自然环境的动态范围常在 100dB 以上，一般摄像机拍摄图像的对比度为几十分贝值。 现阶段，进行图像动态范围扩展，主要在软件算法上扩展动态范围。 选择合适的图像处理方法扩展动态范围，对同一场景连续采集多次，然后利用数字图像处理算法对图像进行合成，达到扩展动态范围的目的，提高图像信噪比，进一步增强图像。 ### 线性扩展算法进行强光抑制 韦伯(Weber)定律指出人们能够觉察到的光强度差别与背景光强度有关，举个例子说明这种关系，在亮度较强的屋子里点一根蜡烛，几乎发现不了蜡烛的存在；若将这根蜡烛移到黑暗的屋子里面，蜡烛就会很明显。由人眼睛视觉和心理特性可知，变换幅度大和细节丰富的区域更容易引起人眼的注意，变化平坦的区域不易引起人的注意，依据人眼睛的灰度特性，处理灰度图像时，对占有范围较窄的低灰度级和高灰度级区域，将它们的灰度间隔拉伸；适当压缩间隔较大的中等灰度区域，并把剩余的灰度级分配给那些需要扩展的高灰度级区域或低灰度级区域。 多幅图像扩展线性动态范围，在图像处理前，选择不同的快门来拍摄图像，在线性动态范围扩展中，选择不同图片中相同位置的图像细节信息，并把它们组成一帧新的图像，最简单的处理方法是是将图像相加求平均，但是处理的图像范围很窄，。研究中，选择了一种和人眼最匹配的线性扩展算法，从两幅图像的相同位置取灰度值$g1(x,y)$、$g2(x,y)$，进行线性加权合成图像$gf(x,y)$： $$gf(x,y)=a_1*g1(x,y) +a2*g2(x,y)其中 $a1$，$a2$是 $g1(x,y)$和 $g2(x,y)$的权值，理论研究证明人的眼睛对图像灰度敏感区域是 32-192 之间，因此进行图像处理时设定两个边界值 $Tmin$=32，$Tmax=192$ 将两幅图像的灰度区间分成三部分，然后对三部分分段线性取权值，然后合成图像。为了达到理想的效果需要在不同的灰度区域取合适的权值，在较亮的场景中，需要将较暗图像的权值设置的大一些，在太暗的情况下就要将较暗图像的权值设置的小一些，在两幅图像合成中，不同区域的权值计算方法如下表所示： 算法步骤如下： 参考文章： 参考文献： 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>图像处理</tag>
        <tag>图像增强</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[低照度图像增强方法-LiTao2004]]></title>
    <url>%2F2020%2F05%2F10%2F%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[低照度图像增强《An Integrated Neighborhood Dependent Approach for Nonlinear Enhancement of Color Images》-LiTao 2004 一种简单快速有效的低照度图像增强方法2004年Tao的一篇论文，《An Integrated Neighborhood Dependent Approach for Nonlinear Enhancement of Color Images 》处理低照度图像效果不错，相比直方图均衡化的效果颜色恢复比较好 算法步骤灰度图像线性增强RGB颜色空间中的彩色图像转换为灰度图像，并且将图像进行归一化，得到归一化后的I(x,y)，通过下面公式进行线性增强。 In(x,y)=(I(x,y)^a+(1-I(x,y))^b+I(x,y)^2)/2类似gamma曲线调整，提高暗区亮度亮度，而亮区亮度增强较少 灰度增强图像高斯卷积接着对灰度增强图像I(x,y)同过不同尺度的高斯核函数对I(x,y)做卷积运算，卷积的结果包含了图像相邻像素的亮度信息。可以采取相关性来处理图像的边界。 高斯核函数的表示方式以及卷积公式如下所示： G(x,y)=Ke(−(x2+y2)/c2)其中c为尺度或者是高斯环绕空间常数 I′(x,y)=I(x,y)∗G(x,y) 将灰度图像与中心像素图像做对比度增强 R(x,y)=In(x,y)r(x,y)r(x,y)=I′(x,y)/I(x,y) 为了获得更加的图像效果，对不同尺度的多个卷积结果进行图像的对比度增强，最终的结果是基于这多个尺度的线性组合。R(x,y)=i∑3​wi​Ri​(x,y)一般取3就够了，本文$wi$（与尺度有关）为1/3。 色彩恢复线性颜色恢复图像，得到增强彩色图像。色彩恢复公式如下： Rj​(x,y)=I(x,y)Ij​(x,y)​∗λ$λ$调整三种波段的色调，本文的$λ$取值为1，结果同样很好。$Ij​(x,y)$指的是原图像的R、G、B三通道。 代码链接https://github.com/AomanHao/Matlab-Image-Dehazing-Enhazing 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>图像处理</tag>
        <tag>图像增强</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ISP图像处理——紫边Purple Fringing]]></title>
    <url>%2F2020%2F04%2F22%2FISP_Purple%20Fringing%2F</url>
    <content type="text"><![CDATA[ISP图像处理——紫边Purple Fringing 图像紫边存在数码相机、监控摄像头等数字成像图像，使用设备在逆光、大光圈条件下拍摄图像的高反差区域容易出现紫边，解决图像自编问题有助设备得到完美图像。 紫边成因分析和确定有助与紫边消除的图像处理算法研究和摄像设备工程改进，能够改善自编的硬件成本更高，非常需要研究去除紫边的图像处理算法。 镜头色差众所周知，镜头色差会使得图像中物体边缘出现不属于物体的颜色，我们将物体边缘出现的颜色称为色差色边。光学色差分为纵向色差和横向色差，纵向色差又叫轴向色差。对于横向色差，通常在图像全局上进项校正，将红绿蓝三 个颜色通道调整到相同的放大倍数，一般通过拍摄棋盘格标定，这对于固定的光学镜头比较有效，但是对变焦镜头则难以适用。 对于紫边的成因，通常认为是镜头/微透镜色差所导致，如图2-1所 示，成像系统一般将绿色通道准确对焦，然而由于镜头/微镜头色差，蓝色和红色通道不能完全准确对焦，从而使物体边缘出现紫红色的色边。 图像颜色插值算法（去马赛克算法〉颜色插值算法是数宇成像系统的核心技术之一，对图像颜色影响巨大，如图 所示为数字成像系统流程。 在数字成像系统中，一般由单个CCD/CMOS 获得经过CFA(Color Filter Array)过滤后的图像原始数据，这样每个传感器只采集 了一个颜色通遣的数据，这些数据排列规律与CFA的样式是一致的。 颜色插值算法如果不能合理地处理红蓝通道的高频混叠，其恢复结果中图像 边缘、图像纹理等高频部分则会出现颜色错误(falsccolor),具体表现如图2-5所 示，右上图为原始图像，右下图•是使用双线性插值得到的插值结果，可见颜色插值算法使得物体的边缘、图像纹理等高频区域颜色出现伪彩色。 早期一些简单的颜色插值算法比如最近邻、双线性、边缘定向(edgedircctcd) 等方法在空间域恢复图像颜色，这些方法没能很好处理高頻混叠导致恢复后 的物体边缘带来锯齿效应以及错误颜色。目前顏色插值算法在消混叠方面已经做得很好，即使在图像中物体边缘，纹 理等高频区域也能很好地恢复图像颜色井避免带来错误颜色 过曝区域图像色边图像的过曝区域边缘会出现蓝紫色背景，具体表现如图〗-2(c)图所示。数字成像器件CCD和CMOS当过度曝光时会产生电荷溢出现象，当一个像素过度曝光时，其产生的电荷会泄漏到临近的像素并污染图像中的临近区域的场景信号，如图所示，CMOS对于过曝溢出的表现要好于CCD。左侧CMOS,右侧CCD 从以上的分析可知，图像紫边是数字成像系统的短波色差引起的，并且在图 像中受紫边影响严重的区域是天空、灯光附近等物体的边缘，由于天空和灯光的 光谱中富含短波成分导致图像中这一区域内部的物体边缘出现较为严重的色边, 进而影响图像在这一区域的视觉效果。对于成像系统的色差校正，最重要的工作在于光学系统的设计。目前的现状 是，由于受到生产制造成本，器件大小等因素的限制，光学镜头能很好地控制光 学色差。但是对一些時定场景下比如逆光对着天空和灯光区域成徼，数字成像系 统对于图像紫边的控制仍然不够，光学系统的短波色差在图像中凸显出来。考虑 到进一步提升镜头设计的成本过高，人们将思路转向后期的图像处理算法，图像 处理算法能够针对性地处理色差色边、图僳紫边等图像问題，并且成本也得到了 极大的节省。 参考文献：《数字成像系统图像消紫边方法研究》 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>ISP</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客Next主题bilibili视频Markdown引入文章]]></title>
    <url>%2F2020%2F04%2F12%2Fhexo_biliVideo%2F</url>
    <content type="text"><![CDATA[Hexo博客Next主题bilibili视频Markdown引入文章 问题及需求B站视频无广告有弹幕，非常简洁，经常看B站视频，在文章引用B站的视频 在不用插件的情况下用官方的iframe方式引入视频，默认的方式导入视频屏幕会很小 一般我们都是自己改width和height来修改大小，但是换成不同的设备就无法正常的显示了 视频大小优化不能自动适配，试试下面的两种办法：Next版本6.XX可以，7.xx版本可以试试 优化方法一div标签自适应与屏幕的大小，iframe以100%顶边撑开。 以next主题为例子：在next\source\css\_custom\custom.styl下底部添加以下css代码：12345678910111213141516171819/*哔哩哔哩视频适配*/.bilibili &#123; position: relative; width: 100%;&#125;@media only screen and (max-width: 767px) &#123; .bilibili &#123;height: 15em;max-width: 25em;&#125;&#125;@media only screen and (min-width: 768px) and (max-width: 991px) &#123; .bilibili &#123;height: 20em;max-width: 30em;&#125;&#125;@media only screen and (min-width: 992px) and (max-width: 1199px) &#123; .bilibili &#123;height: 30em;max-width: 40em;&#125;&#125;@media only screen and (min-width: 1200px) &#123; .bilibili &#123;height: 40em;max-width: 50em;&#125;&#125; 插入视频时，加入标签块123&lt;div class=&quot;bilibili&quot;&gt;&lt;/div&gt; 写成如下形式即可：123&lt;div class=&quot;bilibili&quot;&gt; &lt;iframe src=&quot;//player.bilibili.com/player.html?aid=14875394&amp;cid=24237231&amp;page=1&amp;high_quality=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;&lt;/div&gt; 优化方法二使用@media属性，对不同屏幕大小的设备，设置宽度和高度。@media可以查询到设备的一下属性 设备屏幕的高度设备的方向（如移动设备横屏）可视窗口的宽高屏幕解析度 在next\source\css\_custom\custom.styl下底部添加以下css代码：12345678910111213141516171819/*哔哩哔哩视频适配*/.bilibili &#123; position: relative; width: 100%;&#125;@media only screen and (max-width: 767px) &#123; .bilibili &#123;height: 15em;max-width: 25em;&#125;&#125;@media only screen and (min-width: 768px) and (max-width: 991px) &#123; .bilibili &#123;height: 20em;max-width: 30em;&#125;&#125;@media only screen and (min-width: 992px) and (max-width: 1199px) &#123; .bilibili &#123;height: 30em;max-width: 40em;&#125;&#125;@media only screen and (min-width: 1200px) &#123; .bilibili &#123;height: 40em;max-width: 50em;&#125;&#125; 插入视频时，加入标签块class=&quot;bilibili&quot;到B站的iframe代码: 1&lt;iframe class=&quot;bilibili&quot; src=&quot;//player.bilibili.com/player.html?aid=14875394&amp;cid=24237231&amp;page=1&amp;high_quality=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt; 效果如下： 链接相关参数B站链接的参数1player.bilibili.com/player.html?aid=81148317&amp;cid=138878361&amp;page=1 参数说明及举例使用123456aid 视频ID 就是B站的av号cid 应该是客户端的id,clientid的缩写（推测） 测试表示不填也不会有什么问题page 第几个视频 也就是分P的 默认是1as_wide 是否宽屏 1：宽屏 0：小屏high_quality 视频质量 1：最高视频质量 0：最低视频质量danmaku 是否开启弹幕 1：开启（默认） 0：关闭 举个例子：B站默认视频质量是最低的，可以通过在src链接后面添加&amp;high_quality=1来设置 1234src=&quot;//player.bilibili.com/player.html?aid=14875394&amp;cid=24237231&amp;page=1改为src=&quot;//player.bilibili.com/player.html?aid=14875394&amp;cid=24237231&amp;page=1&amp;high_quality=1 参考文章1参考文章2 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitc错误Failed to connect to 127.0.0.1 port 1080 Connection refused拒绝连接错误]]></title>
    <url>%2F2020%2F04%2F05%2Fgit_error_Connection_refused%2F</url>
    <content type="text"><![CDATA[Failed to connect to 127.0.0.1 port 1080: Connection refused拒绝连接错误 一、git拒绝连接原因分析使用git从远程仓库下载代码出现上述的错误是因为使用了proxy代理，所以要解决该问题，核心操作就是要取消代理 二、解决方式1、查看Linux当前有没有使用代理通过git的配置文件查看有无使用代理（没有成功）查询是否使用代理：123git config --global http.proxy git config --global https.proxy 2、取消代理设置方式一：通过git取消代理设置123git config --global --unset http.proxygit config --global --unset https.proxy 方式二：通过系统命令取消代理123456789unset http_proxyunset ftp_proxyunset all_proxyunset https_proxyunset no_proxy 我的个人博客地址，欢迎访问 我的CSDN地址，欢迎访问 我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome浏览器，有道云笔记的网页剪报需要多次登录且收藏失败报错]]></title>
    <url>%2F2020%2F04%2F03%2FCloud_Note%2F</url>
    <content type="text"><![CDATA[Chrome浏览器，有道云笔记的网页剪报需要多次登录且收藏失败报错 报错代码1&#123;&quot;canTryAgain&quot;:false,&quot;scope&quot;:&quot;SECURITY&quot;,&quot;error&quot;:&quot;207&quot;,&quot;message&quot;:&quot;Message[AUT 客服给出的方案，经测试有效 新版的chrome浏览器，地址栏输入： 1chrome://flags/#same-site-by-default-cookies 选择disabled，禁用此项，按下列图操作 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客Next主题valine评论系统邮件提醒]]></title>
    <url>%2F2020%2F04%2F03%2Fhexo_valine_admin%2F</url>
    <content type="text"><![CDATA[Hexo博客Next主题valine评论系统邮件提醒 简介Valine：一款快速、简洁且高效的无后端评论系统。 Valine-AdminGithub 项目地址，具体教程以 最新版 为准Valine-Admin项目地址 简介 Valine Admin 是 Valine 评论系统的扩展和增强，主要实现评论邮件通知、评论管理、垃圾评论过滤等功能。支持完全自定义的邮件通知模板。基于Akismet API实现准确的垃圾评论过滤。此外，使用云函数等技术解决了免费版云引擎休眠问题，支持云引擎自动唤醒，漏发邮件自动补发。兼容云淡风轻及Deserts维护的多版本Valine。 NOTE: 该项目基于LeanCloud云引擎示例代码实现，您可以自由地复制和修改。包含了一些 trick 实现资源的最大化利用 ，但请勿滥用免费资源。引用本说明文档及Deserts博客上的相关文章务必注明来源。部署 快速开始首先需要确保 Valine 的基础功能是正常的 配置项设置自定义环境变量，需要设置云引擎的环境变量以提供必要的信息，变量参数参考下面的配置项 12345678910变量 示例 说明SITE_NAME HONGWEI’S Blog [必填] 网站名称SITE_URL https://www.zhwei.cn [必填] 网站地址，最后不要加 /SMTP_SERVICE QQ [必填] 邮件服务提供商，支持 QQ、163、126、Gmail 以及 更多。 — 如这里没有你使用的邮件提供商，请查看自定义邮件服务器SMTP_USER xxxx@qq.com [必填] SMTP登录用户，一般为邮箱地址SMTP_PASS xxxx [必填] SMTP登录密码，一般为授权码，而不是邮箱的登陆密码，请自行查询对应邮件服务商的获取方式SENDER_NAME HONGWEI’S Blog Valine 评论提醒 [可选] 发件人ADMIN_URL https://xxx.leanapp.cn/ [建议] Web主机二级域名，用于自动唤醒TO_EMAIL xxxxx@gmail.com [可选] 指定站长收信邮箱，默认值为SITE_USER。用于 SMTP 发件人与站长收件人不一致的情况下使用。TEMPLATE_NAME rainbow [可选] 通知邮件的模板（default和rainbow），参考高级功能 部署进入 Leancloud 对应的 Valine 应用中。点击 云引擎 -&gt; 设置 填写代码库：https://github.com/zhaojun1998/Valine-Admin，保存 注意：这里推荐代码库路径先填写：https://github.com/zhaojun1998/Valine-Admin，然后全部部署完之后试试留言会不会提醒道邮箱里，如果配置成功，在github上frok这个代码库到自己账号，然后代码库路径使用自己账号下的库，比如我的是https://github.com/AomanHao/Valine-Admin，为了稳定运行 点击 云引擎 -&gt; 部署，分支或版本号输入master，部署 后台评论管理点击 云引擎 -&gt; 设置，在Web主机域名位置点击申请，获取二级域名，域名随机不好记，保存在书签里 设置后台管理登录信息，点击 存储 -&gt; 结构化数据，选择_User如果有内容，全部删除，这里是需要新建后台管理的账户。选择_User -&gt; 添加行，只需要填写password、username、email这三个或password、username字段即可, 使用SMTP_USER【之前填的SMTP登录用户，一般为邮箱地址】 作为账号登陆、password 作为账号密码、username 任意即可。（为了安全考虑，此 email 必须为配置中的 SMTP_USER 或 TO_EMAIL） 此后，可以通过上述申请的 https://二级域名.leanapp.cn/管理评论 定时任务免费版的 LeanCloud 容器，是有强制性休眠策略的，不能 24 小时运行：每天必须休眠 6 个小时30 分钟内没有外部请求，则休眠 配置自动唤醒（推荐）创建定时任务，名称任意，生产环境选择self-wake云函数，Cron表达式填入0 */20 7-23 * * ?，表示每天 7 - 23 点每 20 分钟访问一次，这样可以保持每天的绝大多数时间邮件服务是正常的。 配置定时检查创建定时任务，名称任意，生产环境选择resend-mails云函数，Cron表达式填入0 0 8 * * ?，表示每天早8点检查过去24小时内漏发的通知邮件并补发 参考文章 我的个人博客地址，欢迎访问 我的CSDN地址，欢迎访问 我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工业相机常见参数]]></title>
    <url>%2F2020%2F03%2F28%2FISP_CameraPara%2F</url>
    <content type="text"><![CDATA[了解工业相机的相关参数能够帮助我们更好的理解相机功能，进而帮助我们完成对相机的选型工作。所谓外行看热闹，内行看门道，工业相机的门道就从其参数开始。 1、分辨率相机的传感器sensor是有许多像素点按照矩阵的形式排列而成，分辨率就是以水平方向和垂直方向的像素来表示的。分辨率越高，成像后的图像像素数就越高，图像就越清晰。常用的工业面阵相机分辨率有130万、200万、500万等；对于线阵相机而言，分辨率就是传感器水平方向上的像素数，常见有1K、2K、6K等。 在相机分辨率的选型上，要根据我们的项目需求而定，并不一定是分辨率越高就越好，分辨率高带来的图像数据量就大，后期的算法处理复杂度就高，而且一般分辨率大的相机，帧率一般都不会太高。 2、传感器尺寸传感器尺寸是以有效面积（宽x高）或以对角线大小（英寸）来表示的，常见的传感器尺寸如下： 传感器尺寸越大，一定程度上表示相机可容纳像素个数越多，成像的画幅越大。 3、像元尺寸像元尺寸就是每个像素的面积。单个像素面积小，单位面积内的像素数量多，相机的分辨率增加，利于对细小缺陷的检测和增大检测视场。随着像素面积的缩小，满阱能力（每个像素能够储存的电荷数量）也随之减小，造成相机动态范围的降低。 4、像素深度像素深度是指每个像素用多少比特位表示。通常，每个像素的比特位数多，表达图像细节的能力强，这个像素的颜色值更加丰富、分的更细，颜色深度就更深。一般像素深度有1位、8位、16位、24位和32位。 1位像素深度就是有二进制来表示，也叫单色显示。 8位像素深度是最常见的，用8个二进制位来表示颜色，能表示256种颜色，这种就是常说的灰度显示。 16位是用16个二进制位来表示，能表示65536种颜色，这时就可以彩色显示啦。 24位和31位则表达的颜色信息就会更加的丰富。 5、动态范围动态范围是用来描述每个像素能够分辨出的灰度等级。它是饱和电压（最大的输出电平）相机输出的噪声之比。宽动态范围能够使场景中非常亮和非常昏暗部分的细节同时被清晰的显示。一般来说，低动态范围的相机噪声比较多，照片会缺失亮部细节和暗部细节。 6、最大帧率最大帧率表示的是面阵工业相机每秒能够采集并输出的最大帧数，这往往和传感器芯片和数据输出接口带宽有关。根据项目需求，对于拍摄运动物体，建议选取高帧率相机，具体帧率数要根据拍摄精度来确定。 7、曝光方式工业相机常见的曝光方式有帧曝光（global shutter）和行曝光（rolling shutter）。 帧曝光是指传感器阵列中所有像素同时曝光，曝光周期由预先设定的快门时间确定。这种曝光方式的相机适合拍摄运动物体，图像不会偏移，不会失真。 行曝光是指同一行上的像素同时曝光，不同行的曝光起始时间不同，每行的曝光时间是相同的，行间的延迟不变。这种曝光方式的相机适用于拍摄静止的物体，拍摄运动物体，图像会偏移。 8、曝光时间传感器将光信号转换为电信号形成一帧图像，每个像元接受光信号的过程叫曝光，所花费的时间叫曝光时间，也叫快门速度。 9、采集模式采集模式分为了连续采集、外触发采集和软触发采集三种。 连续采集指相机进行连续曝光，输出实时图像。 外触发采集是指当相机处于外触发模式后，相机处于待机模式，不曝光，只有当相机通过I/O口接收到相机规定的单个脉冲（方波）信号后，传感器曝光一次，部分相机支持信号的上升沿、下降沿和高低电平的触发。 软触发是指当相机处于外触发模式后，相机处于待机模式，不曝光，只有当相机软件发出指令后，传感器曝光一次。 10、增益工业相机通常具有一个对传感器的信号进行放大的视频放大器，其放大倍数称为增益。增益越大，噪声就会变大，一般情况不建议增大增益值。 11、光谱响应特性光谱响应特性是指图像传感器对不同光波的敏感特性，变现了传感器的量子效率QE。 12、模拟相机与数字相机工业相机按输出图像信号格式划分为模拟相机与数字相机。早期的工业相机多采用PAL/ NTSC/ CCIR/ EIA-170等标准模拟输出，也有采用非标准模拟输出的产品，随着GigE/IEEE 1394/USB 2.0/ USB 3.0/ Camera Link/ CameraLink HS/ CoaXPress等数字接口技术的发展和普及，越来越多的工业数字相机取代传统的模拟相机出现在各种机器视觉系统中。 数字相机的信号受噪声干扰较少，因此数字相机的动态范围很高，图像质量更好；而模拟相机采集到的是模拟信号，要经过数字采集卡转换为数字信号，受噪声影响较大，分辨率低，且帧率一般固定。 模拟相机工作流程图如下： 数字相机工作流程图如下： 转自公众号《AI图像》 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>ISP</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ISP-YUV格式]]></title>
    <url>%2F2020%2F03%2F28%2FISP_YUV%2F</url>
    <content type="text"><![CDATA[ISP-YUV格式 简介数字图像处理的过程中，YUV文件是比较常见的视频源数据。YUV不像RGB那样要求三个独立的视频信号同时传输，所以用YUV方式传送占用极少的频宽。 YUV采样格式和RGB颜色空间相比，YUV颜色空间充分利用了人眼的特性，人的眼睛对亮度的敏感度远大于色度。在保证基本画质的前提下，可以对一幅画面的色度分量进行删减。下面三张图片是常见的三种YUV采样方式，YUV4：4：4、YUV4：2：2、YUV4：2：0。其中，YUV4：4：4是一种无压缩的采样方式，每一个Y分量对应一组UV分量；YUV4：2：2的采样方式丢弃了一半的色度分量，每两个Y分量对应一组UV分量；YUV4：2：0的采样方式对齐了四分之三的色度分量，每四个Y分量对应一组UV分量。 YUV文件格式之UYVY和I420下面说明UYVY和I420的文件存储格式。 UYVY文件UYVY文件是YUV4：2：2采样格式的一种存储格式，具体的地址对应关系如下图所示，U、Y、V、Y依次按顺序存储在文件中。 I420文件I420文件是YUV4：2：0采样格式的一种存储格式，具体的地址对应关系如下图所示，和UYVY文件稍有不同。I420文件先存储Y块、然后是U块和V块。每个Y/U/V块块内的的像素依次存储在文件中。 以YUV4：2：2 和YUV4：2：0转换为例，如下： 最简单的方式： YUV4:2:2 —-&gt; YUV4:2:0 Y不变，将U和V信号值在行(垂直方向)在进行一次隔行抽样。 YUV4:2:0 —-&gt; YUV4:2:2 Y不变，将U和V信号值的每一行分别拷贝一份形成连续两行数据。 在YUV420中，一个像素点对应一个Y，一个4X4的小方块对应一个U和V。对于所有YUV420图像，它们的Y值排列是完全相同的，因为只有Y的图像就是灰度图像。YUV420sp与YUV420p的数据格式它们的UV排列在原理上是完全不同的。420p它是先把U存放完后，再存放V，也就是说UV它们是连续的。而420sp它是UV、UV这样交替存放的。(见下图) 有了上面的理论，我就可以准确的计算出一个YUV420在内存中存放的大小。width hight =Y（总和） U = Y / 4 V = Y / 4 ，所以YUV420 数据在内存中的长度是 width hight * 3 / 2。 色域转换本文采用的转换公式如下：R =1.164(Y-16) + 1.596(V-128)G =1.164(Y-16) - 0.813(V-128) - 0.392(U-128)B =1.164(Y-16) + 2.017(U-128)具体实践的时候，我又将这些浮点数扩大1024倍变为定点数，然后再做处理，经过处理后的公式如下：R =(1192(Y-16) + 1634(V-128))/1024G =(1192(Y-16) - 833(V-128) -401(U-128))/1024B =(1192(Y-16) + 2065(U-128))/1024 参考YUV播放器设计 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>ISP</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[透雾滤光片及应用]]></title>
    <url>%2F2020%2F03%2F28%2FISP_filter_defog%2F</url>
    <content type="text"><![CDATA[透雾滤光片及应用 光学透雾技术光学透雾技术是由光的不同波段有不同的特性这个特点而形成的，自然光由不同波长的光波组合而成，小于390nm的叫做紫外线，波长大于780nm的叫做红外线，人眼可见范围大致为390nm-780nm。 不同波段的光因为波长的不同具有不同的特性，雾气、烟尘影响可见光成像的原因，而红外线因为拥有较长的波长，在传播时受气溶胶的影响较小，可穿透一定浓度的雾霭烟尘，实现准确聚焦，这就是光学透雾的依据。 了解日夜转换摄像机的人对滤光片都不会陌生，一般此类型摄像机装有两块滤光片，一块负责在白天过滤掉可见光之外的光波，令成像更为清晰亮丽;一块应用在夜晚，负责放行红外波段，实现夜间的红外监控。 专业透雾镜头内置有针对性很强的滤光片，作用是精确截取所需波段的光线，且为了适应特定环境状况，常常会加载多片针对不同波段的滤光片，实现切换。 滤光片应用正常来说，配合透雾镜头的摄像机在基础成像性能上只要具备日夜转换功能即可，从原理可知光学透雾的重点在于对特定近红外波段光线的截取与准确聚焦，而这部分工作大都由镜头完成。可以说镜头的好坏决定了光学透雾的效果，镜头设计的难度首先在于光学设计,但是考虑到透雾镜头高昂的造价，部分摄像机厂家也开始寻求更经济实惠的光学透雾模式，不同于过去两片滤光片的日夜转换摄像机，在摄像机里边加入了四块滤光片，除了实现日夜转换 1、增设一块可选择性过滤400nm-600nm波段光线的滤光片，实现了强光抑制;当然为了更精确截取适合成像的近红外波段， 2、增加了透雾滤光片，以实现较为经济的光学透雾。此机械装置可由摄像机自动控制，也可人工切换。此类滤光片吸收可见光，允许紫外光通过，也允许 一些近红外光通过。 参考文章 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>ISP</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客Next主题留言板]]></title>
    <url>%2F2020%2F03%2F25%2Fhexo_gusetbook%2F</url>
    <content type="text"><![CDATA[hexo博客Next主题留言板 留言让博客看起来更加的人性化NexT 主题官网有给出添加标签页、分类页的方法，其实添加留言本的方式异曲同工。方式稍微会有一点不同。 一、添加留言本 page进入到博客的根目录，运行命令：1hexo new page guestbook 生成index.md，在里面可以写一些留言板介绍内容等1博客根目录\source\guestbook\index.md 二、修改菜单目录Next主题默认只有主页和和关于，如果要增加菜单，在themes/next/_config.yml中修改配置，12345678910111213# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------menu: home: / || home about: /about/ || user tags: /tags/ || tags #标签 categories: /categories/ || th #分类 archives: /archives/ || archive #归档 guestbook: /guestbook/ || comment #留言 #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 其中留言页需要自己增加：1guestbook: /guestbook/ || comment #留言 效果预览本地预览1hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 博客部署博客部署1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 推荐使用 &amp;&amp; 作为组合命令的串联符号 注：一定要严格清理缓存，这样不容易出现问题，即需要执行hexo clean 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[--ISP（图像信号处理）算法概述、工作原理、架构、处理流程]]></title>
    <url>%2F2020%2F03%2F22%2FISP%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[&lt;转&gt;—ISP（图像信号处理）算法概述、工作原理、架构、处理流程 目录ISP的主要内部构成：ISP内部包含 CPU、SUP IP（各种功能模块的通称）、IF 等设备 ISP的控制结构：1、ISP逻辑 2、运行在其上的firmware ISP上的Firmware包含三部分：AP对ISP的操控方式：外置：I2C/SPI。 内置：MEM MAP、MEM SHARE ISP架构方案：内置、外置 ISP 处理流程：Bayer、黑电平补偿 （black level compensation）、镜头矫正（lens shading correction）、坏像素矫正（bad pixel correction）、颜色插值 （demosaic）、Bayer 噪声去除、 白平衡（AWB） 矫正、 色彩矫正（color correction）、gamma 矫正、色彩空间转换（RGB 转换为 YUV）、在YUV 色彩空间上彩噪去除与边缘加强、色彩与对比度加强，中间还要进行自动曝光控制等， 然后输出 YUV（或者RGB） 格式的数据， 再通过 I/O 接口传输到 CPU 中处理。 概念ISP是Image Signal Processor 的简称，也就是图像信号处理器。 DSP是Digital Signal Processor 的缩写，也就是数字信号处理器。 ISP一般用来处理Image Sensor（图像传感器）的输出数据，如做AEC（自动曝光控制）、AGC（自动增益控制）、AWB（自动白平衡）、色彩校正、Lens Shading、Gamma 校正、祛除坏点、Auto Black Level、Auto White Level等等功能的处理。 而DSP功能就比较多了，它可以做些拍照以及回显（JPEG的编解码）、录像以及回放（Video 的编解码）、H.264的编解码、还有很多其他方面的处理，总之是处理数字信号了。ISP是一类特殊的处理图像信号的DSP。 ISP架构方案：分为独立（外置）与集成（内置）两种形式。 CPU处理器包括：AP、BP、CP。 其中BP：基带处理器、AP：应用处理器、CP：多媒体加速器。 ISP的主要内部构成如下图所示，ISP内部包含 CPU、SUP IP、IF 等设备，事实上，可以认为 ISP 是一个 SOC（system of chip），可以运行各种算法程序，实时处理图像信号。 CPU：CPU 即中央处理器，可以运行 AF、LSC 等各种图像处理算法，控制外围设备。现代的 ISP 内部的 CPU 一般都是 ARM Cortex-A 系列的，例如 Cortex-A5、Cortex-A7。 SUB IP：SUB IP 是各种功能模块的通称，对图像进行各自专业的处理。常见的 SUB IP 如 DIS、CSC、VRA 等。图像传输接口：图像传输接口主要分两种，并口 ITU 和串口 CSI。CSI 是 MIPI CSI 的简称，鉴于 MIPI CSI 的诸多优点，在手机相机领域，已经广泛使用 MIPI-CSI 接口传输图像数据和各种自定义数据。外置 ISP 一般包含 MIPI-CSIS 和 MIPI-CSIM 两个接口。内置 ISP 一般只需要 MIPI-CSIS 接口。通用外围设备：通用外围设备指 I2C、SPI、PWM、UART、WATCHDOG 等。ISP 中包含 I2C 控制器，用于读取 OTP 信息，控制 VCM 等。对于外置 ISP，ISP 本身还是 I2C 从设备。AP 可以通过 I2C 控制 ISP 的工作模式，获取其工作状态等。 ISP的控制结构ISP包括： 1、ISP逻辑 2、运行在其上的firmware如图所示，lens 将光信号投射到sensor 的感光区域后，sensor 经过光电转换，将Bayer 格式的原始图像送给ISP，ISP 经过算法处理，输出RGB空间域的图像给后端的视频采集单元。在这个过程中，ISP通过运行在其上的firmware（固件）对ISP逻辑，从而对lens 和sensor 进行相应控制，进而完成自动光圈、自动曝光、自动白平衡等功能。其中，firmware的运转靠视频采集单元的中断驱动。PQ Tools 工具通过网口或者串口完成对ISP 的在线图像质量调节。ISP 由ISP逻辑及运行在其上的Firmware组成，逻辑单元除了完成一部分算法处理外，还可以统计出当前图像的实时信息。Firmware 通过获取ISP 逻辑的图像统计信息，重新计算，反馈控制lens、sensor 和ISP 逻辑，以达到自动调节图像质量的目的。 ISP上的Firmware包含三部分ISP 的Firmware包含三部分，一部分是ISP 控制单元和基础算法库，一部分是AE/AWB/AF 算法库，一部分是sensor 库。Firmware 设计的基本思想是单独提供3A算法库，由ISP控制单元调度基础算法库和3A 算法库，同时sensor 库分别向ISP 基础算法库和3A 算法库注册函数回调，以实现差异化的sensor 适配。ISP firmware 架构如图所示。不同的sensor 都以回调函数的形式，向ISP 算法库注册控制函数。ISP 控制单元调度基础算法库和3A 算法库时，将通过这些回调函数获取初始化参数，并控制sensor，如调节曝光时间、模拟增益、数字增益，控制lens 步进聚焦或旋转光圈等。 AP对ISP的操控方式CPU处理器包括：AP、BP、CP。 BP：基带处理器、AP：应用处理器、CP：多媒体加速器这里所说的控制方式是AP 对 ISP 的操控方式 。I2C/SPI：这一般是外置 ISP 的做法。SPI 一般用于下载固件、I2C 一般用于寄存器控制。在内核的 ISP 驱动中，外置 ISP 一般是实现为 I2C 设备，然后封装成 V4L2-SUBDEV。MEM MAP：这一般是内置 ISP 的做法。将 ISP 内部的寄存器地址空间映射到内核地址空间，MEM SHARE：这也是内置 ISP 的做法。AP 这边分配内存，然后将内存地址传给 ISP，二者实际上共享同一块内存。因此 AP 对这段共享内存的操作会实时反馈到 ISP 端。 ISP架构方案上文多次提到外置 ISP 和内置 ISP，这实际上是 ISP的架构方案。 外置 ISP 架构外置 ISP 架构是指在 AP 外部单独布置 ISP 芯片用于图像信号处理。外置 ISP 的架构图一般如下所示： 外置 ISP 架构的优点主要有：能够提供更优秀的图像质量：在激烈的市场竞争下，能够存活到现在的外置 ISP 生产厂商在此领域一般都有很深的造诣，积累了丰富的影像质量调试经验，能够提供比内置 ISP 更优秀的性能和效果。因此，选用优质的外置 ISP 能提供专业而且优秀的图像质量。能够支援更丰富的设计规划：外置 ISP 的选型基本不受 AP 的影响，因此魅族可以从各个优秀 ISP 芯片供应商的众多产品中甄选最合适的器件，从而设计出更多优秀的产品。能够实现产品的差异化：内置 ISP 是封装在 AP 内部的，是和 AP 紧密的联系在一起，如果 AP 相同，那么 ISP 也就是一样的。因此基于同样 AP 生产出来的手机，其 ISP 的性能也是一样的，可供调教的条件也是固定的，这样就不利于实现产品的差异化。而如果选择外置 ISP，那么同一颗 AP，可以搭配不同型号的 ISP，这样可以实现产品的差异化，为给用户提供更丰富和优质的产品。外置 ISP 架构的缺点主要有：成本价格高：外置 ISP 需要单独购买，其售价往往不菲，而且某些特殊功能还需要额外支付费用。使用外置 ISP，需要进行额外的原理图设计和 LAYOUT，需要使用额外的元器件。开发周期长：外置 ISP 驱动的设计需要多费精力和时间。使用外置 ISP 时，AP 供应商提供的 ISP 驱动就无法使用，需要额外设计编写外置 ISP 驱动。另外，为了和 AP 进行完美的搭配，将效果最大化，也往往需要付出更多的调试精力。上文也提到，使用外置 ISP，需要进行额外的原理图设计和 LAYOUT，需要使用额外的元器件，这也是需要花费时间进行处理的。 内置 ISP 架构：内置 ISP 架构是指在 AP 内部嵌入了 ISP IP，直接使用 AP 内部的 ISP 进行图像信号处理。 内置 ISP 的架构图一般如下所示： 内置 ISP 架构的优点主要有：能降低成本价格：内置 ISP 内嵌在 AP 内部，因此无需像外置 ISP 一样需要额外购买，且不占 PCB 空间，无需单独为其设计外围电路，这样就能节省 BOM，降低成本。鉴于大多数用户在选购手机时会将价格因素放在重要的位置，因此降低成本能有效的降低终端成品价格，有利于占领市场。能提高产品的上市速度：内置 ISP 和 AP 紧密结合，无需进行原理图设计和 LAYOUT 设计，因此可以减小开发周期，加快产品上市的速度。能降低开发难度：如果使用内置 ISP，那么 AP 供应商能在前期提供相关资料，驱动开发人员可以有充足的时间熟悉相关资料，而且不会存在软件版本适配问题，也不存在平台架构兼容性问题。但是，如果使用外置 ISP，那么 ISP 供应商往往都不能提供针对某个平台的代码/资料，而且一般都存在软件版本兼容问题，这就需要驱动开发人员付出额的经历和时间。使用内置 ISP 当然也有相应的不足之处，具体见上文的分析，这里就不赘述了。事实上，鉴于 ISP 的重要性，为了推广其 AP，提高其 AP 竞争力，现在 AP 内置的 ISP 也越来越强大，其性能足以满足手机市场的需求。再加上其一系列优点，现在使用内置 ISP 方案的手机越来越多。 ISP 处理流程 图像产生过程：景物通过 Lens 生成的光学图像投射到 sensor 表面上， 经过光电转换为模拟电信号， 消噪声后经过 A/D 转换后变为数字图像信号， 再送到数字信号处理芯片（ DSP） 中加工处理。所以，从 sensor 端过来的图像是 Bayer 图像，经过黑电平补偿 （black level compensation）、镜头矫正（lens shading correction）、坏像素矫正（bad pixel correction）、颜色插值 （demosaic）、Bayer 噪声去除、 白平衡（awb） 矫正、 色彩矫正（color correction）、gamma 矫正、色彩空间转换（RGB 转换为 YUV）、在YUV 色彩空间上彩噪去除与边缘加强、色彩与对比度加强，中间还要进行自动曝光控制等， 然后输出 YUV（或者RGB） 格式的数据， 再通过 I/O 接口传输到 CPU 中处理。 1.Bayer（拜耳滤波器得到彩色）图像在将实际的景物转换为图像数据时， 通常是将传感器分别接收红、 绿、 蓝三个分量的信息， 然后将红、 绿、 蓝三个分量的信息合成彩色图像。 该方案需要三块滤镜， 这样价格昂贵，且不好制造， 因为三块滤镜都必须保证每一个像素点都对齐。通过在黑白 cmos 图像传感器的基础上， 增加彩色滤波结构和彩色信息处理模块就可以获得图像的彩色信息， 再对该彩色信息进行处理， 就可以获得色彩逼真的彩色图像。通常把彩色图像传感器表面覆盖的滤波称为彩色滤波阵列（Color Filter Arrays，CFA）。目前最常用的滤镜阵列是棋盘格式的， 已经有很多种类的， 其中绝大多数的摄像产品采用的是原色贝尔模板彩色滤波阵列（Bayer Pattern CFA）。R、G、B 分别表示透红色、透绿色和透蓝色的滤镜阵列单元。由于人的视觉对绿色最为敏感，所以在 Bayer CFA 中G分量是 R和B 的二倍，在每个像素点上只能获取一种色彩分量的信息，然后根据该色彩分量的信息通过插值算法得到全色彩图像。 2.BLC(Black level Correction)（黑电平补偿）a.暗电流物理器件不可能是理想的， 由于杂质、 受热等其他原因的影响， 即使没有光照射到象素，象素单元也会产生电荷， 这些电荷产生了暗电流。 而且， 暗电流与光照产生的电荷很难进行区分。 b.Black LevelBlack Level 是用来定义图像数据为0时对应的信号电平。由于暗电流的影响， 传感器出来的实际原始数据并不是我们需要的黑平衡（数据不为0）。所以，为减少暗电流对图像信号的影响，可以采用的有效的方法是从已获得的图像信号中减去参考暗电流信号。一般情况下， 在传感器中，实际像素要比有效像素多， 如下图所示， 像素区头几行作为不感光区（ 实际上，这部分区域也做了RGB 的 color filter），用于自动黑电平校正，其平均值作为校正值， 然后在下面区域的像素都减去此矫正值，那么就可以将黑电平矫正过来了。做了black level 矫正与没做black level 矫正的对比，没做black level矫正的图片会比较亮，影响图像的对比度。 3.LSC(Lens Shading Correction)（镜头矫正）由于镜头本身的物理性质， 造成图像四周亮度相对中心亮度逐渐降低，以及，由于图像光照在透过镜头照射到 pixel 上时，边角处的焦点夹角大于中心焦点夹角，造成边角失光。表现在图像上的效果就是亮度从图像中心到四周逐渐衰减， 且离图像中心越远亮度越暗。 为了补偿四周的亮度， 需要进行 Lens Shading 的矫正。Lens Shading 的矫正的方法是根据一定的算法计算每个像素对应的亮度矫正值，从而补偿周边衰减的亮度。矫正方法有二次项矫正、 四次项矫正。 4.BPC(Bad Pixel Correction)（坏点矫正）a.坏点坏点为全黑环境下输出图像中的白点，高亮环境下输出图像中的黑点。 b.坏点修复方法一般情况下， RGB 信号应与景物亮度呈线性响应关系， 但由于 Senor 部分 pixel 不良导致输出的信号不正常， 出现白点或黑点。 坏点修复方法通常有两种：一种是自动检测坏点并自动修复， 另一种是建立坏点像素链表进行固定位置的坏像素点修复， 这种方式是 OTP 的方式。 5.Demosaic颜色插值 （抵马赛克）当光线通过 Bayer型 CFA（Color Filter Arrays） 阵列之后， 单色光线打在传感器上，每个像素都为单色光，从而理想的Bayer 图是一个较为昏暗的马赛克图。首先需要说明的就是demosaiced并不是和字面的意思一样是为了去除电影中的一些打马赛克的图像，而是数字图像处理中用来从不完整的color samples插值生成完整的color samples的方法(因为bayer pattern看起来像一个个马赛克，因此称为去马赛克)。在sensor端通常需要使用CFA滤镜来得到Bayer pattern，而在后面的处理中需要把bayer pattern变成完整的RGB444(真彩色)图像。在ISP中需要有这么一个模块来做。 在传统的ISP中有很多算法可以来做这个插值，包括最近邻域法，bilinear 插值，cubic 插值等。 6.Bayer Denoise（去噪声）使用 cmos sensor获取图像，光照程度和传感器问题是生成图像中大量噪声的主要因素。同时， 当信号经过ADC 时， 又会引入其他一些噪声。 这些噪声会使图像整体变得模糊， 而且丢失很多细节， 所以需要对图像进行去噪处理空间去噪传统的方法有均值滤波、 高斯滤波等。 但是， 一般的高斯滤波在进行采样时主要考虑了像素间的空间距离关系， 并没有考虑像素值之间的相似程度， 因此这样得到的模糊结果通常是整张图片一团模糊。 所以， 一般采用非线性去噪算法， 例如双边滤波器， 在采样时不仅考虑像素在空间距离上的关系， 同时加入了像素间的相似程度考虑， 因而可以保持原始图像的大体分块， 进而保持边缘。 7.AWB(Automatic White Balance)（自动白平衡）白平衡的基本原理是在任意环境下， 把白色物体还原成白色物体， 也就是通过找到图像中的白块， 然后调整R/G/B 的比例， 如下关系： R’= R * R_GainG’ = G * G_GainB’ = B * B_GainR’ = G’= B’AWB 算法通常包括的步骤如下：(1)色温统计： 根据图像统计出色温； (2)计算通道增益： 计算出R 和B 通道的增益； (3)进行偏色的矫正： 根据给出的增益， 算出偏色图像的矫正。 8.Color Correction（颜色矫正）由于人类眼睛可见光的频谱响应度和半导体传感器频谱响应度之间存在差别，还有透镜等的影响， 得到的RGB 值颜色会存在偏差， 因此必须对颜色进行校正， 通常的做法是通过一个3x3 的颜色变化矩阵来进行颜色矫正。 9.Gamma Correction（伽马矫正）人眼对外界光源的感光值与输入光强不是呈线性关系的， 而是呈指数型关系的。 在低照度下，人眼更容易分辨出亮度的变化， 随着照度的增加，人眼不易分辨出亮度的变化。而摄像机感光与输入光强呈线性关系， 为方便人眼辨识图像， 需要将摄像机采集的图像进行gamma 矫正。Gamma 矫正是对输入图像灰度值进行的非线性操作， 使输出图像灰度值与输入图像灰度值呈指数关系：out = Vin ^ gamma这个指数就是 gamma， 横坐标是输入灰度值， 纵坐标是输出灰度值， 蓝色曲线是 gamma 值小于 1 时的输入输出关系， 红色曲线是 gamma 值大于 1 时的输入输出关系。 可以观察到， 当 gamma 值小于 1 时(蓝色曲线)， 图像的整体亮度值得到提升， 同时低灰度处的对比度得到增加， 更利于分辩低灰度值时的图像细节。 10.色彩空间转换YUV 是一种基本色彩空间， 人眼对亮度改变的敏感性远比对色彩变化大很多， 因此， 对于人眼而言， 亮度分量Y 要比色度分量U、V 重要得多。 所以， 可以适当地抛弃部分U、V分量， 达到压缩数据的目的。YCbCr 其实是YUV 经过缩放和偏移的改动版，Y 表示亮度，Cr、Cb 表示色彩的色差，RGB信号亮度值之间的差异，分别是红色和蓝色的分量。 在YUV 家族中，YCbCr 是在计算机系统中应用最多的成员， 其应用领域很广泛，JPEG、MPEG 均采用此格式。 一般人们所讲的YUV 大多是指YCbCr。YCbCr有许多取样格式，如 4∶4∶4，4∶2∶2， 4∶1∶1和 4∶2∶0。Cb：反映的是RGB输入信号蓝色部分与RGB信号亮度值之间的差异。Cr：反映了RGB输入信号红色部分与RGB信号亮度值之间的差异。在以下两个公式中RGB和YCbCr各分量的值的范围均为0-255。RGB转换为Ycbcr公式： Y = 0.257*R+0.564*G+0.098*B+16Cb = -0.148*R-0.291*G+0.439*B+128Cr = 0.439*R-0.368*G-0.071*B+128YCbCr转换为RGB公式： R = 1.164*(Y-16)+1.596*(Cr-128)G = 1.164*(Y-16)-0.392*(Cb-128)-0.813*(Cr-128)B =1.164*(Y-16)+2.017*(Cb-128)色彩空间转换这个模块， 是将RGB 转换为 YUV444， 然后在YUV 色彩空间上进行后续的彩色噪声去除、 边缘增强等， 也为后续输出转换为jpeg 图片提供方便。 11.Color Denoise为了抑制图像的彩色噪声， 一般采用低通滤波器进行处理。 例如使用M×N的高斯低通滤波器在色度通道上进行处理。 参考：高通camera结构（摄像头基础介绍）ISP算法概述ISP概述、工作原理及架构ISP DSP的区别数字图像处理 颜色空间RGB、HSI、CMYK、YUV的相互转换ISP基本框架及算法介绍ISP（图像信号处理）之——图像处理概述相机系统综述 —— ISP]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理之下采样]]></title>
    <url>%2F2020%2F03%2F20%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B9%8B%E4%B8%8B%E9%87%87%E6%A0%B7%2F</url>
    <content type="text"><![CDATA[图像处理之下采样 下采样 下采样（subsampled）或降采样（downsampled））的目的有： 1、使得图像符合显示区域的大小；2、生成对应图像的缩略图；3、处理大型图像减少运算量。 下采样实现两种方式：方法一，for循环隔行隔列循环遍历每一个像素点12345678910111213141516171819202122232425262728%读入图像进行下采样%两种方法用时只需将对应方法注释掉其中一个即可clear all;close all;clc;img = imread(&apos;F:\MATLAB2017b\AMOutputResults\lena.jpg&apos;);% n为下采样倍数n = 2;img = rgb2gray(img);[h w] = size(img);L =1;R = 1;%对图像进行下采样tic;img_down = zeros(256,256);% %方法一循环遍历每一个像素点，j为行，i表示列% for j = 1:n:h% for i = 1:n:w% img_down(L, R) = img(j,i);% R = R+1;% end% L = L+1;% R = 1;% endtoc;%%%%%%%%%%%%%%%%%%%%%%%%%%tic; 方法二，矩阵隔行隔列复制其实道理也是一样的不过代码更短一些，在程序中间加了tic,toc来计时间，1234%%方法二矩阵隔行隔列赋值%img_down = img(1:n:512,1:n:512);%toc;imshowpair(img,(uint8(img_down)),&apos;montage&apos;); 发现方法一：时间已过 0.002278 秒。方法二大概：时间已过 0.000293 秒。。。第二种方法比第一种for循环快了将近10倍。可见在大型图片下采样时还是尽量避免for嵌套循环，转而用矩阵向量的计算方式，这样会省不少时间 。 DCT域下采样算法在传统的图像，视频的后处理阶段，一般会涉及到图像大小的缩放问题。这样的操作是为了适配不同屏幕分辨率的大小。例如，对于高档相机拍摄的照片，一般都很大，而要在普通显示器上显示，则要在解码图像数据之后再做缩小操作才能显示到屏幕上。对于手机屏幕，更是如此。那么，能否在图像解码的过程中实现图片的缩小？ 通过在视频解码中使用频域下采样技术，我们在400M主频的手机上实现了720p的流畅解码，在400M主频的CPU上实现了1080p的视频解码，但不是很流畅。 1、DCT频率域下采样算法1234567891011121314151617181920212223242526272829303132333435363738% 根据Dugad方法实现%程序作者： celery.chen@yahoo.com.cn%2010-10-12I=imread(&apos;456.png&apos;);I=rgb2gray(I);figure(1);imshow(I);[width,height] = size(I);block_size_x = 8;block_size_y = 8;x_block_num = width/block_size_x;y_block_num = height/block_size_y;z_dst = zeros(width/2,height/2);pfun1 = @dct2;I_freq = blkproc(I,[8 8],pfun1);for i = 1: x_block_num for j = 1 : y_block_num P = I_freq((i-1)*8+1:(i-1)*8+4,(j-1)*8+1:(j-1)*8+4); P = P/2.0; z_dst( (i-1)*4 +1 : (i-1)*4 +4, (j-1)*4 +1 : (j-1)*4 +4) = P; end endpfun2 = @idct2;J = blkproc(z_dst,[4 4],pfun2);J = uint8(round(J));figure(2);imshow(J); 2、DCT频域下采样算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869% dct频率域下采样算法，根据下面论文提到的算法实现% 一种高效的DCT域图像下采样方法 中国图像图形学报 2005年4月%程序作者： celery.chen@yahoo.com.cn ，2010-10clc;clear;I=imread(&apos;456.png&apos;);I=rgb2gray(I);figure(1);imshow(I);[width,height] = size(I);block_size_x = 8*2;block_size_y = 8*2;x_block_num = width/block_size_x;y_block_num = height/block_size_y;C16 = dctmtx(16); C16LL = C16(1:8,1:8); C16LH = C16(1:8,9:16); C16HL = C16(9:16,1:8); C16HH = C16(9:16,9:16); C8 = dctmtx(8); P = C16LL*C8&apos;; P = P/sqrt(2); Q = C16LH*C8&apos;; Q = Q/sqrt(2); E = (P + Q)/2; F = (P - Q)/2;z_dst = zeros(width/2,height/2);pfun1 = @dct2;I_freq = blkproc(I,[8 8],pfun1);for i = 1: x_block_num for j = 1 : y_block_num X1 = I_freq((i-1)*16+1:(i-1)*16+8,(j-1)*16+1:(j-1)*16+8); X2 = I_freq((i-1)*16+1:(i-1)*16+8,(j-1)*16+9:(j-1)*16+16); X3 = I_freq((i-1)*16+9:(i-1)*16+16,(j-1)*16+1:(j-1)*16+8); X4 = I_freq((i-1)*16+9:(i-1)*16+16,(j-1)*16+9:(j-1)*16+16); A = E*(X1+X3)+F*(X1-X3); B = E*(X2+X4)+F*(X2-X4); XLL = (A + B) * E&apos; + (A - B) * F&apos;; z_dst( (i-1)*8 +1 : (i-1)*8 +8, (j-1)*8 +1 : (j-1)*8 +8) = XLL; end endpfun2 = @idct2;J = blkproc(z_dst,[8 8],pfun2);J = uint8(round(J));figure(2);imshow(J); 参考文章-视频图像处理中的频域下采样技术]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理之天空区域识别]]></title>
    <url>%2F2020%2F02%2F23%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B9%8B%E5%A4%A9%E7%A9%BA%E5%8C%BA%E5%9F%9F%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[图像处理之天空区域识别 近几年来，去雾方法得到广泛的研究，汤晓鸥等人发现无雾图像相对于雾化图像具有较高的对比度，通过最大化恢复图像的对比度来实现图像去雾，但由于该方法没有从物理模型上恢复真实的场景反射率，图像去雾后有可能出现颜色过饱和失真。 Kaiming He提出了一种基于暗通道先验的方法，即在有雾图像的特定窗中至少有一个颜色分量的值是零，该算法利用最小值滤波估算出介质传播函数，然后利用软抠图原理对估算的介质传播函数进行优化估计，达到了较好的去雾效果。软抠图需要较高计算量，很难得到实际应用。所以后来Kaiming He又提出了引导滤波法，来精细化透射率。 通过对比实验发现，场景中如果存在较大的天空区域的话，Kaiming He提出的暗通道先验的理论在天空区域将不成立，图像去雾后天空区域存在失真，特別是在天空区域不明显的浓雾环境下。 一 为什么天空区域识别很重要？人们常用传感器进行测距，在自主导航领域常见测距传感器有两类：第一类是主动式传感器，比如雷达，激光传感器，这类传感器比较精确，但缺点是比较贵；第二类是被动式传感器，比如视觉传感器。这类传感器成本较低，主要依赖于算法，但有些场景精度不好。但随着技术的发展，这些精度问题都可以得到解决。 处理不同透射率区域改进的基于暗原色先验的图像去雾算法作者: 蒋建国 对一些含雾图像，基于暗原色先验的去雾结果出现色彩失真，因为含天空、水面等大面积明亮区域的图像，他们的像素值很大，在此区域找不到像素值接近于0的暗原色。 一般情况下大气光A的取值和天空部分应该是非常接近的，而那些符合暗通道的地方则远离天空。 识别出天空区域单独处理专利《一种基于天空识别与分割的暗通道先验去雾方法》 重点：1、进行天空识别与分割，确定天空区域与非天空区域不同透射率。2、引导滤波优化透射率，输出头屋图像 相似操作识别天空区域1、天空部分平坦区域多，处理成梯度图表示图像的像素落差，梯度值越小的区域表示为平坦区域。 2、设定一个阈值来初步划分天空区域与非天空。 3、对第二步的结果进行扩展处理。 4、对第三步的图的像素平均亮度进行判断，如果大于阈值T则认为是真天空区域。（阈值可以设置为0.8，灰度值为204左右均可），自我构思 该方案可以消除去雾图像边缘处的光晕现象，提高处理效率。 分割天空区域专利《一种含天空区域雾天图像的去雾方法、服务器及系统 》 步骤1、利用预设的亮度阈值 + 图像梯度信息，分割天空区域和非天空区域，梯度阈值选择概率最大的梯度，避免误分割；2、利用四分法或者天空区域大气光值；3、非天空区域加权图像融合的方法细化透射率；4、图像去雾 我们希望分为天空、似天空和非天空区域，三个区域采用不同的光透射率。注：如果其他区域的像素满足以下两个条件认为是似天空区域： 弱纹理区域 像素值和Strue区域的平均像素值 相差很小。 其他相关算法程序可以看看我的github]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[亮度估计相关]]></title>
    <url>%2F2019%2F12%2F31%2F%E4%BA%AE%E5%BA%A6%E4%BC%B0%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[亮度估计相关 相机照拍夜视图像曝光亮度估计原理水平集是跟踪界面变化的数值计算方法［7］ ， 其把平面闭合取消描述成三维连续曲面 $φ( x，y)$ 的等值曲线， $φ( x，y)$ 表示水平集函数， 一般令 $φ( x，y) = 0$。在相机照拍夜视图像曝光亮度估计原理中， 通过水平集函数对相机照拍夜视图像曝光亮度进行描述， 为后续曝光亮度估计提供依据。曝光亮度估计公式如下: Hv = Ev * t式( 1) 中，$Ev$ 表示光照度，$t$ 表示时间。 水平集边缘描述方法优势为: 对于水平集函数中夜视图像目标出现的拓扑变化， 水平集函数不会失效， 再拓扑出现变化时依然能够轻松处理。图 1( a) 为夜视图像原图， 图像曲线的水平集函数描述分别如图 1( b) 与图 1( c) 所示， 当图像曲线分裂时， 即进行二次分裂， 三次分裂时， 它的水平集函数没有分裂， 此时函数依然保持有效。 另外， 图像的一些数学特征也可通过水平集函数描述。水平集方法同样适用于处理高维问题， 如采用水平集方法对多传感器融合图像进行光值估计时， 利用水平集方法描述闭合曲面的演化过程等]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像融合简介]]></title>
    <url>%2F2019%2F12%2F31%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E8%9E%8D%E5%90%88%2F</url>
    <content type="text"><![CDATA[图像融合 图像融合（Image fusion）的整体重心是对于目标源信息的信息细节的提取和整合。一般情况下，我们先会对不同传感器取得的各自信息及信号进行一个整合加强过程，例如图像间的配准，图像边缘增强，图像纹理平滑，抑制背景杂波等；然后我们要做的是对于融合层和融合算法的选取，不同的算法处理方式和提取特征信息的方法不同，结果也不尽相同，我们仍需要根据我们需要的要求进行选取。最后是对融合效果的评价，看所得结果是否满足我们的预期要求，如不满足我们应当从新讨论融合层次和算法的选取优化等等，具体划分步骤如下： 1、对于目标探测器的选取。不同的探测器有着各自不同的探测性能，我们需要选取合适的探测器来获取我们想要的信号种类。 2、对于同一目标的多源图像信号的采集。通过传感器进行目标信号采集，采集过程虽然简单，却可也不能轻视，好的采集方法可以获得更优质的信号信息，为后续的信号处理过程打下基础。 3、对于采集信号的预处理。收集到的信号不一定直接就能用，在进行图像融合之前，对采集到的信号进行去噪、增强、配准等预处理，可以大大提高图像的对比度以及分辨率，有助于图像融合效果的进一步提高。 4、图像融合过程。这是整个图像融合最为关键和重要的部分，不同的融合级别有着不同的融合算法以及不同层次的变换域，需要具体情况具体分析对待，以选最合适的融合规则和算法，因为该过程的处理是最为重要的一环。 5、。根据视觉效果以及各项指标进行判断和分析融合结果。 图像融合处理过程的流程框图如下： 不同的层次所进行数据处理的要求和融合算法是不一样的，需要具体问题具体分析，通常我们将图像数据分为三层，融合过程流程图如下： 图像融合层简介： 1、基于像素级的图像融合属于最基本的图像融合技术。这一层主要是直接处理图像的单像素，因为像素级是由源场景的图像最大化描述的。像素级图像融合需要对图像进行预处理，包括图像配准、滤波和增强。像素级图像融合的主要优点是从这一层获得的图像比其他两种图像更快、更快，显示出源和场景信息，大大提高了源图像中包含的有用和详细信息。 2、基于特征层的图像融合是基于不同传感器的图像分析，将有用的信息融合成能展现人们需要的特征，特征层的融合对于多元传感器的选择十分重要，因为需要获取的图像必须有人们需要的特征在里面，再进行算法的图像融合使得特征更加明显，特征的数据更加全面和丰富。如果是实时性的特征融合对于传感器的数据处理能力和数据压缩能力都有很大的要求。 3、对于决策层图像融合所需要做的工作量和工作种类是最大最多的，先是需要对多元传感器所获得的图像进行预处理，再进行特征提取，最后还能做出相应的评判和决策，是图像融合功能最极致却又很难实现的层次。 其他相关算法程序可以看看我的github 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>图像处理</tag>
        <tag>图像融合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客Next主题友链页面]]></title>
    <url>%2F2019%2F12%2F29%2Fhexo_links%2F</url>
    <content type="text"><![CDATA[Hexo博客Next主题友链页面 博客友链太多，需要自定义一个友情链接页面 link渲染文件在 hexo/themes/next/layout 目录下建一个 link.swig文件，写入以下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&#123;% block content %&#125; &#123;######################&#125; &#123;### LINKS BLOCK ###&#125; &#123;######################&#125; &lt;div id=&quot;links&quot;&gt; &lt;style&gt; #links&#123; margin-top: 5rem; &#125; .links-content&#123; margin-top:1rem; &#125; .link-navigation::after &#123; content: &quot; &quot;; display: block; clear: both; &#125; .card &#123; width: 300px; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex; &#125; .card:nth-child(odd) &#123; float: left; &#125; .card:nth-child(even) &#123; float: right; &#125; .card:hover &#123; transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); &#125; .card a &#123; border:none; &#125; .card .ava &#123; width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px; &#125; .card .card-header &#123; font-style: italic; overflow: hidden; width: 236px; &#125; .card .card-header a &#123; font-style: normal; color: #2bbc8a; font-weight: bold; text-decoration: none; &#125; .card .card-header a:hover &#123; color: #d480aa; text-decoration: none; &#125; .card .card-header .info &#123; font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; &#125; &lt;/style&gt; &lt;div class=&quot;links-content&quot;&gt; &lt;div class=&quot;no-icon note warning&quot;&gt;&lt;div class=&quot;link-info&quot;&gt;👨‍🎓 跟着大佬走，成为小大佬&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;link-navigation&quot;&gt; &#123;% for link in theme.defaultlinks %&#125; &lt;div class=&quot;card&quot;&gt; &lt;img class=&quot;ava nofancybox&quot; src=&quot;&#123;&#123; link.avatar &#125;&#125;&quot;/&gt; &lt;div class=&quot;card-header&quot;&gt; &lt;div&gt;&lt;a href=&quot;&#123;&#123; link.site &#125;&#125;&quot; target=&quot;_blank&quot;&gt; &#123;&#123; link.nickname &#125;&#125;&lt;/a&gt; &lt;a href=&quot;&#123;&#123; link.site &#125;&#125;&quot;&gt;&lt;span class=&quot;focus-links&quot;&gt;&lt;i class=&quot;fa fa-plus&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&amp;nbsp;关注&lt;/span&gt;&lt;/a&gt;&lt;/div&gt; &lt;div class=&quot;info&quot;&gt;&#123;&#123; link.info &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;div class=&quot;no-icon note primary&quot;&gt;&lt;div class=&quot;link-info&quot;&gt;🍭 五湖四海的朋友们&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;link-navigation&quot;&gt; &#123;% for link in theme.friendslinks %&#125; &lt;div class=&quot;card&quot;&gt; &lt;img class=&quot;ava nofancybox&quot; src=&quot;&#123;&#123; link.avatar &#125;&#125;&quot;/&gt; &lt;div class=&quot;card-header&quot;&gt; &lt;div&gt;&lt;a href=&quot;&#123;&#123; link.site &#125;&#125;&quot; target=&quot;_blank&quot;&gt; &#123;&#123; link.nickname &#125;&#125;&lt;/a&gt; &lt;a href=&quot;&#123;&#123; link.site &#125;&#125;&quot;&gt;&lt;span class=&quot;focus-links&quot;&gt;&lt;i class=&quot;fa fa-plus&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&amp;nbsp;关注&lt;/span&gt;&lt;/a&gt;&lt;/div&gt; &lt;div class=&quot;info&quot;&gt;&#123;&#123; link.info &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &#123;&#123; page.content &#125;&#125; &lt;/div&gt; &lt;/div&gt; &#123;##########################&#125; &#123;### END LINKS BLOCK ###&#125; &#123;##########################&#125;&#123;% endblock %&#125; page渲染文件然后修改 hexo/themems/next/layout/page.swig 文件，12#&#125;&#123;% elif page.type === &quot;tags&quot; and not page.title %&#125;&#123;# #&#125;&#123;&#123; __(&apos;title.tag&apos;) + page_title_suffix &#125;&#125;&#123;# 位置添加如下代码：123&lt;!-- 友情链接--&gt;#&#125;&#123;% elif page.type === &apos;links&apos; and not page.title %&#125;&#123;# #&#125;&#123;&#123; __(&apos;title.links&apos;) + page_title_suffix &#125;&#125;&#123;# 如图所示： 然后还是在这个 page.swig 文件中，引入刚才新建的 swig 页面：123&lt;!-- 友情链接--&gt;&#123;% elif page.type === &apos;links&apos; %&#125; &#123;% include &apos;links.swig&apos; %&#125; 这个代码位置可以放到下面123456789101112131415 &#123;% elif page.type === &apos;categories&apos; %&#125; &lt;div class=&quot;category-all-page&quot;&gt; &lt;div class=&quot;category-all-title&quot;&gt; &#123;&#123; _p(&apos;counter.categories&apos;, site.categories.length) &#125;&#125; &lt;/div&gt; &lt;div class=&quot;category-all&quot;&gt; &#123;&#123; list_categories() &#125;&#125; &lt;/div&gt; &lt;/div&gt; &#123;% elif page.type === &apos;links&apos; %&#125; &#123;% include &apos;links.swig&apos; %&#125; &#123;% else %&#125; &#123;&#123; page.content &#125;&#125; &#123;% endif %&#125;&lt;/div&gt; index文件然后在 hexo/source 下创建 links 文件夹，创建 index.md 文件，写入以下内容，如下，这个是友链页面的申请信息，可以按照自己想法修改：1234567891011121314151617181920212223242526272829303132----title: 友情链接date: 2019-12-08 03:21:39type: &quot;links&quot;------### 申请要求：1、内容持续更新且可以稳定访问2、网页整洁无繁杂广告推广3、博客主页被百度或谷歌等搜索引擎收录4、头像能够快速加载5、拥有独立域名### 友链声明：1、本站会主动保存您的 HTTPS 形式的头像图片链接2、本站会定期清理无法访问的友链，如果更换了链接信息请至评论区留言，谢谢合作！3、本站会定期查看双方是否互为友链，如果取消本站友链，本站也会将您的友链移除### 申请方式：先将本站的友链添加到您的友链，相关信息如下然后按照以下格式在本站留言区留言，待博主为您添上友链&gt;名称：AomanHao 头像链接：http://www.aomanhao.top/images/Avatar.jpg主页链接：http://www.aomanhao.top/ 说明信息：图像处理，优化世界 config配置文件最后，我们添加友链的话，需要在主题配置文件 hexo/themes/next/_config.xml 文件末尾添加：123456789101112# 友情链接defaultlinks: - nickname: AomanHao # 昵称 avatar: http://www.aomanhao.top/images/Avatar.jpg # 头像地址 site: http://www.aomanhao.top #友链地址 info: 图像处理，优化世界friendslinks: - nickname: AomanHao # 昵称 avatar: http://www.aomanhao.top/images/Avatar.jpg # 头像地址 site: http://www.aomanhao.top #友链地址 info: 图像处理，优化世界 defaultlinks:呼应的是link.swig文件中 👨‍🎓 跟着大佬走，成为小大佬段落，此处链接写大佬的博客；friendslinks:呼应的是link.swig文件中 🍭 五湖四海的朋友们段落，此处链接写朋友的博客。此处内容可以根据自己需要自行修改 菜单栏汉化需要在 hexo/themes/next/languages/zh-CN.yml文件中，新增 links ： 123menu: links: 友链 参考文章，sanarous 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客Next主题相册搭建]]></title>
    <url>%2F2019%2F12%2F22%2Fhexo_photos%2F</url>
    <content type="text"><![CDATA[Hexo博客Next主题相册搭建在blog文件夹/source下创建photos文件夹，在photos文件夹创建index.md文件，编辑index.md文件，写入以下代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330&lt;style type=&quot;text/css&quot;&gt; .header-inner&#123; display: none; &#125; .sidebar&#123; display: none; &#125; .content&#123; margin-bottom: 360px; &#125; .content-wrap&#123; width: 100%; // box-sizing: content-box; padding: initial !important; background:url(&apos;https://s2.ax1x.com/2019/09/07/nlL4pR.jpg&apos;); &#125; .main-inner&#123; width: 100%; &#125; .main &#123; padding-bottom: 150px; margin-top: 0px; background:url(&apos;https://s2.ax1x.com/2019/09/07/nlL4pR.jpg&apos;); &#125; .main-inner&#123; margin-top: unset; &#125; .page-post-detail .post-meta&#123; display: none; &#125; body &#123; background-image: unset; background-attachment: unset; background-size: 100%; /*background-position: top left;*/ &#125; .header&#123; background: rgba(28, 25, 25, 0.6); border-bottom: unset; &#125; .menu .menu-item a&#123; font-weight: 300; color: #e6eaed; &#125; .footer-inner &#123; padding-left: 0px; &#125; img:hover &#123; //opacity:0.8; /*透明度*/ //filter:alpha(opacity=100); /* For IE8 and earlier */ &#125; .imgbox&#123; margin-top: 20px; padding: 1px 10px; width: 100%; overflow: hidden; height: 250px; border-right: 1px solid #bcbcbc; background:url(&apos;https://s2.ax1x.com/2019/09/07/nlL4pR.jpg&apos;); &#125; .box&#123; visibility: visible; overflow: auto; zoom: 1; &#125; .box li&#123; float: left; width: 25%; position: relative; overflow: hidden; text-align: center; list-style: none; margin: 0; /*display: inline;*/ padding: 0; height: 360px; &#125; .box li span&#123; display: block; padding: 12% 7% 10% 7%; min-height: 80px; //background: #fff; color: #fff; font-size: 16px; font-weight: 600; line-height: 26px; -webkit-box-sizing: border-box; box-sizing: border-box; &#125; img.imgitem&#123; padding: unset; padding: unset; border: unset; position: relative; padding: 0px; height: auto; width: 100%; &#125; div#posts.posts-expand &#123; border: unset; padding: unset; margin-bottom: 10px; &#125; .posts-expand .post-body img&#123; padding: 0px !important; &#125; .box p&#123; margin-top: -25px; display: block; background: #121212; color: #fff; font-size: 14px; -webkit-box-sizing: border-box; box-sizing: border-box; text-align: center; &#125; .box span strong&#123; background: rgba(0,0,0,0.4); padding: 20px; &#125; .posts-expand .post-title &#123; display: none; &#125; .title&#123; margin: 10px auto; display: inline-block; vertical-align: middle; //background: url(/images/beichen.jpg); font: 85px/250px &apos;ChaletComprimeMilanSixty&apos;; //background-position: left bottom !important; background-position: center center !important; color: #fff; background-size: 100% auto !important; -webkit-background-size: cover; -moz-background-size: cover; -o-background-size: cover; width: 100%; text-align: center; border: unset; height: 560px; cursor: unset !important; -webkit-box-sizing: border-box; box-sizing: border-box; &#125; @media (max-width: 767px)&#123; .box li &#123; width: 98%; &#125; .title &#123; height: 200px; &#125; .box span &#123; min-height: 80px; border-right: unset; font-size: 17px; &#125; .box p&#123; border-right: unset; font-size: 12px; &#125; .posts-expand &#123; margin: unset; &#125; &#125; @media (min-width: 1600px)&#123; .container .main-inner&#123; width: 100%; &#125; &#125;&lt;/style&gt;&lt;div id=&quot;box&quot; class=&quot;box&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 相册json var json = [ [ &#123; &apos;title&apos;: &apos;七彩丹霞&apos;, &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlRzZt.jpg&apos; &#125;, &#123; &apos;title&apos;: &apos;9月雨后&apos;, &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlRvqI.jpg&apos; &#125;, &#123; &apos;title&apos;: &apos;五花肉&apos;, &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlRbGD.jpg&apos; &#125;, &#123; &apos;title&apos;: &apos;五花肉+1&apos;, &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlRHPO.jpg&apos; &#125;, &#123; &apos;title&apos;: &apos;别样的艳&apos;, &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlRTIK.jpg&apos; &#125;, &#123; &apos;title&apos;: &apos;远处的城堡&apos;, &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlRXMd.md.jpg&apos; &#125;, &#123; &apos;title&apos;: &apos;夕阳红&apos;, &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlRqRe.md.jpg&apos; &#125;, &#123; &apos;title&apos;: &apos;卢浮宫&apos;, &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlRIVx.md.jpg&apos; &#125;, &#123; &apos;title&apos;: &apos;景区一角&apos;, &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlRhrR.md.jpg&apos; &#125;, &#123; &apos;title&apos;: &apos;夕阳🌇&apos;, &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlRbGD.md.jpg&apos; &#125;, &#123; &apos;title&apos;: &apos;冰沟丹霞&apos;, &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlRLxH.md.jpg&apos; &#125;, &#123; &apos;title&apos;: &apos;别样的雨后&apos;, &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlRRxJ.md.jpg&apos; &#125;, &#123; &apos;title&apos;: &apos;卢浮宫&apos;, &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlR4q1.md.jpg&apos; &#125; ], [ &#123; &apos;title&apos;: &apos;世界之巅&apos;, &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nl5540.md.jpg&apos; &#125;, &#123; &apos;title&apos;: &apos;一天的行程&apos;, &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nl56gS.md.jpg&apos; &#125;, &#123; &apos;title&apos;: &apos;珠峰国家公园&apos;, &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nl5RBj.md.jpg&apos; &#125;, &#123; &apos;title&apos;: &apos;盘山公路&apos;, &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nl54Nq.md.jpg&apos; &#125;, &#123; &apos;title&apos;: &apos;保护区&apos;, &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nl5LDJ.md.png&apos; &#125;, &#123; &apos;title&apos;: &apos;珠峰大本营&apos;, &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nlINGV.md.png&apos; &#125;, &#123; &apos;title&apos;: &apos;氧气瓶&apos;, &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nl5jER.md.jpg&apos; &#125;, &#123; &apos;title&apos;: &apos;珠峰日出&apos;, &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nl5cjg.md.jpg&apos; &#125;, &#123; &apos;title&apos;: &apos;海拔最高的寺庙—绒布寺&apos;, &apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nl5hEn.md.jpg&apos; &#125; ] ] var content = json2Array(json); var wid = 250; if ((window.innerWidth) &gt; 1200) &#123; wid = (window.innerWidth*3)/18; &#125; var box = document.getElementById(&apos;box&apos;); var i=0; for (var i = 0; i &lt; content.length; i++) &#123; var conBox = document.createElement(&quot;div&quot;); conBox.id = &apos;conBox&apos;+i; box.appendChild(conBox); var item = document.createElement(&quot;div&quot;); var title = content[i][0].title; var url = content[i][0].url; item.innerHTML = &quot;&lt;button class = &apos;title&apos; style = &apos;background: url(&quot; + url + &quot;);&apos;&gt;&lt;span style = &apos;display: inline;&apos;&gt;&lt;strong style = &apos;color:#f0f3f6;&apos; &gt;&quot; + title + &quot;&lt;/strong&gt;&lt;/span&gt;&lt;/button&gt;&quot;; conBox.appendChild(item); for (var j = 1; j &lt; content[i].length ; j++) &#123; var _title = content[i][j].title; var _url = content[i][j].url; var item = document.createElement(&quot;li&quot;); item.innerHTML=&quot;&lt;div class = &apos;imgbox&apos; id = &apos;imgbox&apos; style = &apos;height: &quot; + wid + &quot;px;&apos;&gt;&lt;img class = &apos;imgitem&apos; src=&apos;&quot; + _url + &quot;&apos; alt=&apos;&quot; + _url + &quot;&apos;&gt;&lt;/div&gt;&lt;span&gt;&quot; + _title +&quot;&lt;/span&gt;&quot;; conBox.appendChild(item); &#125; &#125; //json转二维数组 function json2Array(arr) &#123; for (var i=0; i&lt;arr.length; i++) &#123; var tmpArr = [] for (var attr in arr[i]) &#123; tmpArr.push(arr[i][attr]) &#125; arr[i] = tmpArr &#125; return arr &#125;&lt;/script&gt; 图像修改的地方为:12&apos;title&apos;: &apos;世界之巅&apos;,&apos;url&apos;: &apos;https://s2.ax1x.com/2019/09/07/nl5540.md.jpg&apos; 图片链接和图像注释 背景图片修改地方为：1background:url(&apos;https://s2.ax1x.com/2019/09/07/nlL4pR.jpg&apos;); 参考文章，小红鸡参考文章，主题美化 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>相册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探索生活-消费性快乐与创造性快乐]]></title>
    <url>%2F2019%2F12%2F07%2F%E6%8E%A2%E7%B4%A2%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[探索生活-消费性快乐与创造性快乐 作者“动机在杭州”知乎主页 生活的乐趣分两种：消费型快乐和创造型快乐。 消费型快乐消费型快乐中，我们通过占有和消耗资源来获得快乐。这种快乐依赖于外在的物质化的东西。酒色就是典型的消费型快乐。这种快乐有三个特点： （1）以满足感官等生物性需要为主。我们所做的，是消费。 （2）消耗有限资源。为了满足消费型快乐，我们不得不和别人竞争这些资源。要不然权势王位老有这么多人眼红呢？这造成了人际紧张和冲突。 （3）容易厌倦，尤其是在无限供给的情况下。因为我们的感官系统具有很强的适应性，它只对变化敏感。酒色已经算是不那么容易适应的快乐了，但你觉得后宫佳丽这么多，他整天种猪似的，真有多快乐么？（好吧，有点酸了） 即使对消费型快乐，也有两种态度：粗放型和精致型。对酒，粗放型是豪饮，精致型是慢品。对色，粗放型是交配，细致型是恋爱。同样的资源，不同的态度创造的乐趣也会很不同。所以没有美酒美人，细细品味，粗茶淡饭未必不能有滋有味。 创造型快乐创造型快乐中，我们不是占有者和消耗者，而是分享者和贡献者。在这种创造型快乐中，我们在创造中充分发挥着自己的优势和美德，努力工作和生活，带给社会和他人美好东西的时候，也体会着一种深刻的成就感：那种我正变得更好的感觉。 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模糊特征隶属度及图像增强相关]]></title>
    <url>%2F2019%2F12%2F07%2F%E6%A8%A1%E7%B3%8A%E5%A2%9E%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[模糊特征隶属度及图像增强相关 模糊特征隶属度函数若以像素的相对灰度等级作为感兴趣的模糊特征，模糊隶属度函数的定义方式多，在实际问题中，最常用的隶属度函数形式是标准的$S$型函数和$pai$型函数。其中，$S$型函数是一种从0到1的单调增长喊数；$pai$型函数是指“中间高两边低”的函数。从图像处理的角度看，转化为模糊域的灰度值是从低到高的连续过程，$S$型函数符合边缘的过渡变化过程，所以以$S$型函数作为模糊函数的基本变换形式比较合理。 $S$型函数公式如下： f(x,a,x) = \frac{1}{1+e^{-a(x-c)}}根据参数$a$为正，$S$型隶属度函数的开口朝左 图像模糊增强边缘提取根据灰度级阈值参数$XT$，定义新的隶属函数，式如：当$X{ij}$减小，$\mu_{ij}$减小。 参数$F_d$为倒数型模糊因子，$F_e$为指数型模糊因子，均为正数，其值影响模糊性，影响曲线形状。 图像增强基于模糊集的图像增强基于模糊集的图像增强算法框架如下:模糊域内图像增强实在图像的模糊特征平面上对$\mu{ij}$进行非线性变换，当$\mu{ij}&gt;0.5$时，增大$\mu{ij}$数值，当$\mu{ij}&lt;0.5$时，增大$\mu_{ij}$数值 如下增强因子 $T_r$是$T_1$的多次递归调用，有限次递归调用可以增强图像，地带次数够多，会产生二值图像。 $T$变换图像如下： 空域图像增强模糊域增强图像进行$G^{-1}$逆变换，得到空域增强图像，逆变换公式如下： 模糊边缘提取效果调节模糊参数减少噪声对图像边缘提取的影响，具有一定的抗噪声干扰能力 其他相关算法程序可以看看我的github 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>图像处理</tag>
        <tag>图像增强</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[社会心理学效应]]></title>
    <url>%2F2019%2F12%2F07%2F%E7%A4%BE%E4%BC%9A%E5%BF%83%E7%90%86%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[社会心理学效应 焦点效应与透明度错觉 我们往往把自己看做一切的中心，并且直觉地高估别人对我们的关注程度。 这可能造成对于他人行为的过分解读，而理解这一点可以帮助自己缓解不利情绪，要清楚你所表现出来的尴尬或紧张别人很可能并未察觉。 预测误差 我们常常低估我们完成一项任务的时间%3B也常常高估情绪事件的持续性影响。 这意味着我们对自我的认识是有局限性的，想要准确预测行为最好参考过去在相似情境下的行为，不能仅凭臆想。我们有较完善的心理免疫机制，使得重大事件带给我们情绪的影响很可能比我们曾以为的要轻微得多。 自我服务归因 把好的结果归因于自己，而把坏的结果归因于其他。+就像当我们获得成功的时候，我们常会将原因归于我们超乎寻常的才智和品德。但当我们失败时，我们会觉得自己的失误是普遍发生在其他人身上的。 这能够保护人们免受抑郁，帮助缓解压力，并让我们认为自己比真实的更优秀，激发我们努力去自我实现。但过分地高看自己就显得狂妄和傲慢了，而与之所对应的谦卑，并不是看轻自己，而更像是不太在意自己，一方面让人们为自己的专长而欣喜，另一方面也真诚地认可他人的专长。 自我妨碍我们会通过设置障碍来阻挠自己获得成功。这个行为看上去是自己拆自己的台，但其实自我妨碍并不是为了破坏自我而是保护自我。 因为害怕失败，我们可能在任务刚开始时不好好干，以此不让自己产生过高的期望。因为害怕失败，我们在关系到自己形象的困难任务中不尽全力。尽全力失败了比因耽搁而失败更令人泄气，如果在重重阻碍下我们竟然成功了，那对自己的信任会更加坚固。而如果失败了也不会因此怀疑自己的天赋和能力，自己的自尊也不会受到损害。 错觉思维 我们常常在随机事件中找规律，当我们期待发现某种重要联系时，我们很容易将随机事件联系起来，以此来支持自己的信念。 假如我们相信事件相互关联，我们更可能会更注意某些支持性的证据。就像答主高中时每当体育课因为下雨取消就会记忆深刻，那时候我甚至总结出了体育课那天多半会下雨的经验，现在想想体育课和下雨之间当然没什么联系。 而这种将随机事件建立联系的行为往往容易让我们产生一种控制错觉，认为各种随机事件受我们的影响。这种控制感会让人很爽，但它也能让你沉迷在小概率事件的谜之自信中，比如赌博。 重构记忆 我们可以轻易地无意识地修正自己的记忆，以使它更适合我们当前的认识。 记忆很多时候不是连续的，为了去填补空白所形成的记忆，很多受到当前感受的影响，已经失去了真实性。积极记忆的建构会美化我们的回忆，就像旅行只有在回味时才是迷人的，过去的幸福时光显得无比纯粹。而消极记忆的构建会导致恶性的循环，对于婚姻已经变质的人来说，他们记忆中的婚姻从一开始就很糟糕，即使事实其实并非如此。 安全型自尊 是指不因为外在(例如成绩、长相、金钱和其他的赞美），而是因为自己的内在特质（如个人美德）而感觉良好。 验表明，安全型自尊的人更容易处于健康的状态，而与安全型自尊的人相比，将自尊主要依赖在外部的人的自我价值感更脆弱，他们会经历更多的压力、愤怒、人际关系问题、酗酒以及饮食障碍。 把自我感觉良好做作为自己的目标，便不能敞开心扉接受批评，试图通过漂亮、富有或受人欢迎来寻求自尊的人，更可能对真正提升生活质量的东西视而不见。 所以自我关注少一点，生活愉悦多一些。 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客Next主题文章置顶相关]]></title>
    <url>%2F2019%2F11%2F23%2Fhexo_ArticleTop%2F</url>
    <content type="text"><![CDATA[Hexo博客Next主题文章置顶相关我需要写一些文章做推荐相关，需要文章置顶功能博客效果 置顶方法配置一、修改库文件原理在Hexo生成首页HTML时，将top值高的文章排在前面，达到置顶功能。 修改方法修改Hexo文件夹下的node_modules/hexo-generator-index/lib/generator.js，在生成文章之前进行文章top值排序。 需添加的代码：12345678910111213posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排&#125;); 其中涉及Javascript的比较函数：123cmp(var a, var b) &#123; return a - b; // 升序，降序的话就 b - a&#125; 修改完成后，只需要在front-matter中设置需要置顶文章的top值，将会根据top值大小来选择置顶顺序top值越大越靠前。需要注意的是，这个文件不是主题的一部分，也不是Git管理的，备份的时候比较容易忽略。 修改内容以下是最终的generator.js内容，可以直接复制替换node_modules/hexo-generator-index/lib/generator.js的内容123456789101112131415161718192021222324252627282930313233&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals) &#123; var config = this.config; var posts = locals.posts.sort(config.index_generator.order_by); posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; if(a.top == b.top) return b.date - a.date; else return b.top - a.top; &#125; else if(a.top &amp;&amp; !b.top) &#123; return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 二、插件配置12$ npm uninstall hexo-generator-index --save$ npm install hexo-generator-index-pin-top --save 置顶文章配置然后在需要置顶的文章的Front-matter中加上top: true或者top数字top: 1： 1234title: 置顶date: 2019-09-09 09:09:09top: truetop: 1 按照数字大小依次往下置顶排序 置顶标志置顶的文章会显示在主页最上面，没有明确的置顶标志，我们需要键入置顶标志。 设置置顶标志打开：/blog/themes/next/layout/_macro目录下的post.swig文件，定位到&lt;div class=&quot;post-meta&quot;&gt;标签下，插入如下代码：12345&#123;% if post.top %&#125; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125; 效果展示：12345678 &lt;div class=&quot;post-meta&quot;&gt; &lt;span class=&quot;post-time&quot;&gt;在此之下插入代码，包含在 span块内 &#123;% if post.top %&#125; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &#123;% endif %&#125; 参考文章1参考文章2 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git插件报错，Appears to be a git repo or submodule]]></title>
    <url>%2F2019%2F11%2F21%2Fgit_error_part%2F</url>
    <content type="text"><![CDATA[Git插件报错，Appears to be a git repo or submodule Hexo博客需要引入第三方插件，不少包作者误把包项目得.git文件上传到github，或者在插件的github路径下直接下载插件文件夹，结果是插件内含有.git文件，导致下载别的npm包时报错npm err: 报错信息如下：123456789$ npm install hexo-generator-index-pin-top --save npm ERR! path D:\GitHub\AomanHao.github.io\node_modules\hexo-symbols-count-timenpm ERR! code EISGITnpm ERR! git D:\GitHub\AomanHao.github.io\node_modules\hexo-symbols-count-time: Appears to be a git repo or submodule.npm ERR! git D:\GitHub\AomanHao.github.io\node_modules\hexo-symbols-count-timenpm ERR! git Refusing to remove it. Update manually,npm ERR! git or move it out of the way first.npm ERR! A complete log of this run can be found in:npm ERR! C:\Users\10143\AppData\Roaming\npm-cache\_logs\2019-11-22T12_30_49_238Z-debug.log 解决方式：进入到报错的node_modules\hexo-symbols-count-time目录去把.git目录删除就可以了 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[野居青年-三个男人的诗和远方]]></title>
    <url>%2F2019%2F11%2F21%2FWild_Youth%2F</url>
    <content type="text"><![CDATA[野居青年-三个男人的诗和远方简介： 远离城市，隐居深山，三个男人的诗和远方。野居青年主要由 钟洋、马培源、王淦这三人组成，三人都是毕业于西安建筑科技大学美术系的高材生，希望同龄人能见证他们实实在在的乡野生活。 野居青年的B站主页 喜欢的一集秋名山一集 想来都已经是2年前的作品了，时光过得真快啊 喜欢的理由有人说：他们的视频内容很简单，一狗两鸡三餐四季，还有画画写生，很日常的生活。 有人说：拍的视频不像同类型博主那样精细，但是，会让你觉得很真实。没有夸张的滤镜，简简单单的配乐，不过剪辑是真的好。反正视频我看着是很舒服，对他们这种生活方式也很是向往，也很佩服。 我喜欢他们拍摄视频的创意和编排，喜欢他们的动手能力，自己去完善和实现自己的想法与创意，剪辑的手法与风格也渐渐成熟，希望他们越来越好，越来越火，带来更多的创意视频。 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客Next主题添加粒子时钟特效]]></title>
    <url>%2F2019%2F11%2F04%2Fhexo_clock%2F</url>
    <content type="text"><![CDATA[Hexo博客添加粒子时钟特效博客应用canvas粒子时钟的操作步骤： 在\themes\next\layout\_custom\目录下，新建clock.swig文件，内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264&lt;div style=&quot;&quot;&gt; &lt;canvas id=&quot;canvas&quot; style=&quot;width:60%;&quot;&gt;当前浏览器不支持canvas，请更换浏览器后再试&lt;/canvas&gt;&lt;/div&gt;&lt;script&gt;(function()&#123; var digit= [ [ [0,0,1,1,1,0,0], [0,1,1,0,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,0,1,1,0], [0,0,1,1,1,0,0] ],//0 [ [0,0,0,1,1,0,0], [0,1,1,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [1,1,1,1,1,1,1] ],//1 [ [0,1,1,1,1,1,0], [1,1,0,0,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,1,1,0], [0,0,0,1,1,0,0], [0,0,1,1,0,0,0], [0,1,1,0,0,0,0], [1,1,0,0,0,0,0], [1,1,0,0,0,1,1], [1,1,1,1,1,1,1] ],//2 [ [1,1,1,1,1,1,1], [0,0,0,0,0,1,1], [0,0,0,0,1,1,0], [0,0,0,1,1,0,0], [0,0,1,1,1,0,0], [0,0,0,0,1,1,0], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0] ],//3 [ [0,0,0,0,1,1,0], [0,0,0,1,1,1,0], [0,0,1,1,1,1,0], [0,1,1,0,1,1,0], [1,1,0,0,1,1,0], [1,1,1,1,1,1,1], [0,0,0,0,1,1,0], [0,0,0,0,1,1,0], [0,0,0,0,1,1,0], [0,0,0,1,1,1,1] ],//4 [ [1,1,1,1,1,1,1], [1,1,0,0,0,0,0], [1,1,0,0,0,0,0], [1,1,1,1,1,1,0], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0] ],//5 [ [0,0,0,0,1,1,0], [0,0,1,1,0,0,0], [0,1,1,0,0,0,0], [1,1,0,0,0,0,0], [1,1,0,1,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0] ],//6 [ [1,1,1,1,1,1,1], [1,1,0,0,0,1,1], [0,0,0,0,1,1,0], [0,0,0,0,1,1,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,1,1,0,0,0], [0,0,1,1,0,0,0], [0,0,1,1,0,0,0], [0,0,1,1,0,0,0] ],//7 [ [0,1,1,1,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0] ],//8 [ [0,1,1,1,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,1,1,0], [0,0,0,1,1,0,0], [0,1,1,0,0,0,0] ],//9 [ [0,0,0,0,0,0,0], [0,0,1,1,1,0,0], [0,0,1,1,1,0,0], [0,0,1,1,1,0,0], [0,0,0,0,0,0,0], [0,0,0,0,0,0,0], [0,0,1,1,1,0,0], [0,0,1,1,1,0,0], [0,0,1,1,1,0,0], [0,0,0,0,0,0,0] ]//: ];var canvas = document.getElementById(&apos;canvas&apos;);if(canvas.getContext)&#123; var cxt = canvas.getContext(&apos;2d&apos;); //声明canvas的宽高 var H = 100,W = 700; canvas.height = H; canvas.width = W; cxt.fillStyle = &apos;#f00&apos;; cxt.fillRect(10,10,50,50); //存储时间数据 var data = []; //存储运动的小球 var balls = []; //设置粒子半径 var R = canvas.height/20-1; (function()&#123; var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date()); //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成 data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]); &#125;)(); /*生成点阵数字*/ function renderDigit(index,num)&#123; for(var i = 0; i &lt; digit[num].length; i++)&#123; for(var j = 0; j &lt; digit[num][i].length; j++)&#123; if(digit[num][i][j] == 1)&#123; cxt.beginPath(); cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI); cxt.closePath(); cxt.fill(); &#125; &#125; &#125; &#125; /*更新时钟*/ function updateDigitTime()&#123; var changeNumArray = []; var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date()); var NewData = []; NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]); for(var i = data.length-1; i &gt;=0 ; i--)&#123; //时间发生变化 if(NewData[i] !== data[i])&#123; //将变化的数字值和在data数组中的索引存储在changeNumArray数组中 changeNumArray.push(i+&apos;_&apos;+(Number(data[i])+1)%10); &#125; &#125; //增加小球 for(var i = 0; i&lt; changeNumArray.length; i++)&#123; addBalls.apply(this,changeNumArray[i].split(&apos;_&apos;)); &#125; data = NewData.concat(); &#125; /*更新小球状态*/ function updateBalls()&#123; for(var i = 0; i &lt; balls.length; i++)&#123; balls[i].stepY += balls[i].disY; balls[i].x += balls[i].stepX; balls[i].y += balls[i].stepY; if(balls[i].x &gt; W + R || balls[i].y &gt; H + R)&#123; balls.splice(i,1); i--; &#125; &#125; &#125; /*增加要运动的小球*/ function addBalls(index,num)&#123; var numArray = [1,2,3]; var colorArray = [&quot;#3BE&quot;,&quot;#09C&quot;,&quot;#A6C&quot;,&quot;#93C&quot;,&quot;#9C0&quot;,&quot;#690&quot;,&quot;#FB3&quot;,&quot;#F80&quot;,&quot;#F44&quot;,&quot;#C00&quot;]; for(var i = 0; i &lt; digit[num].length; i++)&#123; for(var j = 0; j &lt; digit[num][i].length; j++)&#123; if(digit[num][i][j] == 1)&#123; var ball = &#123; x:14*(R+2)*index + j*2*(R+1)+(R+1), y:i*2*(R+1)+(R+1), stepX:Math.floor(Math.random() * 4 -2), stepY:-2*numArray[Math.floor(Math.random()*numArray.length)], color:colorArray[Math.floor(Math.random()*colorArray.length)], disY:1 &#125;; balls.push(ball); &#125; &#125; &#125; &#125; /*渲染*/ function render()&#123; //重置画布宽度，达到清空画布的效果 canvas.height = 100; //渲染时钟 for(var i = 0; i &lt; data.length; i++)&#123; renderDigit(i,data[i]); &#125; //渲染小球 for(var i = 0; i &lt; balls.length; i++)&#123; cxt.beginPath(); cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI); cxt.fillStyle = balls[i].color; cxt.closePath(); cxt.fill(); &#125; &#125; clearInterval(oTimer); var oTimer = setInterval(function()&#123; //更新时钟 updateDigitTime(); //更新小球状态 updateBalls(); //渲染 render(); &#125;,50);&#125;&#125;)();&lt;/script&gt; 引用代码直接引用或者通过配置文件配置，二选一 直接引用在博客目录\themes\next\layout\_macro\sidebar.swig尾部中引入： 1&#123;% include &apos;../_custom/clock.swig&apos; %&#125; 示意图如下： 注：代码块要放置在sider-inner的div块中，放在div块的位置决定时钟样式的展示位置。我选择放置在尾部，看着效果好点。 通过配置文件配置1、在博客目录\themes\next\layout\_macro\sidebar.swig尾部中引入：1234&#123;% if theme.diy_time.clock %&#125; &lt;!-- canvas粒子时钟 --&gt; &#123;% include &apos;../_custom/clock.swig&apos; %&#125;&#123;% endif %&#125; 示意图如下： 注：代码块要放置在sider-inner的div块中，放在div块的位置决定时钟样式的展示位置。 2、在主题的配置文件中加入应用代码，配置文件位置是博客目录\themes\next\_config.yml：1234# 侧栏粒子时钟diy_time: runtime: true clock: true # 粒子时钟 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Source Insight 4.0 破解和使用]]></title>
    <url>%2F2019%2F10%2F21%2FSouceInsight4%2F</url>
    <content type="text"><![CDATA[Source Insight 4.0 破解和使用转自博客：https://blog.csdn.net/xiaoxu2050/article/details/82752799 Source Insight 4.0 破解安装1.从官网下载source insight4.0版本(不用下载，在后面已经把所有需要的文件都准备好了); 2.安装source insightt4.0; 3.使用下载好的sourceinsight4.exe替换安装在program file(x86)目录下的sourceinsight4.exe; 4.启动sourceinsight，导入下载好的后缀名为.lic的license文件 所有需要用到的文件已打包，请自取： 链接：https://pan.baidu.com/s/1dF729UT 密码：9nx6 安装卸载附录：如果安装或者安装后提示有问题，请进行完全卸载后，再重装一遍即可。完全卸载方式： 1、清除注册表信息：“win ”+ R 或者 “开始” -&gt; “运行”，输入“regedit”，回车；在弹出的注册表管理器中，选择“编辑”-&gt; “查找”-&gt;“source insight”，或按照下述路径展开：HKEY_CURRENT_USER -&gt; software -&gt; Source Dynamics -&gt; Source Insight;将该项下面的source insight 需要清除的对应版本项目选中，右键“删除“。 2、删除全局配置信息：在 ./user/document/source insight 3.0/4.0 下的所有文件及该文件夹 注意此处的路径可能不同 也可能是:“库”-&gt;“用户”(也可能是你的名字) -&gt; 文档 -&gt; source insight3.0/4.0 或者 你上次安装的时候所指定的其他位置Source Insight4.0软件打开C程序中文注释乱码的解决方法更改Options—Preference—Files中最下面的Default encoding中程序默认的UTF-8改为System Default（windows ANSI）。附录：source insight 安装序列号（如果以上没用）123456SI3US-751793-52670SI3US-205035-36448SI3US-466908-65897SI3US-368932-59383SI3US-065458-30661SI3US-759512-70207 SourceInsight4.0的使用创建一个SI工程管理代码整体思路：告诉SI要解析哪些文件 -&gt; 告诉SI这些文件在哪 -&gt; 告诉SI文件选好了，解析它吧 。首先，这里演示的是C代码工程，其它编程语言也差不多。在解析C代码工程时，你可能希望SI连 .CC 和 .S结尾的文件也一同解析。那么点击 option -&gt; File Type Options -&gt; C/C++ Source File，我们在右边添加 .S;.cc。这里 *号是通配符，用英文;号隔开。代码类型设置 创建工程选择我们的代码工程位置，比如我选择了 D:\linux-to-windows-share\target 这个目录，我的工程代码全在这个目录下（注意不是SI的工程目录），然后点击 OK 继续。 导入项目点击Project-&gt;New Project。 点击Browse，选择你的源代码所在目录。 给新建的Source Insight工程取个名字，然后点击OK。 弹出窗口点击OK，然后点击Add Tree，添加目录结构下所有文件到工程。最后点击Close，项目就建立完成。 SynchronizeFile，双击Project Files窗口中的文件，即可打开文件，进行阅读或编辑。 新建一个项目快捷键Alt+Shift+N可以打开新建项目对话框，然后根据提示填好项目存储位置，源文件位置等，然后会出现添加删除项目文件对话框，选中自己想要编辑和浏览的文件添加即可，这样就建好了一个项目。 添加和删除项目文件（1）在添加删除文件前，可以先设置文件过滤器，菜单栏-选项-文档选项，就可以看到文件过滤器了，怎么设置应该是一目了然的。 （2）菜单栏-项目-添加或删除文件，即可打开添加和删除项目文件对话框。 同步文件 SynchronizeFile快捷键Alt+Shift+S可以同步文件，同步文件后就可以自动找到源代码之间的依赖关系了（如：可以自动找到调用某个函数或变量的位置） 项目报告菜单栏-项目-项目报告，获取当前项目的文件个数，代码行数等。 重建项目菜单栏-项目-重建项目，重新同步代码依赖关系。具体操作如下：依次点击 Project -&gt; new project ，弹出对话框分别是SI的 工程名字 和 工程目录，如：工程名QCA4020，目录名SI_Proj。 选择代码工程目录这一步，进一步确定你要添加哪些代码到你的SI工程中，如果你要添加 target 这个目录下的全部，就选中它，点击 Add Tree 就好。后面你要是增删文件，也在这里。添加好了，就点击 Close 吧。 添加以后，解析它吧。这一步会把代码加到SI数据库中，使得后面查找、关联更快。解析过程有点慢，耐心等待吧。点击Project -&gt; SynchronizeFile， 并选择1，3，4打钩（勾上会强制添加和解析），点击 start 。 解析代码如果解析完了，你突然发现忘记添加某些文件了，或者本来不用添加的你却添加了。不要担心，点击 Project -&gt; Add and Remove Project Files，再次进行添加删除，然后 再进行解析SynchronizeFile 操作才会生效。 添加和删除解析文件解析完，点一下那个书本一样的图标（Project Sympol List），尝试一下，你的代码就出来： SourceInsight 的窗口设置这里对SourceInsight进行一些设置，你完全可以不用设置，默认就好。 选择主题：Option -&gt; Visual Theme （选择你喜欢的）。设置字体大小：Option -&gt; Preference -&gt; Colors &amp; Fonts -&gt; Style -&gt; size 。 显示文件全路径：Option -&gt; Preference -&gt; Display ， 去掉 trim long path names with ellipes。 添加配置文件（别人配置好的）：Option -&gt; Load configuration（前提是你下载了别人的配置文件）。 显示行号：view -&gt; Line Numbers 。 使用技巧如果要 搜索字符位置，选中该字体，点击 工具栏的R图标 或者 Ctrl + F。 在Project Window（默认右边）的对话框中输入文件名，可以搜索到文件。 没有正确显示在右边的file list列表框需要在View菜单下找到Panels级联菜单下的Project Windows，把它勾选上。 Source Insight4.0软件打开C程序中文注释乱码的解决方法更改Options—Preference—Files中最下面的Default encoding中程序默认的UTF-8改为System Default（windows ANSI）。 高亮显示选中的单词高亮显示：F8。取消高亮：再按一次F8。效果如下： 打开Source Insight相关窗口 （1）打开Symbol Window。View-&gt;Symbol Window。快捷键：Alt+F8。 （2）打开Context Window。View-&gt;Panels-&gt;Context Window。 （3）打开Relation Window。View-&gt;Panels-&gt;Relation WindowSource Insight窗口布局我一般设置如下： 窗口字体大小与样式设置步骤：Preferences-&gt;Colors&amp;Fonts-&gt;Set Panel Fonts and Colors。 这里设置只对上面窗口1：符号窗口（Symbol Window）和窗口4：项目文件夹浏览窗口（Project Folder Browser）有效，另外两个窗口无效。 窗口2：上下文窗口（Context Window）字体大小设置如下：在面板内右击-&gt;Context Window Options-&gt;scaling。 窗口3：引用关系窗口（Relation Window）字体大小设置如下： 窗口内右击-&gt;Relation Window Options-&gt;Font。Source Insight的7种窗口的使用。 1、文档窗口（1）、修改窗口颜色属性：菜单栏-选项-参数-颜色标签，可以修改背景颜色、默认字体颜色、修改标记颜色等，如背景颜色改为护眼模式：R199 G237 B204。 （2）、Alt+Y打开文档类型选项窗口，修改字体显示大小、是否显示行号、解析语言选择、工程文件过滤、扩展tab键、是否显示符号窗口等。 扩充1：Source Insight可以定义风格，菜单栏-选项-风格，即可以打开风格窗口，可以新建一个风格或修改一个风格。风格可以继承（和C++继承差不多）。 扩充2：如何使用风格。当选中某种语言解析文档的时候，可以定义一些固定字符以不同的风格显示出来。菜单栏-选项-参数-语言标签，选中解析文档的语言，点击关键字按钮，打开语言关键字窗口，在样式这一栏选中一种风格，然后添加关键字即可。这样文档中这个关键字就以那种风格显示了。 扩充3：如何查看和修改符号（如函数名、变量等）的风格，右击该符号，选择风格，打开窗口就可以看到该符号的风格是什么，然后进行修改。 （3）、快速更名ctrl+’，选中某个函数名，然后按ctrl+’，弹出快速更名窗口，然后根据相应的选项，可以快速更换函数名。（包括函数的声明处，定义处，引用处等）。 （4）、F8，高亮 （5）、ctrl+左击，进入函数定义或变量声明处。 （6）、Alt+，：后退 （7）、Alt+. ：前进 （8）、ctrl+g：调到固定行 （9）、Alt+左击拖动：可以进行列编辑 （10）、自动缩进：Alt+T打开文档选项窗口，点击自动选项，选中第三个smart缩进，并把后面的两个勾都去掉，这样配置比较好。可以尝试一下勾上的效果，然后和不勾的效果对比一下。 （11）、编码格式设置，设置完毕后需要重新打开文件进行浏览。 （12）、Ctrl+F打开查找界面，配置好查找选项，然后关闭查找界面，选中一个单词，按一次Shift+F3，然后只要按F3和F4即可进行查找上一个和下一个。 2、符号窗口这个窗口是显示文档的符号的，那么文档内容哪些是符号呢，这个应该是看文档窗口是设置哪种语言来解析文档的。 （1）、Alt+F8：打开/关闭当前文档的符号窗口。 （2）、Alt+Y打开文档选项窗口，配置所有文档是否打开符号窗口。 （3）、右击符号窗口-符号窗口选项-符号类型，可以选择显示的符号种类。 （4）、右击符号窗口-符号窗口选项，可以修改字体、背景颜色等。 3、项目窗口这个窗口可以使用各种模式来显示文件名、文件目录等。 （1）、右击窗口选项，修改字体或背景颜色、不显示文件大小、目录、日期等。 4、关联窗口这个窗口用来显示文档中的符号在哪些地方进行了引用。如哪些地方调用了函数，或该函数调用了哪些函数等。关联窗口可以有好多个。 （1）、右击关联窗口-窗口属性，可以修改字体、背景颜色等。 （2）、右击关联窗口-新建窗口，则可以打开一个新的关联窗口。 （3）、关联窗口的功能修改，右击关联窗口-窗口属性，可以修改对应符号的关系类型，选择Reference，则该窗口显示调用该函数或变量的地方，选择calls，则该窗口显示该函数调用了哪些函数。 （4）、如何使用该窗口：选中某个函数或变量，关联窗口会自动显示对于内容，如果不想它自己变，就锁上，然后需要找的时候刷新。（锁定、刷新按钮应该可以看到吧） 5、上下文窗口这个窗口一般配合关联窗口使用，单机关联窗口的某一项，可以自动在上下文窗口显示该项的上下文，双击上下文内容，则可以在文档窗口打开上下文。 （1）、右击窗口-属性，修改字体、背景颜色等。 6、剪辑窗口这个窗口的作用相当于是定义了好多粘贴板的意思。一个剪辑相当于一个粘贴板。 （1）、右击窗口-属性，修改字体、背景颜色等。 （2）、新建、修改、删除一个剪辑。 （3）、如何使用新建的剪辑：菜单栏-编辑-粘贴自剪辑/拷贝到剪辑。 7、代码片段窗口（1）、右击窗口-属性，修改字体、背景颜色等 （2）、可以自定义一些代码片段，使用时直接插入即可。 打开上下文窗口context window 在view / panels/ context window 三、自定义命令菜单栏-选项-自定义命令，可以添加一条命令，定义该命令的名字、执行命令语句。 如何运行命令：可以将命令显示在菜单栏（参考第五点菜单分配）或者给命令定义一个快捷键（参考第六点键分配）。 望君举一反三。 1、定义使用gvim打开当前文档的命令，前提是要先安装一个gvim程序。12命令名：editWithGvim执行命令：&quot;C:\Program Files\Vim\vim63\gvim.exe&quot; --remote-silent +%l %f 备注：—remote-silent 是如果已经打开了对应文件，就不会打开第二次，而是在已经打开的文件里跳转到对应行；%l 是当前行；%f是当前文件。 2、在资源管理器中显示当前文档，即打开当前文档位置。123命令名：explorer执行命令：explorer /select,%f备注：不知道，再说吧。 四、宏的使用宏语言是SourceInsight定义的一种可编程语言。安装好一个SourceInsight后，打开SourceInsight，可以看到有一个base项目。打开base项目，可以看到有一个Utils.em文件，该文件就是宏语言文件，在里面可以自己写一些宏，也可以新建一个.em文件写宏，或者下载一个别人写好的.em文件如quiker.em(lushengwen写的，用的人比较多)。新建的.em或别人的.em文件要加载到base工程中（如何加载：菜单栏-项目-添加/删除文件）。 如何调用宏：可以将宏显示在菜单栏（参考第五点菜单分配）或者给宏定义一个快捷键（参考第六点键分配）。 1、宏语言语法这个再说 2、quiker.em的使用（从网络下载）（1）、首先要把这个文件搞到手，然后将其加载到Base工程中，其次要定义一个快捷键调用quiker.em中的宏AutoExpand。quiker.em中写了那么多宏，为什么只调用AutoExpand宏就可以。因为调用AutoExpand宏后，AutoExpand会根据当前文本内容自动调用其他宏。一般情况下都用快捷键ctrl+enter调用AutoExpand宏。 （2）、输入文本config，然后执行AutoExpand，根据提示完成语言、姓名配置。 （3）、输入文本fu，然后执行AutoExpand，根据提示完成函数的注释。（在函数名的上一行执行） （4）、输入文本if，然后执行AutoExpand，可以自动完成语法。其他类似。 （5）、输入文本file，然后执行AutoExpand，可以自动生成.c文件描述。 （6）、输入文本hdn，然后执行AutoExpand，根据提示完成.h文件宏定义。 （7）、在.c文件里输入hd，然后执行AutoExpand，可以自动生成.c文件对应的头文件。 （8）、后续补充 3、自己写的宏（1）、自动注释，给这个宏定义一个快捷键，然后选中几行文本，执行快捷键，即可以进行注释与反注释操作。12345678910111213141516171819202122232425262728293031macro MultiLineComment()&#123; hwnd = GetCurrentWnd() selection = GetWndSel(hwnd) LnFirst =GetWndSelLnFirst(hwnd) //取首行行号 LnLast =GetWndSelLnLast(hwnd) //取末行行号 hbuf = GetCurrentBuf() if(GetBufLine(hbuf, 0) ==&quot;//magic-number:tph85666031&quot;)&#123; stop &#125; Ln = Lnfirst buf = GetBufLine(hbuf, Ln) len = strlen(buf) while(Ln &lt;= Lnlast) &#123; buf = GetBufLine(hbuf, Ln) //取Ln对应的行 if(buf ==&quot;&quot;)&#123; //跳过空行 Ln = Ln + 1 continue &#125; if(StrMid(buf, 0, 1) == &quot;/&quot;)&#123; //需要取消注释,防止只有单字符的行 if(StrMid(buf, 1, 2) == &quot;/&quot;)&#123; PutBufLine(hbuf, Ln, StrMid(buf, 2, Strlen(buf))) &#125; &#125; if(StrMid(buf,0,1) !=&quot;/&quot;)&#123; //需要添加注释 PutBufLine(hbuf, Ln, Cat(&quot;//&quot;, buf)) &#125; Ln = Ln + 1 &#125; SetWndSel(hwnd, selection)&#125; 五、菜单分配菜单栏-选项-菜单分配，可以将自定义命令、宏等显示到菜单栏列表里。 六、健分配菜单栏-选项-键分配，定义快捷键，可以将自定义命令、宏等定义一个快捷键。 七、配置的保存和载入菜单栏-选项-载入配置或保存配置，可以把自己的配置保存下来，或者发给别人让别人使用。获取我的配置文件：http://pan.baidu.com/s/1pKViFHp。 八、布局使用软件提供了四个布局的保存，当配置好一个界面布局后可保存到一个布局当中，这样可以方便切换软件布局。 九、文件名标签设置为最近的使用靠左显示 10、显示/去掉overview附：代码格式化，自己调整，本来想上传配置文件的，我看还是算了，自己调整吧 面是SI4.0版本官网的使用说明介绍网页。https://www.sourceinsight.com/doc/v4/userguide/index.html#t=Manual%2FFrontMatter%2FFrontMatter.html 附简易使用说明：Source Insight导入源代码流程如下： 1）打开Source Insight； 2）选择Project-&gt;New Project，填写工程的名字，工程文件存放路径，点击OK后即创建Source Insight工程相关文件(相应目录会生成*.PR等工程文件)； 3）不断Next，你会发现Add and Remove Project Files对话框，在左边列表中选择你的源代码所在的文件夹，然后点击Add Tree，将源代码中所有文件添加到新创建的Source Insight工程中(即添加到右边列表中)，添加完成后你可以关闭该对话框，点击Project-&gt;Rebuild Project,这时你的源代码中的所有源文件全部都同步到Source Inight工程中了，这时你就可以使用Source Insight阅读源代码了；点击Project-&gt;New Project，就会出现以下界面 再New project name里面写一个项目名字，然后点击Browse，选择到你那个项目的文件夹，此次以我的一个项目为例： 点击确定，然后出现一直ok 直到出现这个界面 然后点击Add Tree，出现这个界面 点击确定，然后出现这个界面 ，然后把这个界面关掉就加载了项目 然后点击右边操作栏中，下面被选中这个按钮 然后会弹出一个提示框，是否要将这些代码关联，确认，然后加载完就可以，此时出现的是所有识别的函数名的列表，然后点击第一个按钮，回到下面这个界面，显示的是文件代码 双击其中Main.cpp文件，出现这个界面 然后随便选择这个文件中一个函数，就可以在下面看到他的定义 下面查看这个函数的全部调用，右击这个函数，选择Lookup References 然后选择Search 如果有弹出下面的框，可以随便选择Replace还是Append 然后就出现下面的界面 来源：https://blog.csdn.net/biubiuibiu/article/details/78044232https://www.jianshu.com/p/adca6c2f94f6https://blog.csdn.net/qq_39660930/article/details/77499455https://baijiahao.baidu.com/s?id=1608656406591755295&amp;wfr=spider&amp;for=pchttps://zhuanlan.zhihu.com/p/32754019https://www.sourceinsight.com/doc/v4/userguide/index.html#t=Manual%2FFrontMatter%2FFrontMatter.htmhttps://zhuanlan.zhihu.com/p/36543793 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像格式及Matlab的格式转换]]></title>
    <url>%2F2019%2F10%2F21%2Fimg_%E6%A0%BC%E5%BC%8F_matlab%2F</url>
    <content type="text"><![CDATA[图像格式及Matlab的格式转换 1. matlab图像保存说明 matlab中读取图片后保存的数据是uint8类型(8位无符号整数，即1个字节)，以此方式存储的图像称作8位图像，好处相比较默认matlab数据类型双精度浮点double（64位，8个字节），自然可以节省很大一部分存储空间。 详细来说imread把灰度图像存入一个8位矩阵，当为RGB图像时，就存入8位RGB矩阵中。例如，彩色图像像素大小是400300( 高 宽 )，则保存的数据矩阵为4003003，其中每个颜色通道值是处于0~255之间。但是虽然matlab中读入图像的数据类型是uint8，而在图像矩阵运算的时候，使用的数据类型却是double类型。一是为了保证精度，二是因为如果不转换，在对uint8进行加减时会产生溢出，可能提示的错误为： 1Function ‘*’ is not defined for values of class ‘uint8’ 1个字节无符号整型最大只能存储数据为255，对图片的操作所以很容易溢出。 2. matlab图像类型转换 matlab读入图像的数据是uint8，而matlab中数值一般采用double型（64位）存储和运算。所以要先将图像转为double格式的才能运算，区别如下：1img = imread(&apos;./1.jpg&apos;); % 读入是unit8型(0~255)数据I1 = im2double(img); % 把图像转换成double精度类型（0~1）I2 = double(img)/255; % uint8转换成double,作用同im2double 这里补充说明一下，im2double( )和double( )的区别。double( img)就是简单的数据类型转换，将无符号整型转换为双精度浮点型double，但是数据大小没有变化，原本数据是0~255之间，转化后还是0~255。例如原来是255，那么转换后为255.0，小数位0个数是由double数据长度决定，实际数据大小还是255，只不过这个255已经是double类型空间存储了，再增加不会发生溢出情况。而im2double(img)则不仅仅是将uint8转换到double类型，而且把数据大小从0~255映射到0~1区间。 另外需要补充说明下面这种情况：1img = imread(&apos;./1.jpg&apos;);I1 = double(img);I2 = im2double(I2); % I2数据依然是0~255，并不是0~1，即I1=I2 因为I1已经是double类型，imdouble不会对double类型数据0~255映射到区间0~1，所以上面im2double操作没有任何作用，I1和I2相等。 总结如下：函数im2double将输入转换成double类型。如果输入是uint8、unit16 或者是二值的logical类型，则函数im2double 将其值归一化到0～1之间，当然就是double类型的了。如果输入本身就是double类型，输出还是double类型，并不进行映射。 如果已经是double类型的数据需要映射，则进行下面操作即可： 1I2 = I1/255; 3. matlab图像显示imshow类型问题 在matlab处理完数据好，我们希望显示或者imwrite写入图片时候，需要注意。如果直接对double之间的数据矩阵I运行imshow(I)，我们会发现有时候显示的是一个白色的图像。 这是因为imshow()显示图像时对double型是认为在0~1范围内，即大于1时都是显示为白色，而imshow显示uint8型时是0~255范围。所以对double类型的图像显示的时候，要么归一化到0~1之间，要么将double类型的0~255数据转为uint8类型。解决方法如下：1imshow(I/255); % 将图像矩阵转化到0-1之间imshow(I,[]); % 自动调整数据的范围以便于显示inshow(uint8(I)); % 转成uint8 4. uint和double数据转换的深入说明 double和uint8、uint16之间数据转换有下面的函数：123im2double(); % 将图像数组转换成double精度类型im2uint8(); % 将图像数组转换成unit8类型 im2uint16(); % 将图像数组转换成unit16类型 当然，当图像数据是double类型的0~1之间，下面两者操作是等价的：12I1=im2uint8(I);I2=uint8(round(I*255)); 但是matlab默认double类型图片数据是位于0~1之间的，而uint8是位于0~255。所以如果矩阵数据图像是double类型（0~1之间）可直接im2uint8，这样不仅完成数据类型转换，而且将0~1之间映射为了0~255之间的数据。但是如果图像矩阵数据是double类型的0~255，直接im2uint8转换的话，matlab会将大于1的数据都转换为255，0~1之间的数据才会映射到0~255之间整型的数据。例如下面程序：1img64 = [1,2,3,4];I8 = im2uint8(img64); % I8结果为[255255255255] 5. mat2gray()和im2double()区别 这两个如果都是对uint8数据操作，区别就在于前者是归一化操作，归一化后也在0~1之间，自然结果也是double类型，后者是将数据从0~255映射到0~1。例如： 123I = uint8([1,1,2,3]);I1 = mat2gray(I); % 归一化，I1结果是double型[0,0,0.5,1]I2 = im2double(I); % 映射化，I2结果是double型[0.0039,0.0039,0.0078,0.0118] 可以看出，虽然两者都是一种归一化，im2double只不过最大值永远是常数255，最小值永远是0，如下：1I−0.0255.0−0.0 而mat2gray最大值和最小值都是当前矩阵中最大最小的值，如下：1I−min(I)max(I)−min(I) 另外补充一个函数，mat2str()是将数型转换为字符串类型，一般在批量处理图片，给保存图片格式的名称中有作用，这样就不需要格式化sprintf操作了，非常方便。 资源来源：https://www.cnblogs.com/psztswcbyy/p/7489516.html 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红外图分特点析及红外图像分割]]></title>
    <url>%2F2019%2F10%2F18%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_IRImageSeg%2F</url>
    <content type="text"><![CDATA[红外图分特点析及红外图像分割 红外热图像所有高于绝对零度（-273℃）的物体都会发出红外辐射。红外热成像仪是利用红外探测器、光学成像物镜和光机扫描系统接受被测目标的红外辐射能量分布图形反映到红外探测器的光敏元上，在光学系统和红外探测器之间，有一个光机扫描机构对被测物体的红外热像进行扫描，并聚焦在单元或分光探测器上，由探测器将红外辐射能转换成电信号，经放大处理、转换或标准视频信号通过电视屏或监测器显示红外热像图。 这种热像图与物体表面的热分布场相对应，但实际被测目标物体各部分红外辐射的热像分布图由于信号非常弱，与可见光图像相比，缺少层次和立体感，因此，在实际过程中为更有效地判断被测目标的红外热分布场，常采用一些辅助措施来增加仪器的实用功能，如图像亮度、对比度的控制，实标校正，伪色彩描绘等高线和直方进行数学运算和处理等。红外热图像是人眼不能直接看到目标的表面温度分布，变成人眼可以看到的代表目标表面温度分布的热图像。 红外图特点由于红外图像是通过“测量”物体向外辐射的热量而获得的，与可见光图像相比有以下特点： 1、分辨率差2、对比度低3、信噪比低4、视觉效果模糊5、信息量少 红外图分割红外图信息量少，根据红外图明显的亮度特征，可以考虑阈值分割， 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>图像处理</tag>
        <tag>图像分割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iphone拍照的历史顽固问题-鬼影]]></title>
    <url>%2F2019%2F10%2F07%2FISP_%E9%AC%BC%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[iphone11系列拍照的历史顽固问题-鬼影 iphone11 系列的鬼影问题近期苹果 iPhone 11 系列的手机又出现了新问题，其中有不少网友表示，自己在用手机拍照后，图片中莫名出现了“鬼影”的现象，这次的“鬼影门”是指手机对着灯光拍照时，手机屏幕内会出现倒影和炫光。 知乎上的相关讨论 拍摄作者是’木西AlexanDENG’，一名专业摄影师，拍摄手机是分别是 iPhone XS 自动测光单张拍摄 和 iPhone 11 Pro Max 自动测光单张拍摄和Mate30 Pro 自动测光单张拍摄 图1 iPhone XS 自动测光单张拍摄 图2 iPhone 11 Pro Max 自动测光单张拍摄 图3 Mate30 Pro 自动测光单张拍摄 从他拍的图片上我们可以看到，在iphone拍摄的图片的上方有鬼影。这种现象在晚上格外的明显，给用户带来了很大的烦恼，用户体验较差。 鬼影产生的原理趣体验评测的科普 不论是专业相机还是手机，能成为拍照系统的几个重要组成部分中，除了影像传感器外，就是镜头。而镜头是由多枚镜片构成的，大部分镜片由玻璃或塑料等材料制造的，如果不进行特殊处理，镜片表面就容易形成反射光。 当在夜景或者暗光环境下拍摄强光时，强光进入镜头，内部的各枚镜片的表面就会和传感器等形成反射，从而就形成了“鬼影”。 专业相机出现鬼影的情况比较少，因为专业相机把图像效果放在第一位，并且使用先进高成本的镜头镀膜工艺，来减少鬼影情况。而手机终端在日常生活中使用场景复杂，会兼顾考虑到镜头成本和镜头耐磨性，新推出的iphone 11系列配备蓝宝石镜头就是提高镜头的耐磨性，但是按照摄影师’木西AlexanDENG’拍的样片来看，iphone的鬼影问题并不是新一代引入的问题。 华为联合徕卡，镜头镀改善鬼影情况而华为在P9系列之后的旗舰手机都会给镜头镀膜来减少鬼影。 媒体报道徕卡与华为的合作 12345678910111213141516171819202122232425手机虽小，五脏俱全。除了尺寸小一点，手机拍照机构的每个部分都和数码相机相对应。但手机的光学设计，有着天然的限制：塑料镜头的光学素质跟光学镜片之间有差距；由于尺寸的限制，传统光学镜头的设计经验可能无法完全继承；镜头模组的加工难度较大，必须考虑生产的良率、量产和成本。所以，当徕卡专家提出镜头模组的光学设计指标时，挑战就排山倒海地来了：发展1 -- 如何提升镜头模组的良率？光学系统的设计在高中低各个频段达到均衡，才能保证图像的细节、层次和轮廓的品质。同时，徕卡专家在镜头的鬼影和炫光指标上也提出了很高的要求。鬼影和炫光是指在有较强的光线进入到镜头里，因为在镜片间多次反射，从而在视野中形成了像骷髅头一样的影子（鬼影）和点状的光斑（炫光）；绝大部分情况下，鬼影和炫光的影响要通过光学系统的设计，尽可能降到最低。徕卡把他们的测试方法介绍给华为的专家和我们的供应商时，把大家都惊呆了。因为徕卡测试鬼影和炫光用的光源相当于投影机的光源，比我们平时用的测试光源强了几十倍，因为只有在这种极端的强光源下，才能彻底暴露镜头在鬼影和炫光上的缺陷。徕卡坚持把徕卡镜头的测试标准用在手机镜头测试，因为这是优秀图像的基础。前面说过，要做出一组符合要求的镜头是可能的，但是要满足大规模量产的要求和成本要求，还要克服更大的工程挑战。一开始的试制良率结果是令人崩溃的，类似于每做出100组镜片，最后只能出品不超过10套符合要求的双镜头模组。我们的光学技术团队接受了这个挑战，事实证明在追求极致的路上华为的研发人是不妥协的，除了聚焦攻克技术难题，还与供应商与徕卡的专家并肩作战，徕卡的专家团队多次和我们一起拜访生产厂家，一起讨论改进方案，充分发挥他们在光学系统设计和生产上的经验，指导我们如何调整镜片形状和间隔，如何考虑周边系统对光学部分的影响。在大家夜以继日的努力下，良率在不断提升，终于在最终deadline来临前，达到了量产的标准。P9/P9 Plus的镜头是真正徕卡品质的镜头，属于SUMMARIT系列（光圈2.2-2.5）。大家可以试一下，用手机对着一个强光源拍照，可以发现很少鬼影和炫光，光晕柔和，稍加调整，就可以拍出不错的“吃光”作品。试产时的每一批次镜头，都要拍摄大量样张做评测。有一次，徕卡专家针对一批和某TOP品牌手机的对比样张，给出了热情洋溢的评测结果。仔细看了他的评测意见，主要是学习从专家的角度如何从样张上评价光学素质；按照他的观点，镜头的素质已经达到业界一流的水准。这封邮件对我们团队的信心提升很大，但同时也带来了新的担心：毕竟这是专家的视角，众多的普通消费者不会这么去看一张图片，我们如何从消费者的角度去呈现一张优秀的照片？发展2 -- 力出一孔，只为表现出“色”——如何拍出有“徕卡味儿”的照片华为负责图像质量的专家最先和徕卡专家交流时，是轻松愉快的，因为发现在对图像的客观评估方面，双方使用的测试仪器和平台都是一样的，这就使交流有了共同的语言。但是很快我们发现徕卡使用的测试标准要高很多！比如用来测试色彩还原的色卡，我们一般测试要求准确还原几十个色块就不错了，徕卡的标准是140个色块的准确还原。要达到徕卡的标准，对手机的器件、ISP算法以及后处理都提出了更高的要求。图像质量的测试包括颜色、对焦、纹理、噪声、畸变、动态等很多个维度，这是一个综合的系统工程；同时，对图像的评测分为客观和主观两个部分。客观的指标是可量化可重复的，主观的评测主要是针对有代表性的场景。研发多媒体部有一个专门的图像评测团队，光是有代表性的固定场景就有100多种，还有随机的场景。我们邀请了摄影协会的很多同事来帮我们做Beta测试，他们不仅提供了各种场景下的照片，而且即时反馈了很多的技术问题，和我们的专家一起分析；他们有精湛的摄影技术，而且给我们提供了第一批精彩的样片。P9摄影的成功有他们重要的贡献！ 文章中提到，徕卡对于鬼影的要求更高，这促进的手机成像的改进和优化。 小结iphone 11的这个问题属于设计缺陷。除了镀膜的问题还有可能是镜片排列及距离的问题。iPhone的祖传鬼影问题一直没有妥善解决，愧对其旗舰机的地位。在大连拍摄测评时我们发现不论是MATE30还是NEX3，鬼影都没有这么严重，甚至可以说好得多。而随着这代iPhone感光能力增强，夜景曝光向右，在黑暗背景里出现的眩光比前几代更加明显。 总之，这次iphone 11系列出现的问题不是小问题，影响程度非常大，以至于在逆光，光比强的白天，夜景灯光，等场景都无法使用。更不是很多人说的所谓“正常，很有可能是因为镜片镀膜存在问题。 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[光敏电阻遇上日夜切换]]></title>
    <url>%2F2019%2F09%2F27%2FISP_ICR_%E5%85%89%E6%95%8F%E7%94%B5%E9%98%BB%2F</url>
    <content type="text"><![CDATA[光敏电阻遇上日夜切换 光敏电阻简介光敏电阻是用硫化隔或硒化隔等半导体材料制成的特殊电阻器，其工作原理是基于内光电效应。光照愈强，阻值就愈低，随着光照强度的升高，电阻值迅速降低，亮电阻值可小至1KΩ以下。光敏电阻对光线十分敏感，其在无光照时，呈高阻状态，暗电阻一般可达1.5MΩ。光敏电阻的特殊性能，随着科技的发展将得到极其广泛应用。 光敏电阻工作原理光敏电阻器是利用半导体的光电导效应制成的一种电阻值随入射光的强弱而改变的电阻器，又称为光电导探测器；入射光强，电阻减小，入射光弱，电阻增大。还有另一种入射光弱，电阻减小，入射光强，电阻增大。 光敏电阻分类根据光敏电阻的光谱特性，可分为三种光敏电阻器：紫外光敏电阻器、红外光敏电阻器、可见光光敏电阻器。 1、紫外光敏电阻器：对紫外线较灵敏，包括硫化镉、硒化镉光敏电阻器等，用于探测紫外线。 2、红外光敏电阻器：主要有硫化铅、碲化铅、硒化铅。锑化铟等光敏电阻器，广泛用于导弹制导、天文探测、非接触测量、人体病变探测、红外光谱，红外通信等国防、科学研究和工农业生产中。 3、可见光光敏电阻器：包括硒、硫化镉、硒化镉、碲化镉、砷化镓、硅、锗、硫化锌光敏电阻器等。主要用于各种光电控制系统，如光电自动开关门户，航标灯、路灯和其他照明系统的自动亮灭，自动给水和自动停水装置，机械上的自动保护装置和“位置检测器”，极薄零件的厚度检测器，照相机自动曝光装置，光电计数器，烟雾报警器，光电跟踪系统等方面。 光敏电阻的作用光敏电阻器一般用于光的测量、光的控制和光电转换（将光的变化转换为电的变化）。常用的光敏电阻器硫化镉光敏电阻器，它是由半导体材料制成的。光敏电阻器对光的敏感性（即光谱特性）与人眼对可见光（0.4~0.76）μm的响应很接近，只要人眼可感受的光，都会引起它的阻值变化。设计光控电路时，都用白炽灯泡（小电珠）光线或自然光线作控制光源，使设计大为简化。 随着的光照强度的增加，光敏电阻的阻值开始迅速下降。若进一步增大光照强度，则电阻值变化减小，然后逐渐趋向平缓。在大多数情况下，该特性为非线性。 可见光敏电阻具有灵敏度高，反应速度快，稳定可靠的特点，根据光敏电阻的这个特性，可用它来设计光控可调光电路，光控开关等。 安防摄像机上的用途光敏电阻模块对环境可见光强最敏感，一般用来检测周围环境的亮度和光强。应用在监控摄像机上可以辅助判断切换日夜模式，在白天可见光充足的条件下，光敏电阻阻值较低，其光敏电阻模块电压较高，可以作为可见光充足的判断条件。摄像机在白天使用红外截止滤光片，过滤掉红外光，避免红外光对图像的干扰。在夜晚可见光不够的低照度场景中，光敏电阻阻值较高，其光敏电阻模块电压较低，可以作为可见光不够的判断条件。摄像机在白天使用全透滤光片，图像切换到黑白模式。 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滤光片相关]]></title>
    <url>%2F2019%2F09%2F21%2Ffilter%2F</url>
    <content type="text"><![CDATA[滤光片相关 滤光片相关 滤光片作为一种光学元器件，是用来选取所需辐射波段的工具，是塑料或玻璃片再加入特种染料做成的，其主要特点是尺寸可做得相当大。薄膜滤光片，一般通过长波较长的光，常用作红外高透滤光片。后者是由高折射率或低折射率的金属介质金属膜或一定厚度的全介质膜通过真空镀膜在一定的衬底上形成的一种低阶、多级串联固体干涉仪。 滤光片分类红外截止滤光片英文名叫IR-cut filter，它放在于LENS与Sensor之间。因人眼与CMOS传感器对各波长的光响应不一样，人的肉眼看不到红外光，但传感器可以感受近红外光，这样会造成sensor对红光感受过强，形成色偏。因此需要红外截止滤光片阻隔近红外光。主要在超薄光学玻璃上镀制IR-cut膜，使之能与镜头产品进行叠装组合。 IR-cut滤光片分为反射式及吸收式两种。反射式IR-cut滤光片在可见光波段有较高透过率，同时有较低的反射率，而在红外区域正好相反，反射较高。因此，当相机以一定角度拍摄时，红外光会对胶片产生较大的反射。当光线被透镜组反射多次后，就会在照片上形成光晕。 吸收式IR-cut滤光片是采用蓝玻璃，它本身是一种吸收玻璃，玻璃中的铜离子对红外线有吸收作用，不存在很大反射，当相机在成角度拍摄照片时，光线通过蓝玻璃的主要吸收，经镜头组多次反射的红外光很弱，不会在照片上形成光晕现象。 IR-cut滤光片主要应用于手机摄像头、数码相机、数码摄像机、电脑摄像头、安防监控器（CCTV）摄像头、可视电话、可视门铃等CCD/CMOS数码成像系统，能有效改善红外线对CCD/CMOS成像的影响，防止图像传感器产生的伪色和波纹，提高彩色CCD、CMOS图像传感器有效分辨率和彩色还原性。 日夜两用双通滤光片红外光在白天等可见光条件下对彩色监视摄像机来说是一种杂散光，会降低彩色监视摄像机的清晰度和色彩恢复性。目前有两种方法可以让彩色监控摄像头在夜晚的条件下感应到红外光。 首先，打开滤光片，用可见光覆盖红外线。在没有可见光的情况下，取下滤光片，让红外线进入。该方案获得了良好的图像质量，但需要使用一种称为切换器的硬件。不仅会增加成本，而且开关的故障率也很高。 第二，在滤光片上打开一个特定的红外线通道，允许与红外灯波长相同的红外光线进来，这就是日夜两用双通道滤光片，该滤光片由光学玻璃基体以及沉积在光学玻璃基体上的滤光膜组成，可阻断混合光源中的紫外线和红外线，有助于数码相机CCD或CMOS不再受紫外线和红外线的信号影响，得到更加鲜明清晰的影像；同时该滤光片还能根据红外灯的不同特性有选择性地通过部分红外光谱，起到增强数码相机的夜视功能的效果。 日夜两用滤光片能通过可见光420nm-620nm和850nm的红外光，阻止近红外线920nm-1100nm的红外光，白天可以获得真彩色图像，晚上可以获得清晰的黑白图像。主要用于CCD芯片彩色摄像机和CMOS成像系统，安防监控器摄像头，数码相机，网络摄像机，可视电话，门铃，数字望远镜，车牌识别摄像机等，抗强光和杂光干扰能力强，色彩失真少。 摄像用滤光片的主要作用有：滤除红外线彩色CCD也能感应红外线，因为它能感应红外线，这将导致无法计算出正确的颜色，所以你必须添加一个过滤器来分离红外线部分的光线，所以只有彩色CCD需要安装的过滤器，而不是黑白。 修整进来的光线由于CCD由许多光感受器（细胞）组成，光直接进入，但为了避免干扰相邻的光感受器，需要对光进行修剪。因此，过滤器不是玻璃，而是石英。它利用石英的物理偏振特性来保持入射光的直射部分，反射斜射部分，避免影响附近的敏感点。 安防监控用的滤光片有什么功能？现在的摄像机都有夜视功能，这个夜视靠的是什么能在完全黑暗的状态下看到物体，靠得是红外灯LED发出红外光，反射后进入CCD成像的，这样就出现一个矛盾。为了滤除白天太阳产生的红外光，我们将蓝色玻璃粘贴在CCD前面，将红外光切断，LED夜间发出的红外光被蓝色玻璃滤除，无法成像。如何解决这一矛盾？在白天截止红外光使图像清晰、真实，晚上又能使LED发出的红外光完全进入CCD完成夜视功能这就是双滤光片的功能了，它是靠一个机械装置来完成白天在CCD前面放截止红外光的滤光片，到了夜晚自动切换成全通透的滤光片，这样就满足了红外夜视摄像机的要求。这种机械装置称为双滤波器切换器。 彩色滤光片分类吸收型彩色滤光片吸收型彩色滤光片是借助材料对可见光的吸收作用实现滤光的，常见的照相机/摄像机滤色片实际上是一种混有颜料的有色玻璃，利用了颜料对光的选择性吸收，它可以帮助实现白平衡或者破坏白平衡，使画面色彩正常或者偏向某一色彩。这种滤光片也可以用于显微镜，帮助校正色差或提高分辨率，也有均匀减弱光强，不改变光谱成分的中性滤光片，它依靠吸收率高的金属层工作，一般用来衰减入射光强。由于一些颜料经过长时问的紫外线照射会分解，对光的吸收能力降低，所以某些吸收型彩色滤光片并不耐久，平板显示中使用的吸收型彩色滤光片有60％的光损耗，降低了它的光能利用效率。 光学薄膜彩色滤光片光学薄膜滤光片通过多层薄膜结构对在其中传播的光的相位或振幅进行调整，使一定波段内光的偏振态被改变或者强度重新分布。光学薄膜滤光片一般包括带通滤光片、截止滤光片和特殊用途的其他滤光片，常用于光谱仪器、光谱修正、光通讯、激光系统等领城。光学薄膜彩色滤光片其有以下优点： 1、性质稳定，不易褪色 2、反射或透射率高，色彩鲜艳 3、材料环保，生产过程污染小 镀膜工艺蒸发沉积镀膜技术在蒸发沉积镀膜技术中，真空室中源材料被电子束加热或蒸发，蒸气在光学表面凝结。在蒸发过程中，通过精确控制加热、真空压力、基片定位和旋转，可以获得比厚度均匀的光学涂层。蒸发这种技术性质比较温和，就会导致涂层变得松散或多孔。这种疏松涂层具有吸水性，改变了薄膜的有效折射率，导致性能下降。离子束辅助沉积可以增强蒸发涂层，其中离子束将对准基片表面。这增加了源材料与光学表面的附着力，产生更大的应力，并使涂层更致密、更耐用。 离子束溅射（IBS）镀膜技术当离子束溅射时，高能电场会加速离子束的产生，这个加速度给离子很大的动能。当与源材料碰撞时，离子束溅射出目标的原子。这些溅射靶离子（由于电离区的影响原子转变为离子）也具有动能，在与光学表面接触时会产生致密的薄膜。 等离子体溅射镀膜技术等离子体溅射是一系列技术的总称，如先进的磁控溅射和等离子体溅射，不管该技术如何，包括等离子体的产生，等离子体中的离子被加速进入源材料，与松散的能量源离子碰撞，然后溅射到目标光学元件上。虽然不同类型的等离子溅射具有其独特的特性和优点和缺点，但是这种涂覆技术比本文所涉及的其它涂覆技术要小得多。 原子层沉积镀膜技术与蒸发沉积不同，原子层沉积的源材料不需要从固体中蒸发，而是直接以气体的形式存在，尽管该技术使用气体，但是在真空室中仍然需要高温。在ALD过程中，气体前驱体通过非重叠脉冲传输，脉冲是自限幅的，该工艺具有独特的化学设计，每个脉冲仅粘附一层，并且对于光学部件的表面几何形状没有特殊要求，因此，这一工艺可以使我们控制涂层厚度和设计，但它会降低沉积速率。 参考文章 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>ISP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像增强—自适应直方图均衡化（AHE）-限制对比度自适应直方图均衡（CLAHE）]]></title>
    <url>%2F2019%2F09%2F21%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%A2%9E%E5%BC%BA_CLAHE%2F</url>
    <content type="text"><![CDATA[图像增强—自适应直方图均衡化（AHE）-限制对比度自适应直方图均衡（CLAHE） 一、自适应直方图均衡化(Adaptive histgram equalization/AHE)1.简述自适应直方图均衡化(AHE)用来提升图像的对比度的一种计算机图像处理技术。和普通的直方图均衡算法不同，AHE算法通过计算图像的局部直方图，然后重新分布亮度来来改变图像对比度。因此，该算法更适合于改进图像的局部对比度以及获得更多的图像细节。不过，AHE有过度放大图像中相同区域的噪音的问题，另外一种自适应的直方图均衡算法即限制对比度直方图均衡（CLAHE）算法能有限的限制这种不利的放大。 2. 普通直方图均衡算法与AHE算法的解释普通的直方图均衡算法对于整幅图像的像素使用相同的直方图变换，对于那些像素值分布比较均衡的图像效果比较好。然后，如果图像中包括明显比图像其它区域暗或者亮的部分，在这些部分的对比度将得不到有效的增强。 AHE算法通过对局部区域执行响应的直方图均衡来改变上述问题。该算法首先被开发出来适用于改进航天器驾驶舱的显示效果。其最简单的形式，就是每个像素通过其周边一个矩形范围内的像素的直方图进行均衡化。均衡的方式则完全同普通的均衡化算法：变换函数同像素周边的累积直方图函数（CDF）成比例。 图像边缘的像素需要特殊处理，因为边缘像素的领域不完全在图像内部。这个通过镜像图像边缘的行像素或列像素来解决。直接复制边缘的像素进行扩充是不合适的。因为这会导致带有剑锋的领域直方图。 3. AHE算法的缺点算法设定的邻域参数小，对比度得到增强，邻域参数大，则对比度会降低。 当某个区域包含的像素值非常接近，其区域的直方图就会尖状化，此时直方图的变换函数会将一个很窄范围内的像素映射到整个像素范围。这将使得某些平坦区域中的少量噪音经AHE处理后过度放大。 二、限制对比度自适应直方图均衡（Contrast Limited Adaptive histgram equalization/CLAHE)1.简述CLAHE同普通的自适应直方图均衡不同的地方主要是其对比度限幅。这个特性也可以应用到全局直方图均衡化中，即构成所谓的限制对比度直方图均衡（CLHE），但这在实际中很少使用。在CLAHE中，对于每个小区域都必须使用对比度限幅。CLAHE主要是用来克服AHE的过度放大噪音的问题。 这主要是通过限制AHE算法的对比提高程度来达到的。在指定的像素值周边的对比度放大主要是由变换函数的斜度决定的。这个斜度和领域的累积直方图的斜度成比例。CLAHE通过在计算CDF前用预先定义的阈值来裁剪直方图以达到限制放大幅度的目的。这限制了CDF的斜度因此，也限制了变换函数的斜度。直方图被裁剪的值，也就是所谓的裁剪限幅，取决于直方图的分布因此也取决于领域大小的取值。通常，直接忽略掉那些超出直方图裁剪限幅的部分是不好的，而应该将这些裁剪掉的部分均匀的分布到直方图的其他部分。如下图所示。这个重分布的过程可能会导致那些倍裁剪掉的部分由重新超过了裁剪值（如上图的绿色部分所示）。如果这不是所希望的，可以不带使用重复不的过程指导这个超出的部分已经变得微不足道了。 2. 通过插值加快计算速度如上所述的直接的自适应直方图，不管是否带有对比度限制，都需要对图像中的每个像素计算器领域直方图以及对应的变换函数，这使得算法及其耗时。 而插值使得上述算法效率上有极大的提升，并且质量上没有下降。首先，将图像均匀分成等份矩形大小，如下图的右侧部分所示（8行8列64个块是常用的选择）。然后计算个块的直方图、CDF以及对应的变换函数。这个变换函数对于块的中心像素（下图左侧部分的黑色小方块）是完全符合原始定义的。而其他的像素通过哪些于其临近的四个块的变换函数插值获取。位于图中蓝色阴影部分的像素采用双线性查插值，而位于便于边缘的（绿色阴影）部分采用线性插值，角点处（红色阴影处）直接使用块所在的变换函数。 这样的过程极大的降低了变换函数需要计算的次数，只是增加了一些双线性插值的计算量。 效果对比测试图像，见下图： 直方图均衡化图像(HE)，见下图： 自适应直方图均衡化参数1（AHE），见下图：自适应直方图均衡化参数2（AHE），见下图： 限制对比度自适应直方图均衡（CLAHE），见下图： 从效果上来看，CLAHE算法效果比较好，提亮了暗处，高亮处不至于过曝；AHE算法需要添加参数，参数不同，影响增强效果不同，并且影响很大；HE算法全局提亮，整体略亮。 感兴趣的同学可以到我的github下载这些代码运行看看，链接如下：Matlab代码链接 参考文章参考文章参考文章参考文章 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>图像处理</tag>
        <tag>图像增强</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理评价指标之模糊度（更新中）]]></title>
    <url>%2F2019%2F09%2F21%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87_%E6%A8%A1%E7%B3%8A%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[图像处理评价指标之模糊度 图像和视频在采集、压缩、传输、存储过程中，无可避免地会引入失真。模糊失真是图像、视频质量下降最主要的因素之一，研究图像模糊度评价方法有非常重要的意义。通过对模糊失真进行评测和度量，可以对整个图像传输或处理系统的质量进行监控，进而采取措施提高系统性能 模糊度和清晰度概念图像模糊是一种很重要的图像降质因素，在图像获取、传输、处理过程中都有很多因素可能造成图像模糊，比如在获取图像时，不正确的聚焦会产生离焦模糊，景物和照相机的相对运动会造成运动模糊，图像压缩后的高频丢失造成的模糊。模糊降低了图像的清晰度，严重影响图像质量，导致图像分析、处理、接收的困难甚至失败，因此必须要使用有效的模糊评价方法来控制模糊图像的使用，从而提高系统整体性能。模糊度和清晰度是描述图像清晰程度（模糊程度）的两个相对但又相互联系的两个概念。图像越清晰，质量越高，清晰度越大，模糊度越小；图像越不清晰（越模糊），质量越低，清晰度越小，模糊度越大。因此描述一幅图像清晰程度时，既可以使用清晰度也可以使用模糊度，只是两个指标数值上成反比；本文采用模图像模糊度评价研究模糊度来描述。 客观评价也可以根据对参考图像的依赖程度分为：全参考图像模糊度评价（Full Reference Image Blur Assessment，FR-IBA）、部分参考图像模糊度评价（Reduced Reference Image Blur Assessment，RR-IBA）、无参考图像模糊度评价（No Reference Image Blur Assessment，NR-IBA）。客观模糊度评价的方法也可以参考客观图像质量评价的方法，但由于只关注模糊度一个指标，在算法设计时更有针对性，应该把重点放在模糊特征参量的提取上。 模糊度评价算法可以分成几个较大的类别，（1）基于像素的技术，包括分析像素灰度值的统计特性以及像素之间的相关性；（2）基于变换域的技术，这利用了在变换域高频成分越多图像越清晰，高频成分越少图像越模糊的原理；（3）基于图像梯度的技术，它利用图像边缘的梯度来衡量图像模糊程度，梯度越大图像越清晰。另外，也有较少的算法是基于直方图。 模糊度分类实际应用中有多种模糊情况，模糊产生的原因很多，一般用下面通用的数学模型来表示图像模糊降质 g(x, y) = f(x, y) \otimes d(x, y) + n(x, y)式中$f (x, y)$是原始图像，$d(x, y)$是点扩散函数（Point Spread Function，PSF），$\otimes$ 是卷积，$n(x, y) $是加性噪声。 1、运动模糊运动模糊是在捕获图像时，快门在打开时间内成像系统和拍摄对象的短暂相对运动，造成成像在某个方向上形成的模糊。 假设图像$f (x, y)$ 在一个平面运动，令$x_0(t) $、$y_0(t) $分别是$x$ 和$y$ 方向上运动的变化分量，$T$ 表示曝光时间，那么模糊后的图像可以看作是在快门开启时间内原始图像在$x$ 、$y$ 方向上的积分： g(x,y)=\int_0^T f[x-x_0(t) , y - y_0(t)] dt2、压缩模糊压缩模糊是图像在进行有损压缩丢失部分信息。 3、高斯模糊高斯模糊是人为引入的一种模糊，使用高斯低通滤波器对原始图像进行滤波得到的。它的点扩散函数可以表示为 d(x,y) = \frac{1}{2 \pi\sigma^2 }* e^ {- \frac{(x^2 +y^2)} {2 \sigma^2 }}模糊度计算方法模糊度的计算可以广泛应用到相机自动聚焦、显微镜自动聚焦、电子显微镜自动聚焦等场景。 1、灰度方差算法该算法以图像所有像素的灰度平均值为参考，对每个像素点的灰度值求差后求平方和，然后用像素总数标准化，它表征了图像灰度变化的平均程度，灰度变化的平均程度越大，图像越清晰，灰度变化平均程度越小，图像越模糊。 2、Roberts 梯度和定义为相邻四个像素对角线像素灰度值差的绝对值之和 s =\sum (f(x,y) - f(x+1,y+1) )+(f(x+1,y)-f(x,y-1))3、拉普拉斯梯度和1f(x,y)+f(x+1,y)+(f(x,y+1)-f(x,y-1 4、拉普拉斯梯度和2 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10句话读懂图像频域滤波（转载）]]></title>
    <url>%2F2019%2F09%2F21%2FISP_Filter%2F</url>
    <content type="text"><![CDATA[10句话读懂图像频域滤波 今天的图像处理依靠各类方便易用的工具箱与函数库似乎已然成为上手就能用的应用科学。但没有那种算法是普适的，知其所以然才能真正理解原理，深刻的理解才能针对具体应用行成独到见解。图像处理是信号与信息处理学科的分支，图像滤波的理论当然得从信号与系统说起。尽管很多文献都有详细的论述，但如果你对LSI系统、空间卷积、二维傅里叶变换、空域与频域、滤波与变换的理论概念虽耳熟能详但仍一知半解，本文将尽力用简单的文字将这些关系屡屡清楚，总结并告诉我们一些不可不知的图像频域滤波处理基本理论。 10句话读懂图像频域滤波基本理论数字图像信号为离散二维或三维信号。 二维灰度图像 三维视频图像 图像处理很简单，给一幅输入图像x得到一幅输出图像y(n1,n2)，通常将这个过程视为一个二维信号处理系统T： 线性移不变(LSI)系统有很多优良的性质，这类系统必须同时具有线性与空间移不变性：输出对任意输入都满足均匀性与叠加性（合称线性），输出与系统的坐标原点位置无关（移不变性） 单位冲激函数δ(n1,n2)通过LSI系统，输出为系统的冲激响应h(n1,n2)： 想得到输出图像其实不难：若已知LSI系统的冲激响应h(n1,n2)，则输出图像=输入图像与冲激响应的二维卷积： 傅里叶很牛，可将图像信号从空域x(n1,n2)变到到频域X(ω1,ω2)，也可以将图像信号从频域变回空域，(ω1,ω2)分别表示频域中的垂直与水平频率 LSI系统冲激响应h(n1,n2)的傅里叶变换就是该系统的频率响应H(ω1,ω2)，它给出了系统在频点(ω1,ω2)处的响应特性： 有了卷积定理，一切变得简单：LSI系统在空域的二维卷积运算，等于该系统在频域的乘积运算： 结论:频域滤波就是设计合适的LSI系统频谱响应H(ω1,ω2)，即可实现对输入图像中某些频率的放大、衰减或不通过（拒绝）： 那么问题来了，到底怎么分析呢(｡･∀･)ﾉﾞ~图像滤波中所用的滤波核或模板就是系统的冲激响应h，每个滤波核都已其特定的频率响应函数H，例如： 低通滤波器：频率响应曲线中间凸、四周低表示低频部分系数高：低频分量通过，高频被抑制 高通滤波器：频率响应曲线四周高、中间凹表示高频部分系数高：高频分量通过，低频被抑制 P.S. 如果还想更进一步，请参考博文“如何构造频域滤波器——图像频域滤波的信号与系统基本理论”。 版权声明：本文为CSDN博主「iracer」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/iracer/article/details/49311463 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《乌合之众》]]></title>
    <url>%2F2019%2F09%2F21%2Fwuhezhizhong%2F</url>
    <content type="text"><![CDATA[《乌合之众》勒庞的《乌合之众》长期以来都是我的枕边书。今天不知谁整理出了《乌合之众》的60条基本观点，如下： 1.人一到群体中，智商就严重降低，为了获得认同，个体愿意抛弃是非，用智商去换取那份让人备感安全的归属感。 2.我们始终有一种错觉，以为我们的感情源自于我们自己的内心。 3.群体只会干两种事——锦上添花或落井下石。 4.个人一旦成为群体的一员，他所作所为就不会再承担责任，这时每个人都会暴露出自己不受到的约束的一面。群体追求和相信的从来不是什么真相和理性，而是盲从、残忍、偏执和狂热，只知道简单而极端的感情。 5.我们以为自己是理性的，我们以为自己的一举一动都是有其道理的。但事实上，我们的绝大多数日常行为，都是一些我们自己根本无法了解的隐蔽动机的结果。 6.所谓的信仰，它能让一个人变得完全受自己的梦想奴役。 7.在与理性永恒的冲突中，感情从未失过手。 8.有时不真实的东西比真实的东西包含更多的真理。 9.群众没有真正渴求过真理，面对那些不合口味的证据，他们会充耳不闻…凡是能向他们提供幻觉的，都可以很容易地成为他们的主人；凡是让他们幻灭的，都会成为他们的牺牲品。 10.数量，即是正义。 11.掌握了影响群众想象力的艺术，也就掌握了统治他们的艺术。 12.没有传统，就没有文明；没有对传统的缓慢淘汰，就没有进步。 13.孤立的个人很清楚，在孤身一人时，他不能焚烧宫殿或洗劫商店，即使受到这样做的诱惑，他也很容易抵制这种诱惑。但是在成为群体的一员时，他就会意识到人数赋予他的力量，这足以让他生出杀人劫掠的念头，并且会立刻屈从于这种诱惑。出乎预料的障碍会被狂暴地摧毁。人类的机体的确能够产生大量狂热的激情，因此可以说，愿望受阻的群体所形成的正常状态，也就是这种激愤状态。 14.一个国家为其年轻人所提供的教育，可以让我们看到这个国家未来的样子。 15.能够感觉到的现象可以比作波浪，是海洋深处我们一无所知的那些乱象在洋面上的表象。 16.昨天受群众拥戴的英雄一旦失败，今天就会受到侮辱。当然名望越高，反应就会越强烈。在这种情况下，群众就会把末路英雄视为自己的同类，为自己曾向一个已不复存在的权威低头哈腰而进行报复。 17.群体在智力上总是低于孤立的个人，但是从感情及其激发的行动这个角度看，群体可以比个人表现得更好或更差，这全看环境如何。一切取决于群体所接受的暗示具有什么性质。 18.群体因为夸大自己的感情，因此它只会被极端感情所打动。希望感动群体的演说家，必须出言不逊，信誓旦旦。夸大其辞、言之凿凿、不断重复、绝对不以说理的方式证明任何事情——这些都是公众集会上的演说家惯用的论说技巧。 19.令人难忘的历史事件，只是人类思想无形的变化造成的有形的后果而已。 20.孤立的个体具有控制自身反应行为的能力，而群体则不具备。 21.专横和偏执是一切类型的群体的共性。 22.影响民众想象力的，并不是事实本身，而是它们发生和引起注意的方式。 23.群体总是对强权俯首帖耳，却很少为仁慈善行感动！在他们看来，仁慈善良只不过是软弱可欺的代名词。 24.大众没有辨别能力，因而无法判断事情的真伪，许多经不起推敲的观点，都能轻而易举的得到普遍赞同! 25.群体盲从意识会淹没个体的理性，个体一旦将自己归入该群体，其原本独立的理性就会被群体的无知疯狂所淹没。 26.从长远看，不断重复的说法会进入我们无意识的自我的深层区域，而我们的行为动机正是在这里形成的。到了一定的时候，我们会忘记谁是那个不断被重复的主张的作者，我们最终会对它深信不移。 27.群体中的个人是沙中之沙，风可以随意搅动他们。 28.群体表现出来的感情不管是好是坏，其突出的特点就是极为简单而夸张。 29.但凡能够成就大业的领袖人物，他重要的品质不是博学多识，而是必须具备强大而持久的意志力，这是一种极为罕见，极为强大的品质，它足以征服一切。 30.文明向来只由少数知识贵族阶级而非群体来创造。 31.身为一位领袖，如果想要让自己创立的宗教或政治信条站住脚，就必须成功地激起群众想入非非的感情。 32.结群后，由于人多势众，个人会产生一种幻觉，感到自己力大无穷，不可战胜，好像没有什么事情是办不到的。 33.当一个人融入社会之中时，他便失去了自我。 34.在迫不得已的情况下，我们也许还是会愿意接受传统教育当中所有的弊端，因为尽管它只会培养一些被社会所抛弃的人、心怀不满的人，但起码，对冗繁知识的肤浅掌握，对成堆教科书的完美背诵，或许可以提高智力水平。但事实上它真的能提高智力吗？不可能！在生活中，判断力、经验、进取心和个性，这些才是取得成功的条件，这些都不是书本所能够给予的。书本是可供查询的有用字典，但倘若把这些冗长的词条都装在脑子里，那可是一点用都没有。 35.文明赖以形成的道德力量失去效力时，它的最终瓦解总是由无意识且野蛮的群体来完成的。 36.一切政治、神学或社会信条，要想在群众中扎根，都必须采取宗教的形式——能够把危险的讨论排除在外的形式。 37.群体精神最需要的不是自由而是服从。他们如此甘愿听从别人的意志，以至于只要有人自称是它们的主人，他们就会本能地听命于他。 38.尽管在那一天的那两个小时里他们做到了或者几乎做到了，到一个月以后他们却不再具备这种能力。他们无法再次通过考试。他们脑中不断丢失大量过于沉重的知识，而且没有新的知识来填充。他们的思想活力开始衰退，促进成长的才能渐渐干涸，这时一个得到充分发展的人诞生了，但此时的他早已疲惫不堪。结婚过上安定的生活，陷入某种循环，并永无止境地重复下去；他将自己封闭在狭隘的工作中，尽职尽责，仅此而已。他们最终变为了平庸之辈。 39.个人一旦融入群体，他的个性便会被湮没，群体的思想便会占据绝对的统治地位，而与此同时，群体的行为也会表现出排斥异议，极端化、情绪化及低智商化等特点。进而对社会产生破坏性的影响。 40.所有时代和所有国家的伟大政客，包括最专横的暴君，也都把群众的想象力视为他们权力的基础，他们从来没有设想过通过与它作对而进行统治。要想掌握这种本领，万万不可求助于智力或推理，也就是说，绝对不可以采用论证的方式。 41.群体的叠加只是愚蠢的叠加，而真正的智慧被愚蠢的洪流淹没。 42.人们经常说起那家大众剧院，它只演令人压抑的戏剧，散场后，必须保护扮演叛徒的演员，免得他遭到观众的暴打。他所犯的罪行，当然是想象出来的，引起了群众的巨大愤怒。我觉得这是群体精神状态最显著的表现之一，这清楚地说明，要给他们什么暗示是一件多么容易的事情。对他们来说，假与真几乎同样奏效。他们明显地表现出真假不分的倾向。 43.各种制度并没有固定的优点，就它们本身而言，它们无所谓好坏。因为在特定的时刻对一个民族有益的制度，对另一个民族也许是极为有害的 。 44.群体也许永远是无意识的，但这种无意识本身，可能就是它力量强大的秘密之一。在自然界，绝对服从本能的生物，其行为会复杂得让我们不敢相信。理智是人类新近才有的东西，太不完美了，不能向我们揭示无意识的规律，更不能替代它。在我们的行为举止中，无意识部分占的比重很大，理智所占的比例却很小。无意识现在仍作为未知的力量在起作用。 45.到了一定的时候我们不会记得那个不断被重复的主张的人是谁，我们最终会对它深信不疑，广告能有令人吃惊的威力，这就是原因 。 46.教育既不会让人更道德，同样不会使他更幸福，它既不能将他的本能改变 ，也不能将他天生的热情改变，而且有在进行不良引导后，它的害处远大于好处。 47.单独一个人必须要为他的行为承担责任——法律上或者道德上。但是，群体则不然，群体不需要承担任何责任，群体就是责任，群体就是道德，群体就是法律，群体就是道德，群体的行为自然是合理的。 48.名望的产生与若干因素有关，而成功永远是其中最重要的一个。 49.学习课程，把一种语法或一篇纲要牢记在心，重复得好，模仿也出色——这实在是一种十分可笑的教育方式，它的每项工作都是一种信仰行为，即默认教师不可能犯错误。这种教育的唯一结果，就是贬低自我，让我们变得无能。 50.民众的想象力是政客的权力基础。 51.在决定人们历史地位上起着更大作用的，不是他们的“真实”面目，而是后人对他们的认识和感受。 52.群体会让每个人在其中的错误缩小，同时让每个人的恶意被无限放大。 54.束缚个人行为的责任感一消失，人便会随心所欲，肆意妄为。 55.群体的无意识行为取代了个体有意识的行为，这是现时代最显著的特征之一。 56.偶像崇拜的五大标识：第一，偶像总是凌驾于信徒，处于高高在上的地位，这一点有着决定性地作用。第二，信徒总是盲目服从偶像的命令。第三，信徒没有能力，也不愿意对偶像规定的信条进行讨论。第四，信徒有着狂热的愿望，希望把偶像的信条广加传播。第五，信徒倾向于把不接受它们的任何人视为仇敌。当群体符合第一条，其形式就等同于宗教，而这种情感就变成了宗教信仰。对群体来说，也许最不合理的才是最合理的选择 57.群众日益被大众文化所湮没，这种文化把平庸低俗当作最有价值的东西。 58.所以不要轻易地成为集体的一份子，这样很容易被别有用心的人利用，即使你以为自己只不过是随声附和了一下而已，实际上你已经成了帮凶。 59.群体的夸张倾向只作用于感情，对智力不起任何作用。 60.群体不善推理，却又急于行动。 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Raw数据相关概念]]></title>
    <url>%2F2019%2F09%2F15%2FISP_RawData%2F</url>
    <content type="text"><![CDATA[Raw数据相关概念 什么是“RAW”？维基百科的字面解释是：原始图像文件包含从数码相机、扫描器或电影胶片扫描仪的图像传感器所处理数据。RAW文件包含创建一个可视图像所必须的相机传感器数据信息。 通俗讲就是摄像机、相机拍摄并记录下来的带有原始信息的视频或者图片，包含传感器元数据、传感器尺寸、颜色属性、配置文件等等信息，以方便后期对视频及图片做更大幅度的处理。几乎未经压缩，也完全没进行各种处理，与记录拍摄时“用户的相机设置信息”数据被一同保存下来。 既然是原始文件，一定很大，对传输带宽、存储空间都有特别的要求，而且每个摄像机、照相机厂家对自己的原始文件（RAW）开放程度、记录方式等要求都不一样。 Raw格式Q:RAW格式是一种非压缩格式吗？ A:有一部分是。有损压缩表示在压缩处理过程中，部分图像数据将会被丢弃。但是抛弃这些信息后，能得到比无损压缩小得多的文件。有些RAW格式，例如尼康公司的.NEF格式就能通过这种形式进行保存，从而可以得到占据空间更小的文件。但这样做会造成画质的下降，在天空等影调过渡较为平滑的部分表现得尤为明显。 所有JPEG文件均使用有损压缩算法。JPEG文件在保存时会提供一个画质设置供我们选择，我们选择的画质越低，丢弃的图像数据越多，得到的图像文件也就越小。反之，画质较高的JPEG文件和画质较低的相比文件尺寸也更大一些。 Raw数据位数Q:RAW文件的8位、12位、14位、16位等有什么区别？ A:我们拍摄的每张照片均由从黑到白之间的不同影调组成，而“位”则表示黑白之间影调范围的多少。位越大，黑白之间的影调就越丰富。所有的JPEG格式文件都是8位图像文件，因此在黑白之间只包含256级影调变化。而RAW格式文件大多为12位或14位，在黑白之间至少包含4096级影调变化。普遍观点认为，想表达柔和、自然的画面至少需要250级左右的影调，所以包含256级影调变化的8位图像文件能满足大多数情况下的需要。 单反/无反相机上的 RAW 和手机上的 RAW,最大的区别在于描述明暗数据的位深不同。手机的CMOS考虑到成本和功耗，一般使用的是10bit的输出模式，部分单反相机则可以输出12bit，安防类相机可以输出16bit。输出16bit的相机可以展现更细腻的色调和颜色，后期修改空间更大。 RAW格式的优缺点优点1234567*转换结果画质更高。*与生俱来的非破坏性调整能力不会造成任何图像信息的损失。*和标准JPEG格式相比高光、阴影细节更加丰富。*进行色彩、白平衡、锐化等后期调整时范围更大。 缺点123456789*和JPEG相比文件更大。*写入速度慢，会显著影响连拍速率。*编辑处理耗时更长。*交流、输出前需将其转换为JPEG或其他格式。*RAW文件的调整需要一定时间学习。 声明： 此资料部分转载自网络，仅供学习参考。 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>ISP</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3D降噪，视频实时降噪利器]]></title>
    <url>%2F2019%2F09%2F12%2FISP_3DNR%2F</url>
    <content type="text"><![CDATA[3D降噪，视频实时降噪利器 3D降噪原理是对图像中的运动物体采取2D降噪，静止部分（称为背景）采取3D降噪以防止运动物体模糊（blur）。 1）第一步为运动估计 在参考帧（为前一帧已经过降噪的图像）中搜索和当前帧中16*16当前块相近的参考块，其中最相近的块为匹配块。 根据匹配块，获得运动向量（motion vector）。 为减小计算，一般仅在以当前块为中心的一个小范围内搜索参考块，如在20*20的小范围内。 2）滤波模式判断 设置两个门限值： 参考块和当前块差值残差阈值TH1 （通常为一个较小的值，如 5 ~ 20之间） 运动向量阈值TH2 （该阈值通常在+/-1 ~ +/- 3） a）若每一像素点处的残差小于TH1，且参考块和当前块的运动向量值小于TH2，则可认为当前块为背景，即非运动物体。滤波策略是：使能2D滤波，同时使能3D滤波。3D滤波即当前块和参考块的平均。b）若残差大于TH1，则，判断为非背景，只使用2D滤波。c）若残差小于TH1，但运动向量大于TH2，则判断为非背景，只使用2D滤波（因背景几乎是不动的）。 3）梯度计算、边缘判断和快效应改善 计算水平和垂直方向相邻像素的差值，获得一个梯度矩阵。 比较两个方向的梯度大小。若梯度超过设定的阈值，则以值较大的一个方向来计算该点的像素值： pxl_new =( (a+4pxl_old+4c + d)/10 + e )/2 声明：版权声明：本文为CSDN博主「tbzj_2000」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/tbzj_2000/article/details/82466180 此资料部分转载自网络，仅供学习参考。 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>ISP</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BM3D算法的坑]]></title>
    <url>%2F2019%2F09%2F07%2FISP_BM3D%2F</url>
    <content type="text"><![CDATA[BM3D算法的坑 声明： 此资料部分转载自网络，仅供学习参考。 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>ISP</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解同为4800W像素的相机传感器，三星GM1和索尼IMX586区别在哪里？]]></title>
    <url>%2F2019%2F09%2F07%2FISP_4800Wsensor%2F</url>
    <content type="text"><![CDATA[详解同为4800W像素的相机传感器，三星GM1和索尼IMX586区别在哪里？ 数字影像之父Bryce Bayer基于RGB模式，通过在感光元件前加上一个滤镜的方法终于实现了彩色照片。Bayer滤镜跨出了照片从黑白到彩色的一大步，但是对于挑剔的人眼来说，每个像素只有一个颜色是远远不够的，所以还需要后期色彩还原去猜色，最后形成一张完整的彩色照片。这一整套流程，就叫做Bayer阵列。数码相机包括手机拍摄照片的大致流程：感光元件→Bayer滤镜→色彩还原。可以看下图 IMX586是索尼适用于手机的全新堆栈式CMOS感光元件，这颗感光元件有效像素高达4800万。通过Quad Bayer的排列结构变换，合成之后能够将感光度提升至1.6μm像素尺寸的水平。就是说，搭载IMX586传感器的手机，正常模式下是4800万像素，在使用夜景模式时，则会转换成高曝光、低噪点的拍照模式。 IMX586最大的特色就是使用 Quad Bayer 阵列，不同于经典的Bayer阵列是以2x2共四格分散RGB的方式成像，Quad Bayer 阵列扩大到了4x4，并且以2x2的方式将RGB相邻排列。在使用搭载IMX586传感器手机拍照的时候，Quad Bayer 阵列会让每一个像素点就近计算周围的颜色，并且通过独立的信号处理变换像素结构，从而实时输出4800万像素的高清照片。换句话说，IMX586的4800万个感光单元每个都能独立显示并且输出数据。4800万像素的照片是硬件直出的，无需软件插值。 三星GM1的输出方式如下图所示，阵列也扩大到了4x4，但是和IMX586相比，每个2x2阵列只能识别同样的颜色，且只能一起输出数据。也就是说，GM1传感器直出的照片素质跟1200万传感器输出的图像结果大体相同。 索尼imx586及更新的imx600都是可以直出4800W像素的传感器，且用在华为的高端旗舰上，三星GM1是不能直出4800W像素的，用在中端手机终端上，宣传4800W是一个吆喝点。声明： 此资料部分转载自网络，仅供学习参考。参考资料 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>ISP</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XXXTENTACION，音乐使之重生]]></title>
    <url>%2F2019%2F08%2F31%2FRIP_XXXTENTACION%2F</url>
    <content type="text"><![CDATA[XXXTENTACION，音乐使之重生 熟悉的街头却变成炼狱，愿你在另一个地方重获新生。Rest In Peace XXXTentacion - 《Look At Me》 look at me, FXXK me!]]></content>
      <tags>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ISP图像处理——白平衡AWB]]></title>
    <url>%2F2019%2F08%2F25%2FISP_%E7%99%BD%E5%B9%B3%E8%A1%A1AWB%2F</url>
    <content type="text"><![CDATA[ISP图像处理——白平衡AWB 工作原理 白平衡是一个很抽象的概念，最通俗的理解就是让白色所成的像依然为白色，那其他景物的影像就会接近人眼的色彩视觉习惯。调整白平衡的过程叫做白平衡调整，白平衡调整在前期设备上一般有三种方式：预置白平衡、手动白平衡调整和自动跟踪白平衡调整。通常按照白平衡调整的程序，推动白平衡的调整开关，白平衡调整电路开始工作，自动完成调校工作，并记录调校结果。 色温曲线色温的概念,并且知道sensor原始图像中的白色如果不经AWB处理,在高色温(如阴天)下偏蓝,低色温下偏黄,如宾馆里的床头灯(WHY!OTZ) (如下图). 白平衡调整在生活中日光的色温是不断变化的，可以说没有两个地方的色温会完全一样，不同的地域、季节、地面白平衡环境、天气、早晚等等都会对色温造成影响，还有大量的人工光源，色温也不尽相同。摄像师调整白平衡的方法大体分粗调、精细调整和自动跟踪(ATW)三种：粗调指在预置情况下改变色温滤光片，使色温接近到3200K的出厂设置;精细调整是指在色温滤光片的配合下通过摄像机白平衡调整功能，针对特定环境色温得到一个更为精确的调整结果;自动跟踪是指依靠摄像机的自动跟踪功能(ATW)，摄像机自身根据画面的色温变化随时调整。 流程原理很简单: 1,在各个色温下(2500~7500)拍几张白纸照片,假设拍6张(2500,3500…7500),可以称作色温照.2,把色温照进行矫正,具体是对R/G/B通道进行轿正,让偏色的白纸照变成白色,并记录各个通道的矫正参数. 实际上只矫正R和B通道就可以,这样就得到了6组矫正参数(Rgain,Bgain).3,上面是做前期工作,只要知道当前场景是什么色温,再轿正一下就可以了 所以,AWB算法的核心就是判断图像的色温 之前拍了6张色温照以及6组矫正参数. 插值一下可以得到无数个值,我们把点连成线, 得到了色温曲线.大概是下面这个样子. 上面提到了三个值(RG,BG,色温),这应该是个三维的.没关系,我们再来一条RG跟色温的曲线,这样只要知道色温,就知道RG,知道RG,就知道BG,知道RG,BG就能轿正了 至此,我们的前期工作已经全部做完了, 并得到了AWB的色温曲线,下一步只要计算得到当前色温,顺藤摸瓜就能得到当前的矫正参数(Rgain,Bgain),那白平衡的工作就完成了 2，色温计算本节主要讲解了白平衡算法中估算当前场景色温的流程. 简述流程:1, 取一帧图像数据,并分成MxN块,假设是25x25,并统计每一块的基本信息(,白色像素的数量及R/G/B通道的分量的均值). 2, 根据第1步中的统计值, 找出图像中所有的白色块,并根据色温曲线判断色温. 3, 至此,我们得出来了图像中所有的可能色温,如果是单一光源的话,可以取色温最多的,当作当前色温. 比如25x25=625 个块中,一共找出了100个有效白色块, 里面又有80个白色块代表了色温4500左右, 那当前色温基本就是4500. 根据4500色温得出的Rgain,Bgain来调整当前图像 详解步骤第1步, 计算每一块的基本信息. 关于白色像素统计,大家知道sensor原始图像是偏色的,怎么统计块中的白色点呢,那只有设置一个颜色范围,只要在范围中,就可以认为是白色像素,范围见下图: 统计白色像素个数的用处是,1,如果块中的白色像素太少,可以抛弃掉. 2,如果白色像素太多,多到每一个像素点都是,那也要抛弃掉,因为很可能在该区域过曝了 接着把统计到的白色像素点R/G/B取均值, 并得到该block 的R/G, B/G值 至此,我们得到了每一块的白点数目及R/G,B/G的值. (请自动对应第1部分中色温曲线). 第二步 计算当前色温 这个比较复杂, 大自然绚丽多彩,景色万千. 上一步中统计的”白色点”难免会有失误的地方,比较常见的如黄色皮肤容易被误判为低色温下的白点,淡蓝色的窗帘,容易被误判为高色温下的白点,一张图中既有白色,也有黄色,也有蓝色的时候,是不是感觉情况有点复杂,其它的大家可继续脑补. 这时我们需要一定的策略来正确的判断出到哪个才是真的白. 通常我们会把取到的白色块,计算一下到曲线的距离,再设置相应的权重.话不多说,上个图大家就都明白了. 假设有上面这样一幅图,该图是在没有开AWB的前提下截取的,可以看到左边白色地方略有偏绿,当前色温是室内白炽灯,大概4000~5000k左右.(请忽略颜色不正的问题,我们在讨论白平衡) 下面我们就根据之前的统计信息和测量好的色温曲线进行白平衡矫正. 首先要找出白区,如下图: 上面这个图中的数字标示出了检测到的白色区域,数字相同的表示一个白区,根据统计信息(白点数,rg/bg值)来区分的.可以看到有误判的地方,比如色卡左上第二块的肤色块.还有最右边从上面数第二块也是容易被判断成低色温白块的情况. 针对这种误判的情况,对不同块根据统计信息进行权重设置,以求让误判的区域对最终结果影响小一些. 上面这个图标注了权重,基本是根据统计信息中白点数来确定的.可以看到图中一片白色被标识了高权重.其它情况被标识了低权重. 权重高低一是看块中白色点数量,二是看rg/bg到色温曲线的距离. 通过上面两个图,大家就可以明显的找到白色区,并根据曲线来矫正,即使不通过曲线矫正,把白色区的r/g,b/g值向1趋近,让r=g=b,也会得到非常好的白平衡效果.如下图所示: 至此,白平衡的基本流程就讲完了,有图有真相,大家一定看着也方便. 总结一下:第一次做白平衡,感觉理论很简单,不用什么基础也能看懂.实际算法调试时,可谓差之毫厘,失之千里.总是感觉不由自主就走上歪路.中间参考了大量资料,比如网上有许多基于色温/灰度世界/白点检测的白平衡算法,实际个人感觉应该把它们都结合起来,让算法强壮,健康才是我们想要的. 本文转载wzwxiaozheng的白平衡算法，主要包括两部分：色温曲线和色温计算。原文http://blog.csdn.net/wzwxiaozheng/article/details/38434391 声明： 此资料部分转载自网络，仅供学习参考。 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>ISP</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安防行业监控摄像机的四大透雾技术]]></title>
    <url>%2F2019%2F08%2F10%2FISP_%E5%AE%89%E9%98%B2%E9%80%8F%E9%9B%BE%2F</url>
    <content type="text"><![CDATA[安防行业监控摄像机的四大透雾技术 背景随着人类对自然的过度开发，环境问题日益凸显，近年来新增的问题之一则是雾霾的出现，雾霾对视频监控系统提出了严峻考验，主要表现在几个方面：物体表面的反射光由于大气粒子的散射而产生衰减，造成物体成像的亮度减弱，图像色彩暗淡;反射光经大气粒子前向散射作用参与其它像素点成像，导致图像模糊、分辨率下降;部分大气粒子的粒径较大，在成像过程中成为噪声，成像上布满糙点;与成像无关的自然光经过大气粒子的散射，进入图像传感器参与成像，造成图像饱和度、对比度降低及色调偏移，一些重要目标的细节更是难以辨识。 透雾技术主要分为四种： 一代透雾技术-光学透雾一般的可见光无法穿透云雾和烟尘，但近红外线可以穿透一定浓度的雾霭烟尘，根据波长不同需要对摄像机进行处理，以达到对其聚焦的目的,同时还需在摄像机上进行重新设计，来将这一频率的不可见光进行成像，由于这个不可见光没有对应的可见光色彩图，所以呈现的图像为黑白色。透过云雾、水气拍摄物体，相当于透过了两重透镜(水珠与实际透镜)，除了R光线可以正确聚焦在CCD成像面上，RGB光线中的GB均无法正常的投射在CCD成像面上，从而阻碍普通模式镜头从云雾、水气中得到正常、清晰的图像。 透雾镜头是指在红外光领域的长波长光线(700nm-950nm)的透过率非常高,且同时具备能控制这种高波长光线成像面(摄像机CCD靶面)功能的镜头.通过将这种镜头与高性能日夜两用摄像机配套使用,即使在雾气,灰尘,烟雾,小雨等可见光(彩色图像)环境中,普通镜头只能得到模模糊糊画面,有效观察距离大大缩短的恶劣条件下,也可拍摄到非常清晰,高对比度的黑白影像,提升远距离观察效果.利用近红外光线可绕射微小颗粒原理，在薄雾天气采用近红外滤色片、镀膜技术及电子图像增强技术,能穿透薄雾.监控距离达到能见度的1.5倍以上,远距离全天候安全监控不再有盲点。 光学透雾就利用近红外线可以绕射微小颗粒的原理，实现准确快速聚焦。技术的关键主要在镜头和滤光片。 通过物理的方式，利用光学成像的原理提升画面清晰度。缺点是只能得到黑白监控画面。 参考文章 二代透雾技术-数字透雾（算法）为了弥补光学透雾的黑白成像，实现更好的透雾效果，同时减低成本，不少厂商为了进入民用市场开始进一步在透雾技术上做文章，从而出现了第二代透雾技术数字透雾。与光学透雾实现原理不同，数字透雾主要是通过对图像的二次处理，是一种算法矫正，强调图像当中某些感兴趣的特征，抑制不感兴趣的特征，使得图像的质量改善，信息量得到增强。数字算法透雾可根据物理上雾霾的形成模型，通过局部区域灰白程度判断雾霾的浓度，从而复原出清晰的无雾霾图像。采用算法透雾技术能够保留图像的原来色彩，在光学透雾的基础上大幅提升图像透雾效果。 我的文章-经典暗通道去雾我的代码-图像去雾算法Matlab实现 三代透雾技术-光电透雾光电透雾是结合上述两种功能，通过机芯一体化通过内嵌的FPGA芯片和ISP/DSP进行运算处理实现彩色画面输出。一方面，该透雾技术可区分远景、近景，雾气浓淡等因素，选择透雾级别，可实现区域效果最佳，不同于过去对画面对比度整体的提高，且没有延时。另一方面，芯片的高速运算必将产生噪声点，夜间光照不足时影响尤为突出，所以一体机芯普遍需要采用CCD传感器和大光圈镜头，以达到良好的低照效果。它是目前市场上透雾效果最好的技术。 前两种透雾技术各有千秋，却也都存在一定的缺陷，且具有互补性，于是第三代透雾技术便将前两代透雾技术进行融合，打造“光学+算法”的透雾技术，配置低照度性能更好的感光芯片和专门的透雾滤光片，同时配合光学透雾镜头增加了相应的算法透雾，成为目前市场上透雾效果最好的技术。 参考文章 假透雾这主要是通过人为调节对比度、锐度、饱和度、亮度等数值，或做一些滤镜切换装置，让图像重点突出，从而改善主观视觉效果。 缺点是不能对景物重新进行聚焦，难以满足视觉体验。随着工业的发展以及其对气候的影响，雾霾越来越成为一种常见的天气现象，这对户外应用的监控系统的画面品质造成很大的影响。而去雾技术能够从多个角度提升视频监控的质量，可以用于各种有雾天气条件的透雾处理;能明显提升图像的对比度、使图像变通透、清晰;能够显著增强图像的细节信息，使原来被隐藏的图像细节被充分展示;能够提升图像的饱和度，使图像色彩鲜艳活泼、生动，透雾处理后的图像保持准确的色调、自然的外观，因而获得了良好的图像质量与视觉感受 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>ISP</tag>
        <tag>图像处理</tag>
        <tag>安防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客迁移到托管平台Netlify]]></title>
    <url>%2F2019%2F07%2F23%2Fhexo_%E8%BF%81%E7%A7%BB%E6%89%98%E7%AE%A1NetLify%2F</url>
    <content type="text"><![CDATA[Hexo个人博客迁移到托管平台Netlify Netlify是一家国外的静态网站的托管平台，提供免费的https，自动化部署和升级，可以监控GitHub、GitLab或者Bitbucket做到自动更新发布。 个人体会访问速度不是很理想，不如部署在GitHub上。 一、使用github或者gitlab登陆netlify打开Netlify网站然后点击右上角Sign up注册账号，选择GitHub关联登录。 二、根据github/gitlab仓库创建网站创建站点，点击New site from Git按钮： 三、选择代码托管空间可以选择GitHub、GitLab或者BitBucket。 四、选择要部署的项目仓库点击你已经建好的库，选好分支（默认master即可），然后点击“Deploy site”，系统就会自动编译你的静态页面了。网站的控制台去进行设置域名绑定和https申请即可，部署成功后会自动进行cdn加速的。 之后我们就不需要这么麻烦了以后编辑好文章之后，只需要执行 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 即可自动化部署，然后要记得将我们的项目文件 push 到 github 的 master分支上去哦。 域名解析网站引导Netlify网站 提供的网站域名是该网站的二级域名，看起来不太美观，如果你拥有自己的域名，可以通过绑定自己的域名然后跳转到Netlify的二级域名。 域名控制台添加两条解析记录，一条A记录，一条CNAME记录。A记录的记录值IP是你的https://xxx.netlify.com域名对应的ip，这个可以网上查。CNAME记录的记录值是https://xxx.netlify.com的xxx.netlify.com值，添加完解析后就可将你的域名绑定到Netlify了。 使用体验想要部署在Netlify的初衷是部署在Coding上需要备案，且已经被公安催了要备案，需要一个不用备案的代码托管网站。在网站部署操作不是很麻烦，但是实际部署下来访问速度不是很理想，不如部署在GitHub上。纠结一下]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Netlify</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理评价指标_划分系数Vpc划分熵Vpe]]></title>
    <url>%2F2019%2F07%2F09%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87_VpcVpe%2F</url>
    <content type="text"><![CDATA[图像处理评价指标_划分系数Vpc划分熵Vpe 划分系数划分熵评价指标划分系数Vpc和划分熵Vpe能够反映分割矩阵的模糊程度，Vpc数值越大，分割矩阵的模糊性越小，分割效果越好；Vpe数值越小，像素分类越准确，分割效果越好。 （1）划分系数Vpc评价指标的定义为： V_{pc} = \sum_{i=1}^{n}\sum_{k=1}^K u_{ki}^2/n其中，$K$表示聚类数目，$u_{ki}$ 是隶属度函数，表示第$i$个像素属于第$k$分类的隶属度，$n$是像素总数。 （2）划分熵Vpe评价指标的定义为： V_{pe} = -\sum_{i=1}^{n}\sum_{k=1}^K u_{ki}*log(u_{ki})/nMatlab代码1234567891011function [V_pc,V_pe_10,V_pe_e]=V_pcpe(u)%评价函数指标 划分系数V_pc，划分熵V_pe%% u是隶属度函数[m,n]=size(u);%% 划分系数V_pcV_pc = sum(sum(u.^2))/n;%% 划分熵V_peV_pe_10=-sum(sum(u.*log10(u)))/n;V_pe_e=-sum(sum(u.*log(u)))/n;]]></content>
      <tags>
        <tag>图像处理</tag>
        <tag>图像分割</tag>
        <tag>评价指标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理_ISP_坏点矫正]]></title>
    <url>%2F2019%2F07%2F08%2FISP_%E5%9D%8F%E7%82%B9%E7%9F%AB%E6%AD%A3%2F</url>
    <content type="text"><![CDATA[图像处理ISP坏点矫正 1 坏点介绍图像坏点(Bad pixel) : 图像传感器上光线采集点(像素点)所形成的阵列存在工艺上的缺陷，或光信号进行转化为电信号的过程中出现错误，从而会造成图像上像素信息错误，导致图像中的像素值不准确，这些有缺陷的像素即为图像坏点。 由于来自不同工艺技术和传感器制造商，尤其对一些低成本、消费品的sensor来说，坏点数会有很多。另外，sensor在长时间、高温环境下坏点也会越来越多，从而破坏了图像的清晰度和完整性。坏点校正的目的就是修复这类问题，通常坏点分为一下两种： (1) 静态坏点：分为静态亮点和静态暗点。 静态亮点：一般来说像素点的亮度值是正比于入射光的，而亮点的亮度值明显大于入射光乘以相应比例，并且随着曝光时间的增加，该点的亮度会显著增加； 静态坏点：无论在什么入射光下，该点的值接近于0; (2) 动态坏点：在一定像素范围内，该点表现正常，而超过这一范围，该点表现的比周围像素要亮。与sensor 温度、增益有关，sensor 温度升高或者gain 值增大时，动态坏点会变的更加明 显； 2 坏点校正成因 为什么图像处理的过程中需要做坏点校正，而且坏点校正(DPC)通常在ISP的pipeline靠前位置？主要有如下原因： (1) 如果图像中存在坏点的话，ISP后续进行插值和滤波处理时，会影响周围的像素点值，因此需要在插值和滤波之前对坏点进行校正 ; (2) 图像存在坏点比较多或动态坏点很多的情况下，会造成图像的边缘出现伪色彩的情况，这种现象不但影响图像的清晰度，而且会影响边缘的色彩; (3) 坏点也会造成图像部分pixel闪烁的现象; 3 坏点校正策略图像的坏点校正(DPC)通常在Bayer域(灰度图原理一致)进行。若Bayer域为R/G/B三通道，则分别进行坏点校正;若Bayer域为RGBIR格式，则分别对R/Gr/Gb/B四通道独立进行。动态坏点校正和静态坏点校正是两个相互独立的过程，可以同时开启，也可以只开启一个，视需要设置。 静态坏点校正：基于已有的静态坏点表，比较当前点的坐标是否与静态坏点表中的某个坐标一致，若一致则判定为坏点，然后再计算校正结果对其进行校正。一般情况下，每个sensor的坏点都不一样，需要sensor厂商给出每个sensor的静态坏点表，但是出于成本的考虑，很多sensor厂商并没有给出，而用户校正的话只能一个一个对其进行校正，因此对于一些低成本的sensor，静态坏点校正的实用性不是很强。另外，由于在硬件设计的时候需要占用大量的memory，考虑到芯片面积以及一些其他原因，因此静态坏点有大小的限制，不可以无限制的校正。 动态坏点校正：可以实时的检测和校正sensor 的亮点与暗点，并且校正的坏点个数不受限制。动态坏点校正相对静态坏点校正具有更大的不确定性。动态dpc可以分为两个步骤，分别为坏点检测和坏点校正。 4 源码实现(Matlab Version)该算法是动态坏点校正策略实现，算法使用梯度百分比的方式去检测坏点，检测到坏点之后通过中值滤波进行坏点校正，最终通过alpha混合的方式计算出最终的计算结果。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465close all;clear;clc;%% variabledp_slope = 0.02;dp_thresh = -0.3;r=3; %Stencil radius%% read raw image% x = 0:255;% y = dp_slope * x + dp_thresh;% y(y&lt;0) = 0;% y(y&gt;1) = 1;% figure,% plot(0:255,y)% axis([0 255 0 1.5])[filename, pathname] = ... uigetfile(&#123;&apos;*.raw&apos;&#125;, &apos;select picture&apos;);str = [pathname filename];fp = fopen(str, &apos;rb&apos;);[X,l] = fread(fp, [1920,1080], &apos;uint16&apos;);fclose(fp);img = uint8(X/16)&apos;;[height, width] = size(img);img_correct = zeros(height, width);%% Image edge extensionimgn=zeros(height+2*r,width+2*r);imgn(r+1:height+r,r+1:width+r)=img;imgn(1:r,r+1:width+r)=img(1:r,1:width); imgn(1:height+r,width+r+1:width+2*r+1)=imgn(1:height+r,width:width+r); imgn(height+r+1:height+2*r+1,r+1:width+2*r+1)=imgn(height:height+r,r+1:width+2*r+1); imgn(1:height+2*r+1,1:r)=imgn(1:height+2*r+1,r+1:2*r);%% dp algorithmfor i = r+1:height-r for j = r+1:width-r img_r = imgn(i-r:2:i+r, j-r:2:j+r); data_r_center = img_r(r, r); data_r_diff(1:r+1, 1:r+1) = abs(img_r - img_r(r,r)); data_r_sort = sort(img_r(:)); data_r_median = data_r_sort(r*2+1); data_r_detect = data_r_diff * dp_slope + dp_thresh; data_r_detect(data_r_detect &lt; 0) = 0; data_r_detect(data_r_detect &gt; 1) = 1; data_r_judge = sum(sum(data_r_detect &gt; 0)); data_r_weight = sum(sum(data_r_detect)) / data_r_judge; if i-r == 18 &amp;&amp; j-r == 43 a = 1; end if data_r_judge &gt;= 7 data_r_correct = data_r_median * data_r_weight + (1-data_r_weight) * data_r_center; else data_r_correct = data_r_center; end img_correct(i-r, j-r) = data_r_correct; endend%% showfigure,imshow(uint8(img));figure,imshow(uint8(img_correct)); 参考文章]]></content>
      <tags>
        <tag>ISP</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理评价指标_PSNR峰值信噪比和SSIM结构相似度]]></title>
    <url>%2F2019%2F07%2F07%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87_PSNR_SSIM%2F</url>
    <content type="text"><![CDATA[图像处理评价指标_PSNR峰值信噪比 PSNRpsnr是“Peak Signal to Noise Ratio”的缩写，即峰值信噪比，是一种评价图像的客观标准。为了衡量经过处理后的影像品质，我们通常会参考PSNR值来衡量某个处理程序能否令人满意。PSNR的单位是dB，数值越大表示失真越小。n为每像素的比特数，一般的灰度图像取8，即像素灰阶数为256。它是原图像与被处理图像之间的均方误差相对于(2n-1)2的对数值(信号最大值的平方，n是每个采样值的比特数)，所以PSNR值越大，就代表失真越少。MATLAB用法的公式如下： PSNR=10*log10((2n-1)2/MSE)其中，MSE是原图像与处理图像之间均方误差。 优缺点PSNR是最普遍，最广泛使用的评鉴画质的客观量测法，不过许多实验结果都显示，PSNR的分数无法和人眼看到的视觉品质完全一致，有可能PSNR较高者看起来反而比PSNR较低者差。这是因为人眼的视觉对于误差的敏感度并不是绝对的，其感知结果会受到许多因素的影响而产生变化（例如：人眼对空间频率较低的对比差异敏感度较高，人眼对亮度对比差异的敏感度较色度高，人眼对一个区域的感知结果会受到其周围邻近区域的影响）。 Matlab代码123456789101112131415161718192021222324252627282930function [PSNR, MSE] = psnr(X, Y)%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 计算峰值信噪比PSNR% 将RGB转成YCbCr格式进行计算% 如果直接计算会比转后计算值要小2dB左右（当然是个别测试）%%%%%%%%%%%%%%%%%%%%%%%%%%%% if size(X,3)~=1 %判断图像时不是彩色图，如果是，结果为3，否则为1 org=rgb2ycbcr(X); test=rgb2ycbcr(Y); Y1=org(:,:,1); Y2=test(:,:,1); Y1=double(Y1); %计算平方时候需要转成double类型，否则uchar类型会丢失数据 Y2=double(Y2); else %灰度图像，不用转换 Y1=double(X); Y2=double(Y); end if nargin&lt;2 D = Y1;else if any(size(Y1)~=size(Y2)) error(&apos;The input size is not equal to each other!&apos;); end D = Y1 - Y2; endMSE = sum(D(:).*D(:)) / numel(Y1); PSNR = 10*log10(255^2 / MSE); SSIMSSIM(structural similarity index)，结构相似性，是一种衡量两幅图像相似度的指标。该指标首先由德州大学奥斯丁分校的图像和视频工程实验室(Laboratory for Image and Video Engineering)提出。SSIM使用的两张图像中，一张为未经压缩的无失真图像，另一张为失真后的图像。 给定两个图像 x和y , 两张图像的结构相似性可按照以下方式求出 其中，$μ_X$、$μ_Y$分别表示图像$X$和$Y$的均值，$σ_X$、$σ_Y$分别表示图像$X$和$Y$的方差，$σ_XY$表示图像$X$和$Y$的协方差。 SSIM分别从亮度、对比度、结构三方面度量图像相似性。 $C1$、$C2$、$C3$为常数，为了避免分母为0的情况，通常取$C1=(K1∗L)2$,$ C2=(K2∗L)2$, $C3=C22$, 一般地K1=0.01, K2=0.03, L=255 则, Matlab公式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318function [ssimval, ssimmap] = ssim(varargin)%SSIM Structural Similarity Index for measuring image quality% SSIMVAL = SSIM(A, REF) calculates the Structural Similarity Index% (SSIM) value for image A, with the image REF as the reference. A and% REF can be 2D grayscale or 3D volume images, and must be of the same% size and class. % % [SSIMVAL, SSIMMAP] = SSIM(A, REF) also returns the local SSIM value for% each pixel in SSIMMAP. SSIMMAP has the same size as A.%% [SSIMVAL, SSIMMAP] = SSIM(A, REF, NAME1, VAL1,...) calculates the SSIM% value using name-value pairs to control aspects of the computation.% Parameter names can be abbreviated.%% Parameters include:%% &apos;Radius&apos; - Specifies the standard deviation of % isotropic Gaussian function used for% weighting the neighborhood pixels around a% pixel for estimating local statistics. This% weighting is used to avoid blocking% artifacts in estimating local statistics.% The default value is 1.5.% % &apos;DynamicRange&apos; - Positive scalar, L, that specifies the% dynamic range of the input image. By% default, L is chosen based on the class of% the input image A, as L =% diff(getrangefromclass(A)). Note that when% class of A is single or double, L = 1 by% default.% % &apos;RegularizationConstants&apos;- Three-element vector, [C1 C2 C3], of % non-negative real numbers that specifies the% regularization constants for the luminance,% contrast, and structural terms (see [1]),% respectively. The regularization constants% are used to avoid instability for image% regions where the local mean or standard% deviation is close to zero. Therefore, small% non-zero values should be used for these% constants. By default, C1 = (0.01*L).^2, C2% = (0.03*L).^2, and C3 = C2/2, where L is the% specified &apos;DynamicRange&apos; value. If a value% of &apos;DynamicRange&apos; is not specified, the% default value is used (see name-value pair% &apos;DynamicRange&apos;).% % &apos;Exponents&apos; - Three-element vector [alpha beta gamma],% of non-negative real numbers that specifies% the exponents for the luminance, contrast,% and structural terms (see [1]),% respectively. By default, all the three% exponents are 1, i.e. the vector is [1 1% 1].% % Notes % -----% 1. A and REF can be arrays of upto three dimensions. All 3D arrays% are considered 3D volumetric images. RGB images will also be% processed as 3D volumetric images.% % 2. Input image A and reference image REF are converted to% floating-point type for internal computation.% % 3. For signed-integer images (int16), an offset is applied to bring the% gray values in the non-negative range before computing the SSIM% index.% % Example% ---------% This example shows how to compute SSIM value for a blurred image given% the original reference image.% % ref = imread(&apos;pout.tif&apos;);% H = fspecial(&apos;Gaussian&apos;,[11 11],1.5);% A = imfilter(ref,H,&apos;replicate&apos;);% % subplot(1,2,1); imshow(ref); title(&apos;Reference Image&apos;);% subplot(1,2,2); imshow(A); title(&apos;Blurred Image&apos;);% % [ssimval, ssimmap] = ssim(A,ref);% % fprintf(&apos;The SSIM value is %0.4f.\n&apos;,ssimval);% % figure, imshow(ssimmap,[]);% title(sprintf(&apos;SSIM Index Map - Mean SSIM Value is %0.4f&apos;,ssimval));% Class Support% -------------% Input arrays A and REF must be one of the following classes: uint8,% int16, uint16, single, or double. Both A and REF must be of the same% class. They must be nonsparse. SSIMVAL is a scalar and SSIMMAP is an% array of the same size as A. Both SSIMVAL and SSIMMAP are of class% double, unless A and REF are of class single in which case SSIMVAL and% SSIMMAP are of class single.% % References:% -----------% [1] Z. Wang, A. C. Bovik, H. R. Sheikh, and E. P. Simoncelli, &quot;Image % Quality Assessment: From Error Visibility to Structural% Similarity,&quot; IEEE Transactions on Image Processing, Volume 13,% Issue 4, pp. 600- 612, 2004.%% See also IMMSE, MEAN, MEDIAN, PSNR, SUM, VAR.% Copyright 2013-2014 The MathWorks, Inc. narginchk(2,10);[A, ref, C, exponents, radius] = parse_inputs(varargin&#123;:&#125;);if isempty(A) ssimval = zeros(0, &apos;like&apos;, A); ssimmap = A; return;endif isa(A,&apos;int16&apos;) % int16 is the only allowed signed-integer type for A and ref. % Add offset for signed-integer types to bring values in the % non-negative range. A = double(A) - double(intmin(&apos;int16&apos;)); ref = double(ref) - double(intmin(&apos;int16&apos;));elseif isinteger(A) A = double(A); ref = double(ref);end % Gaussian weighting functiongaussFilt = getGaussianWeightingFilter(radius,ndims(A));% Weighted-mean and weighted-variance computationsmux2 = imfilter(A, gaussFilt,&apos;conv&apos;,&apos;replicate&apos;);muy2 = imfilter(ref, gaussFilt,&apos;conv&apos;,&apos;replicate&apos;);muxy = mux2.*muy2;mux2 = mux2.^2;muy2 = muy2.^2;sigmax2 = imfilter(A.^2,gaussFilt,&apos;conv&apos;,&apos;replicate&apos;) - mux2;sigmay2 = imfilter(ref.^2,gaussFilt,&apos;conv&apos;,&apos;replicate&apos;) - muy2;sigmaxy = imfilter(A.*ref,gaussFilt,&apos;conv&apos;,&apos;replicate&apos;) - muxy;% Compute SSIM indexif (C(3) == C(2)/2) &amp;&amp; isequal(exponents(:),ones(3,1)) % Special case: Equation 13 from [1] num = (2*muxy + C(1)).*(2*sigmaxy + C(2)); den = (mux2 + muy2 + C(1)).*(sigmax2 + sigmay2 + C(2)); if (C(1) &gt; 0) &amp;&amp; (C(2) &gt; 0) ssimmap = num./den; else % Need to guard against divide-by-zero if either C(1) or C(2) is 0. isDenNonZero = (den ~= 0); ssimmap = ones(size(A)); ssimmap(isDenNonZero) = num(isDenNonZero)./den(isDenNonZero); end else % General case: Equation 12 from [1] % Luminance term if (exponents(1) &gt; 0) num = 2*muxy + C(1); den = mux2 + muy2 + C(1); ssimmap = guardedDivideAndExponent(num,den,C(1),exponents(1)); else ssimmap = ones(size(A), &apos;like&apos;, A); end % Contrast term sigmaxsigmay = []; if (exponents(2) &gt; 0) sigmaxsigmay = sqrt(sigmax2.*sigmay2); num = 2*sigmaxsigmay + C(2); den = sigmax2 + sigmay2 + C(2); ssimmap = ssimmap.*guardedDivideAndExponent(num,den,C(2),exponents(2)); end % Structure term if (exponents(3) &gt; 0) num = sigmaxy + C(3); if isempty(sigmaxsigmay) sigmaxsigmay = sqrt(sigmax2.*sigmay2); end den = sigmaxsigmay + C(3); ssimmap = ssimmap.*guardedDivideAndExponent(num,den,C(3),exponents(3)); end endssimval = mean(ssimmap(:)); end% -------------------------------------------------------------------------function component = guardedDivideAndExponent(num, den, C, exponent)if C &gt; 0 component = num./den;else component = ones(size(num),&apos;like&apos;,num); isDenNonZero = (den ~= 0); component(isDenNonZero) = num(isDenNonZero)./den(isDenNonZero);endif (exponent ~= 1) component = component.^exponent;endendfunction gaussFilt = getGaussianWeightingFilter(radius,N)% Get 2D or 3D Gaussian weighting filterfiltRadius = ceil(radius*3); % 3 Standard deviations include &gt;99% of the area. filtSize = 2*filtRadius + 1;if (N &lt; 3) % 2D Gaussian mask can be used for filtering even one-dimensional % signals using imfilter. gaussFilt = fspecial(&apos;gaussian&apos;,[filtSize filtSize],radius);else % 3D Gaussian mask [x,y,z] = ndgrid(-filtRadius:filtRadius,-filtRadius:filtRadius, ... -filtRadius:filtRadius); arg = -(x.*x + y.*y + z.*z)/(2*radius*radius); gaussFilt = exp(arg); gaussFilt(gaussFilt&lt;eps*max(gaussFilt(:))) = 0; sumFilt = sum(gaussFilt(:)); if (sumFilt ~= 0) gaussFilt = gaussFilt/sumFilt; endendendfunction [A, ref, C, exponents, radius] = parse_inputs(varargin)validImageTypes = &#123;&apos;uint8&apos;,&apos;uint16&apos;,&apos;int16&apos;,&apos;single&apos;,&apos;double&apos;&#125;;A = varargin&#123;1&#125;;validateattributes(A,validImageTypes,&#123;&apos;nonsparse&apos;,&apos;real&apos;&#125;,mfilename,&apos;A&apos;,1);ref = varargin&#123;2&#125;;validateattributes(ref,validImageTypes,&#123;&apos;nonsparse&apos;,&apos;real&apos;&#125;,mfilename,&apos;REF&apos;,2);if ~isa(A,class(ref)) error(message(&apos;images:validate:differentClassMatrices&apos;,&apos;A&apos;,&apos;REF&apos;));end if ~isequal(size(A),size(ref)) error(message(&apos;images:validate:unequalSizeMatrices&apos;,&apos;A&apos;,&apos;REF&apos;));endif (ndims(A) &gt; 3) error(message(&apos;images:validate:tooManyDimensions&apos;,&apos;A and REF&apos;,3));end% Default values for parametersdynmRange = diff(getrangefromclass(A)); C = [];exponents = [1 1 1];radius = 1.5;args_names = &#123;&apos;dynamicrange&apos;, &apos;regularizationconstants&apos;,&apos;exponents&apos;,... &apos;radius&apos;&#125;;for i = 3:2:nargin arg = varargin&#123;i&#125;; if ischar(arg) idx = find(strncmpi(arg, args_names, numel(arg))); if isempty(idx) error(message(&apos;images:validate:unknownInputString&apos;, arg)) elseif numel(idx) &gt; 1 error(message(&apos;images:validate:ambiguousInputString&apos;, arg)) elseif numel(idx) == 1 if (i+1 &gt; nargin) error(message(&apos;images:validate:missingParameterValue&apos;)); end if idx == 1 dynmRange = varargin&#123;i+1&#125;; validateattributes(dynmRange,&#123;&apos;numeric&apos;&#125;,&#123;&apos;positive&apos;, ... &apos;finite&apos;, &apos;real&apos;, &apos;nonempty&apos;,&apos;scalar&apos;&#125;, mfilename, ... &apos;DynamicRange&apos;,i); dynmRange = double(dynmRange); elseif idx == 2 C = varargin&#123;i+1&#125;; validateattributes(C,&#123;&apos;numeric&apos;&#125;,&#123;&apos;nonnegative&apos;,&apos;finite&apos;, ... &apos;real&apos;,&apos;nonempty&apos;,&apos;vector&apos;, &apos;numel&apos;, 3&#125;, mfilename, ... &apos;RegularizationConstants&apos;,i); C = double(C); elseif idx == 3 exponents = varargin&#123;i+1&#125;; validateattributes(exponents,&#123;&apos;numeric&apos;&#125;,&#123;&apos;nonnegative&apos;, ... &apos;finite&apos;, &apos;real&apos;, &apos;nonempty&apos;,&apos;vector&apos;, &apos;numel&apos;, 3&#125;, ... mfilename,&apos;Exponents&apos;,i); exponents = double(exponents); elseif idx == 4 radius = varargin&#123;i+1&#125;; validateattributes(radius,&#123;&apos;numeric&apos;&#125;,&#123;&apos;positive&apos;,&apos;finite&apos;, ... &apos;real&apos;, &apos;nonempty&apos;,&apos;scalar&apos;&#125;, mfilename,&apos;Radius&apos;,i); radius = double(radius); end end else error(message(&apos;images:validate:mustBeString&apos;)); endend% If &apos;RegularizationConstants&apos; is not specified, choose default C.if isempty(C) C = [(0.01*dynmRange).^2 (0.03*dynmRange).^2 ((0.03*dynmRange).^2)/2];endend 参考文章1 参考文章2]]></content>
      <tags>
        <tag>图像处理</tag>
        <tag>图像分割</tag>
        <tag>评价指标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Valine评论插件因为LeanCloud国内域名解析问题无法正常使用的解决方法]]></title>
    <url>%2F2019%2F06%2F23%2FValine_leancloud_error%2F</url>
    <content type="text"><![CDATA[Valine评论插件无法正常使用的解决方法 近日，LeanCloud 国内域名解析存在问题，valine评论插件的评论内容都储存在LeanCloud，使用valine评论插件的个人博客的评论及阅读数会显示失败。 关于 LeanCloud 国内域名解析问题的情况更新（6 月 21 日)声明地址 Valine评论插件的GitHub，关于此问题的issues区issues地址 因为LeanCloud域名解析出现问题，其提供的资源也无法指向，有小伙伴分享了新的资源连接，然后替换掉即可。 替换资源的文件路径blog路径/theme/next/_config.yml，编辑_config.yml，替换如下1234# valine # See: https://github.com/xCss/Valine # Example:leancloud: http://pirogue.org/js/av-min.js 替换效果如下: 然后平常一样部署博客就可以 感谢提供资源的小伙伴，他的门户]]></content>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeanCloud 国内域名解析问题，博客评论及阅读数显示失败]]></title>
    <url>%2F2019%2F06%2F23%2FLeancloud_error%2F</url>
    <content type="text"><![CDATA[博客评论及阅读数显示失败 近日，LeanCloud 国内域名解析存在问题，个人博客基于LeanCloud构建的评论及阅读数显示失败。 个人博客地址关于 LeanCloud 国内域名解析问题的情况更新（6 月 21 日)声明地址 声明内容如下： 各位 LeanCloud 的用户大家好，我是 LeanCloud 的联合创始人江宏。大部分用户都已经知道我们的两个域名目前无法解析，具体的情况我们昨天给大家发了邮件和博客说明，今天又再次发了短信通知。虽然这件事还没有解决，但本着对事件处理过程透明的原则，我想向大家更新一下最新进展，以及我们已经采取的措施。由于在域名被禁用前没有事先通知我们，所以昨天我们在事情发生一段时间之后也不知道具体的原因。后来经过和阿里云一段时间的沟通后得知是因为某违规应用被查封，所以该应用访问的所有域名都受到牵连。事实上工信部在约一个月前因为该应用联系过我们，我们当时在接到通知约一小时内完成了清查和处理，禁用了相关账号并将结果回复给工信部，而这次却不知为何仍然被该应用影响导致两个域名被设为 ClientHold。我在今天下午拜访了工信部信息通信管理局互联网处，递交了我们的处理情况说明、申诉和保证。但因为工信部只是执行网信办的通知，所以仍需要等待网信办确认才可以解禁。很抱歉目前原有域名的恢复时间完全取决于政府部门之间的沟通进展，我们也无法给用户准确的估计。在我们可控制的范围内，我们针对这件事已经完成的应对措施有：为可以替换域名的用户提供可用的替代域名，说明见博客。我们 iOS、Android、JS、Unity 等 SDK 都做了紧急更新，以避免国际版的应用受国内域名的影响。为避免在解决问题过程中出现其它问题，华北和华东节点暂停新开发版应用的创建。如果您有需要可以用邮件联系我们创建，或者使用国际版。华北节点提供了自助绑定 API 自定义域名的功能，自定义域名可用于访问数据存储、云函数、短信、推送以及即时通讯服务。你可以在控制台的「存储 -&gt; 设置 -&gt; 自定义 API 服务域名」中提供一个已备案的域名（如需开启 HTTPS 还需提供对应的证书）来自助绑定。我们之后会再发布一个详细文档说明自定义域名的配置和使用见博客说明。我们还有一些正在实施的措施，既为了应对目前情况，也为了在更长期能把特殊国情带来的特殊风险限制在尽量小的范围。我们也会把后续的和有关部门的沟通结果同步给用户。 有一些用户因为域名解析问题无法联系我们，请注意我们的各个线上联系渠道有的使用了临时域名： 博客：https://blog.avoscloud.com（临时域名）主站：https://avoscloud.com（临时域名）邮件：http://support@leancloud.rocks (不变)工单：https://leanticket.cn（不变）很多用户在此次事件的沟通中给予了我们宝贵的宽容、支持和信任。我想特别向我们的用户表达感谢，并将继续尽我们所能克服未来可能遇到的困难，服务好用户。 希望早日解决问题，继续服务消费者]]></content>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爱礼（爱的礼物——谐音爱你），送给你对象的爱的礼物]]></title>
    <url>%2F2019%2F06%2F22%2FLoveHeart%2F</url>
    <content type="text"><![CDATA[爱礼 项目制作给我的女朋友，可以写一些恋爱情话，记录恋爱时间线，恋爱时间等。 原始项目由hackerzhou发起，作者预览网址失效，项目地址如下:项目地址 我在原始项目上改了改，项目地址如下：我的项目地址 项目效果预览网址如下：效果预览 项目放在我的主域名下的子域名内，主域名对应Github Page的主仓库ID.github.io。 指导复制项目文件我的git项目地址点到我的github，fork这个项目到自己仓库，然后点击setting设置 开启项目的github pages设置页面往下拉， github pages部分，选择一个主题，开启功能，根据显示域名就能访问爱礼页面了 设置域名绑定还是在github pages部分，绑定自有域名方便访问 修改打开i项目的index.html，以下部分根据自己需求修改吧 1234&lt;!-- BGM区域 --&gt;&lt;!-- 文字区域 --&gt;//起始时间 &lt;!-- 附加信息--&gt; 修改完成，直接在浏览器预览index.html内容即可 主题配置主题blog\theme\next\config.yml文件中menu:下补充一个栏目，然后直接写的项目地址1234567menu: home: / || home archives: /archives/ || archive #归档 tags: /tags/ || tags #标签 #categories: /categories/ || th #分类 相册: /photos/ || camera-retro #相册 爱礼: http://www.aomanhao.top/LoveHeart/ || heart #恋爱线 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《重庆森林》]]></title>
    <url>%2F2019%2F06%2F13%2FMovie_ChongQingSenLin%2F</url>
    <content type="text"><![CDATA[《重庆森林》 发条张讲解的B站视频视频链接 简介《重庆森林》是泽东电影公司出品的一部都市时装片，由王家卫执导，林青霞、梁朝伟、王菲、金城武等主演。1994年7月14日，该片在香港上映。影片讲述了两个爱情故事：失恋的警察与神秘女杀手一段都市邂逅以及巡警663与快餐店女孩的爱情故事。1995年，该片获得了第14届香港电影金像奖最佳影片、最佳导演等奖项 背景重庆大厦坐落于香港九龙尖沙咀，位于弥敦道36-44号。于1961年落成，是一座混合型大厦，拥有很多廉价宾馆、商店、食肆、外汇兑换店及其他服务行业。重庆大厦里有着密密匝匝的商铺。一个挨着一个，大多是来自东南亚的商人开的店。 经典台词1.我和她最接近的时候，我们之间的距离只有0.01公分，我对她一无所知，六个钟头之后，她喜欢了另一个男人。 2.如果一个人哭，你只要给他一包纸巾就行;如果一个房子哭，你要做的事就多了。 3.不知道从什么时候开始，在什么东西上面都有个日期，秋刀鱼会过期，肉罐头会过期，连保鲜纸都会过期，我开始怀疑，在这个世界上，还有什么东西是不会过期的? 5.每次我失恋的时候我都会去跑步，因为跑步是能够把我体内多余的水分蒸发掉，那样比较不容易流泪。 6.如果记忆也是一个罐头的话，我希望这罐罐头不会过期;如果一定要加一个日子的话，我希望她是一万年。 7.每天你都有机会和很多人擦身而过，有些人可能会变成你的朋友或者是知己。所以我从来没有放弃任何跟人磨擦的机会。有时候搞得自己头破血流，管他呢!开心就行了。 8.其实了解一个人并不代表什么，人是会变的，今天他喜欢凤梨，明天他可以喜欢别的。 9.不知道是我不记得关水龙头，还是这间屋越来越有感情，我一直以为它很坚强，没想到它哭得最历害，一个人哭，你只须要给他包纸巾，但一间屋哭，你却要做很多很多工夫。(梁朝伟的房间进水) 10.在1994年的5月1号，有一个女人跟我讲了一声“生日快乐”，因为这一句话，我会一直记住这个女人。如果记忆也是一个罐头的话，我希望这罐罐头不会过期;如果一定要加一个日子的话，我希望她是一万年 11.一个女人这么晚了还戴墨镜，只有三个理由：第一个呢，就说明她是个盲子;第二个呢，就说明她在耍帅，所以要戴墨镜;第三个呢，就因为她失恋，因为她不想让人家看出来她哭过” 。 12.在1994年的5月1号，有一个女人跟我讲了一声“生日快乐”，因为这一句话，我会一直记住这个女人。 13.我对她一无所知，57个小时之后，我爱上了她，六个钟头之后，她喜欢了另一个男人。 14.我今天心情好，想看子夜场。 15.有时候我会回家吃饭，因为每一次回来我都可以有个希望。梁走到柜子前，对柜子说：“我知道你回来了，快点出来啊，我数三下，一、二、三”她以前很爱突如其来从衣柜里扑出来吓我，最近少了很多，也对啊，玩多了也腻啦。不知道她会不会躲在厕所里呢? 16.每一个人都有一个习惯，我的习惯呢?就是来这边等阿may下班。 后记我是因为一首歌喜欢上《重庆森林》，在《California dreaming》背景音乐的伴奏下，王菲在快餐店里摇头晃脑，很是自由。]]></content>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣GitHub项目之每日自动给女朋友发微信暖心话]]></title>
    <url>%2F2019%2F06%2F08%2FEverydayWechat%2F</url>
    <content type="text"><![CDATA[有趣GitHub项目之每日自动给女朋友发微信暖心话 GitHub项目地址 以下为作者的参考文档，有待学习用 Python + itchat 写一个爬虫脚本每天定时给多个女友发给微信暖心话项目介绍：开发环境：Python &gt;= 3.6 使用库1234itchat - 微信个人号接口requests - 网络请求库beautifulsoup4 - 解析网页APScheduler - 定时任务 功能定时给女朋友发送每日天气、提醒、每日一句。 数据来源每日一句和上面的大佬一样也是来自 ONE●一个天气信息来自 SOJSON 代码说明目录结构 12345city_dict.py ：城市对应编码字典config.yaml ：设置定时时间，女友微信名称等参数GFWeather.py：核心代码requirements.txt：需要安装的库run.py：项目运行类 核心代码 1.定时任务。每天 9：30 给女朋友们开始给女朋友发送内容。123456### 定时任务scheduler = BlockingScheduler()# 每天9：30给女朋友发送每日一句# scheduler.add_job(start_today_info, &apos;cron&apos;, hour=9, minute=30)scheduler.start()start_today_info 是方法处理类。 2.获取每日一句。数据来源 1： ONE●一个123456789101112def get_dictum_info(self): &apos;&apos;&apos; 获取格言信息（从『一个。one』获取信息 http://wufazhuce.com/） :return: str 一句格言或者短语 &apos;&apos;&apos; print(&apos;获取格言信息..&apos;) user_url = &apos;http://wufazhuce.com/&apos; resp = requests.get(user_url, headers=self.headers) soup_texts = BeautifulSoup(resp.text, &apos;lxml&apos;) # 『one -个』 中的每日一句 every_msg = soup_texts.find_all(&apos;div&apos;, class_=&apos;fp-one-cita&apos;)[0].find(&apos;a&apos;).text return every_msg 数据来源 2： 金山词霸 ● 每日一句 有英文和中文翻译，例如：1When you finally get your own happiness, you will understand the previous sadness is a kind of treasure, which makes you better to hold and cherish the people you love. 等你获得真正属于你的幸福之后，你就会明白一起的伤痛其实是一种财富，它让你学会更好地去把握和珍惜你爱的人。 1234567891011121314151617代码实现 ： def get_ciba_info(self): &apos;&apos;&apos; 从词霸中获取每日一句，带英文。 :return: &apos;&apos;&apos; resp = requests.get(&apos;http://open.iciba.com/dsapi&apos;) if resp.status_code == 200 and self.isJson(resp): conentJson = resp.json() content = conentJson.get(&apos;content&apos;) note = conentJson.get(&apos;note&apos;) # print(f&quot;&#123;content&#125;\n&#123;note&#125;&quot;) return f&quot;&#123;content&#125;\n&#123;note&#125;\n&quot; else: print(&quot;没有获取到数据&quot;) return None 3. 获取今日天气 。天气数据来源：SOJSON12345678def get_weather_info(self, city_code=&apos;&apos;）： weather_url = f&apos;http://t.weather.sojson.com/api/weather/city/&#123;city_code&#125;&apos; resp = requests.get(url=weather_url) if resp.status_code == 200 and resp.json().get(&apos;status&apos;) == 200: weatherJson = resp.json() # 今日天气 today_weather = weatherJson.get(&apos;data&apos;).get(&apos;forecast&apos;)[1]city_code 城市对应 id。 http://cdn.sojson.com/_city.json 登录微信并发送内容。12345itchat.auto_login()itchat.send(today_msg, toUserName=name_uuid)项目运行安装依赖使用 pip install -r requirements.txt 安装所有依赖 参数配置123456789101112131415161718192021222324252627config.yaml# 定时时间alarm_timed: &apos;9:30&apos;# 格言渠道# 1 : ONE●一个# 2 : 词霸（每日英语）dictum_channel: 2girlfriend_infos: - #女友微信昵称 wechat_name: &apos;古典&apos; #女友所在桂林 city_name: &apos;桂林&apos; # 从那天开始勾搭的（可空） start_date: &apos;2017-11-11&apos; # 短句的最后留言（可空） sweet_words: &apos;来自最爱你的我。&apos; #如果有你多个人需要发送，则参照这个样式，复制即可 - wechat_name: &apos;陈老师&apos; city_name: &apos;朝阳区&apos; start_date: &apos;2018-11-11&apos; sweet_words: &apos;来自你俊美的老公。&apos; 开始运行1python run.py]]></content>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[雷米粉丝见面签售会]]></title>
    <url>%2F2019%2F05%2F27%2FLeiMi%2F</url>
    <content type="text"><![CDATA[雷米粉丝见面签售会 雷米,原名刘鹏，中国刑事警察学院学院犯罪心理学教师，精通犯罪心理学和刑侦学，洞悉形形色色的罪恶，甚至超过自己的掌纹。以《心理罪》（网络原名《画像》）等犯罪心理小说闻名于网络，主要作品有《第七位读者》、《心理罪》、《教化场》、《暗河》、《城市之光》等。雷米新书，杂志版《教化场》将于08年10月登陆《今古传奇·故事版》 心理学知识仍然是本书主线，不过犯罪心理画像不再是主线。在《心理罪》中，雷米创造了一个血肉丰盈的人物——方木，如果说叙事的线索构成这部小说硬朗的结构，那么关于方木这个人的一切，则形成了小说的骨血和灵魂，他的命运牵动着我们的每一根神经。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客Next主题DaoVoice实现在线联系]]></title>
    <url>%2F2019%2F05%2F18%2FHexo_Daovoice%2F</url>
    <content type="text"><![CDATA[Hexo博客Next主题DaoVoice实现在线联系 注册登录DaoVoice注册地址如下:http://www.daovoice.io/ 在官网注册帐号需要邀请码，可以输入我的邀请码 b69005f1 复制粘贴代码修改的hexo的文件路劲如下: 博客/themes/next/layout/_partials/head/head.swig 末尾添加下面的代码: 12345678&#123;% if theme.daovoice %&#125; &lt;script&gt;(function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/b6dbddb6.js&quot;,&quot;daovoice&quot;) daovoice(&apos;init&apos;, &#123; app_id: &quot;用户ID&quot;&#125;);daovoice(&apos;update&apos;); &lt;/script&gt;&#123;% endif %&#125; 用户ID需要自行填写，查找的的位置在下图片中显示出来了 修改主题配置文件在Next主题的配置文件博客/themes/next/_config.yml末尾中添加用户ID:12daovoice: truedaovoice_app_id: 用户ID 修改聊天图标等设置应用设置—聊天设置，然后定制欢迎辞，设置聊天窗口样式等 部署Daovoice清理缓存，生成缓存，部署服务1hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 登陆本地服务：http://localhost:4000/，可以看到Daovoice已经成功运行。 DaoVoice官网会提示，服务接入成功]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo个人博客迁移到托管平台Netlify]]></title>
    <url>%2F2019%2F05%2F03%2FHexo_Netlify%2F</url>
    <content type="text"><![CDATA[个人博客迁移到托管平台Netlify上Netlify是一家国外的静态网站的托管平台，提供免费的https，自动化部署和升级，可以监控GitHub、GitLab或者Bitbucket做到自动更新发布。 个人体会访问速度不是很理想，不如部署在GitHub上。 一、使用github或者gitlab登陆netlify打开Netlify网站然后点击右上角Sign up注册账号，选择GitHub关联登录。 二、根据github/gitlab仓库创建网站创建站点，点击New site from Git按钮： 三、选择代码托管空间可以选择GitHub、GitLab或者BitBucket。 四、选择要部署的项目仓库点击你已经建好的库，选好分支（默认master即可），然后点击“Deploy site”，系统就会自动编译你的静态页面了。网站的控制台去进行设置域名绑定和https申请即可，部署成功后会自动进行cdn加速的。 之后我们就不需要这么麻烦了以后编辑好文章之后，只需要执行 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 即可自动化部署，然后要记得将我们的项目文件 push 到 github 的 master分支上去哦。 域名解析网站引导Netlify网站 提供的网站域名是该网站的二级域名，看起来不太美观，如果你拥有自己的域名，可以通过绑定自己的域名然后跳转到Netlity的二级域名。 域名控制台添加两条解析记录，一条A记录，一条CNAME记录。A记录的记录值IP是你的https://xxx.netlify.com域名对应的ip，这个可以网上查。CNAME记录的记录值是https://xxx.netlify.com的xxx.netlify.com值，添加完解析后就可将你的域名绑定到Netlify了。 使用体验想要部署在Netlity的初衷是部署在Coding上需要备案，且已经被公安催了要备案，需要一个不用备案的代码托管网站。在网站部署操作不是很麻烦，但是实际部署下来访问速度不是很理想，不如部署在GitHub上。纠结一下]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客建立标签云及效果展示]]></title>
    <url>%2F2019%2F04%2F20%2Fhexo_Tag_cloud%2F</url>
    <content type="text"><![CDATA[Hexo博客建立标签云及效果展示 hexo-tag-cloud插件介绍hexo-tag-cloud插件是作者写的一个Hexo博客的标签云插件，旨在直观的展示标签的种类，美观大方且非常优雅。 插件地址：插件的GitHub地址 插件说明：说明地址 标签云效果展示：我的博客主页 插件作者提供的效果预览 安装插件进入到 hexo 的根目录，在 package.json 中添加依赖: &quot;hexo-tag-cloud&quot;: &quot;2.0.*&quot; 操作如下： 使用命令行进行安装1npm install hexo-tag-cloud@^2.0.* --save Git clone 下载使用命令行安装插件包的过程中可能会出现问题，安装失败，安装不完全。可以直接克隆插件到博客的插件文件夹blog/node_modules里。或者克隆到桌面，复制到博客的插件文件夹blog/node_modules里。 1git clone https://github.com/MikeCoder/hexo-tag-cloud 配置插件插件的配置需要对应的环境，可以在主题文件夹里找一下，有没有对应的渲染文件，然后根据渲染文件的类型，选择对应的插件配置方法。 swig 用户 (Next主题在列)在主题文件夹找到文件 theme/next/layout/_macro/sidebar.swig, 然后添加如下代码：123456789101112&#123;% if site.tags.length &gt; 1 %&#125;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcloud.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcanvas.js&quot;&gt;&lt;/script&gt;&lt;div class=&quot;widget-wrap&quot;&gt; &lt;h3 class=&quot;widget-title&quot;&gt;Tag Cloud&lt;/h3&gt; &lt;div id=&quot;myCanvasContainer&quot; class=&quot;widget tagcloud&quot;&gt; &lt;canvas width=&quot;250&quot; height=&quot;250&quot; id=&quot;resCanvas&quot; style=&quot;width=100%&quot;&gt; &#123;&#123; list_tags() &#125;&#125; &lt;/canvas&gt; &lt;/div&gt;&lt;/div&gt;&#123;% endif %&#125; 代码添加到后面即可，添加示意图如下: 对于ejs的用户 (默认主题landscape在列)在主题文件夹找到文件hexo/themes/landscape/layout/_widget/tagcloud.ejs,将这个文件修改如下：123456789101112&lt;% if (site.tags.length) &#123; %&gt; &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcloud.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/tagcanvas.js&quot;&gt;&lt;/script&gt; &lt;div class=&quot;widget-wrap&quot;&gt; &lt;h3 class=&quot;widget-title&quot;&gt;Tag Cloud&lt;/h3&gt; &lt;div id=&quot;myCanvasContainer&quot; class=&quot;widget tagcloud&quot;&gt; &lt;canvas width=&quot;250&quot; height=&quot;250&quot; id=&quot;resCanvas&quot; style=&quot;width=100%&quot;&gt; &lt;%- tagcloud() %&gt; &lt;/canvas&gt; &lt;/div&gt; &lt;/div&gt;&lt;% &#125; %&gt; 对于jade用户 (Apollo主题在列)找到 apollo/layout/archive.jade 文件，并且把 container 代码块修改为如下内容:1234567891011block container include mixins/post .archive h2(class=&apos;archive-year&apos;)= &apos;Tag Cloud&apos; script(type=&apos;text/javascript&apos;, charset=&apos;utf-8&apos;, src=&apos;/oj-code/js/tagcloud.js&apos;) script(type=&apos;text/javascript&apos;, charset=&apos;utf-8&apos;, src=&apos;/oj-code/js/tagcanvas.js&apos;) #myCanvasContainer.widget.tagcloud(align=&apos;center&apos;) canvas#resCanvas(width=&apos;500&apos;, height=&apos;500&apos;, style=&apos;width=100%&apos;) !=tagcloud() !=tagcloud() +postList() 主题配置在博客根目录，找到 _config.yml配置文件然后在最后添加如下的配置项，可以自定义标签云的字体和颜色，还有突出高亮:1234567# hexo-tag-cloudtag_cloud: textFont: Trebuchet MS, Helvetica textColor: &apos;#333&apos; textHeight: 25 outlineColor: &apos;#E2E1D1&apos; maxSpeed: 0.1 textColor: ‘#333’ 字体颜色textHeight: 25 字体高度，根据部署的效果调整maxSpeed: 0.1 文字滚动速度，根据自己喜好调整 效果预览本地预览1hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 博客部署博客部署1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 推荐使用 &amp;&amp; 作为组合命令的串联符号 注：一定要严格清理缓存，这样不容易出现问题，即需要执行hexo clean 参考文章1 参考文章2 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[道路监控网络摄像头常见问题]]></title>
    <url>%2F2019%2F04%2F03%2FSecurity_road%2F</url>
    <content type="text"><![CDATA[道路监控网络摄像头常见问题 1. 水波纹（FLICK）问题CMOS高画质传感器在快门速度超过1/200sec以上，因无法处理同步问题，画面上会产生黑条状之水波纹而影响画质（如图一），并会在画面上产生缓慢飘移现象，但快门值低于1/200sec以下则不会产生水波纹问题，CCD高画质传感器就不会有水波纹问题。 设计建议：若车速低于30km/hr，可以采用CMOS摄像头。若车速高于30km/hr，则应采用CCD等级摄像头。 2. 夜间低照度噪点问题百万画素传感器多以1/2.8或1/3寸传感器构成，由于传感器面积未放大但画素密度增加，造成单位画素进光量低，因此一般而言感度效果较传统类比CCD差。一般低照度下传感器会启动自动增益（Auto Gain），等级较差传感器与处理芯片会造成画面噪点颗粒粗大（如图二），使得影像锐利度大幅降低，严重影响画质。 设计建议：采用高感度传感器与处理芯片，并实测自动增益是否维持高锐利度。Sony第二代传感器Xeria比前一代Exmor的感度提升许多，建议采用新一代传感器的摄像头，而CCD的低照度效果与自动增益噪点均比CMOS来的较佳。此外，透过足够的补光灯投射器予以适度补光，也是改善夜间画质的重要方式。 3. 车速快时画面拖影问题若道路监控摄像头快门值设定过低，对于高速行驶车辆会无法冻结车牌，产生拖影问题，造成车牌清晰度下降。道路监控摄像头通常在快门值设计在1/250sec（40km/hr）到1/750sec（100km/hr）下，会有较好的冻结效果，但因曝光值低需克服夜间照度不足问题。在传感器方面，CMOS较易发生拖影问题。由于CMOS传感器取像原理为Rolling Shutter，非全域曝光，因此易有拖影问题，但可透过后端芯片补偿为全域曝光来改善。而CCD传感器为Global Shutter全域曝光，无画面拖影问题。]]></content>
      <tags>
        <tag>安防</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相机镜头参数介绍(待更新)]]></title>
    <url>%2F2019%2F03%2F30%2FCamera%2F</url>
    <content type="text"><![CDATA[相机镜头基本参数介绍 镜头参数：CANON ZOOM LENS EF-S 18 -55mm 1：3.5-5.6 IS 参数解释：焦距范围18 -55mm；最大光圈系数 3.5-5.6；镜头带有防抖功能。 18-55MM是这款镜头的焦段，焦段：简单说就是变焦镜头焦距的变化范围。18指的是镜头广角端的焦段，55指的是镜头长焦端的焦段。 10mm左右的焦段，是超广角焦段，照出来的角度非常大，用于风景摄影，纪实摄影等。24mm左右的焦段，是小广角焦段。50mm左右的焦段，是标准焦段，视角平易近人，变形少，主要用于风景摄影，人像摄影，纪实摄影等。85mm左右的焦段，是中焦段，这个焦段主要用于拍人像，静物等。200mm左右的焦段，是长焦段，这个焦段常用于抓拍，特写等。 光圈是一个用来控制光线透过镜头，进入机身内感光面光量的装置，它通常是在镜头内。表达光圈大小我们是用f值。对于已经制造好的镜头，我们不可能随意改变镜头的直径，但是我们可以通过在镜头内部加入多边形或者圆形，并且面积可变的孔状光栅来达到控制镜头通光量，这个装置就叫做光圈。 比如某单反镜头参数是“18-50mm、0.5m-无限大、F2.8-3.5”，表示它的焦段为18-50mm，焦点为0.5米，在18mm广角端的最大光圈值是2.8，在50mm广角端最大光圈值是3.5。 就单反镜头来说，肯定是光圈值越大它的镜头质量就会越好，同等情况下大炮长焦价格最贵，广角次之，标准最便宜;恒定光圈也会比非恒定光圈值要好一些，但也有其他的影响因素，比如有无有色散片、MACRO，制作材料是金属还是材料等等，都会影响到它的效果和价格。 此外在单反相机镜头中，比较重要的参数是相机的像素以及传感器尺寸，像素越大、传感器尺寸越大，价格肯定是会越贵;对焦速度、快门声音等参数并不是最重要的，像一般中等的单反镜头的对焦、快门等表现就非常好，对于拍摄并不会造成太大影响，因此在购买的时候可以不考虑这两方面因素。 待更新]]></content>
      <tags>
        <tag>Camera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云储存选择做Hexo博客图床（腾讯云、七牛云、网易云）]]></title>
    <url>%2F2019%2F02%2F26%2Fhexo_cloud%2F</url>
    <content type="text"><![CDATA[博客图床 前言博客里需要添加很多图片作为内容的补充，但是把图片放在本地博客文件夹里，上传到网上后，加载这些图片就是一个很大的问题，他们会拖累网页加载的速度，所以建议把图片放图床里，通过外链来访问和加载这些图片。 云对象储存服务商国内免费的云对象储存的服务商(网易云、七牛云、腾讯云) 1.网易云官网：https://www.163yun.com/网易NOS（Netease Object Storage）网易对象存储为你提供基于互联网的数据存取服务，通过使用 NOS，你可以随时通过网络将你的文本、图片、音视频等各类文件存储到 NOS 系统中，并随时可以通过网络进行安全访问。 NOS 对象存储从三个维度进行计量收费：存储容量、流量、接口调用次数。存储容量0-50 GB是免费，下载流量在0-20 GB免费，每月前 10 万次 Put 请求免费，每月前 100 万次 Get 请求免费。 2.七牛云官网：https://www.qiniu.com/ 七牛云存储提供云存储、云处理、云加速分发一站式服务，注册成为标准用户后可获得10GB免费存储空间、每月10GB下载流量、每月10万次Put请求、每月100万次Get请求。 缺点：临时域名仅有三个月，三个月后没有自己的备案域名，所有图片均会失效 3.腾讯云官网：https://cloud.tencent.com/ 腾讯云对象存储服务COS，全称为Cloud Object Service，主要是为开发者提供安全、稳定、高效、实惠的对象存储服务，开发者可以将任意动态、静态生成的数据，存放到COS上，再通过HTTP的方式进行访问。 缺点：自2019年后新建用户可以领取一个6月有效期，50G的存储量。6月过后，按照存储量和流量收费。 在线图床选择https://sm.ms SM图床 https://tu.aixinxi.net/ 爱信息图床 https://imgchr.com/ 路过图床 总结云储存选择网易云，因为网易云对新用户的限制，免费的云储存有待选择 图床选择路过图床 目前还在用路过图床，缺点是图片链接不能看到任何图片名称等图片信息，不方便插入在博客里]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo主题Next配置及加载优化]]></title>
    <url>%2F2019%2F02%2F25%2Ftheme_Nextpro%2F</url>
    <content type="text"><![CDATA[Hexo主题Next配置及加载优化 主题源加载优化把在NexT主题的_config.yml里面的：12# Uri of fonts host. E.g. //fonts.googleapis.com (Default)host: 改为：12# Uri of fonts host. E.g. //fonts.googleapis.com (Default)host: //fonts.lug.ustc.edu.cn 因为fonts.lug.ustc.edu.cn是中科大的源，相比之前能快一下 博客双线部署参考文章地址 压缩网页静态资源参考文章地址hexo-neat插件github地址 常规的做法是使用gulp来进行压缩，每次压缩时还需要输入额外的命令，比较繁琐 配置hexo-neat压缩插件在站点根目录下安装hexo-neat博客目录下运行1npm install hexo-neat --save 如果报错，选择克隆插件，然后手动复制到插件目录里面hexo目录\node_modules\1git clone https://github.com/rozbo/hexo-neat 站点配置文件添加相关配置配置信息添加到博客目录文件夹下的hexo目录\_config.yml的末尾，可以安装自己的需求去自定义配置12345678910111213141516171819202122# hexo-neat# 博文压缩neat_enable: true# 压缩htmlneat_html: enable: true exclude:# 压缩css neat_css: enable: true exclude: - &apos;**/*.min.css&apos;# 压缩jsneat_js: enable: true mangle: true output: compress: exclude: - &apos;**/*.min.js&apos; - &apos;**/jquery.fancybox.pack.js&apos; - &apos;**/index.js&apos; 报错及相应解决参考文章地址 1、跳过压缩文件的正确配置方式如果按照官方插件的文档说明来配置exclude，你会发现完全不起作用。这是因为配置的文件路径不对，压缩时找不到你配置的文件，自然也就无法跳过了。你需要给这些文件指定正确的路径，万能的配置方式如下：1234neat_css:enable: trueexclude: - &apos;**/*.min.css&apos; 2、压缩html时不要跳过.md文件.md文件就是我们写文章时的markdown文件，如果跳过压缩.md文件，而你又刚好在文章中使用到了NexT自带的tab标签，那么当hexo在生成静态页面时就会发生解析错误。这会导致使用到了tab标签的页面生成失败而无法访问。 3、压缩html时不要跳过.swig文件.swig文件是模板引擎文件，简单的说hexo可以通过这些文件来生成对应的页面。如果跳过这些文件，那么你将会发现，你的所有页面完全没有起到压缩的效果，页面源代码里依然存在着一大堆空白。 4、点击的桃心效果消失1234567891011# 压缩jsneat_js: enable: true mangle: true output: compress: exclude: - &apos;**/*.min.js&apos; - &apos;**/jquery.fancybox.pack.js&apos; - &apos;**/index.js&apos; - &apos;**/love.js&apos; gitalk js文件报错在上面的代码底部加入如下代码1- &apos;**/comments.gitalk.js&apos; 5、jquery pjax min js报错我这里的 jquery pjax min js是指的加入pjax前需要以来的两个cdn文件，一个是jq，一个是它，我将它下载到了本地，不要在意这些细节~同样加入如下代码1- &apos;**/jquery_pjax_min_js.js&apos; 图片懒加载参考文章地址 懒加载，在需要的时候才加载图片，而不是一次性加载完整个页面的图片使用lazyload插件，适用于本地图片很多的情况 配置在Hexo博客目录下，执行以下命令：1npm install hexo-lazyload --save 然后在你的 Hexo目录的配置文件 _config.yml 中添加配置:1234lazyload: enable: true # className: #可选 e.g. .J-lazyload-img # loadingImg: #可选 eg. ./images/loading.png 参数：loadingImg - 图片未加载时的代替图 默认路径: /js/lazyload-plugin/loading.svg如果需要自定义，添填入 loading 图片地址，如果是本地图片，不要忘记把图片添加到你的主题目录下。 className - 需要延迟加载的图片 class选择器 默认会延迟加载文章中的所有图片。如果不为空，请填入需要延迟加载的图片class 选择器]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客使用valine评论系统无效果及终极解决方案]]></title>
    <url>%2F2019%2F02%2F20%2Fhexo_valine%2F</url>
    <content type="text"><![CDATA[Hexo博客使用valine评论系统无效果及终极解决方案 注意事项有一些博主valine评论系统无效果，有一些原因： 1、很大程度是因为next的版本升级导致某些参数设置不同2、valine评论是基于LeanCloud，还有一个文章阅读次数功能也是用LeanCloud，两者会有一点冲突 之后会给出一些解决方案 评论系统选择Hexo可用的评论系统有很多，如下： 来必力：https://livere.com （需要邮箱注册，加载慢，较卡顿） 畅言： http://changyan.kuaizhan.com （安装需要备案号） Gitment： https://github.com/imsun/gitment （加载慢，有Bug） Valine: https://github.com/xCss/Valine (简约，实用，使用Leancloud作为线上数据库） 评论系统配置过程next 集成了 leancloud 。可以在leancloud进行账号注册。 1、注册LeanCloud注册地址 https://leancloud.cn/ 2、配置LeanCloud创建一个新的应用 随便取个名字，自己看着取吧 应用创建完成，点开配置按钮 点击设置 &gt; 应用Key 复制App ID 和 App Key 点击设置 &gt; 安全中心 把自己博客网址添加到安全中心，保证数据的调用安全。 修改配置文件在主题themes目录下有第三方提供的主题配置文件\themes\next\_config.yml打开主题配置文件 添加appid 和appkey: 12345678910111213# Valine# You can get your appid and appkey from https://leancloud.cn# More info available at https://valine.js.orgvaline: enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version. appid: 粘贴id appkey: 粘贴key notify: false # mail notifier, See: https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: 欢迎交流讨论... # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 阅读次数功能配置过程创建阅读次数Class类在应用里面创建名称为Counter的Class，名称必须为Counter 创建完成，效果如下： 修改配置文件1234leancloud_visitors: enable: true appid: 粘贴id appkey: 粘贴key 评论系统无效原因及解决方案1、next的版本不同导致某些参数设置不同next为5.X版本的时候，配置文件themes\next\_config.yml的valine的id和key的书写方式为appid和appkey 123valine: appid: 粘贴id appkey: 粘贴key next为6.X版本的时候，配置文件themes\next\_config.yml的valine的id和key的书写方式为app_id和app_key123valine: app_id: 粘贴id app_key: 粘贴key 而Valine文件themes\next\layout\_third-party\comments\valine.swig内调用函数依旧为appid和appkey12appId: &apos;&#123;&#123; theme.valine.appid &#125;&#125;&apos;, appKey: &apos;&#123;&#123; theme.valine.appkey &#125;&#125;&apos;, 参数设置不同解决方案配置文件themes\next\_config.yml的valine的id和key的书写方式统一为为appid和appkey 2、valine评论和文章阅读次数功能均基于LeanCloud，两者有冲突valine评论和文章阅读次数功能均基于LeanCloud，在配置文件themes\next\_config.yml中，valine的配置项和文章阅读次数的配置项均需要填写LeanCloud的id和key123456789valine: enable: true app_id: 粘贴id app_key: 粘贴keyleancloud_visitors: enable: true appid: 粘贴id appkey: 粘贴key 即valine评论和文章阅读功能不能同时为true，只能单选一个功能。 功能冲突解决方案valine作者已经给出了方案，一个两种合一的配置 1234valine: ... visitor: true # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors&apos; for counter compatibility. Article reading statistic https://valine.js.org/visitor.html comment_count: true # if false, comment count will only be displayed in post page, not in home page 相比之前的配置项多了visitor和comment_count两项参数。即要想拥有Valine评论与文章阅读次数可见，设置Valine:为true，leancloud_visitors:为false，配置如下： 123456789101112131415161718# Valine# You can get your appid and appkey from https://leancloud.cn# More info available at https://valine.js.orgvaline: enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version. appid: 粘贴id appkey: 粘贴key notify: false # mail notifier, See: https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: 欢迎交流讨论... # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: true # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors&apos; for counter compatibility. Article reading statistic https://valine.js.org/visitor.html comment_count: true # if false, comment count will only be displayed in post page, not in home pageleancloud_visitors: enable: false Valine的CDN修改官方自带的CDN加载慢，建议将CDN改成第三方CDNvaline:，修改如下 123456# valine # See: https://github.com/xCss/Valine # Example: # valine: //cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js #valine: //cdnjs.cloudflare.com/ajax/libs/valine/1.3.4/Valine.min.js valine: //cdn.jsdelivr.net/npm/valine@1.3.4/dist/Valine.min.js 以上内容完成Valine评论的配置相关，都是自己踩的坑，合并了文章阅读次数的功能。 我的个人博客文章地址，欢迎访问 我的CSDN文章地址，欢迎访问 我的简书文章地址，欢迎访问 我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字数统计和阅读时长(网站底部/文章内)]]></title>
    <url>%2F2019%2F01%2F30%2Fhexo_next_wordcount%2F</url>
    <content type="text"><![CDATA[字数统计和阅读时长（旧版本新版本）插件地址：https://github.com/theme-next/hexo-symbols-count-time安装插件 1npm install hexo-symbols-count-time --save 修改 站点配置文件1234567symbols_count_time: #文章内是否显示 symbols: true time: true # 网页底部是否显示 total_symbols: true total_time: true 修改 主题配置文件123456789101112# Post wordcount display settings# Dependencies: https://github.com/theme-next/hexo-symbols-count-timesymbols_count_time: separated_meta: true #文章中的显示是否显示文字（本文字数|阅读时长） item_text_post: true #网页底部的显示是否显示文字（站点总字数|站点阅读时长） item_text_total: false # Average Word Length (chars count in word) awl: 4 # Words Per Minute wpm: 275]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客Next主题站内搜索模块相关，解决搜索无效、一直loading的问题]]></title>
    <url>%2F2019%2F01%2F30%2Fhexo_theme_next_search%2F</url>
    <content type="text"><![CDATA[Hexo博客Next主题站内搜索模块相关，解决搜索无效、一直loading的问题 站内搜索配置设置方法：首先安装hexo-generator-searchdb插件 1npm install hexo-generator-searchdb --save 编辑博客根目录下的博客本地目录/_config.yml站点配置文件，新增以下内容到任意位置，search顶格放否则可能没效果： 12345search: path: search.xml field: post format: html limit: 10000 编辑博客本地目录/themes/next/_config.yml 主题配置文件，启用本地搜索功能,将local_search:下面的enable:的值，改成true，local_search顶格放置。 123456789local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 # unescape html strings to the readable one unescape: false 可以输入以下命令，先清理缓存，然后本地部署调试12hexo cleanhexo s 命令输入完成，提示：Hexo is running at http://localhost:4000/，可以把网址复制到浏览器上，查看本地生成的博客搜索功能 搜索无效、一直loading的问题根据以上配置出的搜索框有可能出现无法加载，搜索无效，动画一直loading的问题，如下图： 按F12可以查看请求命令的状态，状态码200表示请求成功。但是搜索动画还是一直在转。 解决方案为了解决以上问题，也是花了很多时间在寻找办法，找个几个办法，终于解决了我的问题。 国光的博客地址 Linchao的博客地址 现给出比较详细的解决方法，如果搜索不成功，可能是以下原因之一 1、搜索插件没有配置好配置就按照文章前面配置的步骤走就行了 2、文章中包含特殊字符，文件编码时出错一般情况下，博客部署到网上想要进行本地调试，输入以下命令12hexo cleanhexo s 报错先不用管，命令输入完成，提示：Hexo is running at http://localhost:4000/。可以把网址复制到浏览器上，查看本地生成的博客，体验跟网站版的差不多，不出所料搜索框的动画还是会一直loading。 现在就要检查search.xml 文件，复制以下网址到浏览器，查看search.xml文件内容，是否报错。1localhost:4000/search.xml 效果图如下： 可以看到，有报错，报错内容就是说search.xml 文件有一些不能读取的内容，因为xml文件是有特殊符号不能使用。如果报错，浏览器右侧滑条拉到底，看看是哪里的文章出现问题。 效果图如下： 从最后的文字中找到一些信息，打开博客根目录下的search.xml文件 打开search.xml文件，找到包含那一些信息的那篇文章，最好是能开MarkDown在线编辑，也可以把有问题的.md文件拿出来，重新部署博客。 修改完成后，照平时那样部署博客就行。如果还有错，继续排查。 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的简书主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客Next主题阅读次数热度不能读取的问题，报错Counter not initialized! More info at console err msg.]]></title>
    <url>%2F2019%2F01%2F30%2Ftheme_next_leancloud%2F</url>
    <content type="text"><![CDATA[Hexo博客Next主题阅读次数热度不能读取的问题 加入valine在线评论设置效果： 设置方法：首先要先去LeanCloud注册一个帐号.然后再创建一个应用. 拿到appid和appkey之后，打开themes/next/_config.yml主题配置文件，查找valine，填入appid和 appkey我的配置: 1234567891011121314# You can get your appid and appkey from https://leancloud.cn# More info available at https://valine.js.orgvaline: enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version. appid: appkey: notify: true # mail notifier, See: https://github.com/xCss/Valine/wiki verify: true # Verification code placeholder: 欢迎交流讨论... # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: false # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors&apos; for counter compatibility. Article reading statistic https://valine.js.org/visitor.html comment_count: true # if false, comment count will only be displayed in post page, not in home page Hexo添加阅读次数next 集成了 leancloud 。可以在leancloud进行账号注册。创建一个新的应用。点击应用进入。创建名称为Counter的Class，名称必须为Counter 点击设置 &gt; 应用Key 复制App ID 和 App Key 修改配置文件在主题themes目录下有第三方提供的主题配置文件\themes\next_config.yml打开主题配置文件 添加app_id 和app_key:1234567891011# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.文章热度leancloud_visitors: enable: true app_id: llBsNPTabKsl2d4aU3OvrmSz-gzGzoHsz app_key: gzSQowSIzhnuc5eYPj4k7c7z # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security # If you don&apos;t care about security in leancloud counter and just want to use it directly # (without hexo-leancloud-counter-security plugin), set `security` to `false`. security: false betterPerformance: false 修改统计设置打开主题配置文件 定位到 post_wordcount12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true totalcount: false separated_meta: true Web安全性为了保证应用的统计计数功能仅应用于自己的博客，你可以在应用 &gt; 设置 &gt; 安全中心的Web安全域名中加入自己的博客域名，保证数据的调用安全。 显示文章热度首先要先去LeanCloud注册一个帐号.然后再创建一个应用. 设置方法：next主题集成leanCloud，打开themes/next/layout/_macro/post.swig,准备添加℃ 1234567891011121314&#123;# LeanCloud PageView #&#125;&#123;% if theme.leancloud_visitors.enable or (theme.valine.enable and theme.valine.appid and theme.valine.appkey and theme.valine.visitor) %&#125; &lt;span id=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; class=&quot;leancloud_visitors&quot; data-flag-title=&quot;&#123;&#123; post.title &#125;&#125;&quot;&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;post-meta-item-icon&quot;&gt; &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; &lt;/span&gt; &#123;% if theme.post_meta.item_text %&#125; &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123; __(&apos;post.views&apos;) + __(&apos;symbol.colon&apos;) &#125;&#125;&lt;/span&gt; &#123;% endif %&#125; &lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt; &lt;span&gt;℃&lt;/span&gt; &lt;/span&gt;&#123;% endif %&#125; 插入摄氏度到倒数第三句，如下：1&lt;span&gt;℃&lt;/span&gt; 打开，themes/next/languages/zh-CN.yml,将views后的文字描述改为热度.1views: 热度 有的版本不一样，打开，themes/next/languages/zh-Hans.yml，将以下 1visitors: 热度 然后打开themes/next/_config.yml找到leancloud_visitors,将enable:改成true,再填上自己LeanCloud的app_id和app_key。1234567891011# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.文章热度leancloud_visitors: enable: true app_id: 你自己的id app_key: 你自己的key # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security # If you don&apos;t care about security in leancloud counter and just want to use it directly # (without hexo-leancloud-counter-security plugin), set `security` to `false`. security: true betterPerformance: false 报错Counter not initialized! More info at console err msg.]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo主题Next配置algolia站内搜索]]></title>
    <url>%2F2019%2F01%2F30%2Fhexo_theme_next_algolia%2F</url>
    <content type="text"><![CDATA[Hexo主题Next配置algolia站内搜索 Algolia是一家为网站与移动应用提供托管式搜索API的初创企业，成立于2012年，总部位于旧金山，曾参加过去年的YC训练营。网站或移动应用只需嵌入简单代码数分钟即可实现搜索功能。 实现的效果如下 search注册Algolia打开Algolia进行注册。可直接使用github账号进行注册。 创建index点击 NEW INDEX创建一个新的index。Index Name 后面会使用到。INDEX 编辑KEY点击侧边栏API Keys可以看到 Application ID、 Search-Only API Key 、 Admin API Key。后面我们需要用到。 点击 ALL API KEYS，编辑KEY。 安装hexo-algoliasearch插件在Hexo的根目录下执行1$ npm install hexo-algoliasearch --save 配置站点信息打开 站点配置文件，添加algolia配置信息。123456algolia: applicationID: apiKey: adminApiKey: indexName: #创建index使用的Index Name chunkSize: 5000 打开 主题配置文件，添加algolia配置信息。123456789# Algolia Searchalgolia_search: enable: true hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: &quot;We didn&apos;t find any results for the search: $&#123;query&#125;&quot; hits_stats: &quot;$&#123;hits&#125; results found in $&#123;time&#125; ms&quot; 在环境变量中添加 HEXO_ALGOLIA_INDEXING_KEY， 在Hexo的根目录执行1$ export HEXO_ALGOLIA_INDEXING_KEY=粘贴上一步复制的 API KEY 再次执行12$ hexo clean$ hexo algolia 至此，我们的工作就完成了。 参考： Hexo+next 添加搜索功能 Hexo+Next集成Algolia搜索]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo主题Next配置]]></title>
    <url>%2F2019%2F01%2F20%2Ftheme_NextConfig1%2F</url>
    <content type="text"><![CDATA[Hexo主题Next配置 新建404界面在站点根目录下，输入hexo new page 404，在默认Hexo站点下/source/404/index.md打开新建的404界面，编辑属于自己的404界面，可以显示腾讯公益404界面，代码如下： 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://qzone.qq.com/gy/404/style/404style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/plain&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;/&quot; homePageName=&quot;回到我的主页&quot;&gt; &lt;/script&gt; &lt;script src=&quot;https://qzone.qq.com/gy/404/data.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://qzone.qq.com/gy/404/page.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 静态资源压缩静态资源压缩 在站点目录下安装插件： 1$ npm install gulp -g 12345npm install gulp-minify-css --savenpm install gulp-uglify --savenpm install gulp-htmlmin --savenpm install gulp-htmlclean --savenpm install gulp-imagemin --save 在Hexo站点下添加gulpfile.js文件，文件内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var uglify = require(&apos;gulp-uglify&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);var imagemin = require(&apos;gulp-imagemin&apos;);// 压缩css文件gulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩html文件gulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);// 压缩js文件gulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src([&apos;./public/**/.js&apos;,&apos;!./public/js/**/*min.js&apos;]) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩 public/demo 目录内图片gulp.task(&apos;minify-images&apos;, function() &#123; gulp.src(&apos;./public/demo/**/*.*&apos;) .pipe(imagemin(&#123; optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: false, //类型：Boolean 默认：false 多次优化svg直到完全优化 &#125;)) .pipe(gulp.dest(&apos;./public/uploads&apos;));&#125;);// 默认任务gulp.task(&apos;default&apos;, [ &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;,&apos;minify-images&apos;]); 需要只在每次执行generate命令后执行gulp就可以实现对静态资源的压缩，完成压缩后执行deploy命令同步到服务器： 123hexo ggulphexo d 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用&lt;!--与--&gt;隐藏之间的代码即可，或者直接删除。位置如图： 各版块透明度修改内容板块透明根博客目录themes\next\source\css\_schemes\Pisces\_layout.styl文件.content-wrap标签下background: white修改为：1background: rgba(255,255,255,0.7); //0.7是透明度 菜单栏背景根博客目录themes\next\source\css\_schemes\Pisces\_layout.styl文件.header-inner标签下background: white修改为：1background: rgba(255,255,255,0.7); //0.7是透明度 站点概况背景根博客目录themes\next\source\css\_schemes\Pisces\_sidebar.styl文件.sidebar-inner标签下background: white修改为：1background: rgba(255,255,255,0.7); //0.7是透明度 修改然后根博客目录themes\next\source\css\_schemes\Pisces\_layout.styl文件.sidebar标签下background: $body-bg-color修改为：1background: rgba(255,255,255,0.7); //0.7是透明度 网站底部字数统计具体方法实现 切换到根目录下，然后运行如下代码1npm install hexo-wordcount --save 然后在/themes/next/layout/_partials/footer.swig文件尾部加上：1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 添加侧栏推荐阅读编辑主题配置文件，如下配置即可：12345678# Blog rollslinks_icon: linklinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: Swift 4: https://developer.apple.com/swift/ Objective-C: https://developer.apple.com/documentation/objectivec 博文置顶修改hexo-generator-index插件，把node_modules/hexo-generator-index/lib/generator.js中代码替换为：12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 文章添加Top值，值越大，越靠前：123456789---title: Hexo-NexT主题配置date: 2018-01-20 20:41:08categories: Hexotags:- Hexo- NexTtop: 100--- 网页底部信息隐藏网页底默认最新一次使用，需要取消since注释，设定年份 1234567891011121314151617footer: # Specify the date when the site was setup. # If not defined, current year will be used. since: 2017 # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons/ # `heart` is recommended with animation in red (#ff0000). name: user #设置图标，想修改图标从https://fontawesome.com/v4.7.0/icons获取 # If you want to animate the icon, set it to true. animated: false # Change the color of icon, using Hex Code. color: &quot;#808080&quot; # If not defined, `author` from Hexo main config will be used. copyright: by AomanHao #版权 显示文章阅读进度百分比设置方法：打开themes/next/_config.yml主题配置文件,找到# Scroll percent label in b2t button将scrollpercent:的值,改成true 12# Scroll percent label in b2t button scrollpercent: true 浏览页面的时候显示当前浏览进度如果想把top按钮放在侧边栏,打开themes/next下的_config.yml,搜索关键字b2t,把false改为true 12345# Back to top in sidebar b2t: true # Scroll percent label in b2t button scrollpercent: true 加入valine在线评论设置效果： 设置方法：首先要先去LeanCloud注册一个帐号.然后再创建一个应用. 拿到appid和appkey之后，打开themes/next/_config.yml主题配置文件，查找valine，填入appid和 appkey我的配置: 1234567891011121314# You can get your appid and appkey from https://leancloud.cn# More info available at https://valine.js.orgvaline: enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version. appid: appkey: notify: true # mail notifier, See: https://github.com/xCss/Valine/wiki verify: true # Verification code placeholder: 欢迎交流讨论... # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size visitor: false # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors&apos; for counter compatibility. Article reading statistic https://valine.js.org/visitor.html comment_count: true # if false, comment count will only be displayed in post page, not in home page Hexo添加阅读次数next 集成了 leancloud 。可以在leancloud进行账号注册。创建一个新的应用。点击应用进入。创建名称为Counter的Class，名称必须为Counter 点击设置 &gt; 应用Key 复制App ID 和 App Key 修改配置文件在主题themes目录下有第三方提供的主题配置文件\themes\next_config.yml打开主题配置文件 添加app_id 和app_key:1234567891011# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.文章热度leancloud_visitors: enable: true app_id: app_key: # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security # If you don&apos;t care about security in leancloud counter and just want to use it directly # (without hexo-leancloud-counter-security plugin), set `security` to `false`. security: false betterPerformance: false Web安全性为了保证应用的统计计数功能仅应用于自己的博客，你可以在应用 &gt; 设置 &gt; 安全中心的Web安全域名中加入自己的博客域名，保证数据的调用安全。 显示文章热度首先要先去LeanCloud注册一个帐号.然后再创建一个应用. 设置方法：next主题集成leanCloud，打开themes/next/layout/_macro/post.swig,准备添加℃ 1234567891011121314&#123;# LeanCloud PageView #&#125;&#123;% if theme.leancloud_visitors.enable or (theme.valine.enable and theme.valine.appid and theme.valine.appkey and theme.valine.visitor) %&#125; &lt;span id=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; class=&quot;leancloud_visitors&quot; data-flag-title=&quot;&#123;&#123; post.title &#125;&#125;&quot;&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;post-meta-item-icon&quot;&gt; &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; &lt;/span&gt; &#123;% if theme.post_meta.item_text %&#125; &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123; __(&apos;post.views&apos;) + __(&apos;symbol.colon&apos;) &#125;&#125;&lt;/span&gt; &#123;% endif %&#125; &lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt; &lt;span&gt;℃&lt;/span&gt; &lt;/span&gt;&#123;% endif %&#125; 插入摄氏度到倒数第三句，如下：1&lt;span&gt;℃&lt;/span&gt; 打开，themes/next/languages/zh-CN.yml,将views后的文字描述改为热度.1views: 热度 有的版本不一样，打开，themes/next/languages/zh-Hans.yml，将以下 1visitors: 热度 然后打开themes/next/_config.yml找到leancloud_visitors,将enable:改成true,再填上自己LeanCloud的app_id和app_key。1234567891011# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.文章热度leancloud_visitors: enable: true app_id: 你自己的id app_key: 你自己的key # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security # If you don&apos;t care about security in leancloud counter and just want to use it directly # (without hexo-leancloud-counter-security plugin), set `security` to `false`. security: true betterPerformance: false 添加网站已运行时间在themes/layout/_parrials/footer.swing后添加 1234567891011121314151617&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;&lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date(&quot;11/27/2017 12:00:00&quot;);//在此处修改你的建站时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = &quot;0&quot; + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = &quot;0&quot; + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = &quot;0&quot; + snum;&#125; document.getElementById(&quot;timeDate&quot;).innerHTML = &quot; Runing &quot;+dnum+&quot; D &quot;; document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; H &quot; + mnum + &quot; M &quot; + snum + &quot; S&quot;; &#125; setInterval(&quot;createtime()&quot;,250);&lt;/script&gt; 添加头像打开themes/next下的_config.yml文件，搜索 Avatar关键字，修改url的参数1234567891011avatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/avatar.gif # If true, the avatar would be dispalyed in circle. rounded: true # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: false url链接默认是themes/next/source/images下的avatar.gif文件,有两种方法修改连接 1、本地连接，不建议用比较大的图片（大于1M文件），加载图片需要时间12345url: /images/avatar.gif或者url: /images/xx.jpg等类型图片 2、图床外链，建议使用1url: http://example.com/avatar.png 添加站内搜索设置效果： 设置方法：安装hexo-generator-searchdb插件1npm install hexo-generator-searchdb --save 编辑_config.yml站点配置文件，新增以下内容到任意位置：12345search: path: search.xml field: post format: html limit: 10000 编辑themes/next/_config.yml主题配置文件，启用本地搜索功能,将local_search:下面的enable:的值，改成true 123# Local searchlocal_search: enable: true 底部跳动图标实现注意点：需要到next\layout_partials下的footer.swig文件中，在你所需要调动的图标所对应的span中增加对应的ID去到主体的css文件（next\source\css_variables\custom.styl，增加以下代码即可 123456789101112131415//底部爱心小图标跳动keyframes heartAnimate &#123; 0%,100%&#123;transform:scale(1);&#125; 10%,30%&#123;transform:scale(0.9);&#125; 20%,40%,60%,80%&#123;transform:scale(1.1);&#125; 50%,70%&#123;transform:scale(1.1);&#125;&#125;//图标所对应的span中的ID#heart &#123; animation: heartAnimate 1.33s ease-in-out infinite;&#125;.with-love &#123; color: rgb(255, 113, 113);&#125; 实现统计功能具体实现方法:在根目录下安装 hexo-wordcount,运行：1npm install hexo-wordcount --save 然后在主题的配置文件中，配置如下：123456# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true 修改界面内容显示区域宽度Next主题默认的设置，两边留白的区域很大。当然我们可以修改设置在themes\next\source\css\_custom的custom.styl添加下面参数12345// 屏幕宽度小于1600px$content-desktop = 700px// 屏幕宽度大于或等于 1600px$content-desktop-large = 900px]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo主题Next配置（二）]]></title>
    <url>%2F2019%2F01%2F20%2Ftheme_NextConfig2%2F</url>
    <content type="text"><![CDATA[Hexo主题Next配置（二） 随机背景图片加载原理自动更换背景是修改添加背景的css样式实现 图片来源https://source.unsplash.com/ 修改背景样式修改themes\next\source\css\ _custom\custom.styl文件，这个是Next故意留给用户自己个性化定制一些样式的文件，添加以下代码：1234567body &#123; background:url(https://source.unsplash.com/random/1600x900); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; background-size:cover;&#125; 参数细节url可更换为自己喜欢的图片的地址。repeat：是否重复出现attachment：定义背景图片随滚动轴的移动方式position：设置背景图像的起始位置。background-size:cover为可能有助于大分辨率下背景图的显示 修改不透明度（可加可不加，看实际效果）因为next主题的背景是纯透明的，这样子就造成背景图片的影响看不见文字，这对于博客来说肯定不行。 调整背景的不透明度可以更加美观，参数opacity:建议调整0.8至0.95之间。修改themes\next\source\css\ _custom\custom.styl文件。在后面添加如下代码1234567.main-inner &#123; margin-top: 60px; padding: 60px 60px 60px 60px; background: #fff; opacity: 0.9; min-height: 500px;&#125; 其中：background: #fff; 白色opacity: 0.9;为不透明度 注：效果还可以，但是博客备份在github上，网速限制加载的比较忙，建议博客放在国内的Coding上 固定背景图片加载hexo\themes\next\source\images\ 的路径下；在文件的最上方加上一代码 body { background:url(/images/backGround.jpg（这是你之前加的背景图片的名字）);} 就完事了。 修改背景样式修改themes\next\source\css\ _custom\custom.styl文件，添加以下代码：1234567body &#123; background:url(/images/图片.jpg); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; background-size:cover;&#125; 侧边栏社交小图标设置侧边栏默认只有打开主题配置文件（_config.yml），搜索social_icons:,在fontawesome图标库（网址）找自己喜欢的小图标，并将名字复制在如下位置配置文件 12345678910111213social: GitHub: https://github.com/yourname || github E-Mail: mailto:邮箱地址 || envelope Weibo: https://weibo.com/yourname || weibo CSDN: https://me.csdn.net/yourname || book #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 设置网站图标下载图标图标网站 下载尺寸32 X 32的图标，文件名必须是favicon.ico。 图标放在2.将图标放在下一个/源极/图像文件夹目录下面。 配置3.配置主题目录中的配置文件（敲黑板，重点） 之前网上查到的方法如下:(并没有成功） 放大文章内图片使用了图片浏览放大功能fancybox插件插件地址 下载插件安装包下载插件安装包到blog的lib目录 1$ cd themes/next 1$ git clone https://github.com/theme-next/theme-next-fancybox source/lib/fancybox 注意删掉fancybox文件夹里的 .git``.github文件夹 更改主题配置文件更改next/_config.yml文件1fancybox: true]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理_噪声检测]]></title>
    <url>%2F2018%2F12%2F25%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%99%AA%E5%A3%B0%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[噪声检测 噪声检测方法将噪声和信号区分开来是影响去噪效果好坏的重要因素之一。近年来，学者们提出了诸多噪声判断方法，其中较经典的方法包括：开关阈值法、极值法、两级门限法，下面对这三种方法进行介绍，并进行对比。1.1 常见的噪声检测方法（1）开关阈值法开关阈值判断法[1]基本思想是：该方法通过一定的规则将噪声点和信号点进行判断，区分成两种类别来控制开关单元。若该像素点被判断为噪声点，则开关单元与滤波器相连接，即该点经过滤波后输出；若该像素点被判断为信号点，则开关单元对该点保持原像素值输出。开关阈值法的重点在于噪声检测器的设置，其中较为常见的一种开关阈值判断法表示如下： X_(i,j=)\begin{cases} S,|f(i,j)-average(W[x_(i,j)])|]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理_DCT（占坑）]]></title>
    <url>%2F2018%2F10%2F25%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_DCT%2F</url>
    <content type="text"><![CDATA[DCT]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理_图像噪声]]></title>
    <url>%2F2018%2F10%2F25%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E5%99%AA%E5%A3%B0%2F</url>
    <content type="text"><![CDATA[图像噪声 噪声加性噪声一般指热噪声、散弹噪声等，它们与信号的关系是相加，不管有没有信号，噪声都存在。 高斯白噪声包括热噪声和散粒噪声。在通信信道测试和建模中，高斯噪声被用作加性白噪声以产生加性白高斯噪声。 加性高斯白噪声只是白噪声的一种，另有泊松白噪声等,加性高斯白噪声在通信领域中指的是一种各频谱分量服从均匀分布（即白噪声），且幅度服从高斯分布的噪声信号。因其可加性、幅度服从高斯分布且为白噪声的一种而得名。 而乘性噪声一般由信道不理想引起，它们与信号的关系是相乘，信号在它在，信号不在他也就不在。 一般通信中把加性随机性看成是系统的背景噪声； 而乘性随机性看成系统的时变性（如衰落或者多普勒）或者非线性所造成的。 椒盐噪声定义：椒盐噪声又称为双极脉冲噪声，这种噪声表现的特点是噪声像素的灰度值与邻域像素有着明显差异，而其余像素的灰度值保持不变，因此在图像中造成过亮或过暗的像素点。椒盐噪声严重影响图像的视觉质量，给图像的边缘检测、纹理或者特征点提取等造成困难。 去椒盐噪声办法1234567891、中值滤波2、开关中值滤波器 SMF（Switching Median Filter）[参考文献](Detail - preserving median based filters in image rocessing)3、自适应中值滤波器 AMF（Adaptive Median Filter）[参考文献](Adaptive median filters : New algorithms and results)4、自适应中心加权中值滤波器 ACWMF（Adaptive Center Weighted Median Filter） [参考文献](adaptive impulse detection using center Weighted median filter)5、基于决策的算法ＤＢＡ ( Decision Based Algorithm) [参考文献](A new fast and efficient decision Based algorithm for removal of high density impulse noises) 一般会选择先检测再滤波的思路，通过开关机制抑制噪声，上述方法对低噪声水平的椒盐噪声处理效果良好，噪声水平过高无法得到理想的结果。因为基于中值的滤波方法仅考虑图像局部区域像素点的顺序阶信息，没有充分利用像素点之间的相关性或相似性。噪声像素点的估计值可能与真实值有较大偏差，很难保持图像的细节信息。 高斯噪声高斯噪声是指概率密度函数服从高斯分布（即正态分布）的一类噪声。如果一个噪声，它的幅度服从高斯分布，而它的功率谱密度又是分布均匀的，则称它为高斯白噪声。高斯白噪声的二阶矩不想关，一阶矩为常数，是指先后信号在时间上的相关性。高斯白噪声包括热噪声和散粒噪声。高斯噪声完全由其时变平均值和两瞬时的协方差函数来确定，若噪声为平稳的，则平均值与时间无关，而协方差函数则变成仅和所考虑的两瞬时之方差有关的相关函数，它在意义上等效于功率谱密度。高斯噪声可以由大量独立的脉冲产生，从而在任何有限时间间隔内，这些脉冲中的每一个脉冲值与所有脉冲值的总和相比都可以忽略不计]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客添加相册]]></title>
    <url>%2F2018%2F09%2F23%2FHexo%E7%9B%B8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[相册 实现思路1.在主页上必须有一个可供点击的相册连接2.要用 hexo 生成一个photos.html文件3.photos.html中的图片数据来源?因为这是一个静态页面所有要有一个 json文件4.json文件中有含有信息,图片的文件名.5.图片要有一个完整的路径,用github的空间6.Python脚本剪裁、压缩、上传图片到自定义的github备份仓库中 操作步骤1.在主页上必须有一个可供点击的连接BLOG\source目录下创建一个photos目录，目的是存放利用脚本生成的json文件和渲染文件。 配置 Yilia 主题让其显示出来.yourBlog/themes/yilia/_config.yml文件添加相册 1相册: /photos/ 2.如何生成 photos.html 文件来在github上新建一个仓库，主要用于存储图片，可以通过url访问到，也方便管理，备份图片和其他东西 git clone 到本地，模仿作者的文件目录结构 source文件夹是备份图片，theme是备份yilia配置文件等 min_photos是缩略图文件夹，photos是原图文件夹，blog_photos_copy是渲染文件备份，最后再弄 备份渲染文件，最后再弄 ejs文件是以后要hexo 渲染的文件. ins.js文件设置自己的东西. 3.修改 ejs 模板文件3.1 index.ejs文件可以不用修改3.2 修改 ins.js 文件的 render()函数.这个函数是用来渲染数据的修改图片的路径地址.minSrc 小图的路径. src 大图的路径.修改为自己的图片路径(github的路径). 12var minSrc = &apos;https://raw.githubusercontent.com/AomanHao/Blog-Back-Up/master/source/min_photos/&apos; + data.link[i];var src = &apos;https://raw.githubusercontent.com/AomanHao/Blog-Back-Up/master/source/photos/&apos; + data.link[i]; 这个链接不是直接的图片url，是需要点“下载”才能看到的url。 github仓库上传的图片文件 下载选项，看网址 黄色画出了链接网址，路径地址.minSrc 小图的路径. src 大图的路径 我的路径有source/min_photos/和source/photos，分别是缩略图（压缩的图快速加载预览）和原图（点击查看图片） 3.3生成 json 文件.这一步是关键的一步,也是最后一步.先用脚本把图片处理成一套大图和一套小图,然后上传的七牛或者 github 上再回头生成这个 json文件.每次更新图片都要执行脚本重新生成 json文件.这个json文件会出现在yourBlog/source/photos/data.json 4.处理图片处理脚本试用python语言写的，运行环境也是python python脚本文件原作者GitHub地址：https://github.com/lawlite19/Blog-Back-Up 下载python2或者3，在cmd运行窗口运行python tool.py tool.py是运行主函数，ImageProcess图像处理功能函数，包括裁剪、压缩等 git_operation()方法: 如果你把图片上传到你的 github上这个方法就不用更改了.但是要确保在可以push到github的文件夹里，按照之前操作兴建了博客文件备份仓库 handle_photo()方法:注意: 该脚本对图片的命名规则有要求.最前面是日期，然后用进行分隔；后面是图片的描述信息，注意不要包含和.符号 5.注意事项5.1最前面是日期，然后用进行分隔；后面是图片的描述信息，注意不要包含和.符号 图片应该这样命名: 2016-10-12_xxx.jpg/png；存放在photos中，然后脚本运行会生成压缩图片，放置在min_photos文件夹中。 5.2 tool.py文件中open里面的设置的是本地博客路径 如D:/GitHub/AomanHao.github.io/source/photos/data.json D:/GitHub/AomanHao.github.io/是你的博客在本地的路径，data.json是图片信息文件 5.3点开图片可以显示，缩略图不显示 下载empty图，下载地址，直接右键另存，保存为“empty.png”。 在你博客的本地仓库source下新建一个文件夹命名为assets,再在assets下新建一个文件夹命名为img。最后把empty.png放到img里面。 我的目录如下： 结尾：在github上新建一个仓库，主要用于存储图片，可以通过url访问到，也方便管理将要放到相册的图片处理成json格式的数据，然后进行访问，这里json的格式需要配合要使用的样式，所以需要处理成特定格式的json数据，下面会给出图片裁剪，因为相册显示的样式最好是正方形的的图片，这里使用脚本处理一下图片压缩，相册显示的图片是压缩后的图片，提高加载的速度，打开后的图片是原图。 问题：当我用中文作为相册名字的时候，无法生成data.json文件，很纳闷，报错 UTF8的编码错误 算了，暂时找不改正的方法，可能是python是2.多的原因吧，我的相片都是用了英文命名 参考文章1参考文章2参考文章3]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git配置]]></title>
    <url>%2F2018%2F09%2F19%2FGit%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Git配置 右键菜单配置 Git Bash Here 功能键运行regedit.exe进入注册表，在HKEY_CLASSES_ROOT\Directory\Background\shell中进行设置。 1.新建项Git Bush Here，此时你可以看到在桌面右键会出现“Git Bush Here”菜单。 2.添加Git Bush Icon，在第一步的新建项Git Bush Here下，新建字符串值Icon，然后编辑该值为“C:\Program Files\Git\mingw64\share\git\git-for-windows.ico”，你需要根据你安装的Git 目录进行配置修改。完成此步后，你会发现右键菜单“Git Bush Here”会多出一个Icon。 3.添加Command项。在“Git Bush Here”下再新建项“Command”，将其默认值改为“C:\Program Files\Git\bin\bash.exe —login -i”，这样，你就可以通过右键菜单的方式快速进入Git命令行工具，进行代码版本管理。 git 命令1.git config 该命令允许你获得和设置配置变量；这些变量可以控制Git的外观和操作的各个方面。123使用方法: git config –global user.name “[name]”使用方法: git config –global user.email “[email address]” 2.git init git init命令创建一个空的Git仓库或重新初始化一个现有仓库。1使用方法：git init [repository name] 3.git clone git clone命令将存储库克隆到新目录中。1使用方法：git clone [url] 4.git add git add命令将文件内容添加到索引(将修改添加到暂存区)。也就是将要提交的文件的信息添加到索引库中。1使用方法: git add [file] ; 5.git commit该命令用于将更改记录(提交)到存储库。将索引的当前内容与描述更改的用户和日志消息一起存储在新的提交中。 123使用方法: git commit -m “[ Type in the commit message]”使用方法：git commit -a 在修改文件后,需要使用gitadd把文件加入暂存区,这样gitcommit时才能把已经修改的信息加入版本库,而使用gitcommit-a可以不用再git add。 6.git diff 该命令用于显示提交和工作树等之间的更改。此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。123使用方法: git diff使用方法：git diff –staged gitdiff—staged显示的是暂存区和版本库差异 1使用方法：git diff [first branch] [second branch] 命令显示两个分支之间的差异。 7.git resetgit reset命令用于将当前HEAD复位到指定状态。一般用于撤消之前的一些操作(如:git add,git commit等)。123使用方法: git reset [file]使用方法: git reset [commit] 撤消指定提交后的所有提交，并在本地保留更改。 1使用方法：git reset –hard [commit] 丢弃所有历史记录并返回到指定的提交。 8.git status该命令用于显示工作目录和暂存区的状态。1使用方法: git status 9.git rm该命令用于从工作区和索引中删除文件。1使用方法: git rm [file] 10.git log该命令用于显示提交日志信息。123使用方法: git log使用方法：git log –follow[file] 列出文件的版本历史记录，包括文件的重命名。 11.git show该命令用于显示各种类型的对象。1使用方法: git show [commit] 12.git tag该命令用于创建,列出,删除或验证使用GPG签名的标签对象。1使用方法: git tag [commitID] 13.git branch 该命令列出当前存储库中的所有本地分支。123使用方法: git branch使用方法：git branch [branch name] 创建一个新分支。 1使用方法：git branch -d [branch name] 删除分支 14.git checkout 该命令命令用于从一个分支切换到另一个分支。 使用方法：git checkout [branch name] 使用方法: git checkout -b [branch name] 该命令创建一个新分支并切换过去。 15.git merge该命令用于将两个或两个以上的开发历史加入(合并)一起。 使用方法: git merge [branch name] 16.git remote该命令管理一组跟踪的存储库。 使用方法: git remote add [variable name] [Remote Server Link] 17.git push该命令用于将本地分支的更新,推送到远程主机。 使用方法: git push [variable name] master 使用方法：git push [variable name] [branch] 将分支提交到远程存储库。 使用方法：git push –all [variable name] 将所有分支推送到远程存储库。 使用方法: git push [variable name] :[branch name] 删除远程存储库上的分支。 18.git pull该命令用于从另一个存储库或本地分支获取并集成(整合)。 使用方法: git pull [Repository Link] 19.git stash该命令临时存储所有已修改的跟踪文件。。 使用方法: git stash save 使用方法：git stash pop 可恢复最近隐藏的文件。 使用方法：git stash list 列出所有存储的更改集。 使用方法：git stash drop 移除stash]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VScode配置]]></title>
    <url>%2F2018%2F09%2F19%2FVScode%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[VScode配置 VScode插件Git History（装完输入 git log有惊喜) Git Lens（让本就集成了 git 的 VSC 更加强大 Markdown Preview Enhanced(markdown 预览) Emoji Code Dracula Official 吸血鬼主题，暗黑风格 Code Runner —- 支持多种语言例如： C，C++，Java，JavaSript，PHP，Python，Perl，Perl6 等 Bracket Pair Colorizer 和 Indent Rainbow，这两个插件可以让不同缩减的括号显示不同的颜色。 Auto Close Tag 和 Auto Rename Tag 插件，自动补全标签和联动重名标签 Studio Icons 图标展示，丰富界面 VScode设置中文界面123456781、按f1，搜索 Configore Display Language 设置 zh-cn 关闭软件重启。2、如果重启菜单等还是英文的，在商店查看已安装的插件，把中文插件重新安装一遍，然后重启软件。应用商店搜索插件-chinese(simplified) 参考文章]]></content>
      <tags>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理_灰度变换_直方图]]></title>
    <url>%2F2018%2F09%2F07%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2_%E7%9B%B4%E6%96%B9%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[图像处理灰度变换直方图 直方图均衡化 Histogram Equalization假如图像的灰度分布不均匀，其灰度分布集中在较窄的范围内，使图像的细节不够清晰，对比度较低。通常采用直方图均衡化及直方图规定化两种变换，使图像的灰度范围拉开或使灰度均匀分布，从而增大反差，使图像细节清晰，以达到增强的目的。直方图均衡化，对图像进行非线性拉伸，重新分配图像的灰度值，使一定范围内图像的灰度值大致相等。这样，原来直方图中间的峰值部分对比度得到增强，而两侧的谷底部分对比度降低，输出图像的直方图是一个较为平坦的直方图。 均衡化算法直方图的均衡化实际也是一种灰度的变换过程，将当前的灰度分布通过一个变换函数，变换为范围更宽、灰度分布更均匀的图像。也就是将原图像的直方图修改为在整个灰度区间内大致均匀分布，因此扩大了图像的动态范围，增强图像的对比度。通常均衡化选择的变换函数是灰度的累积概率，直方图均衡化算法的步骤： 1、计算原图像的灰度直方图 $P(S_k)=n_kn$，其中$n$为像素总数，$n_k$为灰度级$S_k$的像素个数 2、计算原始图像的累积直方图$CDF(Sk)=\sum{i=0}^knin=\sum{i=0}^kPs(Si)$$D_j=L⋅CDF(S_i)$其中 $D_j$是目的图像的像素，$CDF(S_i)$是源图像灰度为i的累积分布，$L$是图像中最大灰度级（灰度图为255）直接应用该方法得到图像的灰度直方图 3、将灰度直方图进行归一化，计算灰度的累积概率；创建灰度变化的查找表应用查找表，将原图像变换为灰度均衡的图像 均衡化过程中，必须要保证两个条件 1、像素无论怎么映射，一定要保证原来的大小关系不变，较亮的区域，依旧是较亮的，较暗依旧暗，只是对比度增大，绝对不能明暗颠倒；2、如果是八位图像，那么像素映射函数的值域应在0和255之间的，不能越界。 综合以上两个条件，累积分布函数是个好的选择，因为累积分布函数是单调增函数（控制大小关系），并且值域是0到1（控制越界问题），所以直方图均衡化中使用的是累积分布函数。 累积分布函数累积分布函数具有一些好的性质，那么如何运用累积分布函数使得直方图均衡化？比较概率分布函数和累积分布函数，前者的二维图像是参差不齐的，后者是单调递增的。直方图均衡化过程中，映射方法是 S_k = \sum_{j=0}^k\frac{n_j}{n} . k=0,1...,L-1$n$是图像素总和，$n_k$是当前灰度级的像素个数，$L$是图像中灰度级总数 操作步骤有: 直方图规定化直方图规定化，就是对原始图像做变换，使得变换后的图像的直方图跟我们规定的一样。 具体步骤如下： 1、首先对原始图像做直方图均衡化，得到每个像素s和累积分布T(s); 2、根据需要的规定化直方图，求累积分布G(Z)； 3、显然，如果累积直方图中有0值，那么是不会分配像素值的，因为0乘以255还是零。 4、对于每一个T（s）（假设其像素值为ss）,找到在G（Z）中与其差值最小的那个G（z）值（假设对应的像素值为zz），那么规定化后就把ss变换为zz。 直方图规定化流程下图： 1、计算原图像的累积直方图 2、计算规定直方图的累积直方图 3、计算两累积直方图的差值的绝对值 4、根据累积直方图差值建立灰度级的映射 局部直方图处理&amp;直方图统计Opencv代码灰度直方图均衡123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128// HistogramGrayEqualizeHist.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;opencv2/core/core.hpp&gt; //cvGetSize cvCreateImage#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/opencv.hpp&gt; //cvResize cvInitMatHeader cvGetMinMaxHistValue cvCvtColor#include &lt;opencv2/imgproc/imgproc.hpp&gt;#ifdef _DEBUG#pragma comment(lib, &quot;opencv_core244d&quot;)#pragma comment(lib, &quot;opencv_highgui244d&quot;)#pragma comment(lib, &quot;opencv_imgproc244d&quot;) //cvResize#else#pragma comment(lib, &quot;opencv_core244d&quot;)#pragma comment(lib, &quot;opencv_highgui244d&quot;)#pragma comment(lib, &quot;opencv_imgproc244d&quot;) //cvResize#endif#define cvQueryHistValue_1D(hist,idx0) ((float)cvGetReal1D( (hist)-&gt;bins, (idx0)))using namespace std; #pragma comment(linker, &quot;/subsystem:\&quot;windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;) void FillWhite(IplImage *pImage) &#123; cvRectangle(pImage, cvPoint(0, 0), cvPoint(pImage-&gt;width, pImage-&gt;height), CV_RGB(255, 255, 255), CV_FILLED); &#125; // 创建灰度图像的直方图 CvHistogram* CreateGrayImageHist(IplImage **ppImage) &#123; int nHistSize = 256; float fRange[] = &#123;0, 255&#125;; //灰度级的范围 float *pfRanges[] = &#123;fRange&#125;; CvHistogram *pcvHistogram = cvCreateHist(1, &amp;nHistSize, CV_HIST_ARRAY, pfRanges); cvCalcHist(ppImage, pcvHistogram); return pcvHistogram; &#125; // 根据直方图创建直方图图像 IplImage* CreateHisogramImage(int nImageWidth, int nScale, int nImageHeight, CvHistogram *pcvHistogram) &#123; IplImage *pHistImage = cvCreateImage(cvSize(nImageWidth * nScale, nImageHeight), IPL_DEPTH_8U, 1); FillWhite(pHistImage); //统计直方图中的最大直方块 float fMaxHistValue = 0; cvGetMinMaxHistValue(pcvHistogram, NULL, &amp;fMaxHistValue, NULL, NULL); //分别将每个直方块的值绘制到图中 int i; for(i = 0; i &lt; nImageWidth; i++) &#123; float fHistValue = cvQueryHistValue_1D(pcvHistogram, i); //像素为i的直方块大小 int nRealHeight = cvRound((fHistValue / fMaxHistValue) * nImageHeight); //要绘制的高度 cvRectangle(pHistImage, cvPoint(i * nScale, nImageHeight - 1), cvPoint((i + 1) * nScale - 1, nImageHeight - nRealHeight), cvScalar(i, 0, 0, 0), CV_FILLED ); &#125; return pHistImage; &#125; int main( int argc, char** argv ) &#123; const char *pstrWindowsSrcTitle = &quot;原图&quot;; const char *pstrWindowsGrayTitle = &quot;灰度图&quot;; const char *pstrWindowsHistTitle = &quot;直方图&quot;; const char *pstrWindowsGrayEqualizeTitle = &quot;灰度图-均衡化后&quot;; const char *pstrWindowsHistEqualizeTitle = &quot;直方图-均衡化后&quot;; // 从文件中加载原图 // IplImage *pSrcImage = cvLoadImage(&quot;./images/yangmi.jpg&quot;, CV_LOAD_IMAGE_UNCHANGED); IplImage *pSrcImage = cvLoadImage(&quot;./images/beauty.png&quot;, CV_LOAD_IMAGE_UNCHANGED); IplImage *pGrayImage = cvCreateImage(cvGetSize(pSrcImage), IPL_DEPTH_8U, 1); IplImage *pGrayEqualizeImage = cvCreateImage(cvGetSize(pSrcImage), IPL_DEPTH_8U, 1); // 灰度图 cvCvtColor(pSrcImage, pGrayImage, CV_BGR2GRAY); // 直方图图像数据 int nHistImageWidth = 255; int nHistImageHeight = 150; int nScale = 2; // 灰度直方图及直方图图像 CvHistogram *pcvHistogram = CreateGrayImageHist(&amp;pGrayImage); IplImage *pHistImage = CreateHisogramImage(nHistImageWidth, nScale, nHistImageHeight, pcvHistogram); // 均衡化 //函数功能：直方图均衡化，该函数能归一化图像亮度和增强对比度 //第一个参数表示输入图像，必须为灰度图（8位，单通道图） //第二个参数表示输出图像 //该函数采用如下法则对输入图像进行直方图均衡化： //1：计算输入图像的直方图H。 //2：直方图归一化，因此直方块和为255。 //3：计算直方图积分，H&apos;(i) = Sum(H(j)) (0&lt;=j&lt;=i)。 //4：采用H&apos;作为查询表：dst(x, y) = H&apos;(src(x, y))进行图像变换。 cvEqualizeHist(pGrayImage, pGrayEqualizeImage); // 均衡化后的灰度直方图及直方图图像 CvHistogram *pcvHistogramEqualize = CreateGrayImageHist(&amp;pGrayEqualizeImage); IplImage *pHistEqualizeImage = CreateHisogramImage(nHistImageWidth, nScale, nHistImageHeight, pcvHistogramEqualize); // 显示 cvNamedWindow(pstrWindowsSrcTitle); cvNamedWindow(pstrWindowsGrayTitle); cvNamedWindow(pstrWindowsGrayEqualizeTitle); cvNamedWindow(pstrWindowsHistTitle); cvNamedWindow(pstrWindowsHistEqualizeTitle); cvShowImage(pstrWindowsSrcTitle,pSrcImage); cvShowImage(pstrWindowsGrayTitle,pGrayImage); cvShowImage(pstrWindowsGrayEqualizeTitle,pGrayEqualizeImage); cvShowImage(pstrWindowsHistTitle,pHistImage); cvShowImage(pstrWindowsHistEqualizeTitle,pHistEqualizeImage); cvWaitKey(0); //回收资源代码… cvDestroyWindow(pstrWindowsSrcTitle); cvDestroyWindow(pstrWindowsGrayTitle); cvDestroyWindow(pstrWindowsGrayEqualizeTitle); cvDestroyWindow(pstrWindowsHistTitle); cvDestroyWindow(pstrWindowsHistEqualizeTitle); cvReleaseImage(&amp;pSrcImage); cvReleaseImage(&amp;pGrayImage); cvReleaseImage(&amp;pGrayEqualizeImage); cvReleaseImage(&amp;pHistImage); cvReleaseImage(&amp;pHistEqualizeImage); return 0; &#125; 直方图规定化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void hist_specify(const Mat &amp;src, const Mat &amp;dst,Mat &amp;result)&#123; Histogram1D hist1D; MatND src_hist = hist1D.getHistogram(src); MatND dst_hist = hist1D.getHistogram(dst); float src_cdf[256] = &#123; 0 &#125;; float dst_cdf[256] = &#123; 0 &#125;; // 源图像和目标图像的大小不一样，要将得到的直方图进行归一化处理 src_hist /= (src.rows * src.cols); dst_hist /= (dst.rows * dst.cols); // 计算原始直方图和规定直方图的累积概率 for (int i = 0; i &lt; 256; i++) &#123; if (i == 0) &#123; src_cdf[i] = src_hist.at&lt;float&gt;(i); dst_cdf[i] = dst_hist.at&lt;float&gt;(i); &#125; else &#123; src_cdf[i] = src_cdf[i - 1] + src_hist.at&lt;float&gt;(i); dst_cdf[i] = dst_cdf[i - 1] + dst_hist.at&lt;float&gt;(i); &#125; &#125; // 累积概率的差值 float diff_cdf[256][256]; for (int i = 0; i &lt; 256; i++) for (int j = 0; j &lt; 256; j++) diff_cdf[i][j] = fabs(src_cdf[i] - dst_cdf[j]); // 构建灰度级映射表 Mat lut(1, 256, CV_8U); for (int i = 0; i &lt; 256; i++) &#123; // 查找源灰度级为ｉ的映射灰度 // 和ｉ的累积概率差值最小的规定化灰度 float min = diff_cdf[i][0]; int index = 0; for (int j = 1; j &lt; 256; j++) &#123; if (min &gt; diff_cdf[i][j]) &#123; min = diff_cdf[i][j]; index = j; &#125; &#125; lut.at&lt;uchar&gt;(i) = static_cast&lt;uchar&gt;(index); &#125; // 应用查找表，做直方图规定化 LUT(src, lut, result);&#125;]]></content>
      <tags>
        <tag>图像处理</tag>
        <tag>Opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习面试]]></title>
    <url>%2F2018%2F09%2F04%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%B2%BE%E5%8D%8E%2F</url>
    <content type="text"><![CDATA[机器学习面试 SVM： 简单介绍SVM（详细原理）：从分类平面，到求两类间的最大间隔，到转化为求间隔分之一，等优化问题，然后就是优化问题的解决办法，首先是用拉格拉日乘子把约束优化转化为无约束优化，对各个变量求导令其为零，得到的式子带入拉格朗日式子从而转化为对偶问题， 最后再利用SMO（序列最小优化）来解决这个对偶问题。svm里面的c有啥用 SVM的推导，解释原问题和对偶问题，SVM原问题和对偶问题的关系，KKT限制条件，KKT条件用哪些，完整描述；软间隔问题，解释支持向量、核函数（哪个地方引入、画图解释高维映射，高斯核可以升到多少维，如何选择核函数），引入拉格朗日的优化方法的原因，最大的特点，损失函数解释， SVM与LR最大区别，LR和SVM对于outlier的敏感程度分析，逻辑回归与SVM的区别 为什么要把原问题转换为对偶问题？因为原问题是凸二次规划问题，转换为对偶问题更加高效。为什么求解对偶问题更加高效？因为只用求解alpha系数，而alpha系数只有支持向量才非0，其他全部为0.alpha系数有多少个？样本点的个数 加大训练数据量一定能提高SVM准确率吗？ 与感知器的联系和优缺点比较 如何解决多分类问题、可以做回归吗，怎么做 它与其他分类器对比的优缺点，它的速度 机器学习有很多关于核函数的说法，核函数的定义和作用是什么？https://www.zhihu.com/question/24627666 支持向量机(SVM)是否适合大规模数据？https://www.zhihu.com/question/19591450 SVM和逻辑斯特回归对同一样本A进行训练，如果某类中增加一些数据点，那么原来的决策边界分别会怎么变化？https://www.zhihu.com/question/30123068 各种机器学习的应用场景分别是什么？例如，k近邻,贝叶斯，决策树，svm，逻辑斯蒂回归和最大熵模型。https://www.zhihu.com/question/26726794 Linear SVM 和 LR 有什么异同？https://www.zhihu.com/question/26768865 1VM转化为对偶问题后，分类只需要计算与少数几个支持向量的距离，这个在进行复杂核函数计算时优势很明显，能够大大简化模型和计算量。 LR LR推导（伯努利过程，极大似然，损失函数，梯度下降）有没有最优解？ LR可以用核么？可以怎么用？l1和l2正则项是啥？lr加l1还是l2好？加哪个可以用核（加l2正则项，和svm类似，加l2正则项可以用核方便处理） LR可以用来处理非线性问题么？（还是lr啊 只不过是加了核的lr 这里加核是显式地把特征映射到高维 然后再做lr）怎么做？可以像SVM那样么？为什么？ 为什么LR需要归一化或者取对数，为什么LR把特征离散化后效果更好，为什么把特征组合之后还能提升，反正这些基本都是增强了特征的表达能力，或者说更容易线性可分吧 美团技术团队《Logistic Regression 模型简介》https://tech.meituan.com/intro_to_logistic_regression.html SVM和logistic回归分别在什么情况下使用？https://www.zhihu.com/question/21704547 1234567891011121314151617两种方法都是常见的分类算法，svm-统计的方法 LR-几何的方法 区别在于1、（损失函数的目的都是增加对分类影响较大的数据点的权重）逻辑回归采用的是logistical losssvm采用的是hinge loss2、LR~不带核函数的svm特征少，样本数量适中--用svm算法特征多，样本数量少 --用LR或者不带核函数的svm 特征少，样本数量很多--先增加更多的feature，再使用LR算法或者不带核函数的SVM 3、svm对异常点敏感LR对异常点不敏感 逻辑斯蒂回归能否解决非线性分类问题？https://www.zhihu.com/question/29385169 12对特征做非线性变换 比如kernel，最后一层看成是lr 前面看成是提特征。lr的应用场景主要是特征很多的情况LR用kernel容易过拟合，svm不容易过拟合 为什么LR可以用来做CTR预估？https://www.zhihu.com/question/23652394 逻辑回归估计参数时的目标函数 （就是极大似然估计那部分），逻辑回归估计参数时的目标函数 （呵呵，第二次） 逻辑回归估计参数时的目标函数 如果加上一个先验的服从高斯分布的假设，会是什么样（天啦。我不知道，其实就是在后面乘一个东西，取log后就变成加一个东西，实际就变成一个正则项） 逻辑回归估计参数时的目标函数逻辑回归的值表示概率吗？（值越大可能性越高，但不能说是概率） 手推逻辑回归目标函数，正类是1，反类是-1，这里挖了个小坑，一般都是正例是1，反例是0的，他写的时候我就注意到这个坑了，然而写的太快又给忘了，衰，后来他提醒了一下，改了过来，就是极大似然函数的指数不一样，然后说我这里的面试就到这了。 看没看过scikit-learn源码LR的实现？（回头看了一下是调用的liblinear，囧） 为什么LR需要归一化或者取对数，为什么LR把特征离散化后效果更好，为什么把特征组合之后还能提升，反正这些基本都是增强了特征的表达能力，或者说更容易线性可分吧naive bayes和logistic regression的区别http://m.blog.csdn.net/blog/muye5/19409615 LR为什么用sigmoid函数。这个函数有什么优点和缺点？为什么不用其他函数？sigmoid函数由那个指数族分布，加上二项分布导出来的。损失函数是由最大似然估计求出的。了解其他的分类模型吗，问LR缺点，LR怎么推导（当时我真没准备好，写不出来）写LR目标函数，目标函数怎么求最优解（也不会）讲讲LR的梯度下降，梯度下降有哪几种，逻辑函数是啥 12 L1和L212345678910111213L2正则化，为什么L2正则化可以防止过拟合？L1正则化是啥？深度学习里面怎么防止过拟合？（data aug；dropout；multi-task learning）如何防止过拟合，我跟他列举了4中主要防止过拟合方法：Early Stopping、数据集扩充、正则化法以及dropout，还详细跟他说了每种方法原理及使用的场景，并解释我在哪些项目里具体用到了这些方法，机器学习中使用「正则化来防止过拟合」到底是一个什么原理？为什么正则化项就可以防止过拟合？https://www.zhihu.com/question/20700829机器学习中常常提到的正则化到底是什么意思？https://www.zhihu.com/question/20924039什么是正则项，L1范式，L2范式区别是什么，各自用在什么地方？L1 与 L2 的区别以及如何解决 L1 求导困难；L1正则为什么能让系数变为0？L1正则怎么处理0点不可导的情形？（这个谁会？近端梯度下降）L0，L1，L2正则化(如果能推导绝对是加分项，一般人最多能画个等高线，L0是NP问题)其实上面的这些问题基本都能在《李航：统计学习方法》《周志华：机器学习》里面找到，能翻个4，5遍基本就无压力了避免过拟合策略、如何提高模型泛化能力、L1与L2正则区别，优缺点、生成式，判别式模型、深度学习这块了解多少、如何克服过拟合，欠拟合L1 与 L2 的区别以及如何解决 L1 求导困难；L1正则为什么可以把系数压缩成0，坐标下降法的具体实现细节为什么L1正则可以实现参数稀疏，而L2正则不可以？为什么L1很多系数可以被压缩为0，L2是被压缩至接近于0？树模型 决策树：1234567891011121314151617181920212223242526rf ， gbdt 的区别； gbdt ， xgboost 的区别（烂大街的问题最好从底层原理去分析回答）介绍决策树，谈了3种决策树及其区别和适应场景决策树处理连续值的方法；简单介绍决策树几种算法，有什么区别？决策树基本模型介绍？决策树算法中缺失值怎么处理？决策树算法在应用中有什么值得注意的地方。SVM、LR、决策树的对比？GBDT 和 决策森林 的区别？决策树的特性？（3 ）决策树处理连续值的方法；解释下随机森林和gbdt的区别。gbdt的boosting体现在哪里。解释下随机森林节点的分裂策略，以及它和gbdt做分类有什么区别？哪个效果更好些？为什么？哪个更容易过拟合？为什么？ 问了随机森林的损失函数，和lr的优缺点对比， adaboost和随机森林的比较，为了防止随机森林过拟合可以怎么做，是否用过随机森林，怎么用的。随机森林和GBDT的区别？CART（回归树用平方误差最小化准则，分类树用基尼指数最小化准则）GBDT（利用损失函数的负梯度在当前模型的值作为回归问题提升树算法中的残差的近似值，拟合一个回归树）随机森林（Bagging+CART）SVM与随机森林比较改变随机森林的训练样本数据量，是否会影响到随机森林学习到的模型的复杂度Logistics与随机森林比较GBDT与随机森林比较随机森林的学习过程；随机森林中的每一棵树是如何学习的；随机森林学习算法中CART树的基尼指数是什么？RF 与 GBDT 区别，原理优缺点适用场景分析，哪个具备交叉验证功能等接着写一下信息增益的公式。之后就是问机器学习相关算法，说了一下bagging跟boosting，之后问了GBDT（没做过，只能说说大体思路）。（2 ） rf ， gbdt 的区别； gbdt ， xgboost 的区别；说说xgboost、gbdt区别、Tree-based Model如何处理连续型特征。让我把一个完整的数据挖掘流程讲一下，从预处理，特征工程，到模型融合。介绍常用的算法，gbdt和xgboost区别，具体怎么做预处理，特征工程，模型融合常用方式，融合一定会提升吗？gbdt树根据什么分裂（瞎扯的梯度近似残差、梯度下降方向，其实还是信息增益这种东西）gbdt怎么并发（特征选择层面，树层面不能并发）介绍LR、RF、GBDT ，分析它们的优缺点，是否写过它们的分布式代码XGB和GBDT区别与联系也会经常问到：https://www.zhihu.com/question/41354392/answer/128008021?group_id=773629156532445184CART（回归树用平方误差最小化准则，分类树用基尼指数最小化准则）、Logistics（推导）、GBDT（利用损失函数的负梯度在当前模型的值作为回归问题提升树算法中的残差的近似值，拟合一个回归树）在面试过程中主动引导面试官提问，比如面试官让你讲解 gbdt 原理时，这会你可以跟他说，一般说起 gbdt ，我们都会跟 rf 以及 xgboost 一块讲，然后你就可以主动地向面试官输出你的知识；面试并不是死板地你问我答，而是一种沟通交流，所以尽可能地把面试转化成聊天式的对话，多输出自己一些有价值的观点而不是仅仅为了回答面试官的问题；几种树模型的原理和对比，特征选取怎么选？ 为什么信息增益可以用来选特征？信息熵和基尼指数的关系(信息熵在x=1处一阶泰勒展开就是基尼指数)介绍xgboost一下。写下xgboost目标函数。（因为我提到xgboost在目标函数里显式地加入了正则项..血雪崩）怎么调整XGB参数；xgboost原理 K-means1234567891011k-means 聚类的原理以及缺点及对应的改进；kmeans 算法的优缺点。。。。kmeans 的原理，优缺点以及改进；em 与 kmeans 的关系；kmeans 代码；说说 Kmeans 算法， Kmeans 算法 K 怎么设置、适用什么样数据集、怎么评价 Kmeans 聚类结果、 Kmeans 有什么优缺点？你的项目中使用 Kmeans 遇到哪些问题，怎么解决的 ?用 EM 算法推导解释 Kmeans。KMeans的算法伪代码如何判断自己实现的 LR、Kmeans 算法是否正确？如何优化kmeans算法如何用hadoop实现k-means手写k-means的伪代码（就6行） 集成学习123456bagging和boosting是怎么做的和他们的比较详细讨论了样本采样和bagging的问题聊的比较多的是如何知道一个特征的重要性，如何做ensemble哪些方法比较好。聊了聊计算广告方面FM，embedding。常见融合框架原理，优缺点，bagging，stacking，boosting，为什么融合能提升效果是否了解线性加权、bagging、boosting、cascade等模型融合方式K-means起始点http://www.cnki.com.cn/Article/CJFDTotal-DNZS200832067.htm 贝叶斯12345朴素贝叶斯分类器原理以及公式，出现估计概率值为 0 怎么处理（拉普拉斯平滑），缺点；解释贝叶斯公式和朴素贝叶斯分类。贝叶斯分类，这是一类分类方法，主要代表是朴素贝叶斯，朴素贝叶斯的原理，重点在假设各个属性类条件独立。然后能根据贝叶斯公式具体推导。考察给你一个问题，如何利用朴素贝叶斯分类去分类，比如：给你一个人的特征，判断是男是女，比如身高，体重，头发长度等特征的的数据，那么你要能推到这个过程。给出最后的分类器公式。那你说说贝叶斯怎么分类啊？比如说看看今天天气怎么样？我：blabla，，，利用天气的历史数据，可以知道天气类型的先验分布，以及每种类型下特征数据（比如天气数据的特征：温度啊，湿度啊）的条件分布，这样我们根据贝叶斯公式就能求得天气类型的后验分布了。。。。面试官：en（估计也比较满意吧）那你了解关于求解模型的优化方法吗？一般用什么优化方法来解？贝叶斯分类器的优化和特殊情况的处理 深度学习12345678910111213141516解释一下CNN、介绍CNN、卷积公式，以及特点，假设面试官什么都不懂，详细解释 CNN 的原理；问CNN的细节特点，哪些特点使得CNN这么好用，哪些场景用CNN可以，抽象一下这些场景的特征，可以降采样但仍能保持主要信息；局部连接可以保证获取局部信息；权值共享保证高效，DNN和CNN相比有哪些区别，用过RNN么？画一下RNN的图，你在深度学习过程中遇到过哪些问题？如果出现过拟合你怎么办？dropout是什么？它有什么用？你会怎么用它？当全连接跟dropout连着用需要注意什么？你之前过拟合怎么解决的？如果本身training loss就很大你怎么办？如果数据不变，怎么调整网络结构解决这个问题？（batch normalization）梯度消失知道么？为什么会出现梯度消失？dnn和rnn中的梯度消失原理一样么？dnn中是哪个部分导致梯度消失？（激活层如sigmoid）rnn中怎么解决梯度消失问题？（lstm的结构相对普通RNN多了加和，为避免梯度消散提供了可能。线性自连接的memory是关键。）讲一下CNN吧，有哪些重要的特点？CNN可以处理哪些场景？为什么CNN要用权值共享？（每个卷积核相当于一个特征提取器，它的任务是匹配局部图像中的特征，权值共享后，匹配的特征方式都是一样的，提取若干特征后就知道学习的是啥了）CNN里面哪些层？讲一下卷积。卷积的形式是啥样？给定一个输入，算输出的feature map大小。卷积有啥用？池化有啥用？有哪些池化方式？池化除了降采样还有啥用？（就不知道了）还有哪些层你用过？讲讲dropout。dropout内部是怎么实现只让部分信号通过并不更新其余部分对于输入的权值的？讲讲BN（BatchNormalization）为什么好？全连接有什么用处？知道RNN么？讲讲RNN大致的实现思路。知道梯度消失么？为什么会出现梯度消失？RNN里的梯度消失一般怎么处理？细讲下lstm的结构，这样设计为什么好？（门关闭，当前信息不需要，只有历史依赖；门打开，历史和当前加权平均）你觉得梯度消失靠引入一些新的激活层可以完全解决么？为什么？问了做的比赛里面使用tensorflow的细节，LSTM里调参的细节用过哪些库或者工具，mkl，cuda这些会用吗？有一个弱分类器和大量未被标记过的图像数据，如何人工标记图像来对分类器进行提升介绍下RNN和它的优缺点让我推导BP反向传播、随机梯度下降法权重更新公式卷积神经网络结构特点、各参数对模型结果影响、项目进展遇到的难题、推导BP神经网络参数更新方式、随机梯度下降法（SGD）优化函数存在的缺点以及拟牛顿法在优化函数使用上更有优势、修改Caffe开源框架、开源社区代码贡献量就跟我聊了很多行业发展趋势及问题，知道目前深度学习的一个趋势，也了解到最新行业发展动态，改进相机智能化程度，也聊到了美颜相机美颜效果以及小米相机人脸分类、年龄检测等等不足之处，了解到新兴行业大佬商汤科技和旷视科技（face++脸草）在研究的热门方向看到有deep learning相关的项目，就问了deep learning 相关问题：如何减少参数（权值共享、VGG的感受野、GoogLeNet的inception ），激活函数的选择（sigmoid-&gt;ReLu-&gt;LReLU-&gt;PReLU ），为什么之前没有深度网络出现（数据量不够+机器性能），由数据引申到数据不平衡怎么处理（10W正例，1W负例，牛客上有原题），后面问了下DNN原理，应用，瞎扯一通……你了解神经网络吗？我：了解一些，讲感知机，然后是BP网络。简单讲了一下原理。图像处理题：如何找相似图片。我说用感知哈希算法，计算汉明距离，他说这种方法精度不行；我说那就用SIFT算法吧，他说SIFT效果还可以，但计算有点繁重，有没有轻量级的方法？我想起来去年在美图秀秀实习时，曾经做过一种图像滤波算法，有一步是把像素点用K-means聚类。我就说先把图片灰度化，然后用K-means聚类，把聚类后的各个中心点作为一张图片的特征向量如果两张图片的特征向量相近则说明这两张图片相似。貌似我这个答案有点出乎他的意料，他意味深长地说了个“行吧~~~~”（个人觉得颜色直方图匹配是个他期待的常规回答）介绍卷积神经网络，和 DBN 有什么区别？Deep CNN, Deep RNN, RBM的典型应用与局限，看Hinton讲义和Paper去吧神经网络,plsi的推导验证码图片的去噪和提取字符有限状态自动机,然后要我画状态转移图. 聚类12用过哪些聚类算法，解释密度聚类算法。聚类算法中的距离度量有哪些？ 优化12345678梯度下降的优缺点；主要问最优化方面的知识，梯度下降法的原理以及各个变种（批量梯度下降，随机梯度下降法， mini 梯度下降法），以及这几个方法会不会有局部最优问题，牛顿法原理和适用场景，有什么缺点，如何改进（拟牛顿法）常用优化算法：1.梯度下降法：又有随机梯度下降和负梯度下降，2.牛顿法 主要是问了各自的优缺点，速度，能不能得到全局最优解，牛顿法的二次收敛等问你如果有若干个极小值点，如何避免陷入局部最优解。它们间的牛顿学习法、SGD如何训练，如何判断函数凸或非凸？线性回归的梯度下降和牛顿法求解公式的推导最速下降法和共轭梯度法 wolfe条件 最速下降法和共轭梯度法的收敛速度如何判断深刻理解常用的优化方法：梯度下降、牛顿法、各种随机搜索算法（基因、蚁群等等），深刻理解的意思是你要知道梯度下降是用平面来逼近局部，牛顿法是用曲面逼近局部等等。 推荐系统12345678910介绍SVD、SVD++推荐系统的冷启动问题如何解决深度学习在推荐系统上可能有怎样的发挥？推荐系统的算法中最近邻和矩阵分解各自适用场景白板写SVD/SVD++公式，SGD迭代更新p，q矩阵公式，SVD/SVD++优化方法对推荐算法的未来看法；用过什么算法？最好是在项目/实习的大数据场景里用过，比如推荐里用过 CF、LR，我面的推荐，问了各类协同过滤的好与坏。问了一个很有意思的问题，现实应用中的Top-N推荐问题和学术研究中的评分预测问题之间有什么不同。问我ItemCF的工程实现，面对大数据如何实现，又追问了有没有什么工程优化算法。这个问题我没答好，一开始我说了一个MapReduce模型，他问能不能更快一点，我就卡那了。。。最后面试官告诉我，不能只从算法角度分析，要从系统设计分析，利用内存来减小MapReduce的吞吐量。（当然也许从MapReduce那一刻开始我就输了也不一定）推荐系统的算法中最近邻和矩阵分解各自适用场景http://www.doc88.com/p-3961053026557.html PCA12那你对pca了解吗？我：了解啊，面试官：那讲一下pca是用来干嘛的？我：pca啊，可以用来分析主方向啊，降维啊，特征筛选啊，具体方法是用svd分解得到特征值矩阵和特征向量矩阵，然后根据不同的任务对选择特征值或向量进行计算。 EM1采用 EM 算法求解的模型有哪些，为什么不用牛顿法或梯度下降法？ NLP12345用过哪些 NLP 算法项目中用过哪些机器学习算法。海量的 item 算文本相似度的优化方法；解释 word2vec 的原理以及哈夫曼树的改进；word2vec的原理二面面试官主要跟我聊简历上的几个项目，他好像不能理解词向量的形式，反复解释了很多遍，问的问题都比较简单，有TF-IDF,余弦相似度，分词工具等等。然后我说我做过LDA，问我，Dirichlet Distribution的定义和性质，并问我，为什么它和multinomial distribution是共轭的，顺便问了我啥叫共轭分布。 关联分析：1项目中涉及到频繁模式挖掘，于是问了一下如何实现的？ 用的是 Apriori算法，描述他的原理过程，关键字眼：支持度，支持度计数，k项候选频繁项集，怎么从k项到k+1项等，连接剪枝过程。 hadoop12345678简单介绍 MapReduce 原理，有没有看过源码，说说 Map 阶段怎么实现的,MapReduce 实现统计出现次数最多的前 100 个访问 IP.MapReduce 实现统计不重复用户 ID,MapReduce 实现两个数据集求交集。HBase 行健怎么设计,spark 性能一般优化方法,spark streaming 和 storm 区别.给了一张笔试题， 10 道选择，一道大题。选择题是 java 基础知识，大题一个有三问：根据场景写出 Hive 建表语句； Hsql 从表中查询；用MapReduce写好友推荐，在一堆单词里面找出现次数最多的k个用分布式的方法做采样怎么保证采样结果完全符合预期？后面又问了Hadoop,Spark,storm下面的产品，原理，适用场景，写一个 Hadoop 版本的 wordcount。 HMM1234567891011121314151617181920212223242526272829实现 hmm 的状态转移代码；机器学习理论讲机器学习中常用的损失函数有哪些？交叉熵有什么好处？（凸优化问题）判别模型与生成模型的本质区别是什么分类模型和回归模型的区别，分类模型可以做回归分析吗？反过来可以吗？（我回答是分类不可以做回归，回归倒是可以做分类，不知道对不对）k折交叉验证 中k取值多少有什么关系 （我不知道，随便答，然后面试官后面问我知道bias和variance吗？估计是和这两个东西有关， 知乎上有个问题讨论了k值大小与bias和variance的关系）解释局部相关性特征选择的方法；在模型的训练迭代中，怎么评估效果；特征选择方法有哪些(能说出来10种以上加分)，之后和面试官仔细聊了一下特征选择的问题，我介绍了了解的几种基本的特征选择思路（错误率选择、基于熵的选择、类内类间距离的选择）；有没有接触过机器学习的前沿，深度学习看过paper没有？（并没有）如何用尽可能少的样本训练模型同时又保证模型的性能；你读哪些期刊会议的论文？你遇到的比较有意思的算法？生成模型，判别模型线性分类和非线性分类各有哪些模型比较各个模型的Loss function，设计一个结构存取稀疏矩阵 （面试官最后告诉我了一个极度压缩的存法，相同行或列存偏差，我当时没听懂，还不懂装懂，最后还是没记住）PageRank原理，怎么用模型来查找异常用户，我讲了一大堆我的理解，然后面试官一句你怎么不用规则把我噎到了……无监督和有监督算法的区别？经典算法推导(加分项)，原理，各个损失函数之间区别，使用场景，如何并行化，有哪些关键参数什么叫判别模型什么叫生成模型。先针对项目十分细致地询问了各种细节，然后就问我如何处理数据中的噪声点、数据清洗算法（正好自己做了一个算法）、如何选择特征等。校招TST内推，面过了2面，还是跟之前那个有点类似的游戏开发的安全部门，因为我也玩LOL，又问到怎么来判断玩家有没有作弊之类的问题，这次我小心翼翼的说用模型怎么做，用规则怎么做，感觉这次聊的都挺开心的。是否了解A/B Test以及A/B Test结果的置信度特征工程经验是否了解mutual infomation、chi-square、LR前后向、树模型等特征选择方式深刻理解各种算法对应采用的数据结构和对应的搜索方法。比如KNN对应的KD树、如何给图结构设计数据结构？如何将算法map-red化矩阵的各种变换，尤其是特征值相关的知识。分布式的矩阵向量乘的算法线性分类器与非线性分类器的区别及优劣；特征比数据量还大时，选择什么样的分类器？对于维度很高的特征，你是选择线性还是非线性分类器？对于维度极低的特征，你是选择线性还是非线性分类器？如何解决过拟合问题？L1和L2正则的区别，如何选择L1和L2正则？项目中的数据是否会归一化处理，哪个机器学习算法不需要归一化处理并行计算、压缩算法LDA http://www.doc88.com/p-1621945750499.html]]></content>
      <tags>
        <tag>笔面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab背景颜色修改]]></title>
    <url>%2F2018%2F09%2F01%2Fmatlab_%E8%83%8C%E6%99%AF%2F</url>
    <content type="text"><![CDATA[Matlab背景颜色修改 背景将修改内容添加到matlab的matlab.prf文件中，文件路径为在matlab中运行prefdir的结果,直接添加这些内容保存就好。 操作1， 在matlab命令行中运行prefdir， 获取matlab.prf文件所在路径 2， 打开matlab.prf所在路径， 找到matlab.prf文件， 作备份 3， 在新的matlab.prf中修改与color有关的属性 4，重启matlab，修改主题就完成了 主题选择黑色主题123456789101112131415161718192021Editor.VariableHighlighting.Color=C-6931898ColorsText=C-460558Colors_M_SystemCommands=C-448910Editorhighlight-lines=C-11974594Colors_M_Warnings=C-27648Colors_M_Strings=C-1647756Editor.NonlocalVariableHighlighting.TextColor=C-5471745Colors_HTML_HTMLLinks=C-16732805Colors_M_Comments=C-8355712Colors_M_Errors=C-65536Colors_M_UnterminatedStrings=C-5111808ColorsBackground=C-14211038Colors_M_Keywords=C-10036753Color_CmdWinWarnings=C-39936ColorsMLintAutoFixBackground=C-7973573Colors_M_Keywords=C-10036753Editorhighlight-lines=C-13553108Editorhighlight-caret-row-boolean-color=C-2167080ColorsUseSystem=Bfalse 暖色主题123456789101112131415161718Color_CmdWinErrors=C-1703936Color_CmdWinWarnings=C-39936ColorsBackground=C-198941ColorsMLintAutoFixBackground=C-1121868ColorsText=C-16304574ColorsUseMLintAutoFixBackground=BtrueColorsUseSystem=BfalseColors_HTML_HTMLLinks=C-2935166Colors_M_Comments=C-7167583Colors_M_Errors=C-65536Colors_M_Keywords=C-8021760Colors_M_Strings=C-13983336Colors_M_SystemCommands=C-3454186Colors_M_UnterminatedStrings=C-5111808Colors_M_Warnings=C-27648Editor.NonlocalVariableHighlighting.TextColor=C-32640Editor.VariableHighlighting.Color=C-7167583EditorRightTextLimitLineColor=C-3355444 darkmate123456789101112131415161718192021222324252627ColorsUseSystem=BfalseColorsUseMLintAutoFixBackground=BtrueEditor.VariableHighlighting.Automatic=BtrueEditor.NonlocalVariableHighlighting=BtrueEditorCodepadHighVisible=BtrueEditorCodeBlockDividers=BtrueEditorhighlight-caret-row-boolean=BtrueEditorRightTextLineVisible=BtrueEditorRightTextLimitLineWidth=I4 # slightly widerColorsText=C-1118482 # whiteColorsBackground=C-14474461 # carbonColors_M_Keywords=C-26368 # ambraColors_M_Comments=C-10920873 # asfaltoColors_M_Strings=C-6881536 # limeColors_M_UnterminatedStrings=C-202417 # yellowColors_M_SystemCommands=C-16725605 # algaColors_M_Errors=C-53398 # redColors_HTML_HTMLLinks=C-6385153 # violetColors_M_Warnings=C-26368 # ambraColorsMLintAutoFixBackground=C-11184811 # Editor.VariableHighlighting.Color=C-4495617 # purpleEditor.NonlocalVariableHighlighting.TextColor=C-16725760 # greenEditorhighlight-lines=C-15132391 # Editorhighlight-caret-row-boolean-color=C-16777216 # blackEditorRightTextLimitLineColor=C-13948117 # # XML/HTMLEditor.Language.XML.Color.pi-content=C-6425200 darksteel12345678910111213141516171819202122232425262728293031323334353637ColorsUseSystem=BfalseColorsUseMLintAutoFixBackground=BtrueEditor.VariableHighlighting.Automatic=BtrueEditor.NonlocalVariableHighlighting=BtrueEditorCodepadHighVisible=BtrueEditorCodeBlockDividers=BtrueEditorhighlight-caret-row-boolean=BtrueEditorRightTextLineVisible=BtrueEditorRightTextLimitLineWidth=I1ColorsText=C-1ColorsBackground=C-15066598Colors_M_Keywords=C-1208813Colors_M_Comments=C-14114579Colors_M_Strings=C-16724992Colors_M_UnterminatedStrings=C-4210944Colors_M_SystemCommands=C-7123493Colors_M_Errors=C-45747Colors_HTML_HTMLLinks=C-10592257Colors_M_Warnings=C-27648ColorsMLintAutoFixBackground=C-9223357Editor.VariableHighlighting.Color=C-11184786Editor.NonlocalVariableHighlighting.TextColor=C-16735351Editorhighlight-lines=C-14408662Editorhighlight-caret-row-boolean-color=C-12632257EditorRightTextLimitLineColor=C-5723992# TLCEditor.Language.TLC.Color.Colors_M_Keywords=C-16735351# C/C++Editor.Language.C.Color.preprocessor=C-16735351# VHDLEditor.Language.VHDL.Color.operator=C-16735351# VerilogEditor.Language.Verilog.Color.operator=C-16735351# XMLEditor.Language.XML.Color.operator=C-1710454Editor.Language.XML.Color.doctype=C-6578958Editor.Language.XML.Color.pi-content=C-9868801 monokai1234567891011121314151617181920212223242526ColorsUseSystem=BfalseColorsUseMLintAutoFixBackground=BtrueEditor.VariableHighlighting.Automatic=BtrueEditor.NonlocalVariableHighlighting=BtrueEditorCodepadHighVisible=BtrueEditorCodeBlockDividers=BtrueEditorhighlight-caret-row-boolean=BfalseEditorRightTextLineVisible=BtrueEditorRightTextLimitLineWidth=I1ColorsText=C-460560ColorsBackground=C-14211038Colors_M_Keywords=C-448910Colors_M_Comments=C-9080482Colors_M_Strings=C-1647756Colors_M_UnterminatedStrings=C-65536Colors_M_SystemCommands=C-16711936Colors_M_Errors=C-65536Colors_HTML_HTMLLinks=C-16711681Colors_M_Warnings=C-27648ColorsMLintAutoFixBackground=C-11974594Editor.VariableHighlighting.Color=C-10066330Editor.NonlocalVariableHighlighting.TextColor=C-16729641Editorhighlight-lines=C-13421773Editorhighlight-caret-row-boolean-color=C-10066330EditorRightTextLimitLineColor=C-3355444Color_CmdWinWarnings=C-26368 参考github效果：https://github.com/scottclowe/matlab-schemer/tree/master/schemes]]></content>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基础]]></title>
    <url>%2F2018%2F08%2F31%2FLinux%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Linux基础 VIM 三个模式 一般指令模式（Command mode）：VIM 的默认模式，可以用于移动游标查看内容； 编辑模式（Insert mode）：按下 “i” 等按键之后进入，可以对文本进行编辑； 指令列模式（Bottom-line mode）：按下 “:” 按键之后进入，用于保存退出等操作。 在指令列模式下，有以下命令用于离开或者保存文件。 命令 作用 :w 写入磁盘 :w! 当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关 :q 离开 :q! 强制离开不保存 :wq 写入磁盘后离开 :wq! 强制写入磁盘后离开 磁盘的文件名Linux 中每个硬件都被当做一个文件，包括磁盘 分区1. MBRMBR 中，第一个扇区最重要，里面有主要开机记录（Master boot record, MBR）及分区表（partition table），其中主要开机记录占 446 bytes，分区表占 64 bytes。 2. GPT不同的磁盘有不同的扇区大小，GPT 第 1 个区块记录了主要开机记录（MBR） 文件属性用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。 使用 ls 查看一个文件时，会显示一个文件的信息，例如 drwxr-xr-x. 3 root root 17 May 6 00:14 .config，对这个信息的解释如下： drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段 3：链接数 root：文件拥有者 root：所属群组 17：文件大小 May 6 00:14：文件最后被修改的时间 .config：文件名 常见的文件类型及其含义有： d：目录 -：文件 l：链接文件 9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。 文件时间有以下三种： modification time (mtime)：文件的内容更新就会更新； status time (ctime)：文件的状态（权限、属性）更新就会更新； access time (atime)：读取文件时就会更新。 孤儿进程一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。 孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。 由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。 僵尸进程一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。 僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。 系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。 要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 所收养，这样 init 就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql基础]]></title>
    <url>%2F2018%2F08%2F31%2FMysql%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Mysql基础]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理推荐资料]]></title>
    <url>%2F2018%2F08%2F31%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E6%8E%A8%E8%8D%90%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[图像处理推荐资料 图像处理与计算机视觉相关的书籍 数学 我们所说的图像处理实际上就是数字图像处理，是把真实世界中的连续三维随机信号投影到传感器的二维平面上，采样并量化后得到二维矩阵。数字图像处理就是二维矩阵的处理，而从二维图像中恢复出三维场景就是计算机视觉的主要任务之一。这里面就涉及到了图像处理所涉及到的三个重要属性：连续性，二维矩阵，随机性。所对应的数学知识是高等数学（微积分），线性代数（矩阵论），概率论和随机过程。这三门课也是考研数学的三个组成部分，构成了图像处理和计算机视觉最基础的数学基础。如果想要更进一步，就要到网上搜搜林达华推荐的数学书目了。 信号处理 图像处理其实就是二维和三维信号处理，而处理的信号又有一定的随机性，因此经典信号处理和随机信号处理都是图像处理和计算机视觉中必备的理论基础。2.1经典信号处理信号与系统(第2版) Alan V.Oppenheim等著 刘树棠译 离散时间信号处理(第2版) A.V.奥本海姆等著 刘树棠译 数字信号处理:理论算法与实现 胡广书 (编者) 2.2随机信号处理现代信号处理 张贤达著 统计信号处理基础:估计与检测理论 Steven M.Kay等著 罗鹏飞等译 自适应滤波器原理(第4版) Simon Haykin著 郑宝玉等译 2.3 小波变换信号处理的小波导引:稀疏方法(原书第3版) tephane Malla著, 戴道清等译 2.4 信息论信息论基础(原书第2版) Thomas M.Cover等著 阮吉寿等译 模式识别Pattern Recognition and Machine Learning Bishop, Christopher M. Springer 模式识别(英文版)(第4版) 西奥多里德斯著 Pattern Classification (2nd Edition) Richard O. Duda等著 Statistical Pattern Recognition, 3rd Edition Andrew R. Webb等著 模式识别(第3版) 张学工著 图像处理与计算机视觉的书籍推荐图像处理，分析与机器视觉 第三版 Sonka等著 艾海舟等译 Image Processing, Analysis and Machine Vision ( 附：这本书是图像处理与计算机视觉里面比较全的一本书了，几乎涵盖了图像视觉领域的各个方面。中文版的个人感觉也还可以，值得一看。) 数字图像处理 第三版 冈萨雷斯等著 Digital Image Processing (附：数字图像处理永远的经典，现在已经出到了第三版，相当给力。我的导师曾经说过，这本书写的很优美，对写英文论文也很有帮助，建议购买英文版的。) 计算机视觉：理论与算法 Richard Szeliski著 Computer Vision: Theory and Algorithm (附：微软的Szeliski写的一本最新的计算机视觉著作。内容非常丰富，尤其包括了作者的研究兴趣，比如一般的书里面都没有的Image Stitching和 Image Matting等。这也从另一个侧面说明这本书的通用性不如Sonka的那本。不过作者开放了这本书的电子版，可以有选择性的阅读。 http://szeliski.org/Book/ Multiple View Geometry in Computer Vision 第二版Harley等著 引用达一万多次的经典书籍了。第二版到处都有电子版的。第一版曾出过中文版的，后来绝版了。网上也可以找到中英文版的电子版。) 计算机视觉：一种现代方法 DA Forsyth等著 Computer Vision: A Modern Approach MIT的经典教材。虽然已经过去十年了，还是值得一读。期待第二版 Machine vision: theory, algorithms, practicalities 第三版 Davies著 (附：为数不多的英国人写的书，偏向于工业应用。) 数字图像处理 第四版 Pratt著 Digital Image Processing (附：写作风格独树一帜，也是图像处理领域很不错的一本书。网上也可以找到非常清晰的电子版。)]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客 报错 Cannot read property 'replace' of null]]></title>
    <url>%2F2018%2F08%2F28%2Fhexo_error_replace%2F</url>
    <content type="text"><![CDATA[报错内容-情况报错内容如下123FATAL Cannot read property &apos;replace&apos; of nullTypeError: Cannot read property &apos;replace&apos; of null 如图： 报错情况，执行 hexo clean 清理本地缓存或者 hexo g 生成本地缓存时报此错误 解决方法打开 hexo配置文件，配置123456# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://www.aomanhao.toproot: AomanHao.github.iopermalink: :year/:month/:day/:title/permalink_defaults: root，url属性配置正确，填写自己对应的 参考文章]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理_图像插值]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E6%8F%92%E5%80%BC%2F</url>
    <content type="text"><![CDATA[图像插值 比较常用的插值算法有这么几种：最邻近插值，双线性二次插值，三次插值，Lanczos插值等等 1，最邻近插值最邻近插值算法也叫做零阶插值算法，主要原理是让输出像素的像素值等于邻域内 离它距离最近的像素值。 这种放大图像的方法叫做最临近插值算法，这是一种最基本、最简单的图像缩放算法，效果也是最不好的，放大后的图像有很严重的马赛克，缩小后的图像有很严重的失真；效果不好的根源就是其简单的最临近插值方法引入了严重的图像失真。 2，双线性二次插值3、三次内插法内插值，外插值两张图像混合时通过内插与外插值方法可以实现图像亮度、对比度、饱和度、填色、锐化等常见的图像处理操作。在两张图像混合时最常见是线性插值方法，使用的混合权重公式如下： Out(x,y) = Src2(x,y) *\alpha + Src1(x,y)(1-\alpha)$\alpha$的范围是[0,1]之间 内插值方法：常见的值属于[0,1]之间。 外插值方法：可以用来生成跟内插值效果相反的图像。 比如内插值模糊图像，通过外插值可以去模糊，外插值可以调节饱和度，可以实现图像一些列的处理比如亮度、饱和度、对比度、锐化调整。 插值算法的类型：一般分为两类: 自适应和非自适应。自适应的方法可以根据插值的内容来改变（尖锐的边缘或者是平滑的纹理），非自适应的方法对所有的像素点都进行同样的处理。 非自适应算法包括: 最邻近方法, 双线性, 双三次, 样条, sinc, lanczos 和其他。由于其复杂度, 这些插值的时候使用从0 to 256 (or more) 邻近像素。 包含越多的邻近像素，他们越精确，但是花费的时间也越长。这些算法可以用来扭曲和缩放照片。 OriginalEnlarged 250%自适应算法包含许多专利，如: Qimage, PhotoZoom Pro, Genuine Fractals和其他。许多应用他们插值的不同版本 (on a pixel-by-pixel basis)当他们检测边缘时 —目标是最小化插值干扰。 最邻近插值最邻近算法在所有插值算法中时间最短，因为它只考虑一个像素点—离待插像素点最近的像素点。 双线性插值双线性插值考虑待插像素最近的 2x2 已知像素点。需要加权四个像素值来求得最终的像素值。这使得插值出来比最邻近插值平滑。 双三次插值 基于双线性插值，考虑最近的 4x4已知像素点 —总共16个像素点。由于离待插像素点的距离不同， 在计算中距离近的像素给出的权重较大。双三次产生的图像比前两次的尖锐，有理想的处理时间和输出质量。因此，在很多图像编辑程序中是标准算法 (包括 Adobe Photoshop), 打印机和相机插值。]]></content>
      <tags>
        <tag>图像插值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谷歌浏览器加载静态文件错误，请修改DNS配置]]></title>
    <url>%2F2018%2F08%2F24%2FDNS_error%2F</url>
    <content type="text"><![CDATA[谷歌浏览器加载静态文件错误，请修改DNS配置 当我登陆CSDN/牛客网的时候，页面不能正常显示，只能显示纯文字，访问百度或者视频网站的时候是可以的报错提示静态文件加载出错，请检查当前网络情况是否正常，或者按照下面步骤修改电脑的DNS等等折腾了一晚上 修改DNS百度经验修改DNS 按照要求修改了dns，失败，仍然不能正常加载网页 修改hosts文件百度经验修改hosts文件 hosts属于系统文件，需要谨慎操作，需要很高的权限 打开hosts文件，发现最后一行是192.168.137.1 windows10.microdone.cn神秘代码有没有，寻找其出处，网友指出他是银联网银插件修改的代码解释链接 解决方法：卸载最近安装的 网银插件/控件（我没有就不用卸载了） 然后按照百度经验修改hosts文件，保存后，发现过一会打开又出现了192.168.137.1 windows10.microdone.cn这下怀疑中病毒了 使用360断网急救箱诊断确实是 hosts文件出现异常 修复在检测，依然有问题 使用360系统急救箱深度检测，删了一些文件（可能中毒）重启电脑，依然CSDN/牛客网的时候，页面不能正常显示 谷歌浏览器插件问题我鬼使神差的试试用微软自带的Eage浏览器登陆CSDN/牛客网，可以正常显示，惊了。我这一通操作，就是换个浏览器的题 仔细回想一下，之前安装的谷歌访问助手插件崩溃了，我就卸载了 1、卸载谷歌浏览器，重新安装 失败，不能正常显示网页CSDN/牛客网 2、安装谷歌访问助手插件 CSDN/牛客网可以正常显示了。 原因：怀疑是插件的上网代理搞鬼 解决方法：谷歌浏览器谷歌访问助手重新安装]]></content>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客yilia主题首页添加helper-live2d模型插件]]></title>
    <url>%2F2018%2F08%2F23%2Fhexo_helper_live2d%2F</url>
    <content type="text"><![CDATA[Hexo添加helper-live2d模型插件 插件效果插件的github地址插件作者提供了较为详细的安装步骤，我结合自己操作和图示，提供大家。 效果展示：红框内为2d模型，可以随鼠标移动而变化 安装模块:hexo博客根目录选择cmd命令窗口或者git bash 输入以下代码，安装插件 操作：1npm install --save hexo-helper-live2d 下载模型作者提供了三个下载模型的办法，我选择操作比较简单的一种npm 模块名 的方法 作者提供以下模型的模型包，模型包预览地址见下面的链接，选择你想用的模型，记住名字，选择对应的后缀模型包 作者各种模型包展示 12345678910111213141516171819202122live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16 选择好对应的模型，使用 npm install 模型的包名来安装，比如我选择的的是live2d-widget-model-koharu 模型包 操作：在hexo博客根目录选择cmd命令窗口或者git bash 输入以下代码 1npm install live2d-widget-model-koharu 执行安装就完事了 配置请向Hexo的 _config.yml 文件添加配置. 操作：打开个人Hexo博客文件根目录下的 _config.yml 文件，在最后添加一下代码示例: 12345678910111213141516live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-koharu display: position: right width: 150 height: 300 mobile: show: true 注：在移动端可能会干扰阅览，可以选择取消移动端显示，true改为fasle12mobile: show: fasle 你需要配置的是use: live2d-widget-model-koharuuse后为你选择的安装包的全称 插件部署与配置就完成了 效果预览本地预览1hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 博客部署博客部署1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>yilia</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理_Retinex图像增强]]></title>
    <url>%2F2018%2F08%2F17%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_Retinex%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[图像处理_Retinex图像增强 单尺度SSR(Single Scale Retinex) 图像$S(x,y)$分解为两个不同的图像：反射图像$R(x,y)$,入射图像$L(x,y)$ 图像可以看做是入射图像和反射图像构成，入射光照射在反射物体上，通过反射物体的反射，形成反射光进入人眼。最后形成的图像$r(x,y)$可以如下公式表示 r(x,y)=logR(x,y)=log\frac{S(x,y)}{L(x,y)}R(x, y)表示了物体的反射性质，即图像内在属性，我们应该最大程度的保留；而L(x, y)表示入射光图像，决定了图像像素能达到的动态范围，我们应该尽量去除。 我们把照射图像假设估计为空间平滑图像，原始图像为S(x, y)，反射图像为R(x, y)，亮度图像为L(x, y)，使用公式 r(x,y)=logR(x,y)=log\frac{S(x,y)}{L(x,y)}或者 r(x,y)=logS(x,y)-log[F(x,y)⨂S(x,y)]其中r(x, y)是输出图像,卷积运算，$F(x, y)$是中心环绕函数 F(x,y)=\lambda*e^{-\frac{x^2+y^2}{c^2}}其中C是高斯环绕尺度，λ是一个尺度，满足$∫∫F(x,y)dxdy=1$ SSR算法中的卷积是对入射图像的计算，其物理意义是通过计算像素点与周围区域在加权平均的作用下，估计图像中照度的变化，并将L(x,y)去除，只保留S(x,y)属性。 多尺度MSR(Multi-Scale Retinex) MSR是在SSR基础上发展来的，优点是可以同时保持图像高保真度与对图像的动态范围进行压缩的同时，MSR也可实现色彩增强、颜色恒常性、局部动态范围压缩、全局动态范围压缩，也可以用于X光图像增强。 r(x,y)=∑_k^Kw_klogS(x,y)-log[F_k(x,y)*S(x,y)]K是高斯中心环绕函数的个数。当K=1时，MSR退化为SSR,K取值通常为3 w1=w2=w3=\frac13 缺点:边缘锐化不足，阴影边界突兀，部分颜色发生扭曲，纹理不清晰，高光区域细节没有得到明显改善，对高光区域敏感度小 带颜色恢复的MSR方法MSRCR(Multi-Scale Retinex with Color Restoration)SSR和MSR普遍都存在明显的偏色问题 MSRCR在MSR的基础上，加入了色彩恢复因子C来调节由于图像局部区域对比度增强而导致颜色失真的缺陷。 改进公式： R_{MSRCR_i}(x,y)=C_i(x,y)R_{MSR_i}(x,y)其中 C_i(x,y)=f[I_i^{'}(x,y)]=f[\frac{I_i(x,y)}{∑_{j=1}^{N}I_j(x,y)}]其中 f[I_i^{'}(x,y)]=βlog[αI_i^{'}(x,y)]=β{log[αI_i^{'}i(x,y)]-log[∑_{j=1}^NI_j(x,y)]}参数说明12345Ii(x, y)表示第i个通道的图像Ci表示第i个通道的彩色回复因子，用来调节3个通道颜色的比例；f(·)表示颜色空间的映射函数；β是增益常数；α是受控制的非线性强度； MSRCR算法利用彩色恢复因子C，调节原始图像中3个颜色通道之间的比例关系，从而把相对较暗区域的信息凸显出来，达到了消除图像色彩失真的缺陷。处理后的图像局部对比度提高，亮度与真实场景相似，在人们视觉感知下，图像显得更加逼真。 参考文章]]></content>
      <tags>
        <tag>图像处理</tag>
        <tag>图像增强</tag>
        <tag>Opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10大数据算法排序Java_C++]]></title>
    <url>%2F2018%2F08%2F16%2F10%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8FJava_C%2B%2B%2F</url>
    <content type="text"><![CDATA[10大数据算法排序Java_C++ 冒泡排序 依次比较n与后面的数字，大的放右面，小的放左边Java代码12345678910111213141516171819202122232425/** * 冒泡排序 * 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 * 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 * 针对所有的元素重复以上的步骤，除了最后一个。 * 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 * @param numbers 需要排序的整型数组 */ public static void bubbleSort(int[] numbers) &#123; int temp = 0; int size = numbers.length; for(int i = 0 ; i &lt; size-1; i ++) &#123; for(int j = 0 ;j &lt; size-1-i ; j++) &#123; if(numbers[j] &gt; numbers[j+1]) //交换两数位置 &#123; temp = numbers[j]; numbers[j] = numbers[j+1]; numbers[j+1] = temp; &#125; &#125; &#125; &#125; C++代码1待补充 选择排序 选择n个数组成的数组arr里最大的一个数，放在arr[n-1]，然后维数n-1选择前n-1个数组成的数组，取最大数，放在arr Java代码：1234567891011121314151617181920212223242526272829/** * 选择排序算法 * 在未排序序列中找到最小元素，存放到排序序列的起始位置 * 再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。 * 以此类推，直到所有元素均排序完毕。 * @param numbers */ public static void selectSort(int[] numbers) &#123; int size = numbers.length; //数组长度 int temp = 0 ; //中间变量 for(int i = 0 ; i &lt; size ; i++) &#123; int k = i; //待确定的位置 //选择出应该在第i个位置的数 for(int j = size -1 ; j &gt; i ; j--) &#123; if(numbers[j] &lt; numbers[k]) &#123; k = j; &#125; &#125; //交换两个数 temp = numbers[i]; numbers[i] = numbers[k]; numbers[k] = temp; &#125; &#125; C++代码：1待补充 快速排序及其改进算法C++实现 快速排序可以看成是插入排序的改进，它是一种分治的排序算法 Java代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445public class FastSort&#123; public static void main(String []args)&#123; System.out.println(&quot;Hello World&quot;); int[] a = &#123;12,20,5,16,15,1,30,45,23,9&#125;; int start = 0; int end = a.length-1; sort(a,start,end); for(int i = 0; i&lt;a.length; i++)&#123; System.out.println(a[i]); &#125; &#125; public void sort(int[] a,int low,int high)&#123; int start = low; int end = high; int key = a[low]; while(end&gt;start)&#123; //从后往前比较 while(end&gt;start&amp;&amp;a[end]&gt;=key) //如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较 end--; if(a[end]&lt;=key)&#123; int temp = a[end]; a[end] = a[start]; a[start] = temp; &#125; //从前往后比较 while(end&gt;start&amp;&amp;a[start]&lt;=key)//如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置 start++; if(a[start]&gt;=key)&#123; int temp = a[start]; a[start] = a[end]; a[end] = temp; &#125; //此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，右边的值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用 &#125; //递归 if(start&gt;low) sort(a,low,start-1);//左边序列。第一个索引位置到关键值索引-1 if(end&lt;high) sort(a,end+1,high);//右边序列。从关键值索引+1到最后一个 &#125; &#125; C++代码：cankao12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;int main()&#123; int array[]=&#123;34,65,12,43,67,5,78,10,3,70&#125;,k; int len=sizeof(array)/sizeof(int); cout&lt;&lt;&quot;The orginal arrayare:&quot;&lt;&lt;endl; for(k=0;k&lt;len;k++) cout&lt;&lt;array[k]&lt;&lt;&quot;,&quot;; cout&lt;&lt;endl; quickSort(array,0,len-1); cout&lt;&lt;&quot;The sorted arrayare:&quot;&lt;&lt;endl; for(k=0;k&lt;len;k++) cout&lt;&lt;array[k]&lt;&lt;&quot;,&quot;; cout&lt;&lt;endl; system(&quot;pause&quot;); return 0;&#125; void quickSort(int s[], int low, int high)&#123; if (low&lt; high) &#123; int i = low, j = high, x = s[low]; while (i &lt; j) &#123; while(i &lt; j &amp;&amp; s[j]&gt;= x) // 从右向左找第一个小于x的数 j--; if(i &lt; j) s[i++] = s[j]; while(i &lt; j &amp;&amp; s[i]&lt; x) // 从左向右找第一个大于等于x的数 i++; if(i &lt; j) s[j--] = s[i]; &#125; s[i] = x; quickSort(s, low, i - 1); // 递归调用 quickSort(s, i + 1, high); &#125;&#125; 归并排序 归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。分治思想：合并步骤如下 Java代码：cankao12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package sortdemo;import java.util.Arrays;/** * Created by chengxiao on 2016/12/8. */public class MergeSort &#123; public static void main(String []args)&#123; int []arr = &#123;9,8,7,6,5,4,3,2,1&#125;; sort(arr); System.out.println(Arrays.toString(arr)); &#125; public static void sort(int []arr)&#123; int []temp = new int[arr.length];//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间 sort(arr,0,arr.length-1,temp); &#125; private static void sort(int[] arr,int left,int right,int []temp)&#123; if(left&lt;right)&#123; int mid = (left+right)/2; sort(arr,left,mid,temp);//左边归并排序，使得左子序列有序 sort(arr,mid+1,right,temp);//右边归并排序，使得右子序列有序 merge(arr,left,mid,right,temp);//将两个有序子数组合并操作 &#125; &#125; private static void merge(int[] arr,int left,int mid,int right,int[] temp)&#123; int i = left;//左序列指针 int j = mid+1;//右序列指针 int t = 0;//临时数组指针 while (i&lt;=mid &amp;&amp; j&lt;=right)&#123; if(arr[i]&lt;=arr[j])&#123; temp[t++] = arr[i++]; &#125;else &#123; temp[t++] = arr[j++]; &#125; &#125; while(i&lt;=mid)&#123;//将左边剩余元素填充进temp中 temp[t++] = arr[i++]; &#125; while(j&lt;=right)&#123;//将右序列剩余元素填充进temp中 temp[t++] = arr[j++]; &#125; t = 0; //将temp中的元素全部拷贝到原数组中 while(left &lt;= right)&#123; arr[left++] = temp[t++]; &#125; &#125;&#125; C++代码：cankao1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;const int maxn=500000,INF=0x3f3f3f3f;int L[maxn/2+2],R[maxn/2+2];void merge(int a[],int n,int left,int mid,int right)&#123; int n1=mid-left,n2=right-mid; for(int i=0;i&lt;n1;i++) L[i]=a[left+i]; for(int i=0;i&lt;n2;i++) R[i]=a[mid+i]; L[n1]=R[n2]=INF; int i=0,j=0; for(int k=left;k&lt;right;k++) &#123; if(L[i]&lt;=R[j]) a[k]=L[i++]; else a[k]=R[j++]; &#125;&#125;void mergesort(int a[],int n,int left,int right)&#123; if(left+1&lt;right) &#123; int mid=(left+right)/2; mergesort(a,n,left,mid); mergesort(a,n,mid,right); merge(a,n,left,mid,right); &#125;&#125;int main()&#123; int a[maxn],n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; mergesort(a,n,0,n); for(int i=0;i&lt;n;i++) &#123; if(i) cout&lt;&lt;&quot; &quot;; cout&lt;&lt;a[i]; &#125; cout&lt;&lt;endl; return 0;&#125; 堆排序 http://www.cnblogs.com/MOBIN/p/5374217.html 堆排序主要在于理解堆的构造过程和在输出最大元素后如何对堆进行重新调整 大顶堆：父结点始终&gt;子节点 小顶堆：父结点始终&lt;子节点12345算法思想(以大顶堆为例)：1.将长度为n的待排序的数组进行堆有序化构造成一个大顶堆2.将根节点与尾节点交换并输出此时的尾节点3.将剩余的n -1个节点重新进行堆有序化4.重复步骤2，步骤3直至构造成一个有序序列 我们开始只需要扫描一半的元素（n/2-1 ~ 0）,因为(n/2-1)~0的节点才有子节点 构建有序堆：1、第一次for循环将节点3和它的子节点7 8的元素进行比较，最大者作为父节点（即元素60作为父节点）红色表示交换后的状态2、第二次for循环将节点2和它的子节点5 6的元素进行比较，最大者为父节点（元素80作为父节点）3、第三次for循环将节点1和它的子节点3 4的元素进行比较，最大者为父节点（元素70作为父节点） 调整堆1、堆顶元素80和尾40交换后—&gt;调整堆2、堆顶元素70和尾30交换后—&gt;调整堆。。。完成调整 左右父节点下标:123左：i*2+1右：i*2+2父：(i-1)/2 Java代码：123456789101112131415161718192021222324252627282930313233343536373839404142public class HeapSort &#123;private static void heapSort(int[] arr) &#123;int len = arr.length -1;//堆构造，调整结构，符合大顶堆或者小顶堆for(int i = len/2 ; i &gt;=0; i --)&#123; heapAdjust(arr,i,len);&#125;while (len &gt;=0)&#123;swap(arr,0,len--); //将堆顶元素与尾节点交换后，长度减1，尾元素最大heapAdjust(arr,0,len); //再次对堆进行调整&#125;&#125;public static void heapAdjust(int[] arr,int i,int len)&#123;int left = 2*i+1,right = 2*i+2,largest = i;if(left &lt;= len &amp;&amp; arr[left] &gt; arr[i])largest = left;if(right &lt;= len &amp;&amp; arr[right] &gt; arr[largest])largest = right;if(largest != i) &#123;swap(arr, i, largest);heapAdjust(arr,largest,len);&#125;&#125;public static void swap(int[] arr,int i,int len)&#123;int temp = arr[i];arr[i] = arr[len];arr[len] = temp;&#125;public static void main(String[] args) &#123;int array[] = &#123;20,50,20,40,70,10,80,30,60&#125;;System.out.println(&quot;排序之前：&quot;);for(int element : array)&#123;System.out.print(element+&quot; &quot;);&#125;heapSort(array);System.out.println(&quot;\n排序之后：&quot;);for(int element : array)&#123;System.out.print(element+&quot; &quot;);&#125;&#125;&#125; C++代码：1待补充 插入排序Java代码：1待补充 C++代码：1待补充 桶排序需要求数组中的最大数1、桶排序不在是一种基于比较的排序方法，而是需要待排序列满足以下两个条件： 1、待排序列的值处于一个可枚举的范围内2、待排序列所在可枚举范围不应太大，不然开销会很大。 原理： 假设待排序的数组a中共有N个整数，并且已知数组a中数据的范围[0, MAX)。在桶排序时，创建容量为MAX的桶数组r，并将桶数组元素都初始化为0；将容量为MAX的桶数组中的每一个单元都看作一个”桶”。在排序时，逐个遍历数组a，将数组a的值，作为”桶数组r”的下标。当a中数据被读取时，就将桶的值加1。例如，读取到数组a[3]=5，则将r[5]的值+1。 桶排序适用场景:根据桶排序的特点，桶排序一般适用于一些特定的环境，比如数据范围较为局限或者有一些特定的要求，比如需要通过哈希映射快速获取某些值，需要统计每个数的数量。但是这一切都以确认数据的范围为前提，如果范围跨度过大，则考虑用其他算法。 Java代码：12345678910111213141516171819202122232425262728/// &lt;summary&gt;/// 桶排序//////如果有重复的数字,则需要 List&lt;int&gt;数组,这里举的例子没有重复的数字/// &lt;/summary&gt;/// &lt;param name=&quot;unsorted&quot;&gt;待排数组&lt;/param&gt;/// &lt;param name=&quot;maxNumber&quot;&gt;待排数组中的最大数,如果可以提供的话&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;static int[] bucket_sort(int[] unsorted, int maxNumber = 97)&#123; int[] sorted = new int[maxNumber + 1]; for (int i = 0; i &lt; unsorted.Length; i++) &#123; sorted[unsorted[i]] = unsorted[i]; &#125; return sorted;&#125;static void Main(string[] args)&#123; int[] x = &#123;49、 38 、 35、 97 、 76、 73 、 27、 49 &#125;; var sorted = bucket_sort(x, 97); for (int i = 0; i &lt; sorted.Length; i++) &#123; if (sorted[i] &gt; 0) Console.WriteLine(sorted[i]); &#125; Console.ReadLine();&#125; C++代码：1待补充 Java代码：1待补充 C++代码：1待补充 Java代码：1待补充 C++代码：1待补充 Java代码：1待补充 C++代码：1待补充]]></content>
      <tags>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解]]></title>
    <url>%2F2018%2F08%2F16%2Fleetcode_sum%2F</url>
    <content type="text"><![CDATA[三数之和给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 1 Two Sum5 array、set sort、Two Pointers 8 String to Integer (atoi) 5 string Math15 3Sum 5 array Two Pointers20 Valid Parentheses 5 string Stack21 Merge Two Sorted Lists 5 linked list sort、Two Pointers、merge28 Implement strStr() 5 string Two Pointers、KMP、rolling hash50 Pow(x, n) 5 Binary Search、Math56 Merge Intervals 5 array、linked list、red-black tree sort、merge57 Insert Interval 5 array sort65 Valid Number 5 string Math70 Climbing Stairs 5 DP73 Set Matrix Zeroes 5 array88 Merge Sorted Array 5 array Two Pointers、merge98 Validate Binary Search Tree 5 tree DFS125 Valid Palindrome 5 string Two Pointers127 Word Ladder 5 graph BFS、path2 Add Two Numbers 4 linked list Two Pointers、Math12 Integer to Roman 4 Math13 Roman to Integer 4 Math22 Generate Parentheses 4 string DFS23 Merge k Sorted Lists 4 linked list、heap sort、Two Pointersmerge24 Swap Nodes in Pairs 4 linked list27 Remove Element 4 array Two Pointers46 Permutations 4 array permutation49 Anagrams 4 string、hashtable67 Add Binary 4 string Two Pointers、Math69 Sqrt(x) 4 Binary Search77 Combinations 4 combination78 Subsets 4 array Recursion、combination79 Word Search 4 array DFS91 Decode Ways 4 string Recursion、DP102 Binary Tree Level Order Traversal 4 tree BFS129 Sum Root to Leaf Numbers 4 tree DFS131 Palindrome Partitioning 4 string DFS4 Median of Two Sorted Arrays 3 array Binary Search7 Reverse Integer 3 Math10 Regular Expression Matching 3 string Recursion、DP17 Letter Combinations of a Phone Number 3 string DFS19 Remove Nth Node From End of List 3 linked list Two Pointers26 Remove Duplicates from Sorted Array 3 array Two Pointers29 Divide Two Integers 3 Binary Search33 Search in Rotated Sorted Array 3 array Binary Search34 Search for a Range 3 array Binary Search39 Combination Sum 3 array combination43 Multiply Strings 3 string Two Pointers、Math44 Wildcard Matching 3 string Recursion、DP、greedy51 N-Queens 3 array DFS52 N-Queens II 3 array DFS53 Maximum Subarray 3 array DP62 Unique Paths 3 array DP63 Unique Paths II 3 array DP64 Minimum Path Sum 3 array DP72 Edit Distance 3 string DP74 Search a 2D Matrix 3 array Binary Search81 Search in Rotated Sorted Array II 3 array Binary Search82 Remove Duplicates from Sorted List II 3 linked list Recursion、Two Pointers83 Remove Duplicates from Sorted List 3 linked list86 Partition List 3 linked list Two Pointers93 Restore IP Addresses 3 string DFS94 Binary Tree Inorder Traversal 3 tree、hashtable Recursion、morris、Stack103 Binary Tree Zigzag Level Order Traversal 3 queue、tree BFS、Stack105 Construct Binary Tree from Preorder and Inorder Tr 3 array、tree DFS106 Construct Binary Tree from Inorder and Postorder T 3 array、tree DFS108 Convert Sorted Array to Binary Search Tree 3 tree DFS109 Convert Sorted List to Binary Search Tree 3 linked list Recursion、Two Pointers112 Path Sum 3 tree DFS114 Flatten Binary Tree to Linked List 3 tree Recursion、Stack116 Populating Next Right Pointers in Each Node 3 tree DFS128 Longest Consecutive Sequence 3 array130 Surrounded Regions 3 array BFS、DFS132 Palindrome Partitioning II 3 string DP3 Longest Substring Without Repeating Characters 2 string、hashtable Two Pointers5 Longest Palindromic Substring 2 string9 Palindrome Number 2 Math11 Container With Most Water 2 array Two Pointers18 4Sum 2 array25 Reverse Nodes in k-Group 2 linked list Recursion、Two Pointers31 Next Permutation 2 array permutation35 Search Insert Position 2 array36 Valid Sudoku 2 array37 Sudoku Solver 2 array DFS38 Count and Say 2 string Two Pointers40 Combination Sum II 2 array combination41 First Missing Positive 2 array sort42 Trapping Rain Water 2 array Two Pointers、Stack45 Jump Game II 2 array47 Permutations II 2 array permutation48 Rotate Image 2 array54 Spiral Matrix 2 array55 Jump Game 2 array59 Spiral Matrix II 2 array61 Rotate List 2 linked list Two Pointers66 Plus One 2 array Math68 Text Justification 2 string75 Sort Colors 2 array sort、Two Pointers76 Minimum Window Substring 2 string Two Pointers80 Remove Duplicates from Sorted Array II 2 array Two Pointers84 Largest Rectangle in Histogram 2 array Stack87 Scramble String 2 string Recursion、DP89 Gray Code 2 combination90 Subsets II 2 array Recursion、combination92 Reverse Linked List II 2 linked list Two Pointers97 Interleaving String 2 string Recursion、DP99 Recover Binary Search Tree 2 tree DFS101 Symmetric Tree 2 tree DFS110 Balanced Binary Tree 2 tree DFS113 Path Sum II 2 tree DFS115 Distinct Subsequences 2 string DP117 Populating Next Right Pointers in Each Node II 2 tree DFS124 Binary Tree Maximum Path Sum 2 tree DFS6 ZigZag Conversion 1 string14 Longest Common Prefix 1 string16 3Sum Closest 1 array Two Pointers30 Substring with Concatenation of All Words 1 string Two Pointers32 Longest Valid Parentheses 1 string DP58 Length of Last Word 1 string60 Permutation Sequence 1 permutation、Math71 Simplify Path 1 string Stack85 Maximal Rectangle 1 array DP、Stack95 Unique Binary Search Trees II 1 tree DP、DFS96 Unique Binary Search Trees 1 tree DP100 Same Tree 1 tree DFS104 Maximum Depth of Binary Tree 1 tree DFS107 Binary Tree Level Order Traversal II 1 tree BFS111 Minimum Depth of Binary Tree 1 tree DFS118 Pascal’s Triangle 1 array119 Pascal’s Triangle II 1 array120 Triangle 1 array DP121 Best Time to Buy and Sell Stock 1 array DP122 Best Time to Buy and Sell Stock II 1 array greedy123 Best Time to Buy and Sell Stock III 1 array DP126 Word Ladder II 1]]></content>
      <tags>
        <tag>笔面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer算法Code_Java_C++(0820更新)]]></title>
    <url>%2F2018%2F08%2F16%2F%E5%89%91%E6%8C%87Offer%E7%AE%97%E6%B3%95Code_Java_C%2B%2B%2F</url>
    <content type="text"><![CDATA[剑指Offer算法Code_Java_C++ 1在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路：从左下角元素往上查找，右边元素是比这个元素大，上边是的元素比这个元素小。Java代码1234567891011121314151617public class Solution &#123; public boolean Find(int target, int [][] array) &#123; //填写 int row = array.length; int col = array[0].length; int i=row-1,j=0; while(i&gt;=0&amp;&amp;j&lt;=col-1)&#123; if(target&lt;array[i][j])&#123; i--; &#125;else if(target&gt;array[i][j])&#123; j++; &#125;else return true; &#125; return false; &#125;&#125; C++代码123456789101112131415161718class Solution &#123;public: bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123; // array是二维数组，这里没做判空操作 int rows = array.size(); int cols = array[0].size(); int i=rows-1,j=0;//左下角元素坐标 while(i&gt;=0 &amp;&amp; j&lt;cols)&#123;//使其不超出数组范围 if(target&lt;array[i][j]) i--;//查找的元素较少，往上找 else if(target&gt;array[i][j]) j++;//查找元素较大，往右找 else return true;//找到 &#125; return false; &#125;&#125;; 2请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。Java代码：1234567public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; String str1 = str.toString(); String str2 = str1.replace(&quot; &quot;,&quot;%20&quot;); return str2; &#125;&#125; Java代码：1234567891011121314151617181920212223public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; int spacenum = 0;//spacenum为计算空格数 for(int i=0;i&lt;str.length();i++)&#123; if(str.charAt(i)==&apos; &apos;) spacenum++; &#125; int indexold = str.length()-1; //indexold为为替换前的str下标 int newlength = str.length() + spacenum*2;//计算空格转换成%20之后的str长度 int indexnew = newlength-1;//indexold为为把空格替换为%20后的str下标 str.setLength(newlength);//使str的长度扩大到转换成%20之后的长度,防止下标越界 for(;indexold&gt;=0 &amp;&amp; indexold&lt;newlength;--indexold)&#123; if(str.charAt(indexold) == &apos; &apos;)&#123; // str.setCharAt(indexnew--, &apos;0&apos;); str.setCharAt(indexnew--, &apos;2&apos;); str.setCharAt(indexnew--, &apos;%&apos;); &#125;else&#123; str.setCharAt(indexnew--, str.charAt(indexold)); &#125; &#125; return str.toString(); &#125;&#125; c++代码123456789101112131415161718192021class Solution &#123;public: void replaceSpace(char *str,int length) &#123; int count = 0; for (int i=0;i&lt;length;i++)&#123; if (str[i]==&apos; &apos;)&#123; count++; &#125; for (int i=length-1;i&gt;=0;i--)&#123; if (str[i]==&apos; &apos;)&#123; count--; str[i+2*count]=&apos;%&apos;; str[i+2*count+1]=&apos;2&apos;; str[i+2*count+2]=&apos;0&apos;; &#125;else&#123; str[i+2*count]=str[i]; &#125; &#125; &#125; &#125;&#125;; 3输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 Java代码：1234567891011java 递归超简洁版本public class Solution &#123; ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;Integer&gt;(); public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; if(listNode!=null)&#123; this.printListFromTailToHead(listNode.next); arrayList.add(listNode.val); &#125; return arrayList; &#125;&#125; C++代码1234567891011121314class Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; vector&lt;int&gt; value; if (head != NULL)&#123; value.insert(value.begin(),head-&gt;val); while (head-&gt;next !=NULL)&#123; value.insert(value.begin(),head-&gt;next-&gt;val); head = head -&gt;next; &#125; &#125; return value; &#125;&#125;; 4输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 递归思想，每次将左右两颗子树当成新的子树进行处理，中序的左右子树索引很好找，前序的开始结束索引通过计算中序中左右子树的大小来计算，然后递归求解，直到startPre&gt;endPre||startIn&gt;endIn说明子树整理完到。方法每次返回左子树活右子树的根节点1234567 1 / \ 2 3 /\ /4 5 6 \ / 7 8 Java代码：12345678910111213141516171819202122public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; TreeNode root=reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1); return root; &#125; //前序遍历&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125; private TreeNode reConstructBinaryTree(int [] pre,int startPre,int endPre,int [] in,int startIn,int endIn) &#123; if(startPre&gt;endPre||startIn&gt;endIn) return null; TreeNode root=new TreeNode(pre[startPre]); for(int i=startIn;i&lt;=endIn;i++) if(in[i]==pre[startPre])&#123; root.left=reConstructBinaryTree(pre,startPre+1,startPre+i-startIn,in,startIn,i-1); root.right=reConstructBinaryTree(pre,i-startIn+startPre+1,endPre,in,i+1,endIn); break; &#125; return root; &#125;&#125; 5大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 Java代码123456789101112131415public class Solution &#123; public int Fibonacci(int n) &#123; if(n&lt;1)&#123; return n; &#125; int[] ints = new int[n+1]; ints[0] = 0; ints[1] = 1; for(int i = 2; i &lt;= n; i++ )&#123; ints[i] = ints[i-1] + ints[i-2]; &#125; return ints[n]; &#125;&#125; C++代码：1234567891011121314151617class Solution &#123;public: int Fibonacci(int n) &#123; int pre = 0; int last=1; int result =0; if(n&lt;=1)&#123; return n; &#125; for(int i=2; i&lt;=n; i++)&#123; result=pre+last; pre=last; last=result; &#125; return result; &#125;&#125;; 6一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 思路：，f(1) = 1, f(2) = 2, f(3) = 3, f(4) = 5， 可以总结出f(n) = f(n-1) + f(n-2)的规律Java代码：123456789101112131415public class Solution &#123; public int JumpFloor(int target) &#123; int[] ints= new int[target+1]; if(target &lt;=0 )&#123; return 0; &#125;else if(target==1 || target==2)&#123; return target; &#125; ints[0] = 1;ints[1] = 2; for(int i =2; i&lt;=target; i++)&#123; ints[i] = ints[i-1] + ints[i-2]; &#125; return ints[target-1]; &#125;&#125; C++代码1234567891011121314151617class Solution &#123;public: int jumpFloor(int number) &#123; int first = 1;int second = 2; int result = 0; if (number&lt;=0)&#123; return 0; &#125;else if (number==1||number==2)&#123; return number; &#125; for (int i=3; i&lt;=number; i++)&#123; result = first + second; first = second; second = result; &#125; return result; &#125;&#125;; 7输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 思路：1自身左移动，然后跟原数字做与比较，如果对应相同输出为1，否则为0。Java代码：12345678910111213public class Solution &#123; public int NumberOf1(int n) &#123; int count = 0; int flag = 1; while(flag != 0)&#123; if((n &amp; flag) !=0 )&#123; count++; &#125; flag = flag &lt;&lt; 1; &#125; return count; &#125;&#125; C++代码：123456789101112131415class Solution &#123;public: int NumberOf1(int n) &#123; int count = 0; int flag = 1; while(flag != 0)&#123; if((n &amp; flag)!=0)&#123; count++; &#125; flag = flag &lt;&lt; 1; &#125; return count ; &#125; &#125;; 8输入一个链表，反转链表后，输出新链表的表头: 整体反转链表，但是要把断开的节点保存起来，才能继续反转链表Java代码：12345678910111213141516171819202122232425262728293031public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; if(head==null) return null; //head为当前节点，如果当前节点为空的话，那就什么也不做，直接返回null； ListNode pre = null; ListNode next = null; //当前节点是head，pre为当前节点的前一节点，next为当前节点的下一节点 //需要pre和next的目的是让当前节点从pre-&gt;head-&gt;next1-&gt;next2变成pre&lt;-head next1-&gt;next2 //即pre让节点可以反转所指方向，但反转之后如果不用next节点保存next1节点的话，此单链表就此断开了 //所以需要用到pre和next两个节点 //1-&gt;2-&gt;3-&gt;4-&gt;5 //1&lt;-2&lt;-3 4-&gt;5 while(head!=null)&#123; //做循环，如果当前节点不为空的话，始终执行此循环，此循环的目的就是让当前节点从指向next到指向pre //如此就可以做到反转链表的效果 //先用next保存head的下一个节点的信息，保证单链表不会因为失去head节点的原next节点而就此断裂 next = head.next; //保存完next，就可以让head从指向next变成指向pre了，代码如下 head.next = pre; //head指向pre后，就继续依次反转下一个节点 //让pre，head，next依次向后移动一个节点，继续下一次的指针反转 pre = head; head = next; &#125; //如果head为null的时候，pre就为最后一个节点了，但是链表已经反转完毕，pre就是反转后链表的第一个节点 //直接输出pre就是我们想要得到的反转后的链表 return pre; &#125;&#125; C++代码：123456789101112131415161718192021222324class Solution &#123;public: ListNode* ReverseList(ListNode* pHead) &#123; if(pHead == NULL)&#123; return NULL; &#125; ListNode* pNode = pHead;//当前指针 ListNode* pPre = NULL;//链表的前一个指针 ListNode* pNewHead = NULL; while(pNode != NULL)&#123; ListNode* pNext = pNode-&gt;next; if(pNext == NULL)&#123; //尾节点 pNewHead = pNode; &#125; pNode-&gt;next = pPre; pPre = pNode; pNode = pNext; &#125; return pNewHead; &#125;&#125;; 9输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 两两数值对比,merge可以合并两个事物，链表也行，考点在取两个链表比较小的头节点 Java代码：1234567891011121314151617public class Solution &#123; public ListNode Merge(ListNode list1,ListNode list2) &#123; if(list1 == null)&#123; return list2; &#125; if(list2 == null)&#123; return list1; &#125; if(list1.val &lt;= list2.val)&#123; list1.next = Merge(list1.next,list2); return list1; &#125;else&#123; list2.next = Merge(list1,list2.next); return list2; &#125; &#125;&#125; C++代码：12345678910111213141516171819202122class Solution &#123;public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) &#123; if(pHead1 == NULL)&#123; return pHead2; &#125; if(pHead2 == NULL)&#123; return pHead1; &#125; ListNode* NewHead = NULL; if(pHead1-&gt;val &lt;= pHead2-&gt;val)&#123; NewHead = pHead1; NewHead-&gt;next = Merge(pHead1-&gt;next,pHead2); &#125;else&#123; NewHead = pHead2; NewHead-&gt;next = Merge(pHead1,pHead2-&gt;next); &#125; return NewHead; &#125;&#125;; 10 从上往下打印出二叉树的每个节点，同层节点从左至右打印。 Java代码：123456789101112131415161718192021222324/**思路是用arraylist模拟一个队列来存储相应的TreeNode*/public class Solution &#123; public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; arr = new ArrayList&lt;&gt;(); ArrayList&lt;TreeNode&gt; TN = new ArrayList&lt;&gt;(); if(root==null)&#123; return arr; &#125; TN.add(root); while(TN.size()!=0)&#123; TreeNode temp = TN.remove(0); if(temp.left!= null)&#123; TN.add(temp.left); &#125; if(temp.right!= null)&#123; TN.add(temp.right); &#125; arr.add(temp.val); &#125; return arr; &#125;&#125; C++代码：12345678```### 111个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。&gt;思路：两个相同数字异或=0，一个数和0异或还是它本身。&lt;br&gt;我们首先还是先异或，剩下的数字肯定是A、B异或的结果，这个结果的二进制中的1，表现的是A和B的不同的位。我们就取第一个1所在的位数，假设是第3位，接着把原数组分成两组，分组标准是第3位是否为1。如此，相同的数肯定在一个组，因为相同数字所有位都相同，而不同的数，肯定不在一组。然后把这两个组按照最开始的思路，依次异或，剩余的两个结果就是这两个只出现一次的数字。Java代码： public class Solution { public void FindNumsAppearOnce(int[] array, int[] num1, int[] num2) { int length = array.length; if(length == 2){ num1[0] = array[0]; num2[0] = array[1]; return; } int bitResult = 0; for(int i = 0; i &lt; length; ++i){ bitResult ^= array[i]; } int index = findFirst1(bitResult); for(int i = 0; i &lt; length; ++i){ if(isBit1(array[i], index)){ num1[0] ^= array[i]; }else{ num2[0] ^= array[i]; } } } private int findFirst1(int bitResult){ int index = 0; while(((bitResult &amp; 1) == 0) &amp;&amp; index &lt; 32){ bitResult &gt;&gt;= 1; index++; } return index; } private boolean isBit1(int target, int index){ return ((target &gt;&gt; index) &amp; 1) == 1; } }12C++代码： 链接：https://www.nowcoder.com/questionTerminal/e02fdb54d7524710a7d664d082bb7811来源：牛客网 class Solution {public: void FindNumsAppearOnce(vector data,int num1,int num2) { if(data.size()&gt;1; ++index; } num1=num2=0; for(int i=0;i&gt;index; return (num&amp;1); }};1234567 ^=:逐位异或 ### 12最小的k个数输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。Java代码：(快排/最小堆) 链接：https://www.nowcoder.com/questionTerminal/6a296eb82cf844ca8539b57c23e6e9bf来源：牛客网 / 基于堆排序算法，构建最大堆。时间复杂度为O(nlogk)如果用快速排序，时间复杂度为O(nlogn)； 如果用冒泡排序，时间复杂度为O(nk) /import java.util.ArrayList;public class Solution { public ArrayList GetLeastNumbers_Solution(int [] input, int k) { ArrayList list=new ArrayList(); //检查输入的特殊情况 if(input==null || input.length&lt;=0 || input.length=0; len—){ adjustMaxHeapSort(input,len,k-1); } //从第k个元素开始分别与最大堆的最大值做比较，如果比最大值小，则替换并调整堆。 //最终堆里的就是最小的K个数。 int tmp; for(int i=k; i&lt;input.length; i++){ if(input[i]&lt;input[0]){ tmp=input[0]; input[0]=input[i]; input[i]=tmp; adjustMaxHeapSort(input,0,k-1); } } for(int j=0; j&lt;k; j++){ list.add(input[j]); } return list; } public void adjustMaxHeapSort(int[] input, int pos, int length){ int temp; int child; for(temp=input[pos]; 2*pos+1&lt;=length; pos=child){ child=2*pos+1; if(child&lt;length &amp;&amp; input[child]&lt;input[child+1]){ child++; } if(input[child]&gt;temp){ input[pos]=input[child]; }else{ break; } } input[pos]=temp; } }1### 二叉树的景象 题目描述操作给定的二叉树，将其变换为源二叉树的镜像。输入描述:二叉树的镜像定义：源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11 镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 51C++代码： 12345### 13Java代码： public class Solution { public void Mirror(TreeNode root) { if(root == null){ return; } TreeNode temp; if(root!=null){ temp = root.left; root.left = root.right; root.right = temp; } if(root.left!=null){ Mirror(root.left); } if(root.right!=null){ Mirror(root.right); } } }12C++代码： 12345Java代码： 1C++代码： 1234Java代码： 12C++代码： 12345Java代码： 12C++代码： 12345Java代码： 1C++代码： ```]]></content>
      <tags>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-梯度消失爆炸]]></title>
    <url>%2F2018%2F08%2F16%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E7%88%86%E7%82%B8%2F</url>
    <content type="text"><![CDATA[机器学习-梯度消失爆炸 梯度消失本层的神经元的激活等于上一层神经元对应的权值进行加权和运算，最后通过一个非线性函数（激活函数）如ReLu，sigmoid等函数，最后得到的结果就是本层神经元的输出，逐层逐神经元通过该操作向前传播，最终得到输出层的结果。 梯度消失的影响：1) 浅层基本不学习，后面几层一直在学习，失去深度的意义。2) 无法收敛。 梯度消失的现象呢？因为通常神经网络所用的激活函数是sigmoid函数这个函数有个特点: 就是能将负无穷到正无穷的数映射到0和1之间，并且对这个函数求导的结果是f′(x)=f(x)(1−f(x))。因此两个0到1之间的数相乘，得到的结果就会变得很小了。神经网络的反向传播是逐层对函数偏导相乘，因此当神经网络层数非常深的时候最后一层产生的偏差就因为乘了很多的小于1的数而越来越小，最终就会变为0，从而导致层数比较浅的权重没有更新 一是在深层网络中，网络层数过多二是采用了不合适的损失函数，比如sigmoid 梯度爆炸就是由于初始化权值过大，前面层会比后面层变化的更快，就会导致权值越来越大，梯度爆炸的现象就发生了。 解决用ReLU激活函数来替代sigmoid函数。 区别：（1）sigmoid函数值在[0,1],ReLU函数值在[0,+无穷]，所以sigmoid函数可以描述概率，ReLU适合用来描述实数；（2）sigmoid函数的梯度随着x的增大或减小和消失，而ReLU不会。 早期多层神经网络如果用sigmoid函数或者hyperbolic tangent作为激活函数，如果不进行pre-training的话，会因为gradient vanishing problem而无法收敛。 而预训练的用处：规则化，防止过拟合；压缩数据，去除冗余；强化特征，减小误差；加快收敛速度。而采用ReLu则不需要进行pre-training。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面经-概率论算法]]></title>
    <url>%2F2018%2F08%2F16%2F%E9%9D%A2%E7%BB%8F-%E6%A6%82%E7%8E%87%E8%AE%BA%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Q1100人坐飞机，第一个乘客在座位中随便选一个坐下，第100人正确坐到自己坐位的概率是？ Q2给定三个随机变量X,Y,Z，已知X和Y的相关系数(correlation)为0.8，X和Z的相关系数为0.8。问Y和Z的相关系数最大／最小为多少？ 答： |1|0.8|0.8||0.8|1|a||0.8|a|1| Q3几何分布:一个国家重男轻女，只要生了女孩就继续生，直到生出男孩为止，问这个国家的男女比例？ 答： 1比1 因为只要生了女孩就继续生，直到生出男孩为止，影响的是家庭男女孩的比例，国家总人数比例还是1比1 Q4有50个红球，50个蓝球，如何放入两个盒子中使得拿到红球的概率最大 如果要拿两个红的，一个盒子放一个红球，一个盒子放49红，50蓝，取两个红球概率49/99 Q5一根木棍随机折成三段，能组成三角形的概率多大？ 答：任意两边之和大于第三边p=[(1/8)a^2]/[(1/2)a^2]=1/4=0.25 Q6Q7Q8Q9Q10]]></content>
      <tags>
        <tag>笔面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法_动态规划]]></title>
    <url>%2F2018%2F08%2F16%2F%E7%AE%97%E6%B3%95_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[算法_动态规划 求解最优化问题 背包问题1123456789101112131415161718192021222324252627282930313233343536373839404142434445Problem Description: 有 n 个重量和价值分别为Wi,Vi的物品，现从这些物品中挑选出总量不超过 W 的物品，求所有方案中价值总和的最大值。Input:输入包含多组测试用例，每一例的开头为两位整数 n、W（1&lt;=n&lt;=10000,1&lt;=W&lt;=1000），接下来有 n 行，每一行有两位整数 Wi、Vi（1&lt;=Wi&lt;=10000,1&lt;=Vi&lt;=100）。Output:输出为一行，即所有方案中价值总和的最大值。Sample Input:3 41 22 53 7Sample Output:9Java代码：import java.util.Arrays;import java.util.Scanner; public class Main &#123; static Scanner scan = new Scanner(System.in); static int[] v = new int[10001]; static int[] w = new int[10001]; static int[] dp = new int[10001]; public static void main(String[] args) &#123; // TODO Auto-generated method stub while(scan.hasNext())&#123; int n = scan.nextInt(); int W = scan.nextInt(); v = new int[n+1]; w = new int[n+1]; for(int i=1;i&lt;=n;i++)&#123; w[i] = scan.nextInt(); v[i] = scan.nextInt(); &#125; for(int i = 1; i &lt;= n; i++) for(int j = W; j &gt;= 0; j--)&#123; //每次更新容量为j，所能放下最大价值的物品 if(j &gt;= w[i])&#123; //j一定要大于w[i],要不最大容量为j的背包放不下第i件物品 dp[j] = Math.max(dp[j], dp[j-w[i]] + v[i]); //dp[j] 表示最大容量为j的背包所装下物品最大的价值， 这里求的是第i件物品放和不放的价值的最大的价值 &#125; &#125; System.out.println(dp[W]); &#125; &#125;&#125; 背包问题21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * @author miracle *切割钢条问题： *长度：1 2 3 4 5 6 7 8 9 10 *价格：1 5 8 9 10 17 17 20 24 30 *问长度为n的钢条的最多卖多少钱 */public class Solution &#123; int[] prices = &#123;0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30&#125;; int[] dp = new int[prices.length]; public int solve(int[] prices, int n)&#123; if(n == 0) return 0; int max = Integer.MIN_VALUE; for(int i = 1; i &lt;= n; i++)&#123; max = Math.max(max, prices[i] + solve(prices, n - i)); &#125; return max; &#125; public int solveWithMemoUpToBottom(int[] prices, int n)&#123; if(n == 0 || dp[n] &gt; 0) return dp[n]; int max = Integer.MIN_VALUE; for(int i = 1; i &lt;= n; i++)&#123; max = Math.max(max, prices[i] + solve(prices, n - i)); &#125; dp[n] = max; return max; &#125; public int solveBottomToUp(int[] prices, int n)&#123; int[] dp = new int[prices.length]; for(int i = 1; i &lt;= n; i++)&#123; int max = Integer.MIN_VALUE; for(int j = 1; j &lt;= i; j++)&#123; max = Math.max(max, prices[j] + prices[i - j]); &#125; dp[i] = max; &#125; return dp[n]; &#125; public static void main(String args[])&#123; Solution s = new Solution();// System.out.println(s.solve(s.prices, 1));// System.out.println(s.solve(s.prices, 2));// System.out.println(s.solve(s.prices, 3));// System.out.println(s.solve(s.prices, 4));// System.out.println(s.solve(s.prices, 5)); System.out.println(s.solveBottomToUp(s.prices, 1)); System.out.println(s.solveBottomToUp(s.prices, 2)); System.out.println(s.solveBottomToUp(s.prices, 3)); System.out.println(s.solveBottomToUp(s.prices, 4)); System.out.println(s.solveBottomToUp(s.prices, 5)); &#125;&#125; 递归 运算量比较大 O(2^N) 递归，dp，分治的区别递归只是一种编程的思想，只要自己调用自己，就算是递归。 分治，有三步，先分，再各自处理，最后整合。这里也涉及了子问题，这里的子问题是不重叠的，每一个只被处理一次，因此不需要memo。 dp，可以使用递归，而且dp的子问题是重复的。]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面经—机器学习]]></title>
    <url>%2F2018%2F08%2F15%2F%E9%9D%A2%E7%BB%8F%E2%80%94%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[面经—机器学习 CVTE面经作者：一一后链接：https://www.nowcoder.com/discuss/88069来源：牛客网 1.解释方差 2.PCA的实现过程；推导PCA 3.传统的图像特征有哪些 4.Sift特征为什么能实现尺度不变性（讲sift原理到一半，我发现完全解释不了为啥尺度不变，就停了，尴尬）[参考](https://blog.csdn.net/u014485485/article/details/78681086?locationNum=1&amp;fps=1）123尺度不变性：不管原图尺度是多少，在包含了所有尺度的尺度空间下都能找到那些稳定的极值点，这样就做到了尺度不变！高斯函数是唯一可行的尺度空间核 5.Hough直线检测的原理 6.梯度下降和牛顿法的区别1234567891011牛顿法的优缺点优点：二阶收敛，收敛速度快；缺点：牛顿法是一种迭代算法，每一步都需要求解目标函数的Hessian矩阵的逆矩阵，计算比较复杂。梯度下降法的优化思想是用当前位置负梯度方向作为搜索方向，因为该方向为当前位置的最快下降方向，所以也被称为是”最速下降法“。最速下降法越接近目标值，步长越小，前进越慢梯度下降法的缺点：靠近极小值时收敛速度减慢，；直线搜索时可能会产生一些问题；可能会“之字形”地下降。牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快 7.SVM和Lr的共同点和不同点1234567891011121314151617LR和SVM都是分类算法LR和SVM都是线性分类算法LR和SVM都是监督学习算法LR和SVM都是判别模型LR和SVM在学术界和工业界都广为人知并且应用广泛不同：损失函数LR：逻辑回归方法基于概率理论逻辑回归考虑全局（远离的点对边界线的确定也起作用）对数据不做处理LR必须另外在损失函数上添加正则项SVM：几何间隔最大化原理支持向量机只考虑局部的边界线附近的点，线性SVM不直接依赖于数据分布线性SVM依赖数据表达的距离测度，所以需要对数据先做归一化SVM的损失函数就自带正则 8.rf和Adaboost的异同(优秀的基于决策树的组合算法)123451，相同：二者都是bootsrap自助法选取样本。 2，相同：二者都是要训练很多棵决策树。 3，不同：adaboost后面树的训练，其在变量抽样选取的时候，对于上一棵树分错的样本，抽中的概率会加大。 4，不同：随机森林在训练每一棵树的时候，随机挑选了部分变量作为拆分变量，而不是所有的变量都去作为拆分变量。 5，不同：在预测新数据时，adaboost中所有的树加权投票来决定因变量的预测值，每棵树的权重和错误率有关；随机森林按照所有树中少数服从多数树的分类值来决定因变量的预测值。 9.给出一堆大小不一的矩形框，快速求矩形框的灰度值之和（当时没理解，这不是肯定要遍历么…后来结束后我想这些矩形框可能是重叠的，估计是要问我关于Bing中快速求梯度的算法） 10.有什么要问他的 作业帮提前批机器学习算法岗作者：编程一头牛链接：https://www.nowcoder.com/discuss/90245来源：牛客网 对数据预处理怎么填充的缺失值，哪些判定为异常值，对连续属性进行离散化有什么好处，Logistic回归能处理浮点数吗？多项式组合特征对哪个模型中效果提升最大。这个没答上来，问了面试官，面试官说是Logistic回归里面提升最大，而且组合起来的两个特征也是想出来的，没什么理论支撑。还问了模型的评价指标AUC是如何计算的，ROC曲线的横纵坐标代表了什么含义。XGBoost模型里面参数有哪些？如何发现过拟合。XGBoost模型中对数据进行采样的好处？ 如何最快的找出两个集合中的交集，提出用哈希表的方法，问了这种方法的复杂度，然后又问如果这两个集合都特别大，不能再内存中构建哈希表该如何做？可能是想让我回答多线程相关的内容，但是我不会。如何设计哈希表？期间也问过有编过多线程多进程的代码吗 深信服【机器学习】一面作者：Rnanprince链接：https://www.nowcoder.com/discuss/87283来源：牛客网 【机器学习】一面：1.项目介绍，研究的最成功的地方，我以写的文章为例，涉及到的知识点就问2.笔试的数组求和100怎么做的？没抽到这个题，但是做过；接着我说做了查找重复字符串最大长度，深搜，过了就没想别的方法一个数组，求最长的连续子序列的起始下标，当时没理解明白，其实有歧义，简单说了一下3.自己的哪些方面的优点没有涉及到，介绍一下提到了SVM和决策树，介绍一下什么情况下使用？svm:12345678910111213141516171819202122232425262728293031这个模型的优势是什么？分类效果好；可以有效地处理高维空间的数据；可以有效地处理变量个数大于样本个数的数据；只是使用了一部分子集来进行训练模型，所以SVM模型不需要太大的内存；可以提高泛化能力；无局部极小值问题；他什么情况下表现最好？数据的维度较高；需要模型具有非常强的泛化能力；样本数据量较小时；解决非线性问题；这个模型的缺点是什么？无法处理大规模的数据集，因为该算法需要较长的训练时间；无法有效地处理包含噪声太多的数据集；SVM模型没有直接给出概率的估计值，而是利用交叉验证的方式估计，这种方式耗时较长；对缺失数据非常敏感；对于非线性问题，有时很难找到一个合适的核函数。什么条件下它表现很差？数据集的数据量过大；数据集中的含有噪声；数据集中的缺失较多的数据；对算法的训练效率要求较高；根据我们当前数据集的特点，为什么这个模型适合这个问题。 该项目所提供的样本数据相对较少；该问题是属于非线性问题；数据集经过“独热编码”后，维度较高 决策树：1234567891011121314151617181920212223242526272829303132这个模型的优势是什么？决策树易于实现和理解；对于决策树，数据的准备工作一般比较简单；能够同时处理多种数据类型给定一个决策树模型，可以根据产生的决策树推出相应的逻辑表达式；通过静态测试来对模型的表现进行评价；在相对较短的时间内可以对大量的数据做出非常好的结果；决策树可以很好地扩展到大型数据中，同时决策树的大小独立于数据库的大小；计算复杂度相对较低，结果的输出易于理解，对部分的数据缺失不敏感。他什么情况下表现最好？实例是由“属性-值”对表示的；目标函数具有离散的输出值；训练数据集包含部分错误(决策树对错误有适应性)；训练数据缺少少量属性的实例。这个模型的缺点是什么？易于出现过拟合问题；忽略了数据集中属性之间的相关性；对于类比不一致的样本，决策树的信息增益倾向于那些数据值较多的特征什么条件下它表现很差？决策树匹配的数据过多时；分类的类别过于复杂；数据的属性之间具有非常强的关联。根据我们当前数据集的特点，为什么这个模型适合这个问题。不需要准备太多的训练数据，不需要对数据过多的处理如删除空白值等；易于编码；该问题是非线性问题，决策树能够很好地解决非线性问题；算法的执行效率高，对机器的要求较小。 360浏览器事业部 推荐算法工程师作者：泡了个泡链接：https://www.nowcoder.com/discuss/77924来源：牛客网 二面 1.项目 2.SVM原始问题为什么要转化为对偶问题，为什么对偶问题就好求解，原始问题不能求解么 3.K-means 中我想聚成100类 结果发现只能聚成98类，为什么 4.进程中的内存分段是怎样的 5.每个线程有哪些东西是自己独享的 6.一枚不均匀的硬币，我抛了100次，有70次朝上，那么第101次朝上的概率是多少 这个概率怎么样，公示是如何推导出来的 7.给你个字符串，字符串是个数字，怎么转换为int型，不用库函数的话 8.4个海盗，100个金币，每个人轮流提方案，如果你的方案有半数以上通过，那么久可以，否则就会被杀掉，如果你是第一个人，那么你怎么提方案比较好 9.你的优点是什么 腾讯沈阳现场一面1.项目 2.特征选择方法都有用过哪些 3.随机森林怎么进行特征选择 4.用过哪些机器学习算法 5.加密方法知道哪些 6.MD5可逆么 7.word2vec用过么 8.极大似然估计是什么意思 9.上过哪些课 10.排序算法哪些时间复杂度比较低 11.计算机网络了解多少 阿里 新零售 天猫 算法工程师-机器学习一面先是一个简单的自我介绍；1.然后介绍了项目的框架和主要创新点； 2.说一下随机森林和Adaboost，以及区别 3.说一下GBDT和Adaboost，以及区别 4.说一下LDA的原理 5.对于PCA，会有第一主成分、第二主成分，怎么为什么第一主成分是第一，原因是什么？ 6.PCA的主成分是怎么得到的 3.面向对象的三要素 4.对深度学习了解多少 5.你觉得深度学习的方法和传统机器学习比，有什么大的优势 腾讯提前批作者：IamBright链接：https://www.nowcoder.com/discuss/75166来源：牛客网 女朋友在广州又不想换工作的情况下，微信的机器学习算法工程师是最适合我实习的岗位了，因此最先让腾讯的同学内推了一波，在基本没有准备的情况下，接到了提前批电话一面二面，毫无意外的挂了。 电话一面聊论文，但多数听我在说，没插话什么问题。最后问我第二篇论文里RNN实现的时候有什么trick。问了问凸优化了解吗？传统机器学习了解吗？我答机器学习基本知识都学过，凸优化只了解和机器学习优化算法相关的。也没有继续问细节了。编程题：打印所有子集，我用了迭代，但是写的比较蠢，好在不用调试运行电话二面聊论文，最后问了我跟什么算法做了对比，问我研究的实际意义，产业界现在的水平编程题：打印螺旋矩阵，要我给一个可运行的结果。很简单的题，我一个符号错误调了很久都没发现，这里应该就印象很差了。linux里查看端口被占用的命令，linux不熟，没答上。AUC是什么？我说了是ROC曲线下面积，但是想不起来ROC是啥。我都是做序列数据，没做过二分类问题。LR和SVM的区别。我说了损失函数不同，然后说了SVM通过核技巧可以更好的应对非线性，但是前面好差，这里也没好好组织语言了。提前批挂的没什么话说，就是没准备，好久没做过算法题的情况下，突然出题做就很不顺手。而且机器学习的基础知识都有点忘了，像AUC这种没用过的，基本一问就懵逼。 之后跟工作的同学聊了一下，来牛客刷了刷面经，制定了简单的复习内容和刷题计划。花了一周时间，复习了一下西瓜书前11章和deep learning book前11章，刷了leetcode上三四十道medium的题吧（链表、字符串、迭代、dfs、堆、树、动态规划等每天刷一类题练练手），并且给自己做完2篇论文都准备了面试介绍版，又让同学推了阿里和网易，并进入腾讯笔试流程。 算法、数据挖掘岗面经作者：胖胖胖子链接：https://www.nowcoder.com/discuss/81814来源：牛客网 1.华为回国之后参加的第一次面试就是华为的留学生专场招聘，岗位是大数据开放（华为好像填什么岗位都没差吧~），一共只有两面一面：介绍我的项目经历，我介绍完面试官尴尬的笑了笑说他不是做大数据方向的，也就没问我什么，聊了聊天愉快的过了二面：可能会针对笔试提问，因为面试官问我为什么没参加笔试，然后就问了问职业规划，说大数据方向都在深圳工作，然后就一直问怎么看待华为的加班文化，怎么看待压力之类的大概10天之后就直接把offer发到了邮箱里2.第四范式（二面挂）刚面完华为就参加了第四范式的面试，以为面试就是聊聊天，后来发现真是naive，第四范式的岗位是nlp研究员一面：就写了两个代码，一个是逆时针打印矩阵，一个是leetcode原题count and say，虽然当时还没刷过题但写的都是easy难度，就过了二面：二面面试官是牛津大学的phd，问我是不是distinction我说不是，就感受到了一股失望~讲了讲项目，问的很细，但是都在自己的项目范围内，问完之后又是写代码，一个字符串如何删除不匹配的括号然后输出括号匹配的字符串，比如（abc（），输出（abc）和abc（），哼哼唧唧没写出来就跪了3.招银网络招银网络面试岗位是算法工程师，一共两轮技术面，一轮hr面一面：讲项目，问了决策树ID3，C4.5，CART的区别，讲了SVM的原理，然后写了找两个数的最小公倍数的代码二面：讲项目，然后面试官说他是做C++开发的，问我会不会C++，我说学过但很久没用了，就聊了聊天愉快的过了hr面：略（就谈人生谈理想接不接受调岗） 平安科技招银网络面试岗位是算法工程师，一共两轮技术面，一轮hr面一面：讲项目，问了问当时爬虫有没有用什么框架，然后问为什么文本分类我选择了朴素贝叶斯，然后让我说了一下对word2vec的理解二面：最痛的一次面试，三个面试官，一个问数据结构和数据库：问我知道的数据结构和使用场景，然后口述怎么把单链表变双向链表，讲了一下红黑树，以及红黑树的应用，数据的范式，索引失效的情况，如何优化数据库性能等等。第二个面试官问操作系统和计算机网络：TCP三次握手，四次挥手，第二次挥手和第三次挥手的时间间隔如何界定，TCP拥塞控制，OSI五层模型，每层有什么协议，TCP和UDP的区别，UDP的应用（这个问题我没太理解），ARP协议，python多线程，python3对python2是否有改进。第三个面试官问设计模式和算法：python闭包，bagging/boosting的区别，XGboost特点，tf-idf缺点，单例模式（设计模式我完全不会），怎样设计一个分布式的爬虫。hr面：大概聊了聊对薪资的期望，和工作的部门5.链家链家是参加了牛客的留学生专场，感觉链家的面试官人真的好~岗位是机器学习/数据挖掘工程师，不过链家面试有点坎坷面完前两面才发现我面的大数据开发，其实我想去的是数据挖掘，然后就开始了第三轮面试一面：先写了一个很简单的判断两个二叉树是不是一样的树，然后就说给一台机器内存有限制，然后10台服务器，每个服务器上有一个1G文件，假设文件里单词，如何给这些单词按频率排序，又问了求数据流的中位数，最后是智力题，给你两个一模一样的杯子，假设一共有10层楼，怎样找到杯子摔下来能不碎的最高楼层。二面：面试官先问我职业规划，我说数据挖掘，他就比较懵说他们是大数据开发部门，问我考不考虑，我说还是倾向于做数据挖掘，就开始了面试，问了数据库索引的优缺点，索引失效的情况，然后复合索引如何引用会失效，然后问了ACID，剩下的记不清了，说我基础不错去给我联系数据挖掘的面试官三面：手写LR损失函数，LR/SVM区别，手画word2vec网络结构，bagging，boosting，stacking的区别和联系，如果RF和GBDT达到同样的准确度哪个分裂的树更少为什么，随机梯度下降和梯度下降哪一个更快，XGBoost特点，XGBoost的L1和L2正则化怎么体现，特征工程相关的卡方统计和互信息计算公式，然后写了一个如何用最少的硬币找钱。HR面：介绍了一下链家的福利和部门的发展。6.快手快手4.18的笔试，5.5面试大概是备胎池捞起来了，三轮技术面，一轮hr面一面：介绍项目，边讲项目边提问，然后写了个代码，判断有向图中是否有环二面：介绍项目，边讲项目边提问，问了文本分类问什么朴素贝叶斯比SVM，决策树效果更好，然后分类性能度量，precision，recall，F1 score和ROC AUC对比，写了一个leetcode的flatten nested list iterator三面：只写代码，第一个AABB的字符串输出AB，第二个找数组的最长递增子序列，然后介绍了一下他们做的东西HR面：谈了谈offer 顺丰提前批人工智能岗技术面面经作者：撒泼打滚求Offer链接：https://www.nowcoder.com/discuss/92370来源：牛客网 目标检测了解吗，（了解一点）Faster RCNN跟RCNN有什么区别 SPP， YOLO了解吗（不了解）（后悔没去看看= =） 梯度消失梯度爆炸怎么解决 RNN容易梯度消失，怎么解决（LSTM） LSTM跟RNN有啥区别 传统的机器学习算法了解吗（不怎么了解，说了个KMeans） KMeans讲讲，KMeans有什么缺点，K怎么确定（不会） 卷积层和池化层有什么区别（不是很懂这个问题的点） 防止过拟合有哪些方法 1234567891011121314151、正则化，即在对模型的目标函数（objective function）或代价函数（cost function）加上正则项 随着模型训练的进行，模型的复杂度会增加，此时模型在训练数据集上的训练误差会逐渐减小，但是在模型的复杂度达到一定程度时，模型在验证集上的误差反而随着模型的复杂度增加而增大。此时便发生了过拟合，即模型的复杂度升高。1、early stopping、 迭代次数（epochs）截断的方法（常用 梯度下降法）； 训练数据一次遍历结束，计算指标，指标不增加，停止训练； 记录一个最好的指标，如果之后的10次，20次训练达到的指标都没有之前最好的高，则停止训练。2、数据增强（Data augmentation）、 从数据源采集更多数据 复制原有数据并加上随机噪声 重采样 根据当前数据集估计数据分布参数，使用该分布产生更多数据等3、正则化（Regularization）、 正则化方法是指在进行目标函数或代价函数优化时，在目标函数或代价函数后面加上一个正则项，一般有L1正则与L2正则等。4、Dropout dropout咋回事讲讲 你有什么要问我的吗 联影医疗 Offer作者：吃饭睡觉编论文链接：https://www.nowcoder.com/discuss/52357来源：牛客网 联影医疗 Offer一面1、GBDT和xgboost的区别2、GBDT和LR的区别3、讲项目（为什么用GBDT LR？）4、随便讲一个熟悉的传统图像处理中的特征提取和描述子（sift和sift描述子）二面1、写代码：实现统计图像灰度直方图的代码2、熟悉的聚类算法、k-means原理、混合高斯模型原理3、PCA原理、数学解释（应该是一个最优的线性子空间）4、surf相比sift特征点的优化之处5、写代码：dijkstra最短路径算法6、SVM原理、过拟合怎么解决7、霍夫变换检测直线和圆的原理HR面个人优缺点、拿到的offer、期望薪资、是不是独生子、对联影医疗的了解 VIVO算法作者：MadCoder链接：https://www.nowcoder.com/discuss/94110来源：牛客网 1.评估指标2.在AUC值大时，Log损失也大。请问可能的原因3.梯度消失，梯度爆炸原因及解决4.概率题：8支球队循环赛，前四名晋级。求晋级可能性5.Spark和hadoop实现K-MEANS，及优劣比较]]></content>
      <tags>
        <tag>C++</tag>
        <tag>笔面试</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git_update_error1]]></title>
    <url>%2F2018%2F08%2F01%2Fgit_update_error1%2F</url>
    <content type="text"><![CDATA[git 上传报错及解决 failed to push some refs to报错内容，不能推送文件到github上1error: failed to push some refs to github地址 原因是github项目与本地文件夹一些关键文件的确实，比如.git，readme.md文件等等 解决：本地文件夹打开控制命令台 1、添加本地文件夹，github项目更新到本地12git add .git pull origin master 2、再上传文件夹到github1git push -u origin master fatal: The remote end hung up unexpectedlygit推送项目时候出现 “fatal: The remote end hung up unexpectedly ” 原因是推送的文件太大。 上传网速过慢导致文件传输不完整 解决等一会，重新在push上传一遍]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用LaTex添加公式到Hexo博客里]]></title>
    <url>%2F2018%2F07%2F23%2Fhexo_LaTex1%2F</url>
    <content type="text"><![CDATA[使用LaTex添加公式到Hexo博客里 代码编辑器，强烈推荐使用微软的 VS code，相比Atom开启迅速，使用方便，扩展丰富 第一步： 安装Kramedhexo 默认的渲染引擎是 marked，但是 marked 不支持 mathjax。，所以需要更换Hexo的markdown渲染引擎为hexo-renderer-kramed引擎，后者支持mathjax公式输出。12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 第二步：更改文件配置打开/node_modules/hexo-renderer-kramed/lib/renderer.js，更改：123456789101112// Change inline math rulefunction formatText(text) &#123; // Fit kramed&apos;s rule: $$ + \1 + $$ return text.replace(/`\$(.*?)\$`/g, &apos;$$$$$1$$$$&apos;);&#125;为，直接返回text// Change inline math rulefunction formatText(text) &#123; return text;&#125; 第三步: 停止使用 hexo-math，并安装mathjax包卸载hexo-math1npm uninstall hexo-math --save 安装 hexo-renderer-mathjax 包1npm install hexo-renderer-mathjax --save 第四步: 更新 Mathjax 的 配置文件打开/node_modules/hexo-renderer-mathjax/mathjax.html如图所示更改&lt;script&gt;为：即注释掉&lt;script&gt;代码，并把以下代码复制到对应位置1&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt; 第五步: 更改默认转义规则因为LaTeX与markdown语法有语义冲突，所以 hexo 默认的转义规则会将一些字符进行转义，所以我们需要对默认的规则进行修改. 打开/node_modules\kramed\lib\rules\inline.js 1、1escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/, 更改为1escape: /^\\([`*\[\]()# +\-.!_&gt;])/, 2、1em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, 更改为1em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, 第六步: 开启mathjax打开/themes/yilia主题目录下的config.yml文件因为我用的yilia主题，所以路径是/themes/yilia 我们需要在config.yml文件 中开启 Mathjax， 找到 mathjax 字段添加如下代码：(不同的主题配置方法略微有区别)12mathjax: enable: true 或者1mathjax: true 注意的是：，无论是配置文件还是博客文件，配置项跟配置参数均有有一个空格，否则会配置失败例：123mathjax: true（mathjax:空格true）而不是mathjax:true（mathjax:true） 写博客文件时，要开启 Mathjax选项，， 添加以下内容： 1mathjax: true 例如1234title: 特征提取——局部特征date: 2018-07-16 09:39:40tags: [GitHub, Mysql]mathjax: true 如下图所示 通过以上步骤，我们就可以在 hexo 中使用 Mathjax 来书写数学公式。 效果展示： 参考文章1参考文章2]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习_最优化_损失函数]]></title>
    <url>%2F2018%2F07%2F22%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%9C%80%E4%BC%98%E5%8C%96_%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[机器学习最优化损失函数 通常机器学习每一个算法中都会有一个目标函数，算法的求解过程是通过对这个目标函数优化的过程。 在分类或者回归问题中，通常使用损失函数（代价函数）作为其目标函数。损失函数用来评价模型的预测值和真实值不一样的程度，损失函数越好，通常模型的性能越好。不同的算法使用的损失函数不一样。 损失函数分为经验风险损失函数和结构风险损失函数 损失函数 概念 经验风险损失函数 预测结果和实际结果的差别 结构风险损失函数 经验风险损失函数+正则项 θ^∗=argmin(1/N)\sum_i=1^n\L(y_i,f(x_i;θ_i))\+λ\phi(\theta)0-1损失函数和绝对值损失函数原理：预测值和目标值不相等为1，否则为0。绝对值损失函数为： L(Y,f(X))=1, if Y≠f(X)L(Y,f(X))=0, if Y=f(X)感知机就是用的这种损失函数改进：Y-f(X)&lt;阈值T判断相等绝对值损失函数为： L(Y,f(X)=|Y−f(X)|log对数损失函数原理：假设样本服从伯努利分布（0-1）分布，然后求得满足该分布的似然函数，接着用对数求极值。log损失函数的标准形式： L(Y,P(Y|X))=−logP(Y|X)平方损失函数最小二乘法是线性回归的一种方法，它将回归的问题转化为了凸优化的问题。最小二乘法的基本原则是：最优拟合曲线应该使得所有点到回归直线的距离和最小。通常用欧几里得距离进行距离的度量。平方损失的损失函数为： L(Y|f(X))=∑N(Y−f(X))^2指数损失函数AdaBoost就是一指数损失函数为损失函数的。指数损失函数的标准形式： L(Y|f(X))=exp[−yf(x)]Hinge损失函数Hinge损失函数和SVM是息息相关的。在线性支持向量机中，最优化问题可以等价于 1/m\sum_i=1^m\l(wx_i+by_i)+||w||^2其中l(wx_i+by_i) 就是hinge损失函数，后面相当于L2正则项。 Hinge函数的标准形式： L(y)=max(0,1−ty) y的值在-1和+1之间就可以了,使分类器可以更专注于整体的分类误差 参考文章]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>最优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习_分类_adaboost]]></title>
    <url>%2F2018%2F07%2F21%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_adaboost%2F</url>
    <content type="text"><![CDATA[机器学习_分类_adaboost 简介Boosting, 也称为增强学习或提升法，是一种重要的集成学习技术， 能够将预测精度仅比随机猜度略高的弱学习器增强为预测精度高的强学习器。 AdaBoost是英文”Adaptive Boosting”（自适应增强）的缩写 步骤1231）首先，是初始化训练数据的权值分布D1。假设有N个训练样本数据，则每一个训练样本最开始时，都被赋予相同的权值：w1=1/N。2）然后，训练弱分类器hi。具体训练过程中是：如果某个训练样本点，被弱分类器hi准确地分类，那么在构造下一个训练集中，它对应的权值要减小；相反，如果某个训练样本点被错误分类，那么它的权值就应该增大。权值更新过的样本集被用于训练下一个分类器，整个训练过程如此迭代地进行下去。3）最后，将各个训练得到的弱分类器组合成一个强分类器。各个弱分类器的训练过程结束后，加大分类误差率小的弱分类器的权重，使其在最终的分类函数中起着较大的决定作用，而降低分类误差率大的弱分类器的权重，使其在最终的分类函数中起着较小的决定作用。 误差率低的弱分类器在最终分类器中占的权重较大，否则较小。 alpha值是基于每个弱分类器的错误率进行计算,计算出alpha值之后，可以对权重向量进行更新，以使得那些正确分类的样本的权重降低而错分样本的权重升高，直到错误率为0或者弱分类器的数目达到用户的指定值为止 算法过程 参考文章地址 参考文章 数据分类模型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &quot;opencv2/core/core.hpp&quot; #include &quot;opencv2/highgui/highgui.hpp&quot; #include &quot;opencv2/imgproc/imgproc.hpp&quot; #include &quot;opencv2/ml/ml.hpp&quot; #include &lt;iostream&gt; using namespace cv; using namespace std; int main( int argc, char** argv ) &#123; //训练样本 float trainingData[42][2]=&#123; &#123;40, 55&#125;,&#123;35, 35&#125;,&#123;55, 15&#125;,&#123;45, 25&#125;,&#123;10, 10&#125;,&#123;15, 15&#125;,&#123;40, 10&#125;, &#123;30, 15&#125;,&#123;30, 50&#125;,&#123;100, 20&#125;,&#123;45, 65&#125;,&#123;20, 35&#125;,&#123;80, 20&#125;,&#123;90, 5&#125;, &#123;95, 35&#125;,&#123;80, 65&#125;,&#123;15, 55&#125;,&#123;25, 65&#125;,&#123;85, 35&#125;,&#123;85, 55&#125;,&#123;95, 70&#125;, &#123;105, 50&#125;,&#123;115, 65&#125;,&#123;110, 25&#125;,&#123;120, 45&#125;,&#123;15, 45&#125;, &#123;55, 30&#125;,&#123;60, 65&#125;,&#123;95, 60&#125;,&#123;25, 40&#125;,&#123;75, 45&#125;,&#123;105, 35&#125;,&#123;65, 10&#125;, &#123;50, 50&#125;,&#123;40, 35&#125;,&#123;70, 55&#125;,&#123;80, 30&#125;,&#123;95, 45&#125;,&#123;60, 20&#125;,&#123;70, 30&#125;, &#123;65, 45&#125;,&#123;85, 40&#125; &#125;; Mat trainingDataMat(42, 2, CV_32FC1, trainingData); //训练样本的响应值 float responses[42] = &#123;&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;, &apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;, &apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos; &#125;; Mat responsesMat(42, 1, CV_32FC1, responses); float priors[2] = &#123;1, 1&#125;; //先验概率 CvBoostParams params( CvBoost::REAL, // boost_type 10, // weak_count 0.95, // weight_trim_rate 15, // max_depth false, // use_surrogates priors // priors ); CvBoost boost; boost.train ( trainingDataMat, CV_ROW_SAMPLE, responsesMat, Mat(), Mat(), Mat(), Mat(), params ); //预测样本 float myData[2] = &#123;55, 25&#125;; Mat myDataMat(2, 1, CV_32FC1, myData); double r = boost.predict( myDataMat ); cout&lt;&lt;endl&lt;&lt;&quot;result: &quot;&lt;&lt;(char)r&lt;&lt;endl; return 0; &#125; 基于的OpenCV的检测Demo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;opencv/highgui.h&gt;#include &lt;opencv/cv.h&gt;#include &lt;opencv2/imgproc/imgproc_c.h&gt;#include &lt;opencv2/objdetect/objdetect.hpp&gt;using namespace cv;int main(int argc, char** argv)&#123; CascadeClassifier stFaceCascade; IplImage *pstImage = NULL; std::vector&lt;Rect&gt; faceRects; if( !stFaceCascade.load(&quot;D:\\ProgramFiles\\develop\\opencv2.4.8\\sources\\data\\lbpcascades\\lbpcascade_frontalface.xml&quot;) ) &#123; printf(&quot;Loading cascade error\n&quot;); return -1; &#125; pstImage = cvLoadImage(&quot;D:\\test.jpg&quot;, CV_LOAD_IMAGE_COLOR); stFaceCascade.detectMultiScale(pstImage, faceRects, //检出结果 1.1, //缩放步长 2, //框融合时的最小检出个数 0|CV_HAAR_SCALE_IMAGE,//标志 |CV_HAAR_FIND_BIGGEST_OBJECT|CV_HAAR_DO_ROUGH_SEARCH|CV_HAAR_DO_CANNY_PRUNING Size(30, 30), //最小人脸尺寸 Size(300, 300) ); //最大人脸尺寸 printf(&quot;Face Num[%d]\n&quot;, faceRects.size()); for( unsigned int j = 0; j &lt; faceRects.size(); j++ ) &#123; cvRectangle(pstImage, cvPoint(faceRects[j].x, faceRects[j].y), cvPoint(faceRects[j].x + faceRects[j].width, faceRects[j].y + faceRects[j].height), cvScalar(0,255,0), 2,8,0); &#125; cvShowImage(&quot;FDWin&quot;, pstImage); cvWaitKey(0); cvReleaseImage(&amp;pstImage); return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习_分类_SVM]]></title>
    <url>%2F2018%2F07%2F20%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_SVM%2F</url>
    <content type="text"><![CDATA[机器学习_分类_SVM 支持向量机（Support Vector Machine, SVM）的基本模型是在特征空间上找到最佳的分离超平面使得训练集上正负样本间隔最大。 二分类问题的有监督学习算法，引入了核方法之后SVM也可以用来解决非线性问题一般SVM有下面三种： 1、硬间隔支持向量机（线性可分支持向量机）：当训练数据线性可分时，可通过硬间隔最大化学得一个线性可分支持向量机。2、软间隔支持向量机：当训练数据近似线性可分时，可通过软间隔最大化学得一个线性支持向量机。3、非线性支持向量机：当训练数据线性不可分时，可通过核方法以及软间隔最大化学得一个非线性支持向量机。 SVM算法认为图1中的分类器A在性能上优于分类器B，其依据是A的分类间隔比B要大 这两条平行虚线正中间的分界线就是在保持当前决策面方向不变的前提下的最优决策面。两条虚线之间的垂直距离就是这个最优决策面对应的分类间隔。 那个具有“最大间隔”的决策面就是SVM要寻找的最优解,而这个真正的最优解对应的两侧虚线所穿过的样本点，就是SVM中的支持样本点，称为支持向量。 对于图1中的数据，A决策面就是SVM寻找的最优解，而相应的三个位于虚线上的样本点在坐标系中对应的向量就叫做支持向量。 基于最大间隔分割数据优点，错误率低，计算开销不大，结果容易解释缺点，对参数调节敏感，原始分类器不加修改只能解决二类问题。 w^{t}x+b为分类函数输人数据给分类器会输出一个类别标签,单位阶跃函数）的函数对w^{t}x+b作用得到f(w^{t}x+b),其中当u&lt;0时输出-1, 反之则输出+1。这是由于-1和+1仅仅相差一个符号，方便数学上的处理。 如果数据点处于正方向（即+1类 ）并且离分隔超平面很远的位置时，w^{t}x+b会是一个很大的正数，同时label*(w^{t}x+b)也会是一个很大的正数。而如果数据点处于负方向（-1类 ）并且离分隔超平面远的位置时，此时由于类别标签为-1，则label*(w^{t}x+b)仍然是一个很大的正数。 目标：找到分类器定义中的w和b。找到具有最小间隔的数据点即支持向量。找到支持向量，对间隔最大化。 SVM的目标函数：分离超平面分类函数为0，支持向量的分类函数为+-1,为了优化目标函数，固定一个优化另外一个，该问题是一个带约束条件的优化问题。这里的约束条件就是label*(w^{t}x+b)=1。注：label*(w^{t}x+b)被称为点到分隔面的函数间隔，label*(w^{t}x+b)*(1/w)称为点到分隔面的几何间隔。求解这个问题需要经过一系列的转换。具体如下： 求$ 1/W$的最大值相当于求$0.5w^2$的最小值，一个凸二次规划问题 12345注：新目标函数约束条件：alpha&gt;=0,所有的aplha*lable=0但是数据未必100%线性可分，引人所谓松弛变量C新目标函数约束条件为：C&gt;alpha&gt;=0,所有的aplha*lable=0 SVM中的主要工作就是求解这些alpha。SMO算法(序列最小优化（SequentialMinimalOptimization ))的目标是求出一系列alpha和b，一旦求出了这些alpha，就很容易计算出权重向量w，并得到分隔超平面。 SMO的工作原理是：每次循环中选择两个alpha进行优化处理，一旦找到一对合适的alpha，那么就增大其中一个，同时减小另一个。选择的alpha要满足在间隔边界之外的条件，而且还没有进行过区间化处理或者不再边界上。 核函数：大部分时候数据并不是线性可分的，这个时候满足这样条件的超平面就根本不存在。在上文中，我们已经了解到了SVM处理线性可分的情况，那对于非线性的数据SVM咋处理呢？对于非线性的情况，SVM 的处理方法是选择一个核函数，通过将数据映射到高维空间，来解决在原始空间中线性不可分的问题。 这是原始数据和原始空间，明显有红蓝两类：通过核函数，将样本数据映射到更高维的空间（在这里，是二维映射到三维）：而后进行分离超平面：再将分割的超平面映射回去：效果图： 核函数的选择变成了支持向量机的最大变数（如果必须得用上核函数，即核化），因此选用什么样的核函数会影响最后的结果。而最常用的核函数有：线性核、多项式核、高斯核、拉普拉斯核、sigmoid核、通过核函数之间的线性组合或直积等运算得出的新核函数。 Opencv代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; #include &lt;opencv2/ml/ml.hpp&gt; using namespace cv; int main() &#123; // Data for visual representation int width = 512, height = 512; Mat image = Mat::zeros(height, width, CV_8UC3); // Set up training data float labels[5] = &#123;1.0, -1.0, -1.0, -1.0,1.0&#125;; Mat labelsMat(5, 1, CV_32FC1, labels); float trainingData[5][2] = &#123; &#123;501, 10&#125;, &#123;255, 10&#125;, &#123;501, 255&#125;, &#123;10, 501&#125;,&#123;501,128&#125; &#125;; Mat trainingDataMat(5, 2, CV_32FC1, trainingData); //设置支持向量机的参数 CvSVMParams params; params.svm_type = CvSVM::C_SVC;//SVM类型：使用C支持向量机 params.kernel_type = CvSVM::LINEAR;//核函数类型：线性 params.term_crit = cvTermCriteria(CV_TERMCRIT_ITER, 100, 1e-6);//终止准则函数：当迭代次数达到最大值时终止 //训练SVM //建立一个SVM类的实例 CvSVM SVM; //训练模型，参数为：输入数据、响应、XX、XX、参数（前面设置过） SVM.train(trainingDataMat, labelsMat, Mat(), Mat(), params); Vec3b green(0,255,0), blue (255,0,0); //显示判决域 for (int i = 0; i &lt; image.rows; ++i) for (int j = 0; j &lt; image.cols; ++j) &#123; Mat sampleMat = (Mat_&lt;float&gt;(1,2) &lt;&lt; i,j); //predict是用来预测的，参数为：样本、返回值类型（如果值为ture而且是一个2类问题则返回判决函数值，否则返回类标签）、 float response = SVM.predict(sampleMat); if (response == 1) image.at&lt;Vec3b&gt;(j, i) = green; else if (response == -1) image.at&lt;Vec3b&gt;(j, i) = blue; &#125; //画出训练数据 int thickness = -1; int lineType = 8; circle( image, Point(501, 10), 5, Scalar( 0, 0, 0), thickness, lineType);//画圆 circle( image, Point(255, 10), 5, Scalar(255, 255, 255), thickness, lineType); circle( image, Point(501, 255), 5, Scalar(255, 255, 255), thickness, lineType); circle( image, Point( 10, 501), 5, Scalar(255, 255, 255), thickness, lineType); circle(image, Point( 501, 128), 5, Scalar(0, 0, 0), thickness, lineType); //显示支持向量 thickness = 2; lineType = 8; //获取支持向量的个数 int c = SVM.get_support_vector_count(); for (int i = 0; i &lt; c; ++i) &#123; //获取第i个支持向量 const float* v = SVM.get_support_vector(i); //支持向量用到的样本点，用灰色进行标注 circle( image, Point( (int) v[0], (int) v[1]), 6, Scalar(128, 128, 128), thickness, lineType); &#125; imwrite(&quot;result.png&quot;, image); // save the image imshow(&quot;SVM Simple Example&quot;, image); // show it to the user waitKey(0); &#125;]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Opencv图像分割]]></title>
    <url>%2F2018%2F07%2F19%2Fopencv_imgseg%2F</url>
    <content type="text"><![CDATA[Opencv图像分割 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* * * 功能：通过灰度图做简单的图像分割,再使用findContours去掉多余的轮廓 * */ #include &lt;vector&gt; #include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt; using namespace cv;using namespace std; void contours(); int main()&#123; contours();&#125; void contours()&#123; //--1.读入图片 Mat image = imread(&quot;horse_hw.jpg&quot;); Mat gray;//mat类型数据存放图片，opencv特有 cvtColor(image,gray,CV_RGB2GRAY); Mat binary; threshold(gray,binary,60,255,THRESH_BINARY_INV); vector&lt;vector&lt;Point&gt; &gt; contours; Mat binary_copy; //因为findcontours函数会改变输入的图像，所以复制一个图像作为函数的输入 binary.copyTo(binary_copy); findContours(binary_copy,contours,CV_RETR_EXTERNAL/*获取外轮廓*/,CV_CHAIN_APPROX_NONE/*获取每个轮廓的每个像素*/); //遍历每一个轮廓，把多余的轮廓去掉 vector&lt;vector&lt;Point&gt; &gt;::const_iterator it=contours.begin(); while(it!=contours.end()) &#123; if(it-&gt;size()&lt;500) it = contours.erase(it); else ++it; &#125; Mat dst(image.size(),CV_8U,Scalar(0)); drawContours(dst,contours,-1/*绘制所有轮廓*/,Scalar(255)/*绘制为白色*/,CV_FILLED/*轮廓全部填充*/); //--4.显示结果(原图和结果图显示在一起) const int width = image.cols; const int height = image.rows; Mat show_image(Size(3*width,height),CV_8UC3); //将image拷贝到显示图片指定位置 image.copyTo(show_image(Rect(0,0,width,height))); //将binary,dst转换为3通道，使得show_image和dst通道数一致，或者使用convertTo()函数做操作 cvtColor(binary,binary,CV_GRAY2RGB); cvtColor(dst,dst,CV_GRAY2RGB); //将binary,dst拷贝image指定位置 binary.copyTo(show_image(Rect(width,0,width,height))); dst.copyTo(show_image(Rect(2*width,0,width,height))); //显示 imshow(&quot;show&quot;,show_image); waitKey(0);&#125;]]></content>
      <tags>
        <tag>图像处理</tag>
        <tag>Opencv</tag>
        <tag>图像分割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构_二叉树]]></title>
    <url>%2F2018%2F07%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[数据结构_二叉树 树的遍历顺序大体分为三种：前序遍历（先根遍历、先序遍历），中序遍历（中根遍历），后序遍历（后根遍历） 123456二叉树： A / \ B C /\ / D E F 前序遍历前序遍历可以记为根左右。前序遍历的规则：123（1）访问根节点（2）前序遍历左子树（3）前序遍历右子树 前序遍历的输出结果：ABDECF 中序遍历中序遍历可以记为左根右中序遍历的规则：123（1）中序遍历左子树（2）访问根节点（3）中序遍历右子树 中序遍历的输出结果：DBEAFC 后序遍历后序遍历可以记为左右根后序遍历二叉树的规则：123（1）后序遍历左子树（2）后序遍历右子树（3）访问根节点 后序遍历的输出顺序：DEBFCA]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-正则化-L1L2]]></title>
    <url>%2F2018%2F07%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%AD%A3%E5%88%99%E5%8C%96-L1L2%2F</url>
    <content type="text"><![CDATA[机器学习-正则化-L1L2 样本数据量大：经验⻛风险最⼩小化 样本数据量小：结构⻛风险最⼩小化==正则化 经验风险最⼩小化（empirical risk minimization）认为经验⻛风险最⼩小的模型是最优的模型，即求解最优化问题 minf ∈ F(1/N)\sum_{i=1}^NL(y_i,f(x_i))样本容量量⾜足够⼤大的时候，经验⻛风险最⼩小化学习效果良好 结构⻛风险=经验⻛风险+模型复杂度的正则化项（regularizer）或罚项（penalty term） minf ∈ F(1/N)\sum_{i=1}^NL(y_i,f(x_i))+\lambda{J(f)}$J(f)$是模型的复杂度，模型$f$越复杂，复杂度$J(f)$越大。$\lambda ≥ 0$是系数，⽤用以权衡经验⻛风险和模型复杂度。 结构风险⼩需要1、经验风险和2、模型复杂度同时⼩ 范数因为非负性：可以做损失函数，正则项 损失函数通常是⼀个有下确界的函数 常用范数：L0 L1:绝对值 ||x||=\sum_{i=1}^{d}{|x_i|}L2；平方再开根号 ||x||_2=(\sum_{i=1}^{d}{|x_i^2|})^{1/2}Lp ||x||_2=(\sum_{i=1}^{d}{|x_i^p|})^{1/p}p=1,曼哈顿距离，L1范数，表示某个向量量中所有元素绝对值的和p=2,欧式距离，L2范数 使用L1正则项，倾向于使参数稀疏化，使用L2正则项，使参数稠密的接近于0。L1正则是菱形，参数的交点都落在坐标轴上，实现稀疏化。L2是圆形， 正则项是为了降低模型的复杂度，从而避免模型区过分拟合训练数据，包括噪声与异常点（outliers）。从另一个角度上来讲，正则化即是假设模型参数服从先验概率，即为模型参数添加先验，只是不同的正则化方式的先验分布是不一样的。这样就规定了参数的分布，使得模型的复杂度降低（试想一下，限定条件多了，是不是模型的复杂度降低了呢），这样模型对于噪声与异常点的抗干扰性的能力增强，从而提高模型的泛化能力。还有个解释便是，从贝叶斯学派来看：加了先验，在数据少的时候，先验知识可以防止过拟合；从频率学派来看：正则项限定了参数的取值，从而提高了模型的稳定性，而稳定性强的模型不会过拟合，即控制模型空间。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-线性回归]]></title>
    <url>%2F2018%2F07%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[机器学习-线性回归 LR模型每个特征变量可以首先映射到⼀一个函数，然后再参与线性计算,模型如下： y = \theta_0 + \theta_1x_1 + \theta_2x_2 + · · · + \theta_nx_n其中$ x_1,x_2,…,x_n$表示自变量（特征分量），$y$表示因变量，$\theta$是权重，$\theta_0$是偏移项（截距）;$\theta_i$越大，说明$x_i$对$y$结果的影响越⼤输入空间映射到特征空间(映射函数$\phi(x)$)，建模.为 h_\theta(x)=\theta^T\phi(x)特征映射相关技术，包括特征哈希、特征学习、Kernel等 目标函数预测值$ h_\theta(x)$与真实值$y$之差越小越好，加入损失函数(平方损失函数): J(\theta)={0.5}\sum_{i=1}^{n}{(h_\theta(x^i)-y^i)^2}求$min{J(\theta)}$损失函数就是$x^i$的预测值$h_\theta(x^i)$与真实值$y^i$之差的平方和 回归模型（尤其是线性回归类）的⽬目标函数通常⽤用平⽅方损失函数来作为优化的⽬目标函数 为什么用误差平方和作为目标函数： 根据中⼼心极限定理理，把那些对结果影响⽐比较⼩小的变量量（假设独⽴立同分布）之和认为服从正态分布是合理理的 如果数据是高斯分布的，输入值$x^i$，预测值$\theta^Tx^i$，真实值$y^i$，误差$\epsilon^{i}$，线性模型为， y^i=\theta^Tx^i+\epsilon^{i}根据中心极限定理，认为变量之和服从高斯分布,即 e^{i} = y^i-\theta^Tx^i则，x,y的条件概率为 p(y^i|x^i;\theta) = \frac{1}{\sqrt{2\pi}\sigma}exp(-\frac{(y^i-\theta^Tx^i)^2}{2\sigma^2})$p(y^i|x^i;\theta)$越大，证明越接近真实值，还要考虑拟合过度以及模型的泛化能力问题 优化目标函数：使目标函数最小12345最小二乘法梯度下降法 批量梯度下降法 随机梯度下降法拉格朗日乘子法 例子 \begin{bmatrix} {a_{11}}&{a_{12}}&{\cdots}&{a_{1n}}\\ {a_{21}}&{a_{22}}&{\cdots}&{a_{2n}}\\ {\vdots}&{\vdots}&{\ddots}&{\vdots}\\ {a_{m1}}&{a_{m2}}&{\cdots}&{a_{mn}}\\ \end{bmatrix}]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大佬终极面经]]></title>
    <url>%2F2018%2F07%2F19%2F%E5%A4%A7%E4%BD%AC%E7%BB%88%E6%9E%81%E9%9D%A2%E7%BB%8F%2F</url>
    <content type="text"><![CDATA[大佬终极面经 作者：非理性的猫链接：https://www.nowcoder.com/discuss/92930来源：牛客网 去年秋招在准备求职算法岗的过程中，经过一整个秋招的努力，拿了蚂蚁金服、滴滴、宜信大数据、美图几个厂的算法offer，这中间我参考了牛客网很多大神的经验，自己总结了一些经验，写成这篇文章。 一个完整的机器学习工程师的面试过程主要有以下这些环节：自我介绍、项目介绍、算法推导和解释、数据结构与算法题（写代码）。 关于自我介绍，主要就是简单介绍下自己的教育背景，在校期间的研究方向和所做的项目以及在项目中所充当的角色等等，为之后的面试做个铺垫，让面试官从中捕捉点来问。 项目介绍是最为重要的，这也是体现你综合实力的地方，对项目背景、项目实现的方案，项目所实现的东西都要了如指掌，做机器学习的，必然需要准备一到两个重点的机器学习项目，可以是比赛，也可以是实验室项目，关键是项目中间的技术细节都要了如指掌，比如你用了树模型，就得知道所有树模型相关的推导和原理，决不能含糊，一旦你说不太清楚，面试官就会对项目的真实性存疑。参加比赛应该是没有实验室项目的同学最佳的积累经验的途径，比较好的比赛平台有Kaggle、天池大数据、datacastle等 接下来就是机器学习算法原理和推导，这也是要重点去准备的，在面试前得达到，给你一张白纸，你可以把推导的每一步写的清清楚楚的，推导的话面试常考逻辑回归和SVM的推导，关于原理面试官常会问你几个树模型之间的对比等等等，其他的算法比如LR、SVM、EM、Adaboost、PageRank、 FFM、决策树，随机森林， GBDT ， XGBoost 、推荐算法、聚类、CNN、RNN、LSTM、Word2Vec等等，以及他们的适用场景，再如一些机器学习的理论，非平衡问题、过拟合问题，交叉验证问题，模型选择问题，模型融合问题。这一部分我会在文末贴出一个问题集锦，大家按照这个去准备就行。还有必看的书李航的《统计学习方法》、周志华的《机器学习》、项亮的《推荐系统实践》 最后就是写代码了，很多非计算机出身的大都会栽在这个地方，代码写得少，训练不到位，就会导致当场思路不清晰，不知从哪写起，但目前市面上已经有很多专门为这块总结的一些书籍，推荐使用《剑指offer》、《王道程序员求职宝典》等等，有时间的话再刷一下leetcode。排序算法、查找算法、二叉树遍历这些最基本的一定要很顺溜的写下来，其他的就看自己去拓展了，同样的，我也总结了一些笔记供大家参考， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135机器学习机器学习算法系列（40）：机器学习中的数据清洗与特征处理综述机器学习算法系列（39）：实例详解机器学习如何解决问题机器学习算法系列（38）：外卖订单量预测异常报警模型实践机器学习算法系列（37）：外卖O2O的用户画像实践机器学习算法系列（36）：GBDT算法原理深入解析机器学习算法系列（35）：使用Sklearn进行集成学习（实践）机器学习算法系列（34）：使用Sklearn进行集成学习（理论）机器学习算法系列（33）：特征处理（Feature Processing）机器学习算法系列（32）：MapReduce执行流程详解机器学习算法系列（31）：在线最优化求解（online Optimization）机器学习算法系列（30）：Scikit-Learn总结机器学习算法系列（29）：Sparsity and Some Basics of L1 Regularization机器学习算法系列（28）：L1、L2正则化机器学习算法系列（27）：Isolation Forest机器学习算法系列（26）：因子分解机（FM）与场感知分解机（FFM）机器学习算法系列（24）：机器学习中的损失函数机器学习算法系列（25）：最速下降法、牛顿法、拟牛顿法机器学习算法系列（23）：TF-IDF与余弦相似度机器学习算法系列（22）：主成分分析机器学习算法系列（21）：SVD机器学习算法系列（20）：机器学习模型优化四要素机器学习算法系列（19）：机器学习性能评价指标机器学习算法系列（18）：方差偏差权衡（Bias-Variance Tradeoff）机器学习算法系列（17）：非平衡数据处理机器学习算法系列（16）：统计学习概论机器学习算法系列（15）：EM算法机器学习算法系列（14）：关联分析机器学习算法系列（13）：推荐系统（3）—矩阵分解技术机器学习算法系列（13）：推荐系统（2）—基于领域的协同过滤机器学习算法系列（13）：推荐系统（1）—简介机器学习算法系列（12）：SVM（4）—SMO机器学习算法系列（12）：SVM（3）—非线性支持向量机机器学习算法系列（12）：SVM（2）—线性支持向量机机器学习算法系列（12）：SVM（1）—线性可分支持向量机机器学习算法系列（11）：聚类（4）—密度最大值聚类机器学习算法系列（11）：聚类（3）—DBSCAN机器学习算法系列（11）：聚类（2）—Kmeans机器学习算法系列（11）：聚类（1）—简介机器学习算法系列（10）：朴素贝叶斯机器学习算法系列（9）：感知机机器学习算法系列（8）：XgBoost机器学习算法系列（7）：GBDT机器学习算法系列（6）：AdaBoost机器学习算法系列（5）：随机森林机器学习算法系列（4）：决策树机器学习算法系列（3）：逻辑斯谛回归机器学习算法系列（2）：线性回归机器学习算法系列（1）：K近邻自然语言处理自然语言处理系列（10）：自然语言处理的发展与趋势自然语言处理系列（9）：DCNN自然语言处理系列（8）：RCNN自然语言处理系列（7）：TextCNN调参技巧自然语言处理系列（6）：TextCNN自然语言处理系列（5）：FastText自然语言处理系列（4）：深度学习解决大规模文本分类问题自然语言处理系列（3）：中文维基语料词向量训练自然语言处理系列（2）：Word2Vec自然语言处理系列（1）：词向量和语言模型深度学习深度学习系列（12）：pytorch实现卷积神经网络深度学习系列（11）：神经网络防止过拟合的方法深度学习系列（10）：DMC—卷积神经网络分享深度学习系列（9）：Batch Normalization深度学习系列（8）：激活函数深度学习系列（7）：神经网络的优化方法深度学习系列（6）：递归神经网络深度学习系列（5）：长短时记忆网络（LSTM）深度学习系列（4）：循环神经网络（RNN）深度学习系列（3）：卷积神经网络（CNN）深度学习系列（2）：神经网络MNIST实战深度学习系列（1）：神经网络与反向传播算法数据结构与算法数据结构与算法题解（11）：最长回文子串数据结构与算法题解（10）：0-1背包问题与部分背包问题数据结构与算法题解（9）：最长公共子序列和最长公共子串数据结构与算法题解（8）：KMP算法数据结构与算法题解（7）：最短编辑距离数据结构与算法题解（6）：重点掌握数据结构与算法题解（5）：剑指offer解题报告数据结构与算法题解（4）：二叉树题解数据结构与算法题解（3）：字符串题解数据结构与算法题解（2）：数组题解数据结构与算法题解（1）：链表题解数据结构与算法（19）：海量数据处理数据结构与算法（18）：倒排索引数据结构与算法（17）：simhash数据结构与算法（16）：一致性哈希数据结构与算法（15）：布隆过滤器数据结构与算法（14）：最短路算法数据结构与算法（13）：深度优先搜索和广度优先搜索数据结构与算法（12）：排序数据结构与算法（11）：哈希表数据结构与算法（10）：查找数据结构与算法（9）：Trie树数据结构与算法（8）：红黑树数据结构与算法（7）：数据库索引原理及优化数据结构与算法（6）：B树、B+树数据结构与算法（5）：AVL树数据结构与算法（4）：二叉查找树数据结构与算法（3）：二叉树数据结构与算法（2）：栈与队列数据结构与算法（1）：数组与链表JavaJava学习笔记（12）：单例模式Java学习笔记（11）：进程与线程Java学习笔记（10）：QAJava学习笔记（9）：内部类、抽象类、接口Java学习笔记（8）：常用库类、向量与哈希Java学习笔记（7）：深入理解java异常处理机制Java学习笔记（6）：异常处理Java学习笔记（5）：static、final关键字和Object类Java学习笔记（4）：多态Java学习笔记（3）：继承、覆盖、重载Java学习笔记（2）：类与对象Java学习笔记（1）：语法基础Java集合学习手册（11）：Java HashMap源码全剖析Java集合学习手册（10）：hashCode方法与equal方法Java集合学习手册（9）：Java 集合对比Java集合学习手册（8）：Java 集合框架Java集合学习手册（7）：Java LinkedListJava集合学习手册（6）：Java ArrayListJava集合学习手册（5）：Java LinkedHashSetJava集合学习手册（4）：Java LinkedHashMapJava集合学习手册（3）：Java HashTableJava集合学习手册（2）：Java HashSetJava集合学习手册（1）：Java HashMap 以下是我总结的机器学习提问集锦，大家可以在把所有算法过了一遍的基础上把一个个问题都仔细揣摩一遍，加强对算法的理解和延伸。 SVM：12345678910111213简单介绍SVM（详细原理）：从分类平面，到求两类间的最大间隔，到转化为求间隔分之一，等优化问题，然后就是优化问题的解决办法，首先是用拉格拉日乘子把约束优化转化为无约束优化，对各个变量求导令其为零，得到的式子带入拉格朗日式子从而转化为对偶问题， 最后再利用SMO（序列最小优化）来解决这个对偶问题。svm里面的c有啥用SVM的推导，解释原问题和对偶问题，SVM原问题和对偶问题的关系，KKT限制条件，KKT条件用哪些，完整描述；软间隔问题，解释支持向量、核函数（哪个地方引入、画图解释高维映射，高斯核可以升到多少维，如何选择核函数），引入拉格朗日的优化方法的原因，最大的特点，损失函数解释，SVM与LR最大区别，LR和SVM对于outlier的敏感程度分析，逻辑回归与SVM的区别为什么要把原问题转换为对偶问题？因为原问题是凸二次规划问题，转换为对偶问题更加高效。为什么求解对偶问题更加高效？因为只用求解alpha系数，而alpha系数只有支持向量才非0，其他全部为0.alpha系数有多少个？样本点的个数加大训练数据量一定能提高SVM准确率吗？与感知器的联系和优缺点比较如何解决多分类问题、可以做回归吗，怎么做它与其他分类器对比的优缺点，它的速度机器学习有很多关于核函数的说法，核函数的定义和作用是什么？https://www.zhihu.com/question/24627666支持向量机(SVM)是否适合大规模数据？https://www.zhihu.com/question/19591450SVM和逻辑斯特回归对同一样本A进行训练，如果某类中增加一些数据点，那么原来的决策边界分别会怎么变化？https://www.zhihu.com/question/30123068各种机器学习的应用场景分别是什么？例如，k近邻,贝叶斯，决策树，svm，逻辑斯蒂回归和最大熵模型。https://www.zhihu.com/question/26726794Linear SVM 和 LR 有什么异同？https://www.zhihu.com/question/26768865 LR12345678910111213141516LR推导（伯努利过程，极大似然，损失函数，梯度下降）有没有最优解？LR可以用核么？可以怎么用？l1和l2正则项是啥？lr加l1还是l2好？加哪个可以用核（加l2正则项，和svm类似，加l2正则项可以用核方便处理）LR可以用来处理非线性问题么？（还是lr啊 只不过是加了核的lr 这里加核是显式地把特征映射到高维 然后再做lr）怎么做？可以像SVM那样么？为什么？为什么LR需要归一化或者取对数，为什么LR把特征离散化后效果更好，为什么把特征组合之后还能提升，反正这些基本都是增强了特征的表达能力，或者说更容易线性可分吧美团技术团队《Logistic Regression 模型简介》https://tech.meituan.com/intro_to_logistic_regression.htmlSVM和logistic回归分别在什么情况下使用？https://www.zhihu.com/question/21704547逻辑斯蒂回归能否解决非线性分类问题？https://www.zhihu.com/question/29385169为什么LR可以用来做CTR预估？https://www.zhihu.com/question/23652394逻辑回归估计参数时的目标函数 （就是极大似然估计那部分），逻辑回归估计参数时的目标函数 （呵呵，第二次） 逻辑回归估计参数时的目标函数 如果加上一个先验的服从高斯分布的假设，会是什么样（天啦。我不知道，其实就是在后面乘一个东西，取log后就变成加一个东西，实际就变成一个正则项）逻辑回归估计参数时的目标函数逻辑回归的值表示概率吗？（值越大可能性越高，但不能说是概率）手推逻辑回归目标函数，正类是1，反类是-1，这里挖了个小坑，一般都是正例是1，反例是0的，他写的时候我就注意到这个坑了，然而写的太快又给忘了，衰，后来他提醒了一下，改了过来，就是极大似然函数的指数不一样，然后说我这里的面试就到这了。看没看过scikit-learn源码LR的实现？（回头看了一下是调用的liblinear，囧）为什么LR需要归一化或者取对数，为什么LR把特征离散化后效果更好，为什么把特征组合之后还能提升，反正这些基本都是增强了特征的表达能力，或者说更容易线性可分吧naive bayes和logistic regression的区别http://m.blog.csdn.net/blog/muye5/19409615LR为什么用sigmoid函数。这个函数有什么优点和缺点？为什么不用其他函数？sigmoid函数由那个指数族分布，加上二项分布导出来的。损失函数是由最大似然估计求出的。了解其他的分类模型吗，问LR缺点，LR怎么推导（当时我真没准备好，写不出来）写LR目标函数，目标函数怎么求最优解（也不会）讲讲LR的梯度下降，梯度下降有哪几种，逻辑函数是啥 L1和L212345678910111213L2正则化，为什么L2正则化可以防止过拟合？L1正则化是啥？深度学习里面怎么防止过拟合？（data aug；dropout；multi-task learning）如何防止过拟合，我跟他列举了4中主要防止过拟合方法：Early Stopping、数据集扩充、正则化法以及dropout，还详细跟他说了每种方法原理及使用的场景，并解释我在哪些项目里具体用到了这些方法，机器学习中使用「正则化来防止过拟合」到底是一个什么原理？为什么正则化项就可以防止过拟合？https://www.zhihu.com/question/20700829机器学习中常常提到的正则化到底是什么意思？https://www.zhihu.com/question/20924039什么是正则项，L1范式，L2范式区别是什么，各自用在什么地方？L1 与 L2 的区别以及如何解决 L1 求导困难；L1正则为什么能让系数变为0？L1正则怎么处理0点不可导的情形？（这个谁会？近端梯度下降）L0，L1，L2正则化(如果能推导绝对是加分项，一般人最多能画个等高线，L0是NP问题)其实上面的这些问题基本都能在《李航：统计学习方法》《周志华：机器学习》里面找到，能翻个4，5遍基本就无压力了避免过拟合策略、如何提高模型泛化能力、L1与L2正则区别，优缺点、生成式，判别式模型、深度学习这块了解多少、如何克服过拟合，欠拟合L1 与 L2 的区别以及如何解决 L1 求导困难；L1正则为什么可以把系数压缩成0，坐标下降法的具体实现细节为什么L1正则可以实现参数稀疏，而L2正则不可以？为什么L1很多系数可以被压缩为0，L2是被压缩至接近于0？树模型 决策树：1234567891011121314151617181920212223242526rf ， gbdt 的区别； gbdt ， xgboost 的区别（烂大街的问题最好从底层原理去分析回答）介绍决策树，谈了3种决策树及其区别和适应场景决策树处理连续值的方法；简单介绍决策树几种算法，有什么区别？决策树基本模型介绍？决策树算法中缺失值怎么处理？决策树算法在应用中有什么值得注意的地方。SVM、LR、决策树的对比？GBDT 和 决策森林 的区别？决策树的特性？（3 ）决策树处理连续值的方法；解释下随机森林和gbdt的区别。gbdt的boosting体现在哪里。解释下随机森林节点的分裂策略，以及它和gbdt做分类有什么区别？哪个效果更好些？为什么？哪个更容易过拟合？为什么？ 问了随机森林的损失函数，和lr的优缺点对比， adaboost和随机森林的比较，为了防止随机森林过拟合可以怎么做，是否用过随机森林，怎么用的。随机森林和GBDT的区别？CART（回归树用平方误差最小化准则，分类树用基尼指数最小化准则）GBDT（利用损失函数的负梯度在当前模型的值作为回归问题提升树算法中的残差的近似值，拟合一个回归树）随机森林（Bagging+CART）SVM与随机森林比较改变随机森林的训练样本数据量，是否会影响到随机森林学习到的模型的复杂度Logistics与随机森林比较GBDT与随机森林比较随机森林的学习过程；随机森林中的每一棵树是如何学习的；随机森林学习算法中CART树的基尼指数是什么？RF 与 GBDT 区别，原理优缺点适用场景分析，哪个具备交叉验证功能等接着写一下信息增益的公式。之后就是问机器学习相关算法，说了一下bagging跟boosting，之后问了GBDT（没做过，只能说说大体思路）。（2 ） rf ， gbdt 的区别； gbdt ， xgboost 的区别；说说xgboost、gbdt区别、Tree-based Model如何处理连续型特征。让我把一个完整的数据挖掘流程讲一下，从预处理，特征工程，到模型融合。介绍常用的算法，gbdt和xgboost区别，具体怎么做预处理，特征工程，模型融合常用方式，融合一定会提升吗？gbdt树根据什么分裂（瞎扯的梯度近似残差、梯度下降方向，其实还是信息增益这种东西）gbdt怎么并发（特征选择层面，树层面不能并发）介绍LR、RF、GBDT ，分析它们的优缺点，是否写过它们的分布式代码XGB和GBDT区别与联系也会经常问到：https://www.zhihu.com/question/41354392/answer/128008021?group_id=773629156532445184CART（回归树用平方误差最小化准则，分类树用基尼指数最小化准则）、Logistics（推导）、GBDT（利用损失函数的负梯度在当前模型的值作为回归问题提升树算法中的残差的近似值，拟合一个回归树）在面试过程中主动引导面试官提问，比如面试官让你讲解 gbdt 原理时，这会你可以跟他说，一般说起 gbdt ，我们都会跟 rf 以及 xgboost 一块讲，然后你就可以主动地向面试官输出你的知识；面试并不是死板地你问我答，而是一种沟通交流，所以尽可能地把面试转化成聊天式的对话，多输出自己一些有价值的观点而不是仅仅为了回答面试官的问题；几种树模型的原理和对比，特征选取怎么选？ 为什么信息增益可以用来选特征？信息熵和基尼指数的关系(信息熵在x=1处一阶泰勒展开就是基尼指数)介绍xgboost一下。写下xgboost目标函数。（因为我提到xgboost在目标函数里显式地加入了正则项..血雪崩）怎么调整XGB参数；xgboost原理 K-means1234567891011k-means 聚类的原理以及缺点及对应的改进；kmeans 算法的优缺点。。。。kmeans 的原理，优缺点以及改进；em 与 kmeans 的关系；kmeans 代码；说说 Kmeans 算法， Kmeans 算法 K 怎么设置、适用什么样数据集、怎么评价 Kmeans 聚类结果、 Kmeans 有什么优缺点？你的项目中使用 Kmeans 遇到哪些问题，怎么解决的 ?用 EM 算法推导解释 Kmeans。KMeans的算法伪代码如何判断自己实现的 LR、Kmeans 算法是否正确？如何优化kmeans算法如何用hadoop实现k-means手写k-means的伪代码（就6行） 集成学习123456bagging和boosting是怎么做的和他们的比较详细讨论了样本采样和bagging的问题聊的比较多的是如何知道一个特征的重要性，如何做ensemble哪些方法比较好。聊了聊计算广告方面FM，embedding。常见融合框架原理，优缺点，bagging，stacking，boosting，为什么融合能提升效果是否了解线性加权、bagging、boosting、cascade等模型融合方式K-means起始点http://www.cnki.com.cn/Article/CJFDTotal-DNZS200832067.htm 贝叶斯12345朴素贝叶斯分类器原理以及公式，出现估计概率值为 0 怎么处理（拉普拉斯平滑），缺点；解释贝叶斯公式和朴素贝叶斯分类。贝叶斯分类，这是一类分类方法，主要代表是朴素贝叶斯，朴素贝叶斯的原理，重点在假设各个属性类条件独立。然后能根据贝叶斯公式具体推导。考察给你一个问题，如何利用朴素贝叶斯分类去分类，比如：给你一个人的特征，判断是男是女，比如身高，体重，头发长度等特征的的数据，那么你要能推到这个过程。给出最后的分类器公式。那你说说贝叶斯怎么分类啊？比如说看看今天天气怎么样？我：blabla，，，利用天气的历史数据，可以知道天气类型的先验分布，以及每种类型下特征数据（比如天气数据的特征：温度啊，湿度啊）的条件分布，这样我们根据贝叶斯公式就能求得天气类型的后验分布了。。。。面试官：en（估计也比较满意吧）那你了解关于求解模型的优化方法吗？一般用什么优化方法来解？贝叶斯分类器的优化和特殊情况的处理 深度学习12345678910111213141516解释一下CNN、介绍CNN、卷积公式，以及特点，假设面试官什么都不懂，详细解释 CNN 的原理；问CNN的细节特点，哪些特点使得CNN这么好用，哪些场景用CNN可以，抽象一下这些场景的特征，可以降采样但仍能保持主要信息；局部连接可以保证获取局部信息；权值共享保证高效，DNN和CNN相比有哪些区别，用过RNN么？画一下RNN的图，你在深度学习过程中遇到过哪些问题？如果出现过拟合你怎么办？dropout是什么？它有什么用？你会怎么用它？当全连接跟dropout连着用需要注意什么？你之前过拟合怎么解决的？如果本身training loss就很大你怎么办？如果数据不变，怎么调整网络结构解决这个问题？（batch normalization）梯度消失知道么？为什么会出现梯度消失？dnn和rnn中的梯度消失原理一样么？dnn中是哪个部分导致梯度消失？（激活层如sigmoid）rnn中怎么解决梯度消失问题？（lstm的结构相对普通RNN多了加和，为避免梯度消散提供了可能。线性自连接的memory是关键。）讲一下CNN吧，有哪些重要的特点？CNN可以处理哪些场景？为什么CNN要用权值共享？（每个卷积核相当于一个特征提取器，它的任务是匹配局部图像中的特征，权值共享后，匹配的特征方式都是一样的，提取若干特征后就知道学习的是啥了）CNN里面哪些层？讲一下卷积。卷积的形式是啥样？给定一个输入，算输出的feature map大小。卷积有啥用？池化有啥用？有哪些池化方式？池化除了降采样还有啥用？（就不知道了）还有哪些层你用过？讲讲dropout。dropout内部是怎么实现只让部分信号通过并不更新其余部分对于输入的权值的？讲讲BN（BatchNormalization）为什么好？全连接有什么用处？知道RNN么？讲讲RNN大致的实现思路。知道梯度消失么？为什么会出现梯度消失？RNN里的梯度消失一般怎么处理？细讲下lstm的结构，这样设计为什么好？（门关闭，当前信息不需要，只有历史依赖；门打开，历史和当前加权平均）你觉得梯度消失靠引入一些新的激活层可以完全解决么？为什么？问了做的比赛里面使用tensorflow的细节，LSTM里调参的细节用过哪些库或者工具，mkl，cuda这些会用吗？有一个弱分类器和大量未被标记过的图像数据，如何人工标记图像来对分类器进行提升介绍下RNN和它的优缺点让我推导BP反向传播、随机梯度下降法权重更新公式卷积神经网络结构特点、各参数对模型结果影响、项目进展遇到的难题、推导BP神经网络参数更新方式、随机梯度下降法（SGD）优化函数存在的缺点以及拟牛顿法在优化函数使用上更有优势、修改Caffe开源框架、开源社区代码贡献量就跟我聊了很多行业发展趋势及问题，知道目前深度学习的一个趋势，也了解到最新行业发展动态，改进相机智能化程度，也聊到了美颜相机美颜效果以及小米相机人脸分类、年龄检测等等不足之处，了解到新兴行业大佬商汤科技和旷视科技（face++脸草）在研究的热门方向看到有deep learning相关的项目，就问了deep learning 相关问题：如何减少参数（权值共享、VGG的感受野、GoogLeNet的inception ），激活函数的选择（sigmoid-&gt;ReLu-&gt;LReLU-&gt;PReLU ），为什么之前没有深度网络出现（数据量不够+机器性能），由数据引申到数据不平衡怎么处理（10W正例，1W负例，牛客上有原题），后面问了下DNN原理，应用，瞎扯一通……你了解神经网络吗？我：了解一些，讲感知机，然后是BP网络。简单讲了一下原理。图像处理题：如何找相似图片。我说用感知哈希算法，计算汉明距离，他说这种方法精度不行；我说那就用SIFT算法吧，他说SIFT效果还可以，但计算有点繁重，有没有轻量级的方法？我想起来去年在美图秀秀实习时，曾经做过一种图像滤波算法，有一步是把像素点用K-means聚类。我就说先把图片灰度化，然后用K-means聚类，把聚类后的各个中心点作为一张图片的特征向量如果两张图片的特征向量相近则说明这两张图片相似。貌似我这个答案有点出乎他的意料，他意味深长地说了个“行吧~~~~”（个人觉得颜色直方图匹配是个他期待的常规回答）介绍卷积神经网络，和 DBN 有什么区别？Deep CNN, Deep RNN, RBM的典型应用与局限，看Hinton讲义和Paper去吧神经网络,plsi的推导验证码图片的去噪和提取字符有限状态自动机,然后要我画状态转移图. 聚类12用过哪些聚类算法，解释密度聚类算法。聚类算法中的距离度量有哪些？ 优化12345678梯度下降的优缺点；主要问最优化方面的知识，梯度下降法的原理以及各个变种（批量梯度下降，随机梯度下降法， mini 梯度下降法），以及这几个方法会不会有局部最优问题，牛顿法原理和适用场景，有什么缺点，如何改进（拟牛顿法）常用优化算法：1.梯度下降法：又有随机梯度下降和负梯度下降，2.牛顿法 主要是问了各自的优缺点，速度，能不能得到全局最优解，牛顿法的二次收敛等问你如果有若干个极小值点，如何避免陷入局部最优解。它们间的牛顿学习法、SGD如何训练，如何判断函数凸或非凸？线性回归的梯度下降和牛顿法求解公式的推导最速下降法和共轭梯度法 wolfe条件 最速下降法和共轭梯度法的收敛速度如何判断深刻理解常用的优化方法：梯度下降、牛顿法、各种随机搜索算法（基因、蚁群等等），深刻理解的意思是你要知道梯度下降是用平面来逼近局部，牛顿法是用曲面逼近局部等等。 推荐系统12345678910介绍SVD、SVD++推荐系统的冷启动问题如何解决深度学习在推荐系统上可能有怎样的发挥？推荐系统的算法中最近邻和矩阵分解各自适用场景白板写SVD/SVD++公式，SGD迭代更新p，q矩阵公式，SVD/SVD++优化方法对推荐算法的未来看法；用过什么算法？最好是在项目/实习的大数据场景里用过，比如推荐里用过 CF、LR，我面的推荐，问了各类协同过滤的好与坏。问了一个很有意思的问题，现实应用中的Top-N推荐问题和学术研究中的评分预测问题之间有什么不同。问我ItemCF的工程实现，面对大数据如何实现，又追问了有没有什么工程优化算法。这个问题我没答好，一开始我说了一个MapReduce模型，他问能不能更快一点，我就卡那了。。。最后面试官告诉我，不能只从算法角度分析，要从系统设计分析，利用内存来减小MapReduce的吞吐量。（当然也许从MapReduce那一刻开始我就输了也不一定）推荐系统的算法中最近邻和矩阵分解各自适用场景http://www.doc88.com/p-3961053026557.html PCA12那你对pca了解吗？我：了解啊，面试官：那讲一下pca是用来干嘛的？我：pca啊，可以用来分析主方向啊，降维啊，特征筛选啊，具体方法是用svd分解得到特征值矩阵和特征向量矩阵，然后根据不同的任务对选择特征值或向量进行计算。 EM1采用 EM 算法求解的模型有哪些，为什么不用牛顿法或梯度下降法？ NLP12345用过哪些 NLP 算法项目中用过哪些机器学习算法。海量的 item 算文本相似度的优化方法；解释 word2vec 的原理以及哈夫曼树的改进；word2vec的原理二面面试官主要跟我聊简历上的几个项目，他好像不能理解词向量的形式，反复解释了很多遍，问的问题都比较简单，有TF-IDF,余弦相似度，分词工具等等。然后我说我做过LDA，问我，Dirichlet Distribution的定义和性质，并问我，为什么它和multinomial distribution是共轭的，顺便问了我啥叫共轭分布。 关联分析：1项目中涉及到频繁模式挖掘，于是问了一下如何实现的？ 用的是 Apriori算法，描述他的原理过程，关键字眼：支持度，支持度计数，k项候选频繁项集，怎么从k项到k+1项等，连接剪枝过程。 hadoop12345678简单介绍 MapReduce 原理，有没有看过源码，说说 Map 阶段怎么实现的,MapReduce 实现统计出现次数最多的前 100 个访问 IP.MapReduce 实现统计不重复用户 ID,MapReduce 实现两个数据集求交集。HBase 行健怎么设计,spark 性能一般优化方法,spark streaming 和 storm 区别.给了一张笔试题， 10 道选择，一道大题。选择题是 java 基础知识，大题一个有三问：根据场景写出 Hive 建表语句； Hsql 从表中查询；用MapReduce写好友推荐，在一堆单词里面找出现次数最多的k个用分布式的方法做采样怎么保证采样结果完全符合预期？后面又问了Hadoop,Spark,storm下面的产品，原理，适用场景，写一个 Hadoop 版本的 wordcount。 HMM1234567891011121314151617181920212223242526272829实现 hmm 的状态转移代码；机器学习理论讲机器学习中常用的损失函数有哪些？交叉熵有什么好处？（凸优化问题）判别模型与生成模型的本质区别是什么分类模型和回归模型的区别，分类模型可以做回归分析吗？反过来可以吗？（我回答是分类不可以做回归，回归倒是可以做分类，不知道对不对）k折交叉验证 中k取值多少有什么关系 （我不知道，随便答，然后面试官后面问我知道bias和variance吗？估计是和这两个东西有关， 知乎上有个问题讨论了k值大小与bias和variance的关系）解释局部相关性特征选择的方法；在模型的训练迭代中，怎么评估效果；特征选择方法有哪些(能说出来10种以上加分)，之后和面试官仔细聊了一下特征选择的问题，我介绍了了解的几种基本的特征选择思路（错误率选择、基于熵的选择、类内类间距离的选择）；有没有接触过机器学习的前沿，深度学习看过paper没有？（并没有）如何用尽可能少的样本训练模型同时又保证模型的性能；你读哪些期刊会议的论文？你遇到的比较有意思的算法？生成模型，判别模型线性分类和非线性分类各有哪些模型比较各个模型的Loss function，设计一个结构存取稀疏矩阵 （面试官最后告诉我了一个极度压缩的存法，相同行或列存偏差，我当时没听懂，还不懂装懂，最后还是没记住）PageRank原理，怎么用模型来查找异常用户，我讲了一大堆我的理解，然后面试官一句你怎么不用规则把我噎到了……无监督和有监督算法的区别？经典算法推导(加分项)，原理，各个损失函数之间区别，使用场景，如何并行化，有哪些关键参数什么叫判别模型什么叫生成模型。先针对项目十分细致地询问了各种细节，然后就问我如何处理数据中的噪声点、数据清洗算法（正好自己做了一个算法）、如何选择特征等。校招TST内推，面过了2面，还是跟之前那个有点类似的游戏开发的安全部门，因为我也玩LOL，又问到怎么来判断玩家有没有作弊之类的问题，这次我小心翼翼的说用模型怎么做，用规则怎么做，感觉这次聊的都挺开心的。是否了解A/B Test以及A/B Test结果的置信度特征工程经验是否了解mutual infomation、chi-square、LR前后向、树模型等特征选择方式深刻理解各种算法对应采用的数据结构和对应的搜索方法。比如KNN对应的KD树、如何给图结构设计数据结构？如何将算法map-red化矩阵的各种变换，尤其是特征值相关的知识。分布式的矩阵向量乘的算法线性分类器与非线性分类器的区别及优劣；特征比数据量还大时，选择什么样的分类器？对于维度很高的特征，你是选择线性还是非线性分类器？对于维度极低的特征，你是选择线性还是非线性分类器？如何解决过拟合问题？L1和L2正则的区别，如何选择L1和L2正则？项目中的数据是否会归一化处理，哪个机器学习算法不需要归一化处理并行计算、压缩算法LDA http://www.doc88.com/p-1621945750499.html]]></content>
      <tags>
        <tag>笔面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习_分类_KNN_EM]]></title>
    <url>%2F2018%2F07%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_KNN_EM%2F</url>
    <content type="text"><![CDATA[机器学习_分类_KNN_EM K最近邻(kNN，k-NearestNeighbor)分类算法在KNN中，通过计算对象间距离来作为各个对象之间的非相似性指标，避免了对象之间的匹配问题，在这里距离一般使用欧氏距离或曼哈顿距离： 123456789101112步骤：其算法的描述为：1）计算测试数据与各个训练数据之间的距离；2）按照距离的递增关系进行排序；3）选取距离最小的K个点；4）确定前K个点所在类别的出现频率；5）返回前K个点中出现频率最高的类别作为测试数据的预测分类。 KNN算法的优点：123451）简单、有效。 2）重新训练的代价较低（类别体系的变化和训练集的变化，在Web环境和电子商务应用中是很常见的）。 3）计算时间和空间线性于训练集的规模（在一些场合不算太大）。 4）由于KNN方法主要靠周围有限的邻近的样本，而不是靠判别类域的方法来确定所属类别的，因此对于类域的交叉或重叠较多的待分样本集来说，KNN方法较其他方法更为适合。 5）该算法比较适用于样本容量比较大的类域的自动分类，而那些样本容量较小的类域采用这种算法比较容易产生误分。 KNN算法缺点： 123451）KNN算法是懒散学习方法（lazy learning,基本上不学习），一些积极学习的算法要快很多。 2）类别评分不是规格化的（不像概率评分）。 3）输出的可解释性不强，例如决策树的可解释性较强。 4）该算法在分类时有个主要的不足是，当样本不平衡时，如一个类的样本容量很大，而其他类样本容量很小时，有可能导致当输入一个新样本时，该样本的K个邻居中大容量类的样本占多数。该算法只计算“最近的”邻居样本，某一类的样本数量很大，那么或者这类样本并不接近目标样本，或者这类样本很靠近目标样本。无论怎样，数量并不能影响运行结果。可以采用权值的方法（和该样本距离小的邻居权值大）来改进。 5）计算量较大。目前常用的解决方法是事先对已知样本点进行剪辑，事先去除对分类作用不大的样本。 EM算法EM的策略就是先随便给一个条件概率p1(x1|thera)，然后找到一个l(thera)的下界函数r(x1|thera),求r的最大值p2(x2|thera)，再找到经过p2点的下界函数r2(x2|thera)，重复该过程直到收敛到局部最大值。 灰度图分割：参考 point.h文件1234567891011#ifndef POINT_H#define POINT_H//point结构主要用来存储图像中节点的横坐标，纵坐标以及灰度值struct point&#123; int row; int col; double pixVal; point(int row, int col, double pixVal) :row(row),col(col),pixVal(pixVal) &#123;&#125;&#125;;#endif keams.h头文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#ifndef KMEANS_H#define KMEANS_H#include&lt;opencv2\opencv.hpp&gt;#include&lt;random&gt;#include&lt;time.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;list&gt;#include&lt;iostream&gt;#include&lt;math.h&gt;#include&quot;point.h&quot;using namespace cv;using namespace std;class Kmeans&#123;private: //存储所有点 vector&lt;point&gt; points; //存储簇的中心点 vector&lt;point&gt; centers; //存储每个点到相应的簇 vector&lt;point&gt;* clusters; //向量的维数 int dimension; //簇的个数 int k;public: //构造函数 Kmeans(vector&lt;point&gt; points, vector&lt;point&gt; centers, int k, int dimension) &#123; this-&gt;points = points; this-&gt;centers = centers; this-&gt;dimension = dimension; this-&gt;k = k; clusters = new vector&lt;point&gt;[k]; &#125; //析构函数 ~Kmeans() &#123; delete clusters; &#125; //获取簇 vector&lt;point&gt;* getClusters() &#123; return this-&gt;clusters; &#125; //计算两个向量之间的欧式距离 double getDistanceBetweenTwoPoints(const point&amp; point1, const point&amp; point2) &#123; double sum = 0; //double tmp; //for (int i = 0; i &lt; dimension; i++) //&#123; //tmp = pow(point1.pixVal - point2.pixVal,2); //sum += tmp; //&#125; sum = pow(point1.pixVal - point2.pixVal, 2); return sqrt(sum); &#125; //计算每个点到离它最近的簇中心点，结果保存到vector中 vector&lt;int&gt; getClosetClusterCenterLabel() &#123; double min; int label; vector&lt;int&gt; labels; for (int i = 0; i &lt; points.size(); i++) &#123; label = 0; min = getDistanceBetweenTwoPoints(points[i], centers[0]); for (int j = 1; j &lt; centers.size(); j++) &#123; double tmp = getDistanceBetweenTwoPoints(points[i], centers[j]); if (tmp &lt; min) &#123; min = tmp; label = j; &#125; &#125; labels.push_back(label); &#125; return labels; &#125; //将每个点放入它离的最近的中心点对应的簇中 void computeClusters(const vector&lt;int&gt;&amp; labels) &#123; for (int i = 0; i &lt; k; i++) &#123; clusters[i].clear(); &#125; for (int i = 0; i &lt; labels.size(); i++) &#123; int label = labels[i]; clusters[label].push_back(points[i]); &#125; &#125; //重新计算所有簇的中心点的灰度值 void computeCenters() &#123; centers.clear(); for (int i = 0; i &lt; k; i++) &#123; double sum = 0; for (int j = 0; j &lt; clusters[i].size(); j++) &#123; sum += clusters[i][j].pixVal; &#125; double meanVal = sum / clusters[i].size(); point cp(-1, -1, meanVal); centers.push_back(cp); &#125; &#125; //确定新的中心点后重新计算一次cost double computeCost() &#123; double sum = 0; for (int i = 0; i &lt; k; i++) &#123; vector&lt;point&gt; tmpVec=clusters[i]; for (int j = 0; j &lt; tmpVec.size(); j++) &#123; sum += getDistanceBetweenTwoPoints(tmpVec[j], centers[i]); &#125; &#125; return sum / points.size(); &#125; //迭代执行k-means算法的步骤 void kmeans() &#123; double oldCost, newCost; vector&lt;int&gt; labels=getClosetClusterCenterLabel(); computeClusters(labels); newCost = computeCost(); computeCenters(); labels = getClosetClusterCenterLabel(); computeClusters(labels); oldCost = newCost; newCost = computeCost(); while (oldCost != newCost) &#123; oldCost = newCost; computeCenters(); labels = getClosetClusterCenterLabel(); computeClusters(labels); newCost = computeCost(); &#125; cout &lt;&lt;&quot;Final Cost: &quot;&lt;&lt; newCost &lt;&lt; endl; &#125;&#125;;#endif 测试的kmeans.cpp文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &quot;kmeans.h&quot;//图片的存放位置const String imageFolder = &quot;F:\\&quot;;//簇的个数（即k的大小，根据自己需要调整）const int numOfCluster =4;//最大像素值const int MAX_PIX_VALUE = 255;//存放所有点vector&lt;point&gt; points;//存放所有簇中心vector&lt;point&gt; centers;//存放所有点颜色特征(i,j)-&gt;i*rows+jvector&lt;double&gt; pixVec;//读取图像Mat readImage(String imageName)&#123; String imageLoc = imageFolder + imageName; Mat image=imread(imageLoc); return image;&#125;//初始化k-means聚类中心void initializeCenters(const Mat&amp; img)&#123; srand((unsigned)time(NULL)); for (int i = 0; i &lt; numOfCluster; i++) &#123; int randomX = rand() % img.rows; int randomY = rand() % img.cols; uchar pixVal = img.at&lt;uchar&gt;(randomX, randomY); point cp(randomX, randomY, (double)pixVal); centers.push_back(cp); &#125;&#125;//将图像中的所有点装入points中void initializePoints(const Mat&amp; img)&#123; for (int i = 0; i &lt; img.rows; i++) &#123; const uchar* data = img.ptr&lt;uchar&gt;(i); for (int j = 0; j &lt; img.cols; j++) &#123; uchar pixVal = data[j]; point p(i,j, (double)pixVal); points.push_back(p); &#125; &#125;&#125;int main()&#123; String imageName = &quot;lena.jpg&quot;; Mat img = readImage(imageName); cvtColor(img, img, CV_RGB2GRAY);//转化为灰度图像 namedWindow(imageName,WINDOW_NORMAL); imshow(imageName, img); waitKey(0); int rows = img.rows; int cols = img.cols; initializeCenters(img); initializePoints(img); Kmeans* km=new Kmeans(points, centers, numOfCluster, 1); cout &lt;&lt; &quot;---------------k-means start-------------&quot; &lt;&lt; endl; km-&gt;kmeans(); cout &lt;&lt; &quot;---------------k-means end---------------&quot; &lt;&lt;endl; vector&lt;point&gt;* clusters = km-&gt;getClusters(); Mat res(img.rows,img.cols,img.type()); double div = MAX_PIX_VALUE / numOfCluster; for (int i = 0; i &lt; numOfCluster; i++) &#123; vector&lt;point&gt; tmpVec = clusters[i]; for (int j = 0; j &lt; tmpVec.size(); j++) &#123; res.at&lt;uchar&gt;(tmpVec[j].row, tmpVec[j].col) = i*div; &#125; &#125; namedWindow(&quot;kmeansResult&quot;,WINDOW_NORMAL); imshow(&quot;kmeansResult&quot;, res); waitKey(0); imwrite(&quot;./segment_lena.jpg&quot;, res); system(&quot;pause&quot;);&#125; 彩色图像分割：参考 主函数：123456789101112131415161718192021222324252627282930#include &quot;clusterImagePixels.hpp&quot; int main()&#123; Mat testImage = imread(&quot;E:\\testImage\\board.jpg&quot;); if (testImage.empty()) &#123; return -1; &#125; ClusterPixels clusterPix(testImage,3); Mat colorResults = clusterPix.clusterColorImageByKmeans(); Mat grayResult = clusterPix.clusterGrayImageByKmeans(); if (!colorResults.empty()) &#123; hconcat(testImage, colorResults, colorResults); imshow(&quot;clusterImage&quot;, colorResults); &#125; if (!grayResult.empty()) &#123; hconcat(testImage, grayResult, grayResult); imshow(&quot;grayCluster&quot;, grayResult); &#125; if (waitKey() == 27) return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;opencv.hpp&gt;using namespace cv; Scalar colorTab[] = //10个颜色&#123; Scalar(0, 0, 255), Scalar(0, 255, 0), Scalar(255, 100, 100), Scalar(255, 0, 255), Scalar(0, 255, 255), Scalar(255, 0, 0), Scalar(255, 255, 0), Scalar(255, 0, 100), Scalar(100, 100, 100), Scalar(50, 125, 125)&#125;; class ClusterPixels&#123;private: Mat image; //待聚类图像 Mat labels; //聚类后的标签 int clusterCounts; //分类数,不得大于10，只是颜色定义只有10类，并不是算法限制 public: ClusterPixels() :clusterCounts(0)&#123;&#125; ClusterPixels(const Mat&amp; src, int clusters = 5) :clusterCounts(clusters)&#123; image = src.clone(); &#125; void setImage(const Mat&amp; src)&#123; image = src.clone(); &#125;; void setClusters(int clusters)&#123; clusterCounts = clusters; &#125; Mat getLabels() &#123;return labels; &#125;; //返回聚类后的标签 Mat clusterGrayImageByKmeans() &#123; //转换成灰度图 if (image.channels() != 1) cvtColor(image, image, COLOR_BGR2GRAY); int rows = image.rows; int cols = image.cols; //保存聚类后的图片 Mat clusteredMat(rows, cols, CV_8UC3); clusteredMat.setTo(Scalar::all(0)); Mat pixels(rows*cols, 1, CV_32FC1); //pixels用于保存所有的灰度像素 for (int i = 0; i &lt; rows;++i) &#123; const uchar *idata = image.ptr&lt;uchar&gt;(i); float *pdata = pixels.ptr&lt;float&gt;(0); for (int j = 0; j &lt; cols;++j) &#123; pdata[i*cols + j] = idata[j]; &#125; &#125; kmeans(pixels, clusterCounts, labels, TermCriteria(TermCriteria::EPS + TermCriteria::MAX_ITER, 10, 0), 5, KMEANS_PP_CENTERS); for (int i = 0; i &lt; rows;++i) &#123; for (int j = 0; j &lt; cols;++j) &#123; circle(clusteredMat, Point(j,i), 1, colorTab[labels.at&lt;int&gt;(i*cols + j)]); //标记像素点的类别，颜色区分 &#125; &#125; return clusteredMat; &#125; Mat clusterColorImageByKmeans() &#123; assert(image.channels() != 1); int rows = image.rows; int cols = image.cols; int channels = image.channels(); //保存聚类后的图片 Mat clusteredMat(rows, cols, CV_8UC3); clusteredMat.setTo(Scalar::all(0)); Mat pixels(rows*cols, 1, CV_32FC3); //pixels用于保存所有的灰度像素 pixels.setTo(Scalar::all(0)); for (int i = 0; i &lt; rows; ++i) &#123; const uchar *idata = image.ptr&lt;uchar&gt;(i); float *pdata = pixels.ptr&lt;float&gt;(0); for (int j = 0; j &lt; cols*channels; ++j) &#123; pdata[i*cols*channels + j] = saturate_cast&lt;float&gt;(idata[j]); &#125; &#125; kmeans(pixels, clusterCounts, labels, TermCriteria(CV_TERMCRIT_EPS + CV_TERMCRIT_ITER, 10, 0), 5, KMEANS_PP_CENTERS); for (int i = 0; i &lt; rows; ++i) &#123; for (int j = 0; j &lt; cols*channels; j += channels) &#123; circle(clusteredMat, Point(j/channels,i), 1, colorTab[labels.at&lt;int&gt;(i*cols + (j/channels))]); //标记像素点的类别，颜色区分 &#125; &#125; return clusteredMat; &#125;&#125;; opencv3代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &quot;stdafx.h&quot;#include &quot;opencv2\opencv.hpp&quot;#include &lt;iostream&gt;using namespace std;using namespace cv;using namespace cv::ml;int main()&#123; Mat img = imread(&quot;E:/opencv/opencv/sources/samples/data/digits.png&quot;); Mat gray; cvtColor(img, gray, CV_BGR2GRAY); int b = 20; int m = gray.rows / b; //原图为1000*2000 int n = gray.cols / b; //裁剪为5000个20*20的小图块 Mat data,labels; //特征矩阵 for (int i = 0; i &lt; n; i++) &#123; int offsetCol = i*b; //列上的偏移量 for (int j = 0; j &lt; m; j++) &#123; int offsetRow = j*b; //行上的偏移量 //截取20*20的小块 Mat tmp; gray(Range(offsetRow, offsetRow + b), Range(offsetCol, offsetCol + b)).copyTo(tmp); data.push_back(tmp.reshape(0,1)); //序列化后放入特征矩阵 labels.push_back((int)j / 5); //对应的标注 &#125; &#125; data.convertTo(data, CV_32F); //uchar型转换为cv_32f int samplesNum = data.rows; int trainNum = 3000; Mat trainData, trainLabels; trainData = data(Range(0, trainNum), Range::all()); //前3000个样本为训练数据 trainLabels = labels(Range(0, trainNum), Range::all()); //使用KNN算法 int K = 5; Ptr&lt;TrainData&gt; tData = TrainData::create(trainData, ROW_SAMPLE, trainLabels); Ptr&lt;KNearest&gt; model = KNearest::create(); model-&gt;setDefaultK(K); model-&gt;setIsClassifier(true); model-&gt;train(tData); //预测分类 double train_hr = 0, test_hr = 0; Mat response; // compute prediction error on train and test data for (int i = 0; i &lt; samplesNum; i++) &#123; Mat sample = data.row(i); float r = model-&gt;predict(sample); //对所有行进行预测 //预测结果与原结果相比，相等为1，不等为0 r = std::abs(r - labels.at&lt;int&gt;(i)) &lt;= FLT_EPSILON ? 1.f : 0.f; if (i &lt; trainNum) train_hr += r; //累积正确数 else test_hr += r; &#125; test_hr /= samplesNum - trainNum; train_hr = trainNum &gt; 0 ? train_hr / trainNum : 1.; printf(&quot;accuracy: train = %.1f%%, test = %.1f%%\n&quot;, train_hr*100., test_hr*100.); waitKey(0); return 0;&#125;]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++图像处理程序]]></title>
    <url>%2F2018%2F07%2F19%2FCImageProcess1%2F</url>
    <content type="text"><![CDATA[C++图像处理程序 C++开源项目： Boost.GIL：通用图像库CImg ：用于图像处理的小型开源C++工具包CxImage ：用于加载，保存，显示和转换的图像处理和转换库，可以处理的图片格式包括 BMP, JPEG, GIF, PNG, TIFF, MNG, ICO, PCX, TGA, WMF, WBMP, JBG, J2K。FreeImage ：开源库，支持现在多媒体应用所需的通用图片格式和其他格式。GDCM：Grassroots DICOM 库ITK：跨平台的开源图像分析系统Magick++：ImageMagick程序的C++接口MagickWnd：ImageMagick程序的C++接口OpenCV ： 开源计算机视觉类库tesseract-ocr：OCR引擎VIGRA ：用于图像分析通用C++计算机视觉库VTK ：用于3D计算机图形学，图像处理和可视化的开源免费软件系统。 MakegGray 彩色转灰度函数名称：MakegGray()函数类型：void功能：真彩色转化成256色灰度图像。123456789101112131415161718192021222324252627282930void MakeColorDib::MakegGray() //灰度变化&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 for(int j=0;j&lt;height;j++) // 每行 for(int i=0;i&lt;DibWidth;i+=3) // 每列 &#123; BYTE* pbyBlue = p_data++; //得到蓝色值 BYTE* pbyGreen = p_data++; //得到绿色值 BYTE* pbyRed = p_data++; //得到红色值 BYTE r = *pbyRed; BYTE g = *pbyGreen; BYTE b = *pbyBlue; //取到原r,g,b中的最大值作为像素三分量值的新值 int gray=0; if(r&gt;g) gray=r; else gray=g; if(gray&lt;b) gray=b; *pbyBlue = gray; //将取到的最大值赋给像素的蓝分量 *pbyGreen = gray; //将取到的最大值赋给像素的绿分量 *pbyRed = gray; //将取到的最大值赋给像素的红分量 &#125;&#125; LightAlter 亮度调整函数名称：LightAlter(int m_Light)函数类型：void参数：int m_Light，用户给定的阈值功能：对图像使用阈值法进行亮度调整 12345678910111213141516171819202122void MakeColorDib::LightAlter(int m_Light) //亮度调整&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 for(int j=0;j&lt;height;j++) // 每行 for(int i=0;i&lt;DibWidth;i++) // 每列 &#123; int a=0; a=int(*p_data*m_Light/100); //调整当前点的亮度 *p_data=a; //判断范围，取得合理的值 if(a&lt;0) *p_data=0; if(a&gt;255) *p_data=255; p_data++; //指向下一指针 &#125;&#125; LightReverse 亮度取反函数名称：LightReverse()函数类型：void功能：图像的亮度取反。12345678910111213141516void MakeColorDib::LightReverse() //亮度取反&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 for(int j=0;j&lt;height;j++) // 每行 for(int i=0;i&lt;DibWidth;i++) // 每列 &#123; int a=*p_data; //取得当前点的值 *p_data=255-a; //取反 p_data++; //指向下一指针 &#125;&#125; ContrastAlter 调整对比度（阈值法）函数名称：ContrastAlter(int m_Increment)函数类型：void参数：int m_Increment，用户给定的阈值功能：对图像使用阈值法调整对比度处理。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071void MakeColorDib::ContrastAlter(int m_Increment) ///对比度处理&#123; int nHigh = 255 - m_Increment; //对于极端情况加以处理 if(nHigh &lt; m_Increment) &#123; nHigh = 127; m_Increment = 120; &#125; if(m_Increment &lt; -127) m_Increment = -120; //扩展或压缩区间的长度 int nStretch = 255; if(m_Increment &gt;= 0) nStretch = 255 - 2 * m_Increment; else nStretch = 255 + 2 * m_Increment; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 if(m_Increment &gt;= 0) // m_Increment&gt;=0时 &#123; for(int j=0;j&lt;height;j++) // 每行 for(int i=0;i&lt;DibWidth-3;i+=3) // 每列 &#123; //取得当前点（蓝色）的值，调整 BYTE* pbyBlue = p_data++; if(*pbyBlue&lt;=m_Increment) *pbyBlue=0; else if(*pbyBlue&gt;nHigh) *pbyBlue=255; else *pbyBlue=(BYTE)((((int)*pbyBlue - m_Increment) * 255) / nStretch ); //取得当前点（绿色）的值，调整 BYTE* pbyGreen = p_data++; if(*pbyGreen&lt;=m_Increment) *pbyGreen=0; else if(*pbyGreen&gt;nHigh) *pbyGreen=255; else *pbyGreen=(BYTE)((((int)*pbyGreen - m_Increment) * 255) / nStretch ); //取得当前点（红色）的值，调整 BYTE* pbyRed = p_data++; if(*pbyRed&lt;=m_Increment) *pbyRed=0; else if(*pbyRed&gt;nHigh) *pbyRed=255; else *pbyRed=(BYTE)((((int)*pbyRed - m_Increment) * 255) / nStretch ); &#125; &#125; else // m_Increment &lt; 0 时 &#123; for(int j=0;j&lt;height;j++) for(int i=0;i&lt;DibWidth-3;i+=3) &#123; //取得当前点（蓝色）的值，调整 BYTE* pbyBlue = p_data++; *pbyBlue = (BYTE)((((int)(*pbyBlue) * nStretch) / 255) - m_Increment); //取得当前点（红色）的值，调整 BYTE* pbyGreen = p_data++; *pbyGreen = (BYTE)((((int)(*pbyGreen) * nStretch) / 255) - m_Increment); //取得当前点（红色）的值，调整 BYTE* pbyRed = p_data++; *pbyRed = (BYTE)((((int)(*pbyRed) * nStretch) / 255) - m_Increment); &#125; &#125;&#125; Exposal 曝光处理函数名称：Exposal()函数类型：void功能：图像曝光处理。1234567891011121314151617void MakeColorDib::Exposal() //曝光处理&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 for(int j=0;j&lt;height;j++) // 每行 for(int i=0;i&lt;DibWidth;i++) // 每列 &#123; BYTE* pbydata = p_data++; //取得当前点的值 BYTE a=*pbydata; //传给临时变量 *pbydata=(a&gt;128)?a:(255-a); //调整 &#125; &#125; PaintColor 着色处理（阈值法）函数名称：PaintColor(int m_Red,int m_Green,int m_Blue)函数类型：void参数：int m_Red、m_Green、m_Blue，用户给定的红绿蓝值功能：对图像使用阈值法进行着色处理。1234567891011121314151617181920212223void MakeColorDib::PaintColor(int m_Red,int m_Green,int m_Blue) //着色处理&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 for(int j=0;j&lt;height;j++) // 每行 for(int i=0;i&lt;DibWidth;i+=3) // 每列 &#123; BYTE* pbyBlue = p_data++; //取得当前点（蓝色）的值 BYTE* pbyGreen = p_data++; //取得当前点（绿色）的值 BYTE* pbyRed = p_data++; //取得当前点（红色）的值 BYTE r = *pbyRed; BYTE g = *pbyGreen; BYTE b = *pbyBlue; BYTE gray=(BYTE)(((WORD)r * 59 + (WORD)g * 30 + (WORD)b * 11) / 100); *pbyBlue = (BYTE)((m_Blue * gray) / 255); *pbyGreen = (BYTE)((m_Green * gray) / 255); *pbyRed = (BYTE)((m_Red * gray) / 255); &#125;&#125; NeonLight 霓虹处理函数名称：NeonLight()函数类型：void功能：使图像产生霓虹处理效果。123456789101112131415161718192021222324252627282930void MakeColorDib::NeonLight() //霓虹处理&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像 for(int j=0;j&lt;height-4;j++) // 每行 &#123; for(int i=0;i&lt;DibWidth-1;i++) // 每列 &#123; int pby_pt=0; //对像素执行算法 pby_pt=(*(p_data+(height-j-1)*DibWidth+i)-*(p_data+(height-j-1)*DibWidth+i+3)) *(*(p_data+(height-j-1)*DibWidth+i)-*(p_data+(height-j-1)*DibWidth+i+3)) +(*(p_data+(height-j-1)*DibWidth+i)-*(p_data+(height-j-2)*DibWidth+i)) *(*(p_data+(height-j-1)*DibWidth+i)-*(p_data+(height-j-2)*DibWidth+i)); *(p_temp+(height-j-1)*DibWidth+i)=2*int(sqrt(pby_pt)); //判断合法性 if(*(p_temp+(height-j-1)*DibWidth+i)&lt;0) *(p_temp+(height-j-1)*DibWidth+i)=0; if(*(p_temp+(height-j-1)*DibWidth+i)&gt;255) *(p_temp+(height-j-1)*DibWidth+i)=255; &#125; &#125; memcpy(p_data,p_temp,height*DibWidth); // 复制处理后的图像 delete []p_temp; //删除暂时分配内存&#125; Smoothness 平滑处理函数名称：Smoothness()函数类型：void功能：使图像平滑处理。123456789101112131415161718192021222324252627282930313233343536void MakeColorDib::Smoothness() //平滑处理&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 int h[3][3];////定义(3x3)矩阵 h[0][0] = 1; h[0][1] = 1; h[0][2] = 1; h[1][0] = 1; h[1][1] = 1; h[1][2] = 1; h[2][0] = 1; h[2][1] = 1; h[2][2] = 1; BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像 for(int j=0;j&lt;height-2;j++) // 每行 &#123; for(int i=0;i&lt;DibWidth-8;i++) // 每列 &#123; double pby_pt=0; //对应的第0行的值乘以矩阵对应值，再相加 pby_pt= h[0][0]*(*(p_data+(height-j-1)*DibWidth+i)) +h[0][1]*(*(p_data+(height-j-1)*DibWidth+i+3)) +h[0][2]*(*(p_data+(height-j-1)*DibWidth+i+6)) //对应的第1行的值乘以矩阵对应值，再相加 +h[1][0]*(*(p_data+(height-j-2)*DibWidth+i)) +h[1][1]*(*(p_data+(height-j-2)*DibWidth+i+3)) +h[1][2]*(*(p_data+(height-j-2)*DibWidth+i+6)) //对应的第2行的值乘以矩阵对应值，再相加 +h[2][0]*(*(p_data+(height-j-3)*DibWidth+i)) +h[2][1]*(*(p_data+(height-j-3)*DibWidth+i+3)) +h[2][2]*(*(p_data+(height-j-3)*DibWidth+i+6)); *(p_temp+(height-j-2)*DibWidth+i+3)=abs(int(pby_pt/9));//取总和的的平均值 &#125; &#125; memcpy(p_data,p_temp,height*DibWidth); // 复制处理后的图像 delete []p_temp;//删除暂时分配内存&#125; Embossment 浮雕处理函数名称：Embossment()函数类型：void功能：产生图像浮雕处理效果。12345678910111213141516171819202122232425262728void MakeColorDib::Embossment() //浮雕处理&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像 for(int j=0;j&lt;height;j++) // 每行 &#123; for(int i=0;i&lt;DibWidth-4;i++) // 每列 &#123; int pby_pt=0; //对像素得每个分量执行算法 pby_pt=*(p_data+(height-j-1)*DibWidth+i) -*(p_data+(height-j-1)*DibWidth+i+3)+128; *(p_temp+(height-j-1)*DibWidth+i+3)=pby_pt; //检验合法性 if(*(p_temp+(height-j-1)*DibWidth+i+3)&lt;0) *(p_temp+(height-j-1)*DibWidth+i+3)=0; else if(*(p_temp+(height-j-1)*DibWidth+i+3)&gt;255) *(p_temp+(height-j-1)*DibWidth+i+3)=255; &#125; &#125; memcpy(p_data,p_temp,height*DibWidth); // 复制处理后的图像 delete []p_temp; //删除暂时分配内存&#125; Spread 图像扩散函数名称：Spread()函数类型：void功能：图像扩散处理。123456789101112131415161718192021222324void MakeColorDib::Spread() //扩散处理&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像 for(int j=0;j&lt;height-4;j++) // 每行 &#123; for(int i=0;i&lt;DibWidth-14;i++) // 每列 &#123; int m=0,n=0; m=rand()%5; //取得行随机数 n=rand()%5; //取得列随机数 int pby_pt=0; pby_pt=*(p_data+(height-j-1-m)*DibWidth+i+3*n);//得到对应随机像素值 *(p_temp+(height-j-3)*DibWidth+i+6)=pby_pt; &#125; &#125; memcpy(p_data,p_temp,height*DibWidth); // 复制处理后的图像 delete []p_temp; //删除暂时分配内存&#125; Sharp 锐化函数名称：Sharp()函数类型：void功能：图像锐化处理。12345678910111213141516171819202122232425void MakeColorDib::Sharp() //图像锐化&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 BYTE *p_temp=new BYTE[height*DibWidth]; for(int j=0;j&lt;height-1;j++) // 每行 &#123; for(int i=0;i&lt;DibWidth-5;i++) // 每列 &#123; int pby_pt=0; pby_pt= *(p_data+(height-j-2)*DibWidth+i+3) -*(p_data+(height-j-1)*DibWidth+i); *(p_temp+(height-j-2)*DibWidth+i+3)=*(p_data+(height-j-2)*DibWidth+i+3) +abs(int(pby_pt/4)); if(*(p_temp+(height-j-2)*DibWidth+i+3)&gt;255) *(p_temp+(height-j-2)*DibWidth+i+3)=255; &#125; &#125; memcpy(p_data,p_temp,height*DibWidth); // 复制处理后的图像 delete []p_temp; //删除暂时分配内存&#125; HighLVBO 阈值法进行高通滤波函数名称：HighLVBO(int m_GaoTong)函数类型：void参数：int m_GaoTong，用户给定的阈值来选择矩阵功能：对图像使用阈值法进行高通滤波。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void MakeColorDib::HighLVBO(int m_GaoTong) //高通滤波&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 int h[3][3]; ////定义(3x3)矩阵 if(m_GaoTong==1) &#123; //矩阵1（基本高通） h[0][0] =1; h[0][1] =-2; h[0][2] =1; h[1][0] =-2; h[1][1] =5; h[1][2] =-2; h[2][0] =1; h[2][1] =-2; h[2][2] =1; &#125; else if(m_GaoTong==2) &#123; //矩阵2（中等高通） h[0][0] = 0; h[0][1] = -1; h[0][2] = 0; h[1][0] = -1; h[1][1] = 5; h[1][2] = -1; h[2][0] = 0; h[2][1] = -1; h[2][2] = 0; &#125; else &#123; //矩阵3（过量高通） h[0][0] = -1; h[0][1] = -1; h[0][2] = -1; h[1][0] = -1; h[1][1] = 9; h[1][2] = -1; h[2][0] = -1; h[2][1] = -1; h[2][2] = -1; &#125; BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像 for(int j=0;j&lt;height-2;j++) // 每行 &#123; for(int i=0;i&lt;DibWidth-8;i++) // 每列 &#123; int pby_pt=0; //对应的第0行的值乘以矩阵对应值，再相加 pby_pt= h[0][0]*(*(p_data+(height-j-1)*DibWidth+i)) +h[0][1]*(*(p_data+(height-j-1)*DibWidth+i+3)) +h[0][2]*(*(p_data+(height-j-1)*DibWidth+i+6)) //对应的第1行的值乘以矩阵对应值，再相加 +h[1][0]*(*(p_data+(height-j-2)*DibWidth+i)) +h[1][1]*(*(p_data+(height-j-2)*DibWidth+i+3)) +h[1][2]*(*(p_data+(height-j-2)*DibWidth+i+6)) //对应的第2行的值乘以矩阵对应值，再相加 +h[2][0]*(*(p_data+(height-j-3)*DibWidth+i)) +h[2][1]*(*(p_data+(height-j-3)*DibWidth+i+3)) +h[2][2]*(*(p_data+(height-j-3)*DibWidth+i+6)); *(p_temp+(height-j-2)*DibWidth+i+3)=abs(pby_pt); if(pby_pt&gt;255) //判断是否越界 *(p_temp+(height-j-2)*DibWidth+i+3)=255; &#125; &#125; memcpy(p_data,p_temp,height*DibWidth); // 复制处理后的图像 delete []p_temp; //删除暂时分配内存&#125; LowLVBO 图像低通滤波函数名称：LowLVBO()函数类型：void功能：实现图像低通滤波(3x3)。123456789101112131415161718192021222324252627282930313233343536void MakeColorDib::LowLVBO() //低通滤波(3x3)&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 double h[3][3];////定义(3x3)矩阵 h[0][0] = 0.1; h[0][1] = 0.1; h[0][2] = 0.1; h[1][0] = 0.1; h[1][1] = 0.2; h[1][2] = 0.1; h[2][0] = 0.1; h[2][1] = 0.1; h[2][2] = 0.1; BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像 for(int j=0;j&lt;height-2;j++) // 每行 &#123; for(int i=0;i&lt;DibWidth-8;i++) // 每列 &#123; double pby_pt=0; //对应的第0行的值乘以矩阵对应值，再相加 pby_pt= h[0][0]*(*(p_data+(height-j-1)*DibWidth+i)) +h[0][1]*(*(p_data+(height-j-1)*DibWidth+i+3)) +h[0][2]*(*(p_data+(height-j-1)*DibWidth+i+6)) //对应的第0行的值乘以矩阵对应值，再相加 +h[1][0]*(*(p_data+(height-j-2)*DibWidth+i)) +h[1][1]*(*(p_data+(height-j-2)*DibWidth+i+3)) +h[1][2]*(*(p_data+(height-j-2)*DibWidth+i+6)) //对应的第0行的值乘以矩阵对应值，再相加 +h[2][0]*(*(p_data+(height-j-3)*DibWidth+i)) +h[2][1]*(*(p_data+(height-j-3)*DibWidth+i+3)) +h[2][2]*(*(p_data+(height-j-3)*DibWidth+i+6)); *(p_temp+(height-j-2)*DibWidth+i+3)=abs(int(pby_pt)); &#125; &#125; memcpy(p_data,p_temp,height*DibWidth); // 复制处理后的图像 delete []p_temp; //删除暂时分配内存&#125; LowVBObig 低通滤波函数名称：LowVBObig() 函数类型：void 功能：实现函数低通滤波(5*5)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657void MakeColorDib::LowLVBObig() //低通滤波(5x5)&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 int h[5][5];//定义(5x5)矩阵 h[0][0] = 1; h[0][1] = 1; h[0][2] = 1; h[0][3] = 1; h[0][4] = 1; h[1][0] = 1; h[1][1] = 2; h[1][2] = 2; h[1][3] = 2; h[1][4] = 1; h[2][0] = 1; h[2][1] = 2; h[2][2] = 3; h[2][3] = 2; h[2][4] = 1; h[3][0] = 1; h[3][1] = 2; h[3][2] = 2; h[3][3] = 2; h[3][4] = 1; h[4][0] = 1; h[4][1] = 1; h[4][2] = 1; h[4][3] = 1; h[4][4] = 1; BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像 for(int j=0;j&lt;height-4;j++) // 每行 &#123; for(int i=0;i&lt;DibWidth-14;i++) // 每列 &#123; int pby_pt=0; //对应的第0行的值乘以矩阵对应值，再相加 pby_pt=h[0][0]*(*(p_data+(height-j-1)*DibWidth+i)) +h[0][1]*(*(p_data+(height-j-1)*DibWidth+i+3)) +h[0][2]*(*(p_data+(height-j-1)*DibWidth+i+6)) +h[0][3]*(*(p_data+(height-j-1)*DibWidth+i+9)) +h[0][4]*(*(p_data+(height-j-1)*DibWidth+i+12)) //对应的第1行的值乘以矩阵对应值，再相加 +h[1][0]*(*(p_data+(height-j-2)*DibWidth+i)) +h[1][1]*(*(p_data+(height-j-2)*DibWidth+i+3)) +h[1][2]*(*(p_data+(height-j-2)*DibWidth+i+6)) +h[1][3]*(*(p_data+(height-j-2)*DibWidth+i+9)) +h[1][4]*(*(p_data+(height-j-2)*DibWidth+i+12)) //对应的第2行的值乘以矩阵对应值，再相加 +h[2][0]*(*(p_data+(height-j-3)*DibWidth+i)) +h[2][1]*(*(p_data+(height-j-3)*DibWidth+i+3)) +h[2][2]*(*(p_data+(height-j-3)*DibWidth+i+6)) +h[2][3]*(*(p_data+(height-j-3)*DibWidth+i+9)) +h[2][4]*(*(p_data+(height-j-3)*DibWidth+i+12)) //对应的第3行的值乘以矩阵对应值，再相加 +h[3][0]*(*(p_data+(height-j-4)*DibWidth+i)) +h[3][1]*(*(p_data+(height-j-4)*DibWidth+i+3)) +h[3][2]*(*(p_data+(height-j-4)*DibWidth+i+6)) +h[3][3]*(*(p_data+(height-j-4)*DibWidth+i+9)) +h[3][4]*(*(p_data+(height-j-4)*DibWidth+i+12)) //对应的第4行的值乘以矩阵对应值，再相加 +h[4][0]*(*(p_data+(height-j-5)*DibWidth+i)) +h[4][1]*(*(p_data+(height-j-5)*DibWidth+i+3)) +h[4][2]*(*(p_data+(height-j-5)*DibWidth+i+6)) +h[4][3]*(*(p_data+(height-j-5)*DibWidth+i+9)) +h[4][4]*(*(p_data+(height-j-5)*DibWidth+i+12)); //为了计算方便我们把除以35（矩阵权和）放在求总和之后 *(p_temp+(height-j-3)*DibWidth+i+6)=abs(int(pby_pt/35)); &#125; &#125; memcpy(p_data,p_temp,height*DibWidth); // 复制处理后的图像 delete []p_temp; //删除暂时分配内存&#125; ShuiPingGROW 水平增强函数名称：ShuiPingGROW()函数类型：void功能：使图像水平增强。 12345678910111213141516171819202122232425262728293031void MakeColorDib::ShuiPingGROW() //水平增强&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 int h[3][1];//定义(3x1)矩阵 h[0][0] = -1; h[1][0] = 2; h[2][0] = -1; BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像 for(int j=0;j&lt;height-2;j++) // 每行 &#123; for(int i=0;i&lt;DibWidth-8;i++) // 每列 &#123; int pby_pt=0; //对应的3行的值乘分别以矩阵对应值，再相加 pby_pt= h[0][0]*(*(p_data+(height-j-1)*DibWidth+i)) +h[1][0]*(*(p_data+(height-j-2)*DibWidth+i)) +h[2][0]*(*(p_data+(height-j-3)*DibWidth+i)); if(pby_pt&gt;20) *(p_temp+(height-j-2)*DibWidth+i)=abs(pby_pt)+100; else *(p_temp+(height-j-2)*DibWidth+i)=abs(pby_pt); &#125; &#125; memcpy(p_data,p_temp,height*DibWidth); // 复制处理后的图像 delete []p_temp; //删除暂时分配内存&#125; ChuiZhiGROW 垂直增强函数名称：ChuiZhiGROW()函数类型：void功能：使图像垂直增强。12345678910111213141516171819202122232425262728293031void MakeColorDib::ChuiZhiGROW() //垂直增强&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 int h[1][3];//定义(1x3)矩阵 h[0][0] = -1; h[0][1] = 2; h[0][2] = -1; BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像 for(int j=0;j&lt;height-2;j++) // 每行 &#123; for(int i=0;i&lt;DibWidth-8;i++) // 每列 &#123; int pby_pt=0; //对应的第0行的值乘以矩阵对应值，再相加 pby_pt= h[0][0]*(*(p_data+(height-j-1)*DibWidth+i)) +h[0][1]*(*(p_data+(height-j-1)*DibWidth+i+3)) +h[0][2]*(*(p_data+(height-j-1)*DibWidth+i+6)); if(pby_pt&gt;20) *(p_temp+(height-j-2)*DibWidth+i)=abs(pby_pt)+100; else *(p_temp+(height-j-2)*DibWidth+i)=abs(pby_pt); &#125; &#125; memcpy(p_data,p_temp,height*DibWidth); // 复制处理后的图像 delete []p_temp; //删除暂时分配内存&#125; ShuangXiangGROW 双向增强函数名称：ShuangXiangGROW()函数类型：void功能：使图像双向增强。 123456789101112131415161718192021222324252627282930313233343536373839void MakeColorDib::ShuangXiangGROW() //双向增强&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 int h[3][3];//定义(3x3)矩阵 h[0][0] = -1; h[0][1] = -1; h[0][2] = -1; h[1][0] = -1; h[1][1] = 8; h[1][2] = -1; h[2][0] = -1; h[2][1] = -1; h[2][2] = -1; BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像 for(int j=0;j&lt;height-2;j++) // 每行 &#123; for(int i=0;i&lt;DibWidth-8;i++) // 每列 &#123; int pby_pt=0; //对应的第0行的值乘以矩阵对应值，再相加 pby_pt= h[0][0]*(*(p_data+(height-j-1)*DibWidth+i)) +h[0][1]*(*(p_data+(height-j-1)*DibWidth+i+3)) +h[0][2]*(*(p_data+(height-j-1)*DibWidth+i+6)) //对应的第1行的值乘以矩阵对应值，再相加 +h[1][0]*(*(p_data+(height-j-2)*DibWidth+i)) +h[1][1]*(*(p_data+(height-j-2)*DibWidth+i+3)) +h[1][2]*(*(p_data+(height-j-2)*DibWidth+i+6)) //对应的第2行的值乘以矩阵对应值，再相加 +h[2][0]*(*(p_data+(height-j-3)*DibWidth+i)) +h[2][1]*(*(p_data+(height-j-3)*DibWidth+i+3)) +h[2][2]*(*(p_data+(height-j-3)*DibWidth+i+6)); if(pby_pt&gt;20) *(p_temp+(height-j-2)*DibWidth+i)=abs(pby_pt)+100; else *(p_temp+(height-j-2)*DibWidth+i)=abs(pby_pt); &#125; &#125; memcpy(p_data,p_temp,height*DibWidth); // 复制处理后的图像 delete []p_temp; //删除暂时分配内存&#125; Mosaic 马塞克函数名称：Mosaic()函数类型：void功能：使图像产生马赛克效果。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void MakeColorDib::Mosaic() //马赛克&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像 for(int j=0;j&lt;height-4;j+=5) // 每行 &#123; for(int i=0;i&lt;DibWidth-14;i+=15) // 每列 &#123; //对应周围(5x5)矩阵蓝色值求和平均 int pby_pt=0; for(int m=0;m&lt;5;m++) for(int n=0;n&lt;15;n+=3) &#123; pby_pt+=*(p_data+(height-j-1-m)*DibWidth+i+n); &#125; for(m=0;m&lt;5;m++) for(int n=0;n&lt;14;n+=3) &#123; *(p_temp+(height-j-1-m)*DibWidth+i+n)=int(pby_pt/25); &#125; //对应周围(5x5)矩阵绿色值求和平均 pby_pt=0; for(m=0;m&lt;5;m++) for(int n=0;n&lt;15;n+=3) &#123; pby_pt+=*(p_data+(height-j-1-m)*DibWidth+i+n+1); &#125; for(m=0;m&lt;5;m++) for(int n=0;n&lt;14;n+=3) &#123; *(p_temp+(height-j-1-m)*DibWidth+i+n+1)=int(pby_pt/25); &#125; //对应周围(5x5)矩阵红色值求和平均 pby_pt=0; for(m=0;m&lt;5;m++) for(int n=0;n&lt;15;n+=3) &#123; pby_pt+=*(p_data+(height-j-1-m)*DibWidth+i+n+2); &#125; for(m=0;m&lt;5;m++) for(int n=0;n&lt;14;n+=3) &#123; *(p_temp+(height-j-1-m)*DibWidth+i+n+2)=int(pby_pt/25); &#125; &#125; &#125; memcpy(p_data,p_temp,height*DibWidth); // 复制处理后的图像 delete []p_temp; //删除暂时分配内存&#125;]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习推荐书]]></title>
    <url>%2F2018%2F07%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8E%A8%E8%8D%90%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[机器学习推荐书 5本深度学习书籍资源推荐 深度学习（Deep Learning）byIan Goodfellow and Yoshua Bengio and Aaron Courville 中文版下载地址：https://github.com/exacity/deeplearningbook-chinese R语言深度学习实践指南（Deep Learning Made Easy with R）by Dr. N.D. Lewis 下载地址：http://download.csdn.net/detail/oscer2016/9829915 深度学习基础（Fundamentals of Deep Learning）by Nikhil Buduma 下载地址：http://www.taodocs.com/p-32598980.html 神经网络和统计学习（Neural networks and statistical learning） by K.-L. Du and M.N.s. Swamy 下载地址：http://download.csdn.net/detail/oscer2016/9829919 神经网络和深度学习（Neural Networks and Deep Learning） by Michael Niels 下载地址：http://download.csdn.net/download/newhotter/9651111 10本机器学习书籍资源推荐 机器学习、神经网络和统计分类（Machine Learning, Neural Networks, and Statistical Classification）by D. Michie, D.J. Spiegelhalter, C.C. Taylor 下载地址：http://www1.maths.leeds.ac.uk/~charles/statlog/ 贝叶斯推理和机器学习（Bayesian Reasoning and Machine Learning）by David Barber 下载地址：http://web4.cs.ucl.ac.uk/staff/D.Barber/pmwiki/pmwiki.php?n=Brml.Online 机器学习的高斯过程（Gaussian Processes for Machine Learning） by Carl Edward Rasmussen and Christopher K. I. Williams，The MIT Press 下载地址：http://www.gaussianprocess.org/gpml/ 信息理论、推理和学习算法（Information Theory, Inference, and Learning Algorithms） by David J.C. MacKay 下载地址：http://www.inference.phy.cam.ac.uk/mackay/itprnn/book.html 统计学习元素（The Elements of Statistical Learning）by Trevor Hastie, Robert Tibshirani, Jerome Friedman 下载地址：http://statweb.stanford.edu/~tibs/ElemStatLearn/printings/ESLII_print10.pdf 机器学习课程（A Course in Machine Learning）by Hal Daumé III 下载地址：http://ciml.info/ 机器学习导论（Introduction to Machine Learning）by Amnon Shashua，Cornell University 下载地址：https://arxiv.org/abs/0904.3664v1 强化学习（Reinforcement Learning） 下载地址：https://www.intechopen.com/books/reinforcement_learning 机器学习导论（Introduction to Machine Learning）- By Nils Nilsson 下载地址：http://ai.stanford.edu/~nilsson/mlbook.html 强化学习（Reinforcement Learning）- MIT Press 下载地址：http://webdocs.cs.ualberta.ca/~sutton/book/the-book.html]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[特征提取_图像矩阵变换]]></title>
    <url>%2F2018%2F07%2F19%2F%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E5%9B%BE%E5%83%8F%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[特征提取_图像矩阵变换 基本的二维变换可包括缩放、旋转、扭曲，和平移四种 几何运算则可以转换为一些基本的矩阵运算 平移运算不是线性的,使用矩阵乘法再使用矩阵加法来完成此操作 综合这几种基本运算，数学家们将其统一为一个3*3矩阵，存储形式 仿射变换的矩阵的第三列总是（0，0，1），在存储矩阵的时候，大多只存成一个2*3的数组。 复合变换是有顺序的，一般说来，先旋转、再缩放、然后平移]]></content>
      <tags>
        <tag>特征提取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习常见算法总结]]></title>
    <url>%2F2018%2F07%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[机器学习常见算法总结 学习方式 概念 监督式学习 从给定的训练数据集中学习出一个函数，当新的数据到来时，可以根据此函数预测结果。训练数据集中的目标由人标注的。常见的算法有回归分析和统计分类 非监督式学习 与监督式学习相比，训练集没有人为标注的结果，常见的算法有聚类 半监督式学习 训练集部分被标识，部分没有被标识。常见的算法有SVM 强化学习 输入数据作为模型的反馈，模型对此作出调整。常见的算法有时间差学习 |机器学习算法分类|概念||—————-|—-||决策树算法|根据数据属性，采用树状结构建立决策模型。常用来解决分类和回归问题。常见算法：CART(Classification And Regression Tree)，ID3，C4.5，随机森林等||回归算法|对连续值预测，如逻辑回归LR等||分类算法|对离散值预测，事前已经知道分类，如k-近邻算法||聚类算法|对离散值预测，事前对分类未知，如k-means算法||神经网络|模拟生物神经网络，可以用来解决分类和回归问题感知器神经网络(Perceptron Neural Network) ，反向传递(Back Propagation)和深度学习（DL）||集成算法 |集成几种学习模型进行学习，将最终预测结果进行汇总Boosting、Bagging、AdaBoost、随机森林 (Random Forest) 等| 机器学习算法分类决策树算法根据数据属性，采用树状结构建立决策模型。常用来解决分类和回归问题。常见算法：CART(Classification And Regression Tree)，ID3，C4.5，随机森林等回归算法对连续值预测，如逻辑回归LR等分类算法对离散值预测，事前已经知道分类，如k-近邻算法聚类算法对离散值预测，事前对分类未知，如k-means算法神经网络模拟生物神经网络，可以用来解决分类和回归问题感知器神经网络(Perceptron Neural Network) ，反向传递(Back Propagation)和深度学习（DL）集成算法集成几种学习模型进行学习，将最终预测结果进行汇总Boosting、Bagging、AdaBoost、随机森林 (Random Forest) 等 SVM1、SVM不太容易过拟合：松弛因子+损失函数形式 SVM的求解方法叫拉格朗日乘子法 有时候如果你非要很明确地分类，那么结果就会像右边的一样 —— 过拟合。明显左边的两个都比过拟合好多了，可是这样就要求允许一些样本不在正确的类上. 目标：找出总损失值最小并且能大概分类的超平面 2、方法选择1231、如果Feature的数量很大，跟样本数量差不多，这时候选用LR或者是Linear Kernel的SVM2、如果Feature的数量比较小，样本数量一般，不算大也不算小，选用SVM+Gaussian Kernel3、如果Feature的数量比较小，而样本数量很多，需要手工添加一些feature变成第一种情况 3、数据维度如果数据特征维度高，svm要使用核函数来求解123Note：拉格朗日对偶没有改变最优解，但改变了算法复杂度：原问题—样本维度；对偶问题–样本数量。线性分类 样本维度&lt;样本数量：原问题求解（liblinear默认）； 非线性–升维—一般导致 样本维度&gt;样本数量：对偶问题求解 朴素贝叶斯朴素贝叶斯的优点：对小规模的数据表现很好，适合多分类任务，适合增量式训练。缺点：对输入数据的表达形式很敏感（离散、连续，值极大极小之类的） 线性回归线性回归试图学得一个线性模型以尽可能准确地预测实值输出标记。均方误差是回归任务中最常用的性能度量，基于均方误差最小化来进行模型求解的方法成为最小二乘法。在线性回归中，最小二乘法就是试图找到一条直线，使得所有样本到直线上的欧式距离之和最小。这个想法和分类问题是正好相反的，分类问题是找到一个分界面离所有样本尽可能远。 优化方法 当x矩阵是列满秩的时候，可以用最小二乘法，但是求矩阵的逆比较慢 机器学习算法选择 没有最好的分类器，只有最合适的分类器。 数据维度越高，随机森林就比AdaBoost强越多，但是整体不及SVM。 数据量越大，神经网络就越强。 1、K近邻典型KNN，它的思路就是——对于待判断的点，找到离它最近的几个数据点，根据它们的类型决定待判断点的类型。它的特点是完全跟着数据走，没有数学模型可言。123适用情景：需要一个特别容易解释的模型的时候。比如需要向用户解释原因的推荐算法。 2、贝叶斯典型的例子是Naive Bayes，核心思路是根据条件概率计算待判断点的类型。是相对容易理解的一个模型，至今依然被垃圾邮件过滤器使用。12345适用情景：需要一个比较容易解释，而且不同维度之间相关性较小的模型的时候。可以高效处理高维数据，虽然结果可能不尽如人意。 3、决策树 (Decision tree)决策树的特点是它总是在沿着特征做切分。随着层层递进，这个划分会越来越细。举个简单的例子，当我们预测一个孩子的身高的时候，决策树的第一层可能是这个孩子的性别。男生走左边的树进行进一步预测，女生则走右边的树。这就说明性别对身高有很强的影响。 12适用情景：同时它也是相对容易被攻击的分类器。这里的攻击是指人为的改变一些特征，使得分类器判断错误。常见于垃圾邮件躲避检测中。因为决策树最终在底层判断是基于单个条件的，攻击者往往只需要改变很少的特征就可以逃过监测。受限于它的简单性，决策树更大的用处是作为一些更有用的算法的基石。 随机森林 (Random forest)随机森林其实算是一种集成算法。它首先随机选取不同的特征(feature)和训练样本(training sample)，生成大量的决策树，然后综合这些决策树的结果来进行最终的分类。 它相对于决策树，在准确性上有了很大的提升，同时一定程度上改善了决策树容易被攻击的特点。 12345适用情景：数据维度相对低（几十维），同时对准确性有较高要求时。因为不需要很多参数调整就可以达到不错的效果，基本上不知道用什么方法的时候都可以先试一下随机森林。 优化问题的求解方法大部分的机器学习算法的本质都是建立优化模型，通过最优化方法对目标函数（或损失函数）进行优化，从而训练出最好的模型。常见的最优化方法有梯度下降法、牛顿法和拟牛顿法、共轭梯度法等等。 1、梯度下降法 优化思想1当目标函数是凸函数时，梯度下降法的解是全局解。一般情况下，其解不保证是全局最优解，梯度下降法的速度也未必是最快的。梯度下降法的优化思想是用当前位置负梯度方向作为搜索方向，因为该方向为当前位置的最快下降方向，所以也被称为是”最速下降法“。最速下降法越接近目标值，步长越小，前进越慢。 缺点梯度下降法的最大问题就是会陷入局部最优，靠近极小值时收敛速度减慢。 2、批量梯度下降法1最小化所有训练样本的损失函数，使得最终求解的是全局的最优解，即求解的参数是使得风险函数最小，但是对于大规模样本问题效率低下。 3、随机梯度下降法1最小化每条样本的损失函数，虽然不是每次迭代得到的损失函数都向着全局最优方向， 但是大的整体的方向是向全局最优解的，最终的结果往往是在全局最优解附近，适用于大规模训练样本情况。 随机梯度下降是通过每个样本来迭代更新一次，如果样本量很大的情况（例如几十万），那么可能只用其中几万条或者几千条的样本，就已经将theta迭代到最优解了，对比上面的批量梯度下降，迭代一次需要用到十几万训练样本，一次迭代不可能最优，如果迭代10次的话就需要遍历训练样本10次。但是，SGD伴随的一个问题是噪音较BGD要多，使得SGD并不是每次迭代都向着整体最优化方向。 4、牛顿法 牛顿法是一种在实数域和复数域上近似求解方程的方法。方法使用函数f (x)的泰勒级数的前面几项来寻找方程f (x) = 0的根。牛顿法最大的特点就在于它的收敛速度很快。 牛顿法比梯度下降法快 牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快。如果更通俗地说的话，比如你想找一条最短的路径走到一个盆地的最底部，梯度下降法每次只从你当前所处位置选一个坡度最大的方向走一步，牛顿法在选择方向时，不仅会考虑坡度是否够大，还会考虑你走了一步之后，坡度是否会变得更大。所以，可以说牛顿法比梯度下降法看得更远一点，能更快地走到最底部。 但是牛顿法要算hessian矩阵的逆，比较费时间。 5、拟牛顿法 拟牛顿法的本质思想是改善牛顿法每次需要求解复杂的Hessian矩阵的逆矩阵的缺陷，它使用正定矩阵来近似Hessian矩阵的逆，从而简化了运算的复杂度。拟牛顿法和最速下降法一样只要求每一步迭代时知道目标函数的梯度。通过测量梯度的变化，构造一个目标函数的模型使之足以产生超线性收敛性。这类方法大大优于最速下降法，尤其对于困难的问题。另外，因为拟牛顿法不需要二阶导数的信息，所以有时比牛顿法更为有效。 6、拉格朗日法 拉格朗日乘数法 拉格朗日乘子法主要用于解决约束优化问题，它的基本思想就是通过引入拉格朗日乘子来将含有n个变量和k个约束条件的约束优化问题转化为含有（n+k）个变量的无约束优化问题。拉格朗日乘子背后的数学意义是其为约束方程梯度线性组合中每个向量的系数。 通过引入拉格朗日乘子建立极值条件，对n个变量分别求偏导对应了n个方程，然后加上k个约束条件（对应k个拉格朗日乘子）一起构成包含了（n+k）变量的（n+k）个方程的方程组问题，这样就能根据求方程组的方法对其进行求解 过拟合： 如果一味的去提高训练数据的预测能力，所选模型的复杂度往往会很高，这种现象称为过拟合。所表现的就是模型训练时候的误差很小，但在测试的时候误差很大。 训练模型很好用，测试时候误差较大 参考]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习_分类_决策树]]></title>
    <url>%2F2018%2F07%2F18%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_%E5%86%B3%E7%AD%96%E6%A0%91%2F</url>
    <content type="text"><![CDATA[机器学习分类决策树 决策树算法是借助于树的分支结构实现分类。 叶子节点：存放决策结果非叶子节点：特征属性，及其对应输出，按照输出选择分支决策过程：从根节点出发，根据数据的各个属性，计算结果，选择对应的输出分支，直到到达叶子节点，得到结果 决策树使用自顶向下递归分治法，并采用不回溯的贪心策略。分裂属性的选择算法很多，这里介绍3种常用的算法：信息增益（Information gain）、增益比率（gain ratio）、基尼指数（Gini index）。 我们通过基尼不纯度或者熵来对一个集合进行的有序程度进行量化，然后引入信息增益概念对一次拆分进行量化评价 基尼不纯度基尼不纯度是指将来自集合中的某种结果随机应用于集合中某一数据项的预期误差率。该值越高，说明拆分的越不理想，如果该值为 0，说明完美拆分。 Gini(D)=1−∑_i=(1^m)p_i^2熵用来表示集合的无序程度，熵越大表示集合越混乱 E = -P * log2P 基尼不纯度与熵对比两者主要区别在于，熵到达峰值的过程相对慢一些。因此熵对混乱集合的「判罚」往往更重一些。通常情况下，熵的使用更加频繁。 信息增益（Information Gain）基于香浓的信息论，信息熵表示不确定度，均匀分布时，不确定度最大，此时熵就最大。当选择某个特征对数据集进行分类时，数据集分类后的信息熵会比分类前的小，其差值即为信息增益。信息增益可以衡量某个特征对分类结果的影响大小，越大越好。 信息增益=abs(信息熵（分类后）-信息熵（分类前）) Gain(R)=Info(D)−InfoR(D) 决策树降剪枝 为什么要剪枝训练出得决策树存在过度拟合现象——决策树过于针对训练的数据，专门针对训练集创建出来的分支，其熵值可能会比真实情况有所降低。 如何剪枝人工设置一个信息增益的阀值，自下而上遍历决策树，将信息增益低于该阀值的拆分进行合并 处理缺失数据 决策树模型还有一个很大的优势，就是可以容忍缺失数据。如果决策树中某个条件缺失，可以按一定的权重分配继续往以后的分支走，最终的结果可能有多个，每个结果又一定的概率，即：1最终结果=某个分支的结果 x 该分支的权重(该分支下的结果数/总结果数) 生成算法：ID3和C4.5。1、ID3算法ID3算法可用于划分标称型数据集，没有剪枝的过程，为了去除过度数据匹配的问题，可通过裁剪合并相邻的无法产生大量信息增益的叶子节点（例如设置信息增益阀值）。考虑某个特征后，信息熵减小的多，这个特征就是好的特征(在每层分裂时，选择使得Gain(R)最大的属性作为分裂属性)ID3算法中根据信息增益评估和选择特征，每次选择信息增益最大的特征作为判断模块建立子结点 缺点：1、此公式偏向数据量多的属性，如果样本分布不均，则会导致过拟合。2、不能处理连续分布的数据特征 2、C4.5算法C4.5算法用信息增益率来选择属性，继承了ID3算法的优点优点： 1、克服了用信息增益选择属性时偏向选择取值多的属性的不足；2、在树构造过程中进行剪枝；3、能够完成对连续属性的离散化处理；4、能够对不完整数据进行处理。1C4.5算法产生的分类规则易于理解、准确率较高；但效率低，因树构造过程中，需要对数据集进行多次的顺序扫描和排序C4.5算法在结构与递归上与ID3完全相同，区别只在于选取决决策特征时的决策依据不同，二者都有贪心性质：即通过局部最优构造全局最优 svm:123456789101112131415161718192021222324252627282930313233343536模型在真实世界中也应用场景 支撑向量机用于文本和超文本的分类；用于图像分类；用于手写体识别；这个模型的优势是什么？分类效果好；可以有效地处理高维空间的数据；可以有效地处理变量个数大于样本个数的数据；只是使用了一部分子集来进行训练模型，所以SVM模型不需要太大的内存；可以提高泛化能力；无局部极小值问题；他什么情况下表现最好？数据的维度较高；需要模型具有非常强的泛化能力；样本数据量较小时；解决非线性问题；这个模型的缺点是什么？无法处理大规模的数据集，因为该算法需要较长的训练时间；无法有效地处理包含噪声太多的数据集；SVM模型没有直接给出概率的估计值，而是利用交叉验证的方式估计，这种方式耗时较长；对缺失数据非常敏感；对于非线性问题，有时很难找到一个合适的核函数。什么条件下它表现很差？数据集的数据量过大；数据集中的含有噪声；数据集中的缺失较多的数据；对算法的训练效率要求较高；根据我们当前数据集的特点，为什么这个模型适合这个问题。 该项目所提供的样本数据相对较少；该问题是属于非线性问题；数据集经过“独热编码”后，维度较高 决策树：1234567891011121314151617181920212223242526272829303132这个模型的优势是什么？决策树易于实现和理解；对于决策树，数据的准备工作一般比较简单；能够同时处理多种数据类型给定一个决策树模型，可以根据产生的决策树推出相应的逻辑表达式；通过静态测试来对模型的表现进行评价；在相对较短的时间内可以对大量的数据做出非常好的结果；决策树可以很好地扩展到大型数据中，同时决策树的大小独立于数据库的大小；计算复杂度相对较低，结果的输出易于理解，对部分的数据缺失不敏感。他什么情况下表现最好？实例是由“属性-值”对表示的；目标函数具有离散的输出值；训练数据集包含部分错误(决策树对错误有适应性)；训练数据缺少少量属性的实例。这个模型的缺点是什么？易于出现过拟合问题；忽略了数据集中属性之间的相关性；对于类比不一致的样本，决策树的信息增益倾向于那些数据值较多的特征什么条件下它表现很差？决策树匹配的数据过多时；分类的类别过于复杂；数据的属性之间具有非常强的关联。根据我们当前数据集的特点，为什么这个模型适合这个问题。不需要准备太多的训练数据，不需要对数据过多的处理如删除空白值等；易于编码；该问题是非线性问题，决策树能够很好地解决非线性问题；算法的执行效率高，对机器的要求较小。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Opencv_斑点检测]]></title>
    <url>%2F2018%2F07%2F16%2Fopencv_%E6%96%91%E7%82%B9%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[Opencv_斑点检测 opencv中检测Blobs的类为SimpleBlobDetector这个类在opencv中的定义如下：123456789101112131415161718192021222324252627282930313233class SimpleBlobDetector : public FeatureDetector&#123;public:struct Params&#123; Params(); float thresholdStep; float minThreshold; float maxThreshold; size_t minRepeatability; float minDistBetweenBlobs; bool filterByColor; uchar blobColor; bool filterByArea; float minArea, maxArea; bool filterByCircularity; float minCircularity, maxCircularity; bool filterByInertia; float minInertiaRatio, maxInertiaRatio; bool filterByConvexity; float minConvexity, maxConvexity;&#125;;SimpleBlobDetector(const SimpleBlobDetector::Params &amp;parameters = SimpleBlobDetector::Params());protected: ...&#125;; 算法的大致步骤如下： 对[minThreshold,maxThreshold)区间，以thresholdStep为间隔，做多次二值化。对每张二值图片，使用findContours()提取连通域并计算每一个连通域的中心。根据2得到的中心，全部放在一起。一些很接近的点［由theminDistBetweenBlobs控制多少才算接近］被归为一个group,对应一个bolb特征..从3得到的那些点,估计最后的blob特征和相应半径，并以key points返回。同时该支持提取特征的方法，一共有5个选项，这里就不多加描述了，默认是提取黑色圆形的Blob特征。下面是一个示例1234567891011121314151617int main(int argc, char** argv) &#123; Mat image = imread(argv[1]); vector&lt;KeyPoint&gt; keyPoints; SimpleBlobDetector::Params params; SimpleBlobDetector blobDetect(params); blobDetect.create(&quot;SimpleBlob&quot;); blobDetect.detect(image, keyPoints); cout &lt;&lt; keyPoints.size() &lt;&lt; endl; drawKeypoints(image, keyPoints, image, Scalar(255,0,0)); namedWindow(&quot;blobs&quot;); imshow(&quot;blobs&quot;, image); waitKey(); return 0; &#125; 总体来说，OpenCV的斑点检测效果还算不错，但是在有些图像的效果上明显不如LOG算子检测的检测效果]]></content>
      <tags>
        <tag>图像处理</tag>
        <tag>Opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[opencv_ocr]]></title>
    <url>%2F2018%2F07%2F16%2Fopencv_ocr%2F</url>
    <content type="text"><![CDATA[opencv_ocr]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像分割-大津法]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2_%E5%A4%A7%E6%B4%A5%E6%B3%95%2F</url>
    <content type="text"><![CDATA[图像分割-大津法 算法介绍最大类间方差法是1979年由日本学者大津提出的，是一种自适应阈值确定的方法，又叫大津法，简称OTSU 算法公式 代码 Opencv249 + vs201012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &quot;stdio.h&quot;#include &quot;cv.h&quot;#include &quot;highgui.h&quot;#include &quot;Math.h&quot;int Otsu(IplImage* src);int main()&#123; IplImage* img = cvLoadImage(&quot;lena.jpg&quot;,0); //获取灰度图像img IplImage* dst = cvCreateImage(cvGetSize(img), 8, 1); int threshold = Otsu(img); //调用大津法求出最佳阈值 printf(&quot;otsu threshold = %d\n&quot;, threshold); cvThreshold(img, dst, threshold, 255, CV_THRESH_BINARY); //用otsu的阈值二值化 cvNamedWindow( &quot;img&quot;, 1 ); cvNamedWindow( &quot;dst&quot;, 1 ); cvShowImage(&quot;img&quot;, img); cvShowImage(&quot;dst&quot;, dst); cvWaitKey(-1); cvReleaseImage(&amp;img); cvReleaseImage(&amp;dst); cvDestroyWindow( &quot;img&quot; ); cvDestroyWindow( &quot;dst&quot; ); return 0;&#125;int Otsu(IplImage* src) &#123; int height=src-&gt;height; int width=src-&gt;width; //histogram float histogram[256] = &#123;0&#125;; for(int i=0; i &lt; height; i++) &#123; unsigned char* p=(unsigned char*)src-&gt;imageData + src-&gt;widthStep * i; for(int j = 0; j &lt; width; j++) &#123; histogram[*p++]++; &#125; &#125; //normalize histogram &amp; average pixel value int size = height * width; float u =0; for(int i = 0; i &lt; 256; i++) &#123; histogram[i] = histogram[i] / size; u += i * histogram[i]; //整幅图像的平均灰度 &#125; int threshold; float maxVariance=0; float w0 = 0, avgValue = 0; for(int i = 0; i &lt; 256; i++) &#123; w0 += histogram[i]; //假设当前灰度i为阈值, 0~i 灰度像素所占整幅图像的比例即前景比例 avgValue += i * histogram[i]; //avgValue/w0 = u0 float t = avgValue/w0 - u; //t=u0-u float variance = t * t * w0 /(1 - w0); if(variance &gt; maxVariance) &#123; maxVariance = variance; threshold = i; &#125; &#125; return threshold; &#125; 代码212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;opencv2/opencv.hpp&gt; #include &lt;cv.h&gt;#include &lt;highgui.h&gt;#include &lt;cxcore.h&gt;using namespace std;using namespace cv;Mat otsuGray(const Mat src) &#123; Mat img = src; int c = img.cols; //图像列数 int r = img.rows; //图像行数 int T = 0; //阈值 uchar* data = img.data; //数据指针 int ftNum = 0; //前景像素个数 int bgNum = 0; //背景像素个数 int N = c*r; //总像素个数 int ftSum = 0; //前景总灰度值 int bgSum = 0; //背景总灰度值 int graySum = 0; double w0 = 0; //前景像素个数占比 double w1 = 0; //背景像素个数占比 double u0 = 0; //前景平均灰度 double u1 = 0; //背景平均灰度 double Histogram[256] = &#123;0&#125;; //灰度直方图 double temp = 0; //临时类间方差 double g = 0; //类间方差 //灰度直方图 for(int i = 0; i &lt; r ; i ++) &#123; for(int j = 0; j &lt;c; j ++) &#123; Histogram[img.at&lt;uchar&gt;(i,j)]++; &#125; &#125; //求总灰度值 for(int i = 0; i &lt; 256; i ++) &#123; graySum += Histogram[i]*i; &#125; for(int i = 0; i &lt; 256; i ++) &#123; ftNum += Histogram[i]; //阈值为i时前景个数 bgNum = N - ftNum; //阈值为i时背景个数 w0 = (double)ftNum/N; //前景像素占总数比 w1 = (double)bgNum/N; //背景像素占总数比 if(ftNum == 0) continue; if(bgNum == 0) break; //前景平均灰度 ftSum += i*Histogram[i]; u0 = ftSum/ftNum; //背景平均灰度 bgSum = graySum - ftSum; u1 = bgSum/bgNum; g = w0*w1*(u0-u1)*(u0-u1); if(g &gt; temp) &#123; temp = g; T = i; &#125; &#125; for(int i=0; i&lt;img.rows; i++) &#123; for(int j=0; j&lt;img.cols; j++) &#123; if((int)img.at&lt;uchar&gt;(i,j)&gt;T) img.at&lt;uchar&gt;(i,j) = 255; else img.at&lt;uchar&gt;(i,j) = 0; &#125; &#125; return img;&#125;]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理_图像增强]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[图像处理_图像增强 图像增强前期知识图像增强是图像模式识别中非常重要的图像预处理过程。图像增强的目的是通过对图像中的信息进行处理，使得有利于模式识别的信息得到增强，不利于模式识别的信息被抑制，扩大图像中不同物体特征之间的差别，为图像的信息提取及其识别奠定良好的基础。图像增强按实现方法不同可分为点增强、空域增强和频域增强。 1、点增强点增强主要指图像灰度变换和几何变换。图像的灰度变换也称为点运算、对比度增强或对比度拉伸，它是图像数字化软件和图像显示软件的重要组成部分。灰度变换是一种既简单又重要的技术，它能让用户改变图像数据占据的灰度范围。一幅输入图像经过灰度变换后将产生一幅新的输出图像，由输入像素点的灰度值决定相应的输出像素点的灰度值。灰度变换不会改变图像内的空间关系。图像的几何变换是图像处理中的另一种基本变换。它通常包括图像的平移、图像的镜像变换、图像的缩放和图像的旋转。通过图像的几何变换可以实现图像的最基本的坐标变换及缩放功能。 2、空域增强图像的空间信息可以反映图像中物体的位置 、形状、大小等特征，而这些特征可以通过一定的物理模式来描述。例如，物体的边缘轮廓由于灰度值变化剧烈一般出现高频率特征，而一个比较平滑的物体内部由于灰度值比较均一则呈现低频率特征。因此，根据需要可以分别增强图像的高频和低频特征。对图像的高频增强可以突出物体的边缘轮廓，从而起到锐化图像的作用。例如，对于人脸的比对查询，就需要通过高频增强技术来突出五宫的轮廓。相应地，对图像的低频部分进行增强可以对图像进行平滑处理，一般用于图像的噪声消除。 3、频域增强图像的空域增强一般只是对数字图像进行局部增强，而图像的频域增强可以对图像进行全局增强。频域增强技术是在数字图像的频率域空间对图像进行滤波，因此需要将图像从空间域变换到频率域，一般通过傅里叶变换实现。在频率域空间的滤波与空域滤波一样可以通过卷积实现，因此傅里叶变换和和卷积理论是频域滤波技术的基础。 图像增强的方法分类： 图像增强方法 实现方法 处理对象 灰度图 （伪）彩色图 - - 处理策略 全局处理 局部处理（ROI ROI，Region of Interest Interest） - - 处理方法 空间域（点域运算，即灰度变换） 空间域（邻域方法，即空域滤波） 频域方法 - - 处理目的 图像锐化 平滑去噪 灰度调整（对比度增强） 图像增强的方法之对比度增强 图像增强方法 实现方法 灰度变换法 线性变换（已实现） 对数变换（已实现） 指数变换（已实现） - - 直方图调整法 直方图均衡化（已实现） 直方图匹配（未实现） 图像对比度增强 图像对比度增强 直接 间接 直方图拉伸 直方图均衡化 1234直方图拉伸 是通过对比度拉伸对直方图进行调整，从而“扩大”前景和背景灰度的差别，以达到增强对比度的目的，这种方法可以利用线性或非线性的方法来实现;直方图均衡化则通过使用累积函数对灰度值进行“调整”以实现对比度的增强。直方图均衡化处理 “中心思想”是把原始图像的灰度直方图从比较集中的某个灰度区间变成在全部灰度范围内的均匀分布。直方图均衡化就是对图像进行非线性拉伸，重新分配图像像素值，使一定灰度范围内的像素数量大致相同。直方图均衡化就是把给定图像的直方图分布改变成“均匀”分布直方图分布。 常用图像增强直方图均衡化 直方图均衡化 优点 处理过亮过暗图像很有效(曝光过度或者曝光不足),刻画更多细节 是一个相当直观的技术并且是可逆操作，如果已知均衡化函数，那么就可以恢复原始的直方图，并且计算量也不大 - - 缺点 处理数据随机，可能会降低信噪比(会增加背景噪声对比度，降低有用信号对比度) c语言代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &quot;fftw3.h&quot;#include &quot;string&quot;#include &quot;vector&quot;#include &lt;windows.h&gt;#include &lt;opencv2/legacy/legacy.hpp&gt;#include &lt;opencv2/nonfree/nonfree.hpp&gt;//opencv_nonfree模块：包含一些拥有专利的算法，如SIFT、SURF函数源码。 #include &quot;opencv2/core/core.hpp&quot;#include &quot;opencv2/features2d/features2d.hpp&quot;#include &quot;opencv2/highgui/highgui.hpp&quot;#include &lt;opencv2/nonfree/features2d.hpp&gt; using namespace cv;using namespace std; class hisEqt&#123;public: hisEqt::hisEqt(); hisEqt::~hisEqt();public: int w; int h; int nlen; int *pHis; float *pdf; //=====求像素分布概率密度==== void getPdf(); //======统计像素个数======= void getHis(unsigned char*imgdata); //==========画统计分布直方图=============== void drawHistogram(const float*pdf,Mat &amp;hist1); //===========直方图均衡化========== void hisBal(); //====直方图均衡化后的图像=== void imgBal(unsigned char* img);&#125;; hisEqt::hisEqt() :nlen(0)&#123; pHis = new int[256 * sizeof(int)]; memset(pHis, 0, 256 * sizeof(int)); pdf = new float[255 * sizeof(float)]; memset(pdf, 0, 255 * sizeof(float));&#125; hisEqt::~hisEqt()&#123; delete[]pHis; delete[]pdf;&#125; //======统计像素个数======= void hisEqt::getHis(unsigned char*imgdata)&#123; for (int i = 0; i&lt;nlen; i++) &#123; pHis[imgdata[i]]++; &#125;&#125; //=====求像素分布概率密度==== void hisEqt::getPdf()&#123; for (int k = 0; k&lt;256; k++) &#123; pdf[k] = pHis[k] / float(nlen); &#125;&#125; //===========直方图均衡化========== void hisEqt::hisBal()&#123; for (int k = 1; k&lt;256; k++) &#123; pdf[k] += pdf[k - 1]; &#125; for (int k = 0; k&lt;256; k++) &#123; pHis[k] = 255 * pdf[k]; &#125;&#125; //====直方图均衡化 void hisEqt::imgBal(unsigned char* img)&#123; for (int i = 0; i&lt;nlen; i++) &#123; img[i] = pHis[img[i]]; &#125;&#125; void hisEqt::drawHistogram(const float *pdf, Mat&amp; hist1)&#123; for (int k = 0; k&lt;256; k++) &#123; if (k % 2 == 0) &#123; Point a(k, 255), b(k, 255 - pdf[k] * 2550); line(hist1, a, b, Scalar(0, 0, 255), 1); &#125; else &#123; Point a(k, 255), b(k, 255 - pdf[k] * 2550); line(hist1, a, b, Scalar(0, 255, 0), 1); &#125; &#125;&#125; int main()&#123; Mat image = imread(&quot;Fig0651(a)(flower_no_compression).tif&quot;); if (!image.data) return -1; Mat hist2(256, 256, CV_8UC3, Scalar(0, 0, 0)); Mat hist1(256, 256, CV_8UC3, Scalar(0, 0, 0)); Mat imgOut = Mat(image.rows, image.cols, CV_8UC3, Scalar(0, 0, 0)); vector&lt;Mat&gt; planes; int chn = image.channels(); if (chn == 3) &#123; split(image, planes); &#125; while (chn) &#123; chn--; unsigned char* imageData = new unsigned char[sizeof(unsigned char)*(image.cols*image.rows)]; memcpy(imageData, planes[chn].data, planes[chn].cols*planes[chn].rows); hisEqt his;//自定义的类 his.nlen = image.rows*image.cols; his.getHis(imageData); his.getPdf(); // //======画原图直方图并保存============ his.drawHistogram(his.pdf, hist1); string pic_name = &quot;hisline&quot;; pic_name = pic_name + to_string(chn); pic_name=pic_name+ &quot;.jpg&quot;; imwrite(pic_name, hist1); his.hisBal(); his.getPdf(); // //======画均衡化后直方图并保存============ his.drawHistogram(his.pdf, hist2); string pic_name0 = &quot;his_balanceline&quot;; pic_name0 = pic_name0 + to_string(chn); pic_name0 = pic_name0 + &quot;.jpg&quot;; imwrite(pic_name0, hist2); // //=====图像均衡化=== his.imgBal(imageData); memcpy(planes[chn].data, imageData, planes[chn].cols*planes[chn].rows); delete[] imageData; imageData = NULL; &#125; merge(planes, imgOut);//单通道合并 imwrite(&quot;result.jpg&quot;, imgOut); return 0;&#125; 指数变换 先做归一化，再指数变换，最后反归一化 S=c*R^r通过合理的选择c和r可以压缩灰度范围，算法以c=1.0/255.0, r=2实现 Opencv代码：123456789101112131415161718192021222324252627void ExpEnhance(IplImage* img, IplImage* dst)&#123; // 由于oldPixel:[1,256],则可以先保存一个查找表 uchar lut[256] =&#123;0&#125;; double temp = 1.0/255.0; for ( int i =0; i&lt;255; i++) &#123; lut[i] = (uchar)(temp*i*i+0.5); &#125; for( int row =0; row &lt;img-&gt;height; row++) &#123; uchar *data = (uchar*)img-&gt;imageData+ row* img-&gt;widthStep; uchar *dstData = (uchar*)dst-&gt;imageData+ row* dst-&gt;widthStep; for ( int col = 0; col&lt;img-&gt;width; col++) &#123; for( int k=0; k&lt;img-&gt;nChannels; k++) &#123; uchar t1 = data[col*img-&gt;nChannels+k]; dstData[col*img-&gt;nChannels+k] = lut[t1]; &#125; &#125; &#125; &#125; 对数变换 低灰度值部分扩展，高灰度值部分压缩,来强调图像低灰度部分 s=c*log_{v+1}(1+v*r)底数为（v+1），实际输入范围为归一化的【0-1】，其输出也为【0-1】。底数越大，对低灰度部分的强调就越强，对高灰度部分的压缩也就越强 matlab代码12345678function dst_img=myLogEnhance(src_img,v) c=1.0; src_img = mat2gray(src_img,[0 255]); g =c*log2(1 + v*src_img)/log2(v+1); %反归一化 max=255; min=0; dst_img=uint8(g*(max-min)+min); 灰度拉伸 灰度拉升可以改善图像的动态范围 s=\frac{1}{1+\frac{m}{r+eps}^E}输入r为【0-1】，其输出s也为【0-1】 线性拉伸三段线性变换 突出感兴趣的目标或者灰度区间，相对抑制那些不感兴趣的灰度区域 1234567891011121314151617181920212223242526272829范围吧%横轴fa=20; fb=80;%纵轴ga=50; gb=230;function dst_img=myLinearEnhance(src_img,fa,fb,ga,gb) [height,width] = size(src_img);dst_img=uint8(zeros(height,width)); src_img=double(src_img); %三段斜率k1=ga/fa; k2=(gb- ga)/(fb- fa);k3=(255- gb)/(255- fb);for i=1:height for j=1:width if src_img(i,j) &lt;= fa dst_img(i,j)= k1*src_img(i,j); elseif fa &lt; src_img(i,j) &amp;&amp; src_img(i,j) &lt;= fb dst_img(i,j)= k2*( src_img(i,j)- fa)+ ga; else dst_img(i,j)= k3*( src_img(i,j)- fb)+ gb; end endenddst_img=uint8(dst_img); 频率域图像增强 傅里叶变换提供了一种从空间域到频域的转换手段，且用傅里叶反变换可以实现从频域到空间域的无损转换，不丢失任何信息 频域图像增强 类型 高通滤波器 突出图像的边界 低通滤波器 抑制图像噪声，改善图像质量 分析频谱图1234567891011121314clc; %清空命令行clear;%清空变量 I1=imread(&apos;beauty.jpg&apos;);subplot(1,2,1);imshow(I1);title(&apos;beauty.jpg&apos;); I2=fft2(I1);%计算二维FFTspectrum =fftshift(I2);%将零点移到中心temp= log(1+ abs(spectrum) ); %对幅值做 对数变换 以压缩动态范围subplot(1,2,2);imshow(temp,[]);title(&apos;FFT&apos;); 低频分量:主要对整副图像的强度的综合度量.灰度变化缓慢的特性高频分量:主要是对图像边缘和轮廓的度量.灰度变化快的特性 幅度图，看图像的频率分布，哪里亮那里暗，低频一般在图像中央如果只保留图像的中心点，则图像的细节会丢失，大致轮廓还在，不同区域好友不同的灰度如果保留远离中心的点，而去掉中心的幅度，则保留着图像的细节，而不同区域的灰度一样 频域低通滤波理想低通滤波器理想低通滤波器并不能很好的兼顾 滤除噪声 与 保留细节 这两个方面 理想低通滤波器：12345678910111213141516171819% 频域低通滤波器 imidealflpf.m%&#123;函数： function ff=imidealflpf(I,freq)函数说明：构造理想的频域低通滤波器（即 滤镜）参数说明：I：为输入原图像 freq:为截止频率返回值： 与I等大的频域滤镜 %&#125; function ff=imidealflpf(I,freq) [M,N]=size(I); ff=ones(M,N); for i=1:M for j=1:N if (sqrt ((i-M/2)^2+ (j-N/2)^2 ) &gt;freq) ff(i,j)=0; %高于截止频率 设为0 end end end 不同截止频率的滤波结果： 高斯低通滤波器12345678910111213141516171819%高斯低通滤波器滤镜 imgaussflpf.m%&#123;函数： function ff=imgaussflpf(I,sigma)函数说明：构造高斯低通滤镜参数说明：I：输入图像 sigma：标准差返回值：与原图像等大的高斯低通滤镜 %&#125; function ff=imgaussflpf(I,sigma)[M,N]=size(I); ff=ones(M,N); for i=1:M for j=1:N ff(i,j)= exp( -((i-M/2)^2+(j-N/2)^2) /2/(sigma^2) ); %高斯函数 end end 高斯滤波结果： 高斯相比于低通滤波，在有效抑制噪声的同时，图像的模糊程度更低 cankao 频域高通滤波器 图像锐化可以通过衰减频域中的低频信号来实现 1234567891011121314151617181920%高斯高通滤波器滤镜 imgaussfhpf.m%&#123;函数： function ff=imgaussfhpf(I,sigma)函数说明：构造高斯高通滤镜参数说明：I：输入图像 sigma：标准差返回值：与原图像等大的高斯高通滤镜 %&#125; function ff=imgaussfhpf(I,sigma)[M,N]=size(I); ff=ones(M,N); for i=1:M for j=1:N ff(i,j)= 1-exp( -((i-M/2)^2+(j-N/2)^2) /2/(sigma^2) ); % 1-(gauss) end end 1、高斯高通滤波器可以较好的提取边缘信息；2、sigma越小，Gauss高通的截止频率越低，通过的低频成分越多，边缘提取越不精确，会包含更多的非边缘信息；（要求太低，多了浑水摸鱼者）3、sigma越大，边缘提取越精确，但可能包含不完整的边缘信息。（要求太高，有了漏网之鱼） 拉普拉斯滤波器1234567891011121314151617181920%laplace滤波器滤镜 imlapf.m%&#123;函数： function ff=imlapf(I)函数说明：构造laplace滤镜参数说明：I：输入图像 返回值：与原图像等大的laplace滤镜 %&#125; function ff=imlapf(I)[M,N]=size(I); ff=ones(M,N); for i=1:M for j=1:N ff(i,j)= -((i-M/2)^2+(j-N/2)^2) % end end 图像处理评价指标基于误差灵敏度评价算法：最简单的质量评价算法就是均方差(Mean Squared Error, MSE)和峰值信噪比(Peak Signal- Noise Ratio, PSNR)。MSE 和 PSNR 计算复杂度小，易于实现，在图像处理领域中广泛应用。但缺点是它们给出的数值与图像的感知质量之间没有必然联系。 峰值信噪比-PSNR图像压缩等领域信号重建质量的评价 MSE为当前图像 X 和参考图像 Y 的均方误差,H、W 分别表示图像的高和宽；n为每像素的比特数，一般取8，即像素灰阶数为256。PSNR的单位是dB，数值越大表示失真越小。 matlab代码：123456789101112131415function pnsr_result = psnr(img_ref,img_in) % img_ref is a high reference quality image % img_in is the denoise image % pnsr_result is the PSNR of the denoise image width = size(img_ref,2); heigh = size(img_ref,1); if( width ~= size(img_in,2) || heigh ~= size(img_in,1) ) disp(&apos;Please check whether the input image and reference image have same size&apos;); return end [a,b]=size(img_ref); XX=double(img_ref) - double(img_in); mse_value = sum(sum( XX.^2 ))/(a*b); pnsr_result = 10*log10( 255*255 / mse_value ); end SSIM信噪比（SNR）信噪比就是有用信号与噪声信号的比值 snr=10*log_{10}\frac{sigma(I2)}{sigma(I2-I1)}12345678910111213141516171819202122function snr=SNR2(I,In)% 计算噪声比% I :original signal% In:noisy signal% snr=10*log10(sigma2(I2)/sigma2(I2-I1)) [~,~,nchannel]=size(I);snr=0;I=double(I);In=double(In);if nchannel==1 Ps=sum(sum((I-mean(mean(I))).^2));%signal power Pn=sum(sum((I-In).^2));%noise power snr=10*log10(Ps/Pn);elseif nchannel==3 for i=1:3 Ps=sum(sum((I(:,:,i)-mean(mean(I(:,:,i)))).^2));%signal power Pn=sum(sum((I(:,:,i)-In(:,:,i)).^2));%noise power snr=snr+10*log10(Ps/Pn); end snr=snr/3;end 基于结构相似度评价算法其他曝光过度问题处理计算当前图像的反相（255-image)，然后取当前图像和反相图像的较小者为当前像素位置的值。 min(image,(255-image))加Masaic算法原理：用中心像素来表示邻域像素Opencv代码：123456789101112131415161718192021222324252627282930313233343536uchar getPixel( IplImage* img, int row, int col, int k)&#123; return ((uchar*)img-&gt;imageData + row* img-&gt;widthStep)[col*img-&gt;nChannels +k];&#125; void setPixel( IplImage* img, int row, int col, int k, uchar val)&#123; ((uchar*)img-&gt;imageData + row* img-&gt;widthStep)[col*img-&gt;nChannels +k] = val;&#125;--// nSize:为尺寸大小，奇数// 将邻域的值用中心像素的值替换void Masic(IplImage* img, IplImage* dst, int nSize)&#123; int offset = (nSize-1)/2; for ( int row = offset; row &lt;img-&gt;height - offset; row= row+offset) &#123; for( int col= offset; col&lt;img-&gt;width - offset; col = col+offset) &#123; int val0 = getPixel(img, row, col, 0); int val1 = getPixel(img, row, col, 1); int val2 = getPixel(img, row, col, 2); for ( int m= -offset; m&lt;offset; m++) &#123; for ( int n=-offset; n&lt;offset; n++) &#123; setPixel(dst, row+m, col+n, 0, val0); setPixel(dst, row+m, col+n, 1, val1); setPixel(dst, row+m, col+n, 2, val2); &#125; &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理_图像滤波]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2%2F</url>
    <content type="text"><![CDATA[图像滤波 噪声加性噪声一般指热噪声、散弹噪声等，它们与信号的关系是相加，不管有没有信号，噪声都存在。 高斯白噪声包括热噪声和散粒噪声。在通信信道测试和建模中，高斯噪声被用作加性白噪声以产生加性白高斯噪声。 加性高斯白噪声只是白噪声的一种，另有泊松白噪声等,加性高斯白噪声在通信领域中指的是一种各频谱分量服从均匀分布（即白噪声），且幅度服从高斯分布的噪声信号。因其可加性、幅度服从高斯分布且为白噪声的一种而得名。 而乘性噪声一般由信道不理想引起，它们与信号的关系是相乘，信号在它在，信号不在他也就不在。 一般通信中把加性随机性看成是系统的背景噪声； 而乘性随机性看成系统的时变性（如衰落或者多普勒）或者非线性所造成的。 空域滤波空域滤波可以用于非线性滤波，但是频域滤波不能用于非线性滤波 图像滤波 空域 线性滤波 均值滤波 - - - 非线性滤波 中值滤波 双边滤波 滤波模板图像滤波 模板：12345线性平均滤波：1|0 1 0 |-|1 1 1 |5|0 1 0 | 图像锐化 模板：123456789锐化滤波：图像锐化一般是通过微分运算来实现的|-1 0 1||-1 0 1||-1 0 1|| 1 1 1|| 0 0 0||-1 -1 -1| 方向滤波器-sobel算子123456789x轴：|-1 0 1||-2 0 2||-1 0 1|y轴：|-1 -2 -1|| 0 0 0|| 1 2 1| Scharr算子123456789x轴：|-3 0 3||-10 0 10||-3 0 3|y轴：|-3 -10 -3|| 0 0 0|| 3 10 3| 线性空域滤波线性空域滤波指的是像素的输出值是计算该像素邻域内像素值的线性组合线性滤波中滤波模板也称为卷积模板 模板卷积模板卷积的主要步骤包括如下几个步骤， 1) 将模板在图像中进行遍历，将模板中心和各个像素位置重合； 2) 将模板的各个系数与模板对应像素值进行相乘； 3) 将所有的乘积相加，并将求和结果赋值于模板中心对应的像素 延拓模板的行或列就会超出图像之外，因此常常采用延拓的方式解决外边界问题。常用的方法有四种，分别是补零、重复、对称和循环方式。 补零是指通过在图像边界外围补零来扩展图像；重复是指在图像边界外围通过复制外边界的值来扩展图像；对称是指在图像边界外围通过镜像反射外边界的值来扩展图像；循环是在图像边界外围指将图像看成二维周期函数的一个周期来扩展。 均值滤波高斯滤波高斯滤波器宽度(决定着平滑程度)是由参数σ表征的，而且σ和平滑程度的关系是非常简单的．σ越大，高斯滤波器的频带就越宽，平滑程度就越好．通过调节平滑程度参数σ 高斯分布：$h(x,y)=e^-(\frac{x^2+y^2}{2a^2})$ 双边滤波一种非线性的滤波方法，是结合图像的空间邻近度和像素相似度的的一种折中处理。它是一种保持边缘的非迭代平滑滤波方法。中心像素的距离和灰度差值的增大，邻域像素的权系数逐渐减小 优点：保持边缘性能良好，对低频信息滤波良好缺点：不能处理高频信息 假设高斯函数表达式如下： W_ij=\frac{1}{K_i}e^-\frac{(x_j-x_i)^2}{σ^2_G}K是归一化的常量，W是权重，权重只跟像素之间的空间距离有关系。 双边滤波器: W_ij=\frac{1}{K_i}e^-\frac{(x_j-x_i)^2}{σ^2_G}e^-\frac{(I_j-I_i)^2}{σ^2_r}中值滤波中值滤波是统计排序滤波的一种，中值滤波对椒盐噪声效果好；滤波图像边缘信息好，边缘清晰|统计排序滤波||||-|-|-||最大值滤波|有效地滤除椒噪声(黑色)|寻找最亮点，亮化图片||最小值滤波|有效地滤除盐噪声(白色)|寻找最暗点，暗化图片||自适应中值滤波|有效地滤除椒盐噪声|钝化图像、去除噪音| 操作步骤： 1) 将模板在图像中遍历 2) 将模板对应的邻域内像素的灰度值排序 3) 查找中间值，将其赋于模板中心对应的像素 Matlab函数Matlab滤波相关函数主要有imfilter()和fspecial()。 imfilter()是滤波操作fspecial()是构建自定义的二维滤波器，供imfilter()函数使用 imfilter()函数定义 g = imfilter(f, w, option1, option2, ...) 其中：f:待滤波图像w:滤波模板option1, option2:可选项 可选项分为： （1） 边界项：遍历处理边界元素时，需要提前在图像边界周围补充元素 参数：X—表示具体的数字，默认用0补充 symmetric—镜像边界元素 replicate—重复边界像素 circular—周期性填充边界内容 （2） 尺寸项：处理图像前扩充了边界，比原图大一圈，此项输出图像大小参数: same—输出图像输入图像尺寸相同full—输出图像与扩充边界的图像尺寸相同，即比原图大一圈（3） 模式项：滤波过程选择参数：corr—相关滤波过程conv—卷积相关过程（4） fspecial()函数定义 h = fspecial(type, parameters) 其中：type:滤波类型 参数：average—平均模板disk—圆形邻域平均模板guassian—高斯模板laplacian—拉普拉斯模板log—高斯-拉普拉斯模板prewitt—prewitt水平边缘检测算子sobel—Sobel水平边缘检测算子 频域滤波可以用图像增强，首先把图像通过傅里叶变换将图像从空间域转换到频率域，频域处理，反傅里叶变换转到空间域 C++代码均值滤波123456789101112131415void meanFilter (unsigned char* corrupted, unsigned char* smooth, int width, int height) &#123; memcpy ( smooth, corrupted, width*height*sizeof(unsigned char) ); for (int j=1;j&lt;height-1;j++) &#123; for (int i=1;i&lt;width-1;i++) &#123; smooth [ j*width+i ] = ( corrupted [ (j-1)*width+(i-1) ] + corrupted [ (j-1)*width+i] + corrupted [ (j-1)*width+(i+1) ] + corrupted [ j*width+(i-1) ] + corrupted [ j*width+i] + corrupted [ j*width+(i+1) ] + corrupted [ (j+1)*width+(i-1) ] + corrupted [ (j+1)*width+i] + corrupted [ (j+1)*width+(i+1) ] ) / 9; &#125; &#125; &#125; 中值滤波1234567891011121314151617181920212223242526272829void medianFilter (unsigned char* corrupted, unsigned char* smooth, int width, int height) &#123; memcpy ( smooth, corrupted, width*height*sizeof(unsigned char) ); for (int j=1;j&lt;height-1;j++) &#123; for (int i=1;i&lt;width-1;i++) &#123; int k = 0; unsigned char window[9]; for (int jj = j - 1; jj &lt; j + 2; ++jj) for (int ii = i - 1; ii &lt; i + 2; ++ii) window[k++] = corrupted[jj * width + ii]; // Order elements (only half of them) for (int m = 0; m &lt; 5; ++m) &#123; int min = m; for (int n = m + 1; n &lt; 9; ++n) if (window[n] &lt; window[min]) min = n; // Put found minimum element in its place unsigned char temp = window[m]; window[m] = window[min]; window[min] = temp; &#125; smooth[ j*width+i ] = window[4]; &#125; &#125; &#125;]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理-图像去雾]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE%2F</url>
    <content type="text"><![CDATA[图像处理-图像去雾 雾图模型I(x)=J(x)t(x)+A(1-t(x))1234I(x) ——待去雾的图像J(x)——无雾图像A——全球大气光成分t——折射率（大气传递系数） 暗通道先验在无雾图像中，每一个局部区域都很有可能会有阴影，或者是纯颜色的东西，又或者是黑色的东西。因此，每一个局部区域都很有可能有至少一个颜色通道会有很低的值。把这个统计规律叫做Dark Channel Prior。 实际生活中造成暗原色中低通道值主要有三个因素：a)汽车、建筑物和城市中玻璃窗户的阴影，或者是树叶、树与岩石等自然景观的投影；b)色彩鲜艳的物体或表面，在RGB的三个通道中有些通道的值很低（比如绿色的草地／树／植物，红色或黄色的花朵／叶子，或者蓝色的水面）；c)颜色较暗的物体或者表面，例如灰暗色的树干和石头。总之，自然景物中到处都是阴影或者彩色，这些景物的图像的暗原色总是很灰暗的。 首先求出每个像素RGB分量中的最小值，存入一副和原始图像大小相同的灰度图中，然后再对这幅灰度图进行最小值滤波(邻域中取最小值) 验证了暗通道先验理论的普遍性 计算折射率t(x)=1-wmin(minI(y)/A)估计大气光1231.选取暗通道图像暗通道最亮的0.1%的像素（一般来说，这些像素表示雾浓度最大的地方）2.取输入图像里面这些像素对应的像素里面最亮的作为大气光（暗图像最亮的0.1%的像素对应的原图最亮的为大气光） 注：选中的像素未必是全图最亮的，而且要比选取全图最亮的方式鲁棒性更好。 去雾J(x)=I(x)-A/max(t(x),t0) +At0=0.1 流程：1.求图像暗通道 2.利用暗通道计算出折射率 3.利用暗通道估计大气光 4.代回雾图公式去雾 我的代码-图像去雾算法Matlab实现]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[形态学滤波]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%BD%A2%E6%80%81%E5%AD%A6%E6%BB%A4%E6%B3%A2_leitao%E8%AE%BA%E6%96%87%2F</url>
    <content type="text"><![CDATA[形态学滤波]]></content>
      <tags>
        <tag>图像处理</tag>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习_分类_随机森林]]></title>
    <url>%2F2018%2F07%2F16%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%2F</url>
    <content type="text"><![CDATA[机器学习分类随机森林 它也是最常用的算法之一，随机森林建立了多个决策树，并将它们合并在一起以获得更准确和稳定的预测。随机森林的一大优势在于它既可用于分类，也可用于回归问题 随机森林的主要限制在于使用大量的树会使算法变得很慢，并且无法做到实时预测。一般而言，这些算法训练速度很快，预测十分缓慢。越准确的预测需要越多的树，这将导致模型越慢。在大多数现实世界的应用中，随机森林算法已经足够快，但肯定会遇到实时性要求很高的情况，那就只能首选其他方法。 随机森林和Adaboost，以及区别：bagging 随机森林，不同的分类器是通过串行训练而获得的，每个新分类器都根据已训练出的分类器的性能来进行训练分类器权重相等. boost ：— §是通过集中关注被已有分类器错分的那些数据来获得新的分类器。匕0081丨明分类的结果是基于所有分类器的加权求和结果的，分类器权重并不相等，每个权重代表的是其对应分类器在上一轮迭代中的成功度 说一下GBDT和Adaboost，以及区别 Bagging + 决策树 = 随机森林 2）AdaBoost + 决策树 = 提升树 3）Gradient Boosting + 决策树 = GBDT]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习_分类_数据聚类]]></title>
    <url>%2F2018%2F07%2F16%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_%E6%95%B0%E6%8D%AE%E8%81%9A%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[机器学习分类数据聚类 K-Means（k-平均或k-均值）可以称的上是知名度最高的一种聚类算法 123456789首先，我们确定要几个的聚类（cluster，也称簇），并为它们随机初始化一个各自的聚类质心点（cluster centroids），它在上图中被表示为“X”。要确定聚类的数量，我们可以先快速看一看已有的数据点，并从中分辨出一些独特的数据。其次，我们计算每个数据点到质心的距离来进行分类，它跟哪个聚类的质心更近，它就被分类到该聚类。需要注意的是，初始质心并不是真正的质心，质心应满足聚类里每个点到它的欧式距离平方和最小这个条件。因此根据这些被初步分类完毕的数据点，我们再重新计算每一聚类中所有向量的平均值，并确定出新的质心。最后，重复上述步骤，进行一定次数的迭代，直到质心的位置不再发生太大变化。当然你也可以在第一步时多初始化几次，然后选取一个看起来更合理的点节约时间。K-Means的优点是速度非常快，因为我们所做的只是计算数据点和质心点之间的距离，涉及到的计算量非常少！因此它的算法时间复杂度只有O(n)。另一方面，K-Means有两个缺点。一是你必须一开始就决定数据集中包含多少个聚类。这个缺点并不总是微不足道的，理想情况下，我们的目标其实是用一种算法来分类这些数据，并从结果中观察出一些规律，而不是限制几个条件强行聚类。二是一开始质心点的选取是随机的，算法可能会初始化出差异巨大的点。这个缺点导致的结果是质心点的位置不可重复且缺乏一致性。K-Medians是与K-Means相关的另一种聚类算法，不同之处在于它使用簇的中值向量来重新计算质心点。该方法对异常值不敏感（因为使用中值），但在较大数据集上运行时速度会慢很多，因为每次计算中值向量，我们都要重新排序。 Mean-Shift聚类12345678Mean shift算法，又称均值漂移算法，这是一种基于核密度估计的爬山算法，可用于聚类、图像分割、跟踪等。它的工作原理基于质心，这意味着它的目标是定位每个簇/类的质心，即先算出当前点的偏移均值，将该点移动到此偏移均值，然后以此为新的起始点，继续移动，直到满足最终的条件（找出最密集的区域）。1、为了理解均值漂移，我们可以像上图一样想象二维空间中的一组数据点，然后先随机选择一个点C，以它为圆心画一个半径为r的圆开始移动。之前提到了，这是个爬山算法，它的核函数会随着迭代次数增加逐渐向高密度区域靠近。2、在每轮迭代中，算法会不断计算圆心到质心的偏移均值，然后整体向质心靠近。漂移圆圈内的密度与数据点数成正比。到达质心后，算法会更新质心位置，并继续让圆圈向更高密度的区域靠近。3、当圆圈到达目标质心后，它发现自己无论朝哪个方向漂移都找不到更多的数据点，这时我们就认为它已经处于最密集的区域。4、这时，算法满足了最终的条件，即退出。Mean-Shift不需要实现定义聚类数量，因为这些都可以在计算偏移均值时得出。这是一个巨大的优势。同时，算法推动聚类中心在向密度最大区域靠近的效果也非常令人满意，这一过程符合数据驱动型任务的需要，而且十分自然直观。如果要说Mean-Shift有什么缺点，那就是对高维球区域的半径r的定义，不同选择可能会产生高度不同的影响。 EM聚类1234567891011均值→质心，方差→椭圆聚类，权重→聚类大小。K-Means算法的主要缺点之一是它直接用了距离质心的平均值。1、首先，我们确定聚类的数量（如K-Means），并随机初始化每个聚类的高斯分布参数。你也可以尝试通过快速查看数据来为初始参数提供更好的猜测，但从上图可以看出，这其实不是很必要，因为算法会很快进行优化。2、其次，根据每个聚类的高斯分布，计算数据点属于特定聚类的概率。如果数据点越接近高斯质心，那它属于该聚类的概率就越高。这很直观，因为对于高斯分布，我们一般假设大部分数据更靠近聚类质心。3、在这些概率的基础上，我们为高斯分布计算一组新的参数，使聚类内数据点的概率最大化。我们用数据点位置的加权和来计算这些新参数，其中权重就是数据点属于聚类的概率。为了可视化这个过程，我们可以看看上面的图片，特别是黄色的聚类。第一次迭代中，它是随机的，大多数黄点都集中在该聚类的右侧。当我们按概率计算加权和后，虽然聚类的中部出现一些点，但右侧的比重依然很高。随着迭代次数增加，黄点在聚类中的位置也完成了“右下→左下”的移动。因此，标准差的变化调整着聚类的形状，以使它能更适合数据点的分布。4、迭代步骤2和步骤3，直至收敛。GMM有两个关键优势。首先它比K-Means更灵活，由于标准差的引入，最后聚类的形状不再局限于圆形，它还可以是大小形状不一的椭圆形——K均值实际上是GMM的一个特例，其中每个聚类的协方差在所有维上都接近0。其次，权重的引入为同一点属于多个聚类找到了解决方案。如果一个数据点位于两个聚类的重叠区域，那我们就可以简单为它定义一个聚类，或者计算它属于X聚类的百分比是多少，属于Y聚类的百分比是多少。简而言之，GMM支持混合“成员”。谈及缺点，和K-Means相比，GMM每一步迭代的计算量比较大。另外，它的求解办法基于EM算法，因此有可能陷入局部极值，需要经过多次迭代。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习_最优化_数学]]></title>
    <url>%2F2018%2F07%2F16%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%9C%80%E4%BC%98%E5%8C%96_%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[机器学习最优化数学 泰勒展开式 期望概率加权下的平均值离散型：$E(x)=\sumix_ip_i$连续型：$E(x)=\int{-\infty}^{\infty}xf(x)dx$ 极大似然估计取对数：$lnL(\theta1,\theta_2,…,\theta_k=\sum{i=1}^nlnf(x,\theta_1,\theta_2,…,\theta_k))$求驻点：$\partial{lnL(\theta)}/\partial{\theta_i}=0,i=1,2,…k$ 概率论中心极限定理：设n个随机变量$X_1,X_2,…,X_n$相互独立，均具有相同的数学期望与方差，即$E(X_i)=\mu;D(X_i)=\sigma^2$, Y_n=X_1+X_2+...+X_nZ_n=\frac{Y_n-E(Y_n)}{\sqrt{D(Y_n)}}=\frac{Y_n-n\mu}{\sqrt{n}\sigma}→N(0,1)随机变量$Z_n$为n个随机变量$X_1,X_2,…,X_n$的规范和设从均值为$\mu$、方差为$\sigma^2$（有限）的任意一个总体中抽取样本量为$n$的样本，当$n$充分⼤大时，样本均值的抽样分布$\frac{Y_n}{n}$近似服从于均值为$\mu$、方差为$\sigma^2$的正态分布。 中心极限定理，把那些对结果影响⽐比较小的变量（假设独⽴立同分布）之和认为服从正态分布是合理理的。 高斯分布输入值$x^i$，预测值$\theta^Tx^i$，真实值$y^i$，误差$\epsilon^{i}$ y^i=\theta^Tx^i+\epsilon^{i}根据中心极限定理，认为变量之和服从高斯分布,即 \epsilon^{i} = y^i-\theta^Tx^i则，x,y的条件概率为 p(y^i|x^i;\theta) = \frac{1}{\sqrt{2\pi}\sigma}exp(-\frac{(y^i-\theta^Tx^i)^2}{2\sigma^2})矩阵论最优化]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>最优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习_概率论_数学基础]]></title>
    <url>%2F2018%2F07%2F16%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%A6%82%E7%8E%87%E8%AE%BA_%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[机器学习_概率论 概念先验概率：A的边缘概率表示为P(A)，B的边缘概率表示为P(B) 联合概率:表示两个事件共同发生的概率。A与B的联合概率表示为P(A∩B)或者P(A,B)。 条件概率（又称后验概率）：事件A在另外一个事件B已经发生条件下的发生概率。条件概率表示为P(A|B)，读作“在B条件下A的概率”,。 123456789考虑一个问题：P(A|B)是在B发生的情况下A发生的可能性。首先，事件B发生之前，我们对事件A的发生有一个基本的概率判断，称为A的先验概率，用P(A)表示；其次，事件B发生之后，我们对事件A的发生概率重新评估，称为A的后验概率，用P(A|B)表示；类似的，事件A发生之前，我们对事件B的发生有一个基本的概率判断，称为B的先验概率，用P(B)表示；同样，事件A发生之后，我们对事件B的发生概率重新评估，称为B的后验概率，用P(B|A)表示。 贝叶斯公式贝叶斯定理 P(B_i|A) = \frac{P(B_i)P(A|B_i)}{\sum_{j=1}^n{P(B_j)}{P(A|B_j)}}贝叶斯公式 P(A|B)=\frac{P(B|A)P(A)}{P(B)}因为联合概率$P(A,B)$ P(A,B)=P(A|B)*P(B)=P(B|A)*P(A)假设B事件是由A1、A2事件导致的 P(B)=P(B|A1)P(A1)+P(B|A2)P(A2)理解：P(规律|现象)=P(现象|规律)P(规律)/P(现象) 案例1假设有两个班级其中1班有男生30人，女生20人；2班有男生25人、女生25人。体育老师抓到一个抽烟的男生，该男生打死也不告诉体育老师是那个班的。问题来了体育老师怎么判断该男生来自那个班？ 先将1班和2班标记为事件A1和事件A2，男生标记为事件B 那么我们所求的就是P(A1丨B)和P(A2丨B) 因为只有2个班那么我们先验概率P(A1)=P(A2)=50%；来自1班男生的概率P(B丨A1)=3/5：来自2班男生的概率P(B丨A2)=1/2 那么我们求出P(B)就可以代入公式得到结果: P(B)=P(B丨A1)P(A1) P(B丨A2)P(A2)=0.55 P(A1丨B)=P(B丨A1)P(A1)/P(B)=0.6*0.5/0.55=55% P(A2丨B)=P(B丨A2)P(A2)/P(B)=0.5*0.5/0.55=45% 由结果我们可以得出：该男生来自1班的概率从50%（先验概率）上升到55%（后验概率） 案例2一种癌症，得了这个癌症的人被检测出为阳性的几率为90%，未得这种癌症的人被检测出阴性的几率为90%，而人群中得这种癌症的几率为1%，一个人被检测出阳性，问这个人得癌症的几率为多少？ 我们用 A 表示事件 “测出为阳性”, 用 $B_1$ 表示“得癌症”, $B_2$ 表示“未得癌症”。 得到以下信息:$P(A|B_1)=0.9$得癌症的人检测阳性 0.9$P(A|B_2)=0.1$得癌症的人检测阴性 0.1$P(B_1)=0.01$得癌症的概率 0.01$P(B_2)=0.99$未得癌症的概率 0.99 计算：人群中检测为阳性且得癌症的几率$P(B_1,A)$，联合概率 P(B_1,A)=P(B_1)*P(A|B_1)=0.01*0.9=0.009检测阳性并且未得癌症概率$P(B_2,A)$，联合概率 P(B_2,A)=P(B_2)*P(A|B_2)=0.99*0.1=0.099目前状态是已经检测除阳性，求患癌症概率$P(B_1|A)$$P(B_1|A)=\frac{0.009}{0.099+0.009}=0.083$未患癌症概率$P(B_2|A)$$P(B_2|A)=\frac{0.099}{0.099+0.009}=0.917$]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习_最优化]]></title>
    <url>%2F2018%2F07%2F16%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%9C%80%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[机器学习-最优化-梯度下降-牛顿法等(梯度消失爆炸)) 铺垫微分意义121、函数图像中，某点的切线的斜率2、函数的变化率 梯度意义 梯度就是分别对每个变量进行微分，然后用逗号分割开，梯度是用&lt;&gt;包括起来，说明梯度其实一个向量。121、在单变量的函数中，梯度其实就是函数的微分，代表着函数在某个给定点的切线的斜率2、在多变量函数中，梯度是一个向量，向量有方向，梯度的方向就指出了函数在给定点的上升最快的方向 梯度的方向实际就是函数在此点上升最快的方向！而我们需要朝着下降最快的方向走，自然就是负的梯度的方向，所以此处需要加上负号 梯度下降法（Gradient Descent） 梯度下降法的优化思想是用当前位置负梯度方向作为搜索方向，因为该方向为当前位置的最快下降方向，所以也被称为是”最速下降法“。最速下降法越接近目标值，步长越小，前进越慢 梯度下降法的缺点：12345（1）靠近极小值时收敛速度减慢，；（2）直线搜索时可能会产生一些问题；（3）可能会“之字形”地下降。 \theta^1=\theta^0 - \alpha\nabla(j(\theta)是关于Θ的一个函数，我们当前所处的位置为Θ0点，要从这个点走到J的最小值点$\nabla$ 是梯度,$\alpha$是学习率或者步长 批量梯度下降法将$j(\theta)$对$\theta$求偏导，得到每个$\theta$对应的的梯度：每个参数$\theta$的梯度负方向，来更新每个$\theta$ 优点：它得到的是一个全局最优解缺点：数据量大，计算缓慢 随机梯度下降随机梯度下降是通过每个样本来迭代更新一次，如果样本量很大的情况（例如几十万），那么可能只用其中几万条或者几千条的样本 优点：只用部分数据继续优化，运算量小缺点：损失一部分进度，增加迭代次数 两者关系： 随机梯度下降方法以损失很小的一部分精确度和增加一定数量的迭代次数为代价，换取了总体的优化效率的提升。增加的迭代次数远远小于样本的数量。 总结： 批量梯度下降—最小化所有训练样本的损失函数，使得最终求解的是全局的最优解，即求解的参数是使得风险函数最小，但是对于大规模样本问题效率低下。 随机梯度下降—最小化每条样本的损失函数，虽然不是每次迭代得到的损失函数都向着全局最优方向， 但是大的整体的方向是向全局最优解的，最终的结果往往是在全局最优解附近，适用于大规模训练样本情况。 牛顿法和拟牛顿法牛顿法是一种在实数域和复数域上近似求解方程的方法。牛顿法最大的特点就在于它的收敛速度很快。 单变量例如：方法使用函数$f(x)$的泰勒级数的前面几项来寻找方程$f(x)= 0$的根。 1、选择一个接近函数$ f (x)$零点的 $x_0$，计算相应的$ f (x_0)$ 和切线斜率$f ‘ (x_0)$（这里$f ‘ $表示函数$ f $ 的导数）。然后我们计算穿过点$(x_0, f (x_0))$ 并且斜率为$f ‘(x_0)$的直线和 $x $轴的交点的$x$坐标，也就是求如下方程的解： x*f'(x_0)+f(x_0)-x_0*f'(x_0)=0求得新的$x$坐标$x_1$,$x_1$比$x_0$更加接近收敛值的解，也就是使得$f(x)=0$，单变量迭代公式： x_n+1=x_n-f(x_n)/f'(x_n) 如果$f ‘$ 是连续的，牛顿法必定收敛 多变量的话，需要用到雅可比矩阵和海森矩阵。 总结： 牛顿法的优缺点优点：二阶收敛，收敛速度快；缺点：牛顿法是一种迭代算法，每一步都需要求解目标函数的Hessian矩阵的逆矩阵，计算比较复杂。 牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快 牛顿法就是用一个二次曲面去拟合你当前所处位置的局部曲面，而梯度下降法是用一个平面去拟合当前的局部曲面，通常情况下，二次曲面的拟合会比平面更好，所以牛顿法选择的下降路径会更符合真实的最优下降路径。 Hessian 矩阵非正定（非凸）导致无法收敛；Hessian 矩阵维度过大带来巨大的计算量。 拟牛顿法（Quasi-Newton Methods）拟牛顿法是求解非线性优化问题最有效的方法之一。 拟牛顿法的本质思想是改善牛顿法每次需要求解复杂的Hessian矩阵的逆矩阵的缺陷，它使用正定矩阵来近似Hessian矩阵的逆，从而简化了运算的复杂度。只需要用到一阶导数，不需要计算Hessian矩阵 以及逆矩阵，因此能够更快收敛 正定矩阵：如果$X^TAX&gt;0$判定定理1：对称阵A为正定的充分必要条件是：A的特征值全为正。 判定定理2：对称阵A为正定的充分必要条件是：A的各阶顺序主子式都为正。 判定定理3：任意阵A为正定的充分必要条件是：A合同于单位阵。 拉格朗日乘子法作为一种优化算法，拉格朗日乘子法主要用于解决约束优化问题，它的基本思想就是通过引入拉格朗日乘子来将含有n个变量和k个约束条件的约束优化问题转化为含有（n+k）个变量的无约束优化问题。拉格朗日乘子背后的数学意义是其为约束方程梯度线性组合中每个向量的系数。 典型：求函数$z=f(x,y)$在满足$b(x,y)=0$下的条件极值转化为函数$F(x,y,\alpha)=f(x,y)+\alpha b(x,y)$的无条件极值问题 列题：给定椭球：$x^2/a^2+y^2/b^2+z^2/c^2=1$(约束条件),求内接长方体最大体积，求极值问题，求$f(x,y,z)=8xyz$的最大值用拉格朗日乘子法：转化为 F(x,y,z,\alpha)=f(x,y,z)+\alpha b(x,y,z)=8xyz+\alpha(x^2/a^2+y^2/b^2+z^2/c^2-1)对F(x,y,z,\alpha)求偏导得然后联立三个方程的$bx=ay,az=cx$，带入第四个方程解解为： 共轭梯度法共轭梯度法是介于最速下降法与牛顿法之间的一个方法，它仅需利用一阶导数信息，但克服了最速下降法收敛慢的缺点，又避免了牛顿法需要存储和计算Hesse矩阵并求逆的缺点，共轭梯度法不仅是解决大型线性方程组最有用的方法之一，也是解大型非线性最优化最有效的算法之一。 在各种优化算法中，共轭梯度法是非常重要的一种。其优点是所需存储量小，具有步收敛性，稳定性高，而且不需要任何外来参数。 参考文章参考文章 梯度不稳定什么是梯度不稳定问题：深度神经网络中的梯度不稳定性，前面层中的梯度或会消失，或会爆炸。 原因：前面层上的梯度是来自于后面层上梯度的乘乘积。当存在过多的层次时，就出现了内在本质上的不稳定场景，如梯度消失和梯度爆炸。 后果：训练很难进行，不收敛了1、loss过早地不再下降2、精确度过早地不在提高 梯度消失梯度消失：一是在深层网络中；二是采用了不合适的损失函数，比如sigmoid。sigmoid导数最大为1/4，故只有当abs(w)&gt;4时才可能出现。先前传递误差就很小，前端网络w几乎没什么变化，等于这一层没能学习什么东西，网络层数越多就浪费了 解决方法：1、初始化一个合适的w2、选合适的激励函数 relu、leakrelu、elu等激活函数 relu函数：目前使用最多的激活函数 Relu(x)=max(x,0)函数图像： relu的主要贡献在于：优点：1、— 解决了梯度消失、爆炸的问题2、— 计算方便，计算速度快3、— 加速了网络的训练缺点：1、由于负数部分恒为0，会导致一些神经元无法激活（可通过设置小学习率部分解决）2、输出不是以0为中心的 leakrelu:leakrelu就是为了解决relu的0区间带来的影响 leakrelu=max(k*x,x)函数图像： 爆炸问题梯度爆炸：一般出现在深层网络和权值初始化值太大的情况下。当权值过大，前面层比后面层梯度变化更快，会引起梯度爆炸问题。]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>最优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[特征提取——局部特征]]></title>
    <url>%2F2018%2F07%2F16%2F%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E5%B1%80%E9%83%A8%E7%89%B9%E5%BE%81%2F</url>
    <content type="text"><![CDATA[特征提取——局部特征 LOG,HOG,DOG微分算子在近圆的斑点检测方面效果很好 HOG特征https://blog.csdn.net/coming_is_winter/article/details/72850511https://blog.csdn.net/zouxy09/article/details/7929348/123456总结：Dalal提出的Hog特征提取的过程：把样本图像分割为若干个像素的单元（cell），把梯度方向平均划分为9个区间（bin），在每个单元里面对所有像素的梯度方向在各个方向区间进行直方图统计，得到一个9维的特征向量，每相邻的4个单元构成一个块（block），把一个块内的特征向量联起来得到36维的特征向量，用块对样本图像进行扫描，扫描步长为一个单元。最后将所有块的特征串联起来，就得到了人体的特征。例如，对于64*128的图像而言，每16*16的像素组成一个cell，每2*2个cell组成一个块，因为每个cell有9个特征，所以每个块内有4*9=36个特征，以8个像素为步长，那么，水平方向将有7个扫描窗口，垂直方向将有15个扫描窗口。也就是说，64*128的图片，总共有36*7*15=3780个特征。特征总数： 一个cell有9个特征（9个梯度方向），每个特征cell块里有 num*9个特征，步长像素规格：（列像素数-步长）/步长*（行像素数-步长）/步长，总特征数:（列像素数-步长）/步长*（行像素数-步长）/步长*num*9 LOG特征1图像与某一个二维函数进行卷积运算实际就是求取图像与这一函数的相似性。同理，图像与高斯拉普拉斯函数的卷积实际就是求取图像与高斯拉普拉斯函数的相似性。当图像中的斑点尺寸与高斯拉普拉斯函数的形状趋近一致时，图像的拉普拉斯响应达到最大。 Laplace可以用来检测图像中的局部极值点，但是对噪声敏感，所以在我们对图像进行Laplace卷积之前，我们用一个高斯低通滤波对图像进行卷积，目标是去除图像中的噪声点123456789101112先对图像f(x,y)用方差为σ的高斯核进行高斯滤波，去除图像中的噪点。L(x,y;σ)=f(x,y)∗G(x,y;σ)G(x,y;σ)高斯核然后对图像的拉普拉斯图像则为：∇^2=(∂^2L/∂^x2)+(∂^2L/∂y^2)而实际上有下面等式：∇^2[G(x,y)∗f(x,y)]=∇^2[G(x,y)]∗f(x,y)我们可以先求高斯核的拉普拉斯算子，再对图像进行卷积 使用LoG虽然能较好的检测到图像中的特征点，但是其运算量过大，通常可使用DoG（差分高斯，Difference of Gaussina）来近似计算LoG Haar特征Haar特征分为三类：边缘特征、线性特征、中心特征和对角线特征，组合成特征模板。特征模板内有白色和黑色两种矩形，并定义该模板的特征值为白色矩形像素和减去黑色矩形像素和 Haar-like特征https://blog.csdn.net/zouxy09/article/details/7929570 1234567积分图就是只遍历一次图像就可以求出图像中所有区域像素和的快速算法，大大的提高了图像特征值计算的效率。 积分图主要的思想是将图像从起点开始到各个点所形成的矩形区域像素之和作为一个数组的元素保存在内存中，当要计算某个区域的像素和时可以直接索引数组的元素，不用重新计算这个区域的像素和，从而加快了计算（这有个相应的称呼，叫做动态规划算法）。积分图能够在多种尺度下，使用相同的时间（常数时间）来计算不同的特征，因此大大提高了检测速度。 我们来看看它是怎么做到的。 积分图是一种能够描述全局信息的矩阵表示方法。积分图的构造方式是位置（i,j）处的值ii(i,j)是原图像(i,j)左上角方向所有像素的和： 归一化图像123i¯(x,y)=(i(x,y)−μ)/cσ公式中i¯(x,y)表示归一化之后的图像，而i(x,y)表示原始的图像，其中μ表示图像的均值，而σ表示图像的标准差σ2=(1/N)∑x2−μ2 2是平方 SIFT特征SIFT的全称是Scale Invariant Feature Transform，尺度不变特征变换(物体怎么转，人都能识别)。SIFT特征对旋转、尺度缩放、亮度变化等保持不变性，是一种非常稳定的局部特征。 有4个主要步骤 1、尺度空间的极值检测 搜索所有尺度空间上的图像，通过高斯微分函数来识别潜在的对尺度和选择不变的兴趣点。12345678910$$$L(x,y,σ)=G(x,y,σ)∗I(x,y)$为了有效的在尺度空间检测到稳定的关键点，提出了高斯差分尺度空间（DOG scale-space）。利用不同尺度的高斯差分核与图像卷积生成。构造高斯差分尺度空间(DOG scale-space): $$D(x,y,σ)=(G(x,y,kσ)−G(x,y,σ))∗I(x,y)=L(x,y,kσ)−L(x,y,σ)$$σ 是尺度坐标。σ大小决定图像的平滑程度，大尺度对应图像的概貌特征，小尺度对应图像的细节特征。大的σ值对应粗糙尺度(低分辨率)，反之，对应精细尺度(高分辨率)。对于一幅图像I，建立其在不同尺度(scale)的图像,后面每个采样都是原图的1/4倍。每个点都要与邻域的点，上下相邻尺度的点做比较（9+8+9）26个点作比较（以确保在尺度空间和二维图像空间都检测到极值点）。一个点如果在DOG尺度空间本层以及上下两层的26个领域中是最大或最小值时，就认为该点是图像在该尺度下的一个特征点 2、特征点定位 在每个候选的位置上，通过一个拟合精细模型来确定位置尺度，关键点的选取依据他们的稳定程度。1拟和三维二次函数以精确确定关键点的位置和尺度，同时去除低对比度的关键点和不稳定的边缘响应点(因为DoG算子会产生较强的边缘响应)，以增强匹配稳定性、提高抗噪声能力 用Harris Corner检测参考文章 3、特征方向赋值 基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向，后续的所有操作都是对于关键点的方向、尺度和位置进行变换，从而提供这些特征的不变性。1每个特征点计算一个方向，依照这个方向做进一步的计算， *利用关键点邻域像素的梯度方向分布特性为每个关键点指定方向参数，使算子具备旋转不变性。 m(x,y)=(L(x+1,y)−L(x−1,y))2+(L(x,y+1)−L(x,y−1))2√θ(x,y)=atan2(L(x,y+1)−L(x,y−1)L(x+1,y)−L(x−1,y)每个关键点有三个信息：位置、所处尺度、方向。由此可以确定一个SIFT特征区域。4、特征点描述 在每个特征点周围的邻域内，在选定的尺度上测量图像的局部梯度，这些梯度被变换成一种表示，这种表示允许比较大的局部形状的变形和光照变换。 高斯函数是唯一可行的尺度空间核 尺度空间多分辨率图像金字塔:121、对原始图像进行平滑2、对处理后的图像进行降采样（通常是水平、垂直方向的1/2）降采样后得到一系列不断尺寸缩小的图像。显然，一个传统的金字塔中，每一层的图像是其上一层图像长、高的各一半。多分辨率的图像金字塔虽然生成简单，但其本质是降采样，图像的局部特征则难以保持，也就是无法保持特征的尺度不变性。 高斯尺度空间：12345678图像的模糊程度来模拟人在距离物体由远到近时物体在视网膜上成像过程，距离物体越近其尺寸越大图像也越模糊，这就是高斯尺度空间，使用不同的参数模糊图像（分辨率不变）图像和高斯函数进行卷积运算，图像模糊，使用不同的“高斯核”可得到不同模糊程度的图像L(x,y,σ)=G(x,y,σ)∗I(x,y)其中G(x,y,σ)是高斯核函数G(x,y,σ)=（1/2Πσ^2）e^((x^2+y^2)/(2σ^2)) 构建尺度空间的目的是为了检测出在不同的尺度下都存在的特征点，而检测特征点较好的算子是Δ^2G(高斯拉普拉斯,LoG） DoG特征使用LoG虽然能较好的检测到图像中的特征点，但是其运算量过大，通常可使用DoG（差分高斯，Difference of Gaussina）来近似计算LoG。 DOG可以看作为LOG的一个近似，但是它比LOG的效率更高。设k为相邻两个高斯尺度空间的比例因子，则DoG的定义： 1D(x,y,σ)=[G(x,y,kσ)−G(x,y,σ)]∗I(x,y)=L(x,y,kσ)−L(x,y,σ) L(x,y,σ) 是图像的高斯尺度空间将相邻的两个高斯空间的图像相减就得到了DoG的响应图像 Harris角点特征提取Harris角点检测是一种基于图像灰度的一阶导数矩阵检测方法。检测器的主要思想是局部自相似性/自相关性，即在某个局部窗口内图像块与在各个方向微小移动后的窗口内图像块的相似性。 1、角点可以是两个边缘的角点；&lt;/br&gt;2、角点是邻域内具有两个主方向的特征点；1人眼对角点的识别通常是在一个局部的小区域或小窗口完成的。如果在各个方向上移动这个特征的小窗口，窗口内区域的灰度发生了较大的变化，那么就认为在窗口内遇到了角点。如果这个特定的窗口在图像各个方向上移动时，窗口内图像的灰度没有发生变化，那么窗口内就不存在角点；如果窗口在某一个方向移动时，窗口内图像的灰度发生了较大的变化，而在另一些方向上没有发生变化，那么，窗口内的图像可能就是一条直线的线段。 x^{y^z}=(1+{\rm e}^x)^{-2xy^w}sqrt() 结论：1、增大α的值，将减小角点响应值R，降低角点检测的灵性，减少被检测角点的数量；减小α值，将增大角点响应值R，增加角点检测的灵敏性，增加被检测角点的数量。&lt;/br&gt;2、Harris角点检测算子对亮度和对比度的变化不敏感&lt;/br&gt;3、Harris角点检测算子具有旋转不变性&lt;/br&gt;4、Harris角点检测算子不具有尺度不变性&lt;/br&gt;]]></content>
      <tags>
        <tag>图像处理</tag>
        <tag>特征提取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[特征提取——纹理特征]]></title>
    <url>%2F2018%2F07%2F16%2F%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E7%BA%B9%E7%90%86%E7%89%B9%E5%BE%81%2F</url>
    <content type="text"><![CDATA[特征提取——纹理特征 LBP图像特征图像处理之特征提取（二）之LBP特征简单梳理https://blog.csdn.net/coming_is_winter/article/details/72859957https://blog.csdn.net/zouxy09/article/details/7929531LBP特征理解。http://blog.csdn.net/hqh45/article/details/24501097LBP（Local Binary Pattern，局部二值模式）是一种用来描述图像局部纹理特征的算子；它具有旋转不变性和灰度不变性等显著的优点。它是首先由T. Ojala, M.Pietikäinen, 和 D. Harwood 在1994年提出，用于纹理特征提取。而且，提取的特征是图像的局部的纹理特征；12lbp理论：原始的LBP算子定义为在3*3的窗口内，以窗口中心像素为阈值，将相邻的8个像素的灰度值与其进行比较，若周围像素值大于中心像素值，则该像素点的位置被标记为1，否则为0。这样，3*3邻域内的8个点经比较可产生8位二进制数（通常转换为十进制数即LBP码，共256种），即得到该窗口中心像素点的LBP值，并用这个值来反映该区域的纹理信息。 圆形LBP算子： 半径为R1基本的 LBP算子的最大缺陷在于它只覆盖了一个固定半径范围内的小区域，这显然不能满足不同尺寸和频率纹理的需要。为了适应不同尺度的纹理特征，并达到灰度和旋转不变性的要求，Ojala等对 LBP 算子进行了改进，将 3×3邻域扩展到任意邻域，并用圆形邻域代替了正方形邻域，改进后的 LBP 算子允许在半径为 R 的圆形邻域内有任意多个像素点。从而得到了诸如半径为R的圆形区域内含有P个采样点的LBP算子； 即不断旋转圆形邻域得到一系列初始定义的 LBP值，取其最小值作为该邻域的 LBP 值。 灰度共生矩阵（GLCM，Gray-Level Co-occurrence Matrix）概念： 灰度共生矩阵是涉及像素距离和角度的矩阵函数，它通过计算图像中一定距离和一定方向的两点灰度之间的相关性，来反映图像在方向、间隔、变化幅度及快慢上的综合信息。灰度直方图是对图像上单个像素具有某个灰度进行统计的结果，而灰度共生矩阵是对图像上保持某距离的两像素分别具有某灰度的状况进行统计得到的。 含义：以（1，1）点为例，GLCM（1，1）值为1说明左侧原图只有一对灰度为1的像素水平相邻。GLCM（1，2）值为2，是因为原图有两对灰度为1和2的像素水平相邻。 1234567891011矩阵|1 2 1||2 2 2| |1 2 2|对应GLMC矩阵（最大是2，所以是2*2矩阵）GLCM矩阵: 1 21|0 2| 2|1 6|0(1,1)相邻， 2(1,2)水平相邻， 2(2,1)垂直相邻， 6(2,2)相邻 灰度共生矩阵的特征 1) 角二阶矩（Angular Second Moment, ASM)公式：$ASM = sum(p(i,j)^2)$，其中 $p(i,j) $表示归一后的灰度共生矩阵意义：角二阶矩是图像灰度分布均匀程度和纹理粗细的一个度量，当图像纹理绞细致、灰度分布均匀时，能量值较大，反之，较小。 结论：值大，灰度分布均匀 2) 熵（Entropy, ENT)公式：$ENT=sum[-p(i,j)log(p(i,j))] $意义：描述图像具有的信息量的度量，表明图像的复杂程度，当复杂程度高时，熵值较大，反之则较小。 结论：值大，复杂程度高 3) 反差分矩阵（Inverse Differential Moment, IDM)公式：$IDM=sum[p(i,j)/(1+(i-j)^2)]$意义：反映了纹理的清晰程度和规则程度，纹理清晰、规律性较强、易于描述的，值较大；杂乱无章的，难于描述的，值较小。 结论：值大，纹理清晰、规律性较强 Gabor小波Gabor函数是一个用于边缘提取的线性滤波器 作用：Gabor小波可以方便的提取图像在各个尺度和方向上的纹理信息，同时在一定程度上降低了图像中光照变化和噪声的影响。提取目标的局部空间和频率域信息方面具有良好的特性。特点：1、Gabor小波对于图像的边缘敏感2、对光照不敏感3、对图像旋转有一定适应性 灰度共生矩阵opencv代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151// 0°灰度共生矩阵void getGLCM0(Mat&amp; src, Mat&amp; dst, int gray_level)// 0度灰度共生矩阵&#123; CV_Assert(1 == src.channels()); int height = src.rows; int width = src.cols; dst.create(gray_level, gray_level, CV_32SC1); dst = Scalar::all(0); for (int i = 0; i &lt; height; i++) &#123; int*srcdata = src.ptr&lt;int&gt;(i); for (int j = 0; j &lt; width - 1; j++) &#123; // 同样的像素对，水平相邻 int rows = srcdata[j]; int cols = srcdata[j + 1]; dst.ptr&lt;int&gt;(rows)[cols]++; &#125; &#125; &#125; // 90°灰度共生矩阵void getGLCM90(Mat&amp; src, Mat&amp; dst, int gray_level)&#123; CV_Assert(1 == src.channels()); int height = src.rows; int width = src.cols; dst = Mat(gray_level, gray_level, CV_32SC1, Scalar(0)); for (int i = 0; i &lt; height - 1; i++) &#123; int*srcdata = src.ptr&lt;int&gt;(i); int*srcdata1 = src.ptr&lt;int&gt;(i + 1); for (int j = 0; j &lt; width; j++) &#123; // 同样的像素对，垂直相邻 int rows = srcdata[j]; int cols = srcdata1[j]; dst.ptr&lt;int&gt;(rows)[cols]++; &#125; &#125;&#125; // 45°灰度共生矩阵void getGLCM45(Mat&amp; src, Mat&amp; dst, int gray_level)&#123; CV_Assert(1 == src.channels()); int height = src.rows; int width = src.cols; dst = Mat(gray_level, gray_level, CV_32SC1, Scalar(0)); for (int i = 0; i &lt; height - 1; i++) &#123; int*srcdata = src.ptr&lt;int&gt;(i); int*srcdata1 = src.ptr&lt;int&gt;(i + 1); for (int j = 0; j &lt; width - 1; j++) &#123; // 同样的像素对，45°相邻 int rows = srcdata[j]; int cols = srcdata1[j + 1]; dst.ptr&lt;int&gt;(rows)[cols]++; &#125; &#125;&#125; // 135°灰度共生矩阵void getGLCM135(Mat&amp; src, Mat&amp; dst, int gray_level)&#123; CV_Assert(1 == src.channels()); int height = src.rows; int width = src.cols; dst = Mat(gray_level, gray_level, CV_32SC1, Scalar(0)); for (int i = 0; i &lt; height - 1; i++) &#123; int*srcdata = src.ptr&lt;int&gt;(i); int*srcdata1 = src.ptr&lt;int&gt;(i + 1); for (int j = 1; j &lt; width; j++) &#123; // 同样的像素对，135°相邻 int rows = srcdata[j]; int cols = srcdata1[j - 1]; dst.ptr&lt;int&gt;(rows)[cols]++; &#125; &#125; &#125; // 计算特征值void featureGLCM(Mat&amp;src, double&amp; Asm, double&amp; Ent, double&amp; Con, double&amp; Idm)&#123; CV_Assert(src.channels() == 1); int height = src.rows; int width = src.cols; int total = 0; //求图像所有像素的灰度值的和 for (int i = 0; i &lt; height; i++) &#123; int*srcdata = src.ptr&lt;int&gt;(i); for (int j = 0; j &lt; width; j++) &#123; total += srcdata[j]; &#125; &#125; //图像每一个像素的的值除以像素总和 Mat mean; mean.create(height, width, CV_64FC1); for (int i = 0; i &lt; height; i++) &#123; int*srcdata = src.ptr&lt;int&gt;(i); double*copydata = mean.ptr&lt;double&gt;(i); for (int j = 0; j &lt; width; j++) &#123; copydata[j] = (double)srcdata[j] / (double)total; &#125; &#125; for (int i = 0; i &lt; height; i++) &#123; double*srcdata = mean.ptr&lt;double&gt;(i); for (int j = 0; j &lt; width; j++) &#123; // 能量 Asm += srcdata[j] * srcdata[j]; // 熵(Entropy) if (srcdata[j]&gt;0) Ent -= srcdata[j] * log(srcdata[j]); // 对比度 Con += (double)(i - j)*(double)(i - j)*srcdata[j]; // 逆差矩 Idm += srcdata[j] / (1 + (double)(i - j)*(double)(i - j)); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>图像处理</tag>
        <tag>特征提取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[特征提取——局部特征-SIFT算法尺度不变性的理解]]></title>
    <url>%2F2018%2F07%2F16%2F%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E5%B1%80%E9%83%A8%E7%89%B9%E5%BE%81_SIFT%2F</url>
    <content type="text"><![CDATA[特征提取——局部特征 参考这个就完事了 局部特征不管原图尺度是多少，在包含了所有尺度的尺度空间下都能找到那些稳定的极值点，这样就做到了尺度不变！ 高斯函数是唯一可行的尺度空间核比如说一张美女图片，想要框出帽子的信息，图像尺寸小时框要这么大，图像尺寸大时，框也要相应调大： 尺度不变性： L(x,y,σ)=G(x,y,σ)*I(x,y)为了有效的在尺度空间检测到稳定的关键点，提出了高斯差分尺度空间（DOG scale-space）。利用不同尺度的高斯差分核与图像卷积生成。构造高斯差分尺度空间(DOG scale-space): D(x,y,σ)=(G(x,y,kσ)-G(x,y,σ))*I(x,y)=L(x,y,kσ)-L(x,y,σ)σ 是尺度坐标。σ大小决定图像的平滑程度，大尺度对应图像的概貌特征，小尺度对应图像的细节特征。大的σ值对应粗糙尺度(低分辨率)，反之，对应精细尺度(高分辨率)。 旋转不变性：123Lowe采用的方法是在生成描述子前将图片旋转到一个特定的方向上，这个方向是根据图片内容得到的，具体就是用在某个半径大小的圆内的像素的梯度信息。sigma取的是1.5*&lt;scale of key point&gt;,r取3*sigma将图片先旋转到主方向，这个方向由于是用相同的信息得到的，所以总是指向同一方。 抵抗噪声：1DoG得到极值点后，去除低对比度的点的点舍弃,在确定主方向和生成描述子时都将梯度模值加进行加权，即是噪声影响了部分点，经过加权统计会抑制变化，不会对全局造成太大影响 参考文章 OpenCV代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// opencv_empty_proj.cpp : 定义控制台应用程序的入口点。// #include &quot;stdafx.h&quot;#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/features2d/features2d.hpp&gt;#include&lt;opencv2/nonfree/nonfree.hpp&gt;#include&lt;opencv2/legacy/legacy.hpp&gt;#include&lt;vector&gt;using namespace std;using namespace cv; int _tmain(int argc, _TCHAR* argv[])&#123; const char* imagename = &quot;img.jpg&quot;; //从文件中读入图像 Mat img = imread(imagename); Mat img2=imread(&quot;img2.jpg&quot;); //如果读入图像失败 if(img.empty()) &#123; fprintf(stderr, &quot;Can not load image %s\n&quot;, imagename); return -1; &#125; if(img2.empty()) &#123; fprintf(stderr, &quot;Can not load image %s\n&quot;, imagename); return -1; &#125; //显示图像 imshow(&quot;image before&quot;, img); imshow(&quot;image2 before&quot;,img2); //sift特征检测 SiftFeatureDetector siftdtc; vector&lt;KeyPoint&gt;kp1,kp2; siftdtc.detect(img,kp1); Mat outimg1; drawKeypoints(img,kp1,outimg1); imshow(&quot;image1 keypoints&quot;,outimg1); KeyPoint kp; vector&lt;KeyPoint&gt;::iterator itvc; for(itvc=kp1.begin();itvc!=kp1.end();itvc++) &#123; cout&lt;&lt;&quot;angle:&quot;&lt;&lt;itvc-&gt;angle&lt;&lt;&quot;\t&quot;&lt;&lt;itvc-&gt;class_id&lt;&lt;&quot;\t&quot;&lt;&lt;itvc-&gt;octave&lt;&lt;&quot;\t&quot;&lt;&lt;itvc-&gt;pt&lt;&lt;&quot;\t&quot;&lt;&lt;itvc-&gt;response&lt;&lt;endl; &#125; siftdtc.detect(img2,kp2); Mat outimg2; drawKeypoints(img2,kp2,outimg2); imshow(&quot;image2 keypoints&quot;,outimg2); SiftDescriptorExtractor extractor; Mat descriptor1,descriptor2; BruteForceMatcher&lt;L2&lt;float&gt;&gt; matcher; vector&lt;DMatch&gt; matches; Mat img_matches; extractor.compute(img,kp1,descriptor1); extractor.compute(img2,kp2,descriptor2); imshow(&quot;desc&quot;,descriptor1); cout&lt;&lt;endl&lt;&lt;descriptor1&lt;&lt;endl; matcher.match(descriptor1,descriptor2,matches); drawMatches(img,kp1,img2,kp2,matches,img_matches); imshow(&quot;matches&quot;,img_matches); //此函数等待按键，按键盘任意键就返回 waitKey(); return 0;&#125;]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[特征提取——颜色特征]]></title>
    <url>%2F2018%2F07%2F16%2F%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E9%A2%9C%E8%89%B2%E7%89%B9%E5%BE%81%2F</url>
    <content type="text"><![CDATA[特征提取——颜色特征 颜色直方图OpenCV之颜色空间: 颜色空间RGB（Red 红色，Green 绿色，Blue 蓝色） R的取值范围：0-255 G的取值范围：0-255 B的取值范围：0-255 颜色空间HSV （Hue 色相，Saturation 饱和度，intensity 亮度） H的取值范围：0-179 S的取值范围：0-255 V的取值范围：0-255 颜色空间HLS (Hue 色相，lightness 亮度，Saturation 饱和度) H的取值范围：0-179 L的取值范围：0-255 S的取值范围：0-255 颜色矩这种方法的数学基础在于图像中任何的颜色分布均可以用它的矩来表示。此外，由于颜色分布信息主要集中在低阶矩中，因此仅采用颜色的一阶矩（mean）、二阶矩（variance）和三阶矩（skewness）就足以表达图像的颜色分布。与颜色直方图相比，该方法的另一个好处在于无需对特征进行向量化。图像的颜色矩一共只需要9个分量（3个颜色分量，每个分量上3个低阶矩）颜色矩常和其它特征结合使用，而且一般在使用其它特征前起到过滤缩小范围（narrow down）的作用。 一阶矩(均值,mean),反映图像明暗程度1u=(1/N)sum(Pij) 二阶矩(方差,viarance),反映图像颜色分布范围1a=sqrt(((1/N)sum(Pij-u)^2),2) 三阶矩(斜度,skewness),反映图像颜色分布对称性1a=sqrt(((1/N)sum(Pij-u)^3),3)]]></content>
      <tags>
        <tag>图像处理</tag>
        <tag>特征提取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理_边缘检测]]></title>
    <url>%2F2018%2F07%2F16%2F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[图像处理_边缘检测 边缘检测：https://blog.csdn.net/tigerda/article/details/61192943 常见边缘检测算子：Roberts 、Sobel 、Prewitt、Laplacian、Log/Marr、Canny、Kirsch、Nevitia&lt;/br&gt; 一阶微分算子：Roberts 、Sobel 、Prewitt&lt;/br&gt;1234567891011121314151617181920模板：Roberts |1, 0||0,-1|sobel算子|1, 0 , 1||1, 0 , 1||1, 0 , 1|prewitt算子|1, 0 , 1||1, 0 , 1||1, 0 , 1|Sobel各向同性算子: |-1 ,0, 1| |-1,-跟2,-1|Gx=|-跟2,0,跟2| ,Gx=| 0, 0, 0| |-1 ,0, 1| | 1, 跟2, 1| Sobel各向同性算子的权值比普通Sobel算子的权值更准确。为什么？模板的权值是离中心位置越远则权值（看绝对值）影响越小123456789101112计算边缘幅值与方向？以Sobel算子为例。3*3Sobel两个方向的算子在图像上滑动，模板与其覆盖的图像3*3区域9个像素进行卷积，求和后得到此方向的边缘检测幅值。 |-1,0,1| |-1,-2,-1|Gx=|-2,0,2|*f(x,y) ,Gx=| 0, 0, 0|*f(x,y) |-1,0,1| | 1, 2, 1|G^2=Gx^2+Gy^2P=arctan(Gx/Gy)f(x,y)为图像，Gx和Gy分别是水平和竖直方向算子的卷积结果，G则是最终得到的边缘幅值，θ值则是边缘方向。当然G的计算有时简化为G=|Gx|+|Gy| 或者 G=max(|Gx|,|Gy|) 二阶微分算子：Laplacian、Log/Marr123456789101112131415Laplacian算子 |-1,-1,-1| Gx=|-1, 8,-1| |-1,-1,-1| | 0,-1, 0| Gx=|-1, 4,-1| | 0,-1, 0| |-2,-4,-4,-4,-2| |-4, 0, 8, 0,-4| Gx=|-4, 8,24, 8,-4| |-4, 0, 8, 0,-4| |-2,-4,-4,-4,-2|Log边缘检测则是先进行高斯滤波再进行拉普拉斯算子检测 非微分边缘检测算子：Canny 算 子 优缺点比较 Roberts 对具有陡峭的低噪声的图像处理效果较好，但利用 Roberts算子提取边缘的结果是边缘比较粗，因此边缘定位不是很准确。 Sobel 对灰度渐变和噪声较多的图像处理效果比较好， Sobel算子对边缘定位比较准确。 Kirsch 对灰度渐变和噪声较多的图像处理效果较好。 Prewitt 对灰度渐变和噪声较多的图像处理效果较好。 aplacian 对图像中的阶跃性边缘点定位准确，对噪声非常敏感，丢失一部分边缘的方向信息，造成一些不连续的检测边缘。 LoG 算 子 经 常 出 现 双 边 缘 像 素 边 界 ， 而 且 该 检 测 方 法 对 噪 声 比铰 敏 感 ， 所 以 很 少 用 LoG算 子 检 测 边 缘 ， 而 是 用 来 判 断 边 缘 像素是位于图像的明区还是暗区。 Canny 此方法不容易受噪声的干扰，能够检测到真正的弱边缘。在edge函数中，最有效的边缘检测方法是 Canny方法。该方法的优点在于使用两种不同的阈值分别检测强边缘和弱边缘，并且汉当弱边缘与强边缘相连时，才将弱边缘包含在输出图像中。因此，这种方法不容易被噪声“填充”，跟容易检测出真正的弱边缘。]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习—聚类降维]]></title>
    <url>%2F2018%2F07%2F09%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E9%99%8D%E7%BB%B4_GMM_KMEANS%2F</url>
    <content type="text"><![CDATA[机器学习—聚类降维 机器学习—Kmeans聚类属于无监督学习，朴素贝叶斯、SVM等都是有类别标签y的，即已经给出了样本的分类 12345671、随机给K个聚类质心 v2、重复下面过程直到收敛2.1对于每一个样例i，计算其应该属于的类 隶属度 ：zi=argmin||xi−μj||^2求距离近的2.2 聚类中心 u= 其聚类精度明显优于传统的随机选择种子的方法，且计算速度也比较快。而对于更大型的数据集，kmeans++需要进一步扩展，才能获取更好的表现，即kmeans是高度可扩展的。 机器学习—GMM常用作聚类，可以运动目标检测。 高斯混合模型（Gaussian Mixed Model）指的是多个高斯分布函数的线性组合，理论上GMM可以拟合出任意类型的分布，通常用于解决同一集合下的数据包含多个不同的分布的情况（或者是同一类分布但参数不一样，或者是不同类型的分布，比如正态分布和伯努利分布） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 基于混合高斯模型的运动目标检测// Author： http://blog.csdn.net/icvpr #include &lt;iostream&gt;#include &lt;string&gt; #include &lt;opencv2/opencv.hpp&gt; int main(int argc, char** argv)&#123; std::string videoFile = &quot;../test.avi&quot;; cv::VideoCapture capture; capture.open(videoFile); if (!capture.isOpened()) &#123; std::cout&lt;&lt;&quot;read video failure&quot;&lt;&lt;std::endl; return -1; &#125; cv::BackgroundSubtractorMOG2 mog; cv::Mat foreground; cv::Mat background; cv::Mat frame; long frameNo = 0; while (capture.read(frame)) &#123; ++frameNo; std::cout&lt;&lt;frameNo&lt;&lt;std::endl; // 运动前景检测，并更新背景 mog(frame, foreground, 0.001); // 腐蚀 cv::erode(foreground, foreground, cv::Mat()); // 膨胀 cv::dilate(foreground, foreground, cv::Mat()); mog.getBackgroundImage(background); // 返回当前背景图像 cv::imshow(&quot;video&quot;, foreground); cv::imshow(&quot;background&quot;, background); if (cv::waitKey(25) &gt; 0) &#123; break; &#125; &#125; return 0;&#125; EM算法：第一步先求出要估计参数的粗略值。第二步使用第一步的值最大化似然函数。因此要先求出GMM的似然函数。]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Opencv</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown 基本用法(常用)]]></title>
    <url>%2F2018%2F07%2F01%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[markdown 基本用法 在线markdown编辑器 标题类别一级标题用”&lt;/h数字&gt;”或者多个”#”隔开 &lt;h1&gt;一级标题&lt;/h1&gt; # 一级标题 二级标题 &lt;h2&gt;二级标题&lt;/h2&gt; ## 二级标题 以此类推 代码块四个空格后开始写代码（空空空空zxcvbasdfgqwert） 或者用12 AAA 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 (四个空格两个字节)zxcvbasdfgqwert--- ## 语句强调&lt;h3&gt;斜体&lt;/h3&gt;文字两端使用1个&quot;*&quot;或者&quot;_&quot;夹起来*a* *a* 或者 _a_---### 粗体文字两端使用2个&quot;*&quot;或者&quot;_&quot;夹起来---### 分隔线三个&quot;*&quot;或者&quot;-&quot; *** ------## 无序列表使用加号&quot;+&quot;或是减号&quot;-&quot;作为列表标记：+ 可乐+ 雪碧 +（空格）可乐 +（空格）雪碧---## emoji表情Markdown文档支持文中插入emoji表情比如：&lt;br&gt;`:laughing:` 表示:laughing:`:heart:` 表示:heart:其他emoji的地址如下链接：[emoji地址](https://github.com/guodongxiaren/README/blob/master/emoji.md)## 引用`&gt;`表示引用 `&gt;&gt;` 表示引用中的引用效果展示:&gt;引用(一个小于号) &gt;&gt; 引用中的引用（两个小于号）---### 1. 斜体和粗体使用 * 和 ** 表示斜体和粗体。示例：这是 *斜体*，这是 **粗体**。### 2. 分级标题使用 === 表示一级标题，使用 --- 表示二级标题。示例： 这是一个一级标题这是一个二级标题这是一个三级标题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。### 3. 外链接使用 \[描述](链接地址) 为文字增加外链接。示例：这是去往 [本人博客](http://ghosertblog.github.com) 的链接。### 4. 无序列表使用 `*`，`+`或者`-` 表示无序列表。示例：- 无序列表项 一- 无序列表项 二- 无序列表项 三### 5. 有序列表使用数字和点表示有序列表。`1.`示例：1. 有序列表项 一2. 有序列表项 二3. 有序列表项 三### 6. 文字引用使用 &gt; 表示文字引用。示例：&gt; 野火烧不尽，春风吹又生。### 7. 行内代码块使用 上顿点\`代码` 表示行内代码块。&gt;`代码`示例：让我们聊聊 `html`。### 8. 代码块使用 四个缩进空格 或者上下三个上顿点 表示代码块。&gt;\` 上顿点前后各三个示例： 这是一个代码块，此行左侧有四个不可见的空格。### 9. 插入图像使用 \!\[描述](图片链接地址) 插入图像。示例：[![kZq279.jpg](https://s2.ax1x.com/2019/01/24/kZq279.jpg)](https://imgchr.com/i/kZq279)# Cmd Markdown 高阶语法手册### 1. 内容目录在段落中填写 `[TOC]` 以显示全文内容的目录结构。[TOC]### 2. 标签分类在编辑区任意行的列首位置输入以下代码给文稿标签：标签： 数学 英语 Markdown或者Tags： 数学 英语 Markdown### 3. 删除线使用 ~~ 表示删除线。~~这是一段错误的文本。~~### 4. 注脚使用 [^keyword] 表示注脚。这是一个注脚[^footnote]的样例。这是第二个注脚[^footnote2]的样例。### 5. LaTeX 公式$ 表示行内公式： 质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。$$ 表示整行公式：$$\sum_&#123;i=1&#125;^n a_i=0$$$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$$$\sum^&#123;j-1&#125;_&#123;k=0&#125;&#123;\widehat&#123;\gamma&#125;_&#123;kj&#125; z_k&#125;$$访问 [MathJax](http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference) 参考更多使用方法。### 6. 加强的代码块支持四十一种编程语言的语法高亮的显示，行号显示。非代码示例： $ sudo apt-get install vim-gnome12345678910111213141516Python 示例：```python@requires_authorizationdef somefunc(param1=&apos;&apos;, param2=0): &apos;&apos;&apos;A docstring&apos;&apos;&apos; if param1 &gt; param2: # interesting print &apos;Greater&apos; return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = &apos;&apos;&apos;interpreter... prompt&apos;&apos;&apos; JavaScript 示例： 1234567891011121314151617/*** nth element in the fibonacci series.* @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) &#123; var a = 1, b = 1; var tmp; while (--n &gt;= 0) &#123; tmp = a; a += b; b = tmp; &#125; return a;&#125;document.write(fib(10)); 7. 流程图示例12345678910st=&gt;start: Start:&gt;https://www.zybuluo.comio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io 更多语法参考：流程图语法参考8. 序列图示例 1123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 示例 212345Title: Here is a titleA-&gt;B: Normal lineB--&gt;C: Dashed lineC-&gt;&gt;D: Open arrowD--&gt;&gt;A: Dashed open arrow 更多语法参考：序列图语法参考9. 甘特图甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。 12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 更多语法参考：甘特图语法参考10. Mermaid 流程图1234A[Hard edge] --&gt;|Link text| B(Round edge)B --&gt; C&#123;Decision&#125;C --&gt;|One| D[Result one]C --&gt;|Two| E[Result two] 更多语法参考：Mermaid 流程图语法参考11. Mermaid 序列图1234Alice-&gt;John: Hello John, how are you?loop every minute John--&gt;Alice: Great!end 更多语法参考：Mermaid 序列图语法参考12. 表格支持 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 13. 定义型列表名词 1: 定义 1（左侧有一个可见的冒号和四个不可见的空格） 代码块 2: 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 14. Html 标签本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格： &lt;table&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李强&lt;/td&gt; &lt;td&gt;张明&lt;/td&gt; &lt;td&gt;王平&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 值班人员 星期一 星期二 星期三 李强 张明 王平 15. 内嵌图标本站的图标系统对外开放，在文档中输入 &lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt; 即显示微博的图标： 替换 上述 i 标签 内的 icon-weibo 以显示不同的图标，例如： &lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt; 即显示人人的图标： 更多的图标和玩法可以参看 font-awesome 官方网站。 16. 待办事宜 Todo 列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如： - [ ] **Cmd Markdown 开发** - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 - [ ] 支持以 PDF 格式导出文稿 - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments) - [x] 改进 LaTex 功能 - [x] 修复 LaTex 公式渲染问题 - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers) - [ ] **七月旅行准备** - [ ] 准备邮轮上需要携带的物品 - [ ] 浏览日本免税店的物品 - [x] 购买蓝宝石公主号七月一日的船票 对应显示如下待办事宜 Todo 列表： [ ] Cmd Markdown 开发 [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 [ ] 支持以 PDF 格式导出文稿 [x] 新增Todo列表功能 语法参考 [x] 改进 LaTex 功能 [x] 修复 LaTex 公式渲染问题 [x] 新增 LaTex 公式编号功能 语法参考 [ ] 七月旅行准备 [ ] 准备邮轮上需要携带的物品 [ ] 浏览日本免税店的物品 [x] 购买蓝宝石公主号七月一日的船票 footnote. 这是一个 注脚 的 文本。 &#8617; footnote2. 这是另一个 注脚 的 文本。 &#8617; 字体123456&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=7 face=&quot;黑体&quot;&gt;color=#0099ff size=72 face=&quot;黑体&quot;&lt;/font&gt;&lt;font color=#00ffff size=72&gt;color=#00ffff&lt;/font&gt;&lt;font color=gray size=72&gt;color=gray&lt;/font&gt; 颜色123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144颜色名 十六进制颜色值 颜色AliceBlue #F0F8FF rgb(240, 248, 255)AntiqueWhite #FAEBD7 rgb(250, 235, 215)Aqua #00FFFF rgb(0, 255, 255)Aquamarine #7FFFD4 rgb(127, 255, 212)Azure #F0FFFF rgb(240, 255, 255)Beige #F5F5DC rgb(245, 245, 220)Bisque #FFE4C4 rgb(255, 228, 196)Black #000000 rgb(0, 0, 0)BlanchedAlmond #FFEBCD rgb(255, 235, 205)Blue #0000FF rgb(0, 0, 255)BlueViolet #8A2BE2 rgb(138, 43, 226)Brown #A52A2A rgb(165, 42, 42)BurlyWood #DEB887 rgb(222, 184, 135)CadetBlue #5F9EA0 rgb(95, 158, 160)Chartreuse #7FFF00 rgb(127, 255, 0)Chocolate #D2691E rgb(210, 105, 30)Coral #FF7F50 rgb(255, 127, 80)CornflowerBlue #6495ED rgb(100, 149, 237)Cornsilk #FFF8DC rgb(255, 248, 220)Crimson #DC143C rgb(220, 20, 60)Cyan #00FFFF rgb(0, 255, 255)DarkBlue #00008B rgb(0, 0, 139)DarkCyan #008B8B rgb(0, 139, 139)DarkGoldenRod #B8860B rgb(184, 134, 11)DarkGray #A9A9A9 rgb(169, 169, 169)DarkGreen #006400 rgb(0, 100, 0)DarkKhaki #BDB76B rgb(189, 183, 107)DarkMagenta #8B008B rgb(139, 0, 139)DarkOliveGreen #556B2F rgb(85, 107, 47)Darkorange #FF8C00 rgb(255, 140, 0)DarkOrchid #9932CC rgb(153, 50, 204)DarkRed #8B0000 rgb(139, 0, 0)DarkSalmon #E9967A rgb(233, 150, 122)DarkSeaGreen #8FBC8F rgb(143, 188, 143)DarkSlateBlue #483D8B rgb(72, 61, 139)DarkSlateGray #2F4F4F rgb(47, 79, 79)DarkTurquoise #00CED1 rgb(0, 206, 209)DarkViolet #9400D3 rgb(148, 0, 211)DeepPink #FF1493 rgb(255, 20, 147)DeepSkyBlue #00BFFF rgb(0, 191, 255)DimGray #696969 rgb(105, 105, 105)DodgerBlue #1E90FF rgb(30, 144, 255)Feldspar #D19275 rgb(209, 146, 117)FireBrick #B22222 rgb(178, 34, 34)FloralWhite #FFFAF0 rgb(255, 250, 240)ForestGreen #228B22 rgb(34, 139, 34)Fuchsia #FF00FF rgb(255, 0, 255)Gainsboro #DCDCDC rgb(220, 220, 220)GhostWhite #F8F8FF rgb(248, 248, 255)Gold #FFD700 rgb(255, 215, 0)GoldenRod #DAA520 rgb(218, 165, 32)Gray #808080 rgb(128, 128, 128)Green #008000 rgb(0, 128, 0)GreenYellow #ADFF2F rgb(173, 255, 47)HoneyDew #F0FFF0 rgb(240, 255, 240)HotPink #FF69B4 rgb(255, 105, 180)IndianRed #CD5C5C rgb(205, 92, 92)Indigo #4B0082 rgb(75, 0, 130)Ivory #FFFFF0 rgb(255, 255, 240)Khaki #F0E68C rgb(240, 230, 140)Lavender #E6E6FA rgb(230, 230, 250)LavenderBlush #FFF0F5 rgb(255, 240, 245)LawnGreen #7CFC00 rgb(124, 252, 0)LemonChiffon #FFFACD rgb(255, 250, 205)LightBlue #ADD8E6 rgb(173, 216, 230)LightCoral #F08080 rgb(240, 128, 128)LightCyan #E0FFFF rgb(224, 255, 255)LightGoldenRodYellow #FAFAD2 rgb(250, 250, 210)LightGrey #D3D3D3 rgb(211, 211, 211)LightGreen #90EE90 rgb(144, 238, 144)LightPink #FFB6C1 rgb(255, 182, 193)LightSalmon #FFA07A rgb(255, 160, 122)LightSeaGreen #20B2AA rgb(32, 178, 170)LightSkyBlue #87CEFA rgb(135, 206, 250)LightSlateBlue #8470FF rgb(132, 112, 255)LightSlateGray #778899 rgb(119, 136, 153)LightSteelBlue #B0C4DE rgb(176, 196, 222)LightYellow #FFFFE0 rgb(255, 255, 224)Lime #00FF00 rgb(0, 255, 0)LimeGreen #32CD32 rgb(50, 205, 50)Linen #FAF0E6 rgb(250, 240, 230)Magenta #FF00FF rgb(255, 0, 255)Maroon #800000 rgb(128, 0, 0)MediumAquaMarine #66CDAA rgb(102, 205, 170)MediumBlue #0000CD rgb(0, 0, 205)MediumOrchid #BA55D3 rgb(186, 85, 211)MediumPurple #9370D8 rgb(147, 112, 216)MediumSeaGreen #3CB371 rgb(60, 179, 113)MediumSlateBlue #7B68EE rgb(123, 104, 238)MediumSpringGreen #00FA9A rgb(0, 250, 154)MediumTurquoise #48D1CC rgb(72, 209, 204)MediumVioletRed #C71585 rgb(199, 21, 133)MidnightBlue #191970 rgb(25, 25, 112)MintCream #F5FFFA rgb(245, 255, 250)MistyRose #FFE4E1 rgb(255, 228, 225)Moccasin #FFE4B5 rgb(255, 228, 181)NavajoWhite #FFDEAD rgb(255, 222, 173)Navy #000080 rgb(0, 0, 128)OldLace #FDF5E6 rgb(253, 245, 230)Olive #808000 rgb(128, 128, 0)OliveDrab #6B8E23 rgb(107, 142, 35)Orange #FFA500 rgb(255, 165, 0)OrangeRed #FF4500 rgb(255, 69, 0)Orchid #DA70D6 rgb(218, 112, 214)PaleGoldenRod #EEE8AA rgb(238, 232, 170)PaleGreen #98FB98 rgb(152, 251, 152)PaleTurquoise #AFEEEE rgb(175, 238, 238)PaleVioletRed #D87093 rgb(216, 112, 147)PapayaWhip #FFEFD5 rgb(255, 239, 213)PeachPuff #FFDAB9 rgb(255, 218, 185)Peru #CD853F rgb(205, 133, 63)Pink #FFC0CB rgb(255, 192, 203)Plum #DDA0DD rgb(221, 160, 221)PowderBlue #B0E0E6 rgb(176, 224, 230)Purple #800080 rgb(128, 0, 128)Red #FF0000 rgb(255, 0, 0)RosyBrown #BC8F8F rgb(188, 143, 143)RoyalBlue #4169E1 rgb(65, 105, 225)SaddleBrown #8B4513 rgb(139, 69, 19)Salmon #FA8072 rgb(250, 128, 114)SandyBrown #F4A460 rgb(244, 164, 96)SeaGreen #2E8B57 rgb(46, 139, 87)SeaShell #FFF5EE rgb(255, 245, 238)Sienna #A0522D rgb(160, 82, 45)Silver #C0C0C0 rgb(192, 192, 192)SkyBlue #87CEEB rgb(135, 206, 235)SlateBlue #6A5ACD rgb(106, 90, 205)SlateGray #708090 rgb(112, 128, 144)Snow #FFFAFA rgb(255, 250, 250)SpringGreen #00FF7F rgb(0, 255, 127)SteelBlue #4682B4 rgb(70, 130, 180)Tan #D2B48C rgb(210, 180, 140)Teal #008080 rgb(0, 128, 128)Thistle #D8BFD8 rgb(216, 191, 216)Tomato #FF6347 rgb(255, 99, 71)Turquoise #40E0D0 rgb(64, 224, 208)Violet #EE82EE rgb(238, 130, 238)VioletRed #D02090 rgb(208, 32, 144)Wheat #F5DEB3 rgb(245, 222, 179)White #FFFFFF rgb(255, 255, 255)WhiteSmoke #F5F5F5 rgb(245, 245, 245)Yellow #FFFF00 rgb(255, 255, 0)YellowGreen #9ACD32 rgb(154, 205, 50)]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git上传文件到Github]]></title>
    <url>%2F2018%2F07%2F01%2Fgit_git2github%2F</url>
    <content type="text"><![CDATA[准备工作： 1、电脑装有Git2、GitHub 已有仓库 1、克隆GitHub仓库，到本地 文件夹右键选择Git Bash Here，输入代码 1Git clone git@github.com:用户名/仓库名.git 2、放置代码内容到第一步下载的文件夹里 3、执行代码 123git add .git commit -m &quot;情况说明&quot;git push origin master 4、上传成功 多电脑同步使用电脑搭建好博客后可能面临如下问题 1、是在家里私人电脑上搭建的，想在公司也可以愉快的写文章2、换了一台新的电脑（挣钱了要换装备😂）3、电脑系统崩了😭 关于多电脑同步解决方案1 gitHub分支管理，master分支存博客静态网页资源，Hexo分支存所有源文件（设置为默认分支）每个电脑每次更新文章前需要正常的git同步操作每个电脑每次更新文章后需要正常的git同步操作但是个人感觉不安全，别人可能直接把你的Hexo分支拉取下来就等于获取了你的全部博客资源（虽然我的博客没什么有用的价值😂）具体分支实现可参考利用分支同步关于多电脑同步解决方案2 每次手动拷贝最新的文件夹替换另一台电脑旧文件夹（想想就麻烦）通过云盘如Dropbox自动同步整个文件夹，使所有的电脑都可以同步到最新的目标电脑获取到最新的博客文件后 如果是情形3可以考虑先把整个博客目录拷贝出来到新的系统博客目录下GitHub添加配置新电脑的SSH key 和搭建时一样参考Mac搭建Hexo博客及NexT主题配置优化配置运行环境，执行如下指令12brew install node // 安装Node.jsnpm install -g hexo // 安装hexo 切换到博客目录下安装博客模块和插件 (具体参考之前安装过的插件)123456npm install npm install hexo-deployer-git --save npm install hexo-generator-feed --save npm install hexo-generator-sitemap --save npm install hexo-generator-feed --save npm install hexo-generator-searchdb --save 1234567 npm install -g gulp npm install gulp-minify-css --save npm install gulp-uglify --save npm install gulp-htmlmin --save npm install gulp-htmlclean --save npm install gulp-imagemin --save]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab的gui图像处理操作界面，实现重置和退出按钮功能]]></title>
    <url>%2F2018%2F03%2F09%2Fmatlab_gui_exit%2F</url>
    <content type="text"><![CDATA[axes控件实现了展示图片，动态txt控件实现了展示或者输入参数。 在gui界面右键点击“重置”pushbotton回到代码块callback，编写代码 .png) .png) 以下代码是实现图片和参数数字重置，是重置按钮（puttern）的功能实现12345678910111213141516function pushbutton1_Callback(hObject, eventdata, handles)% hObject handle to pushbutton1 (see GCBO)% eventdata reserved - to be defined in a future version of MATLAB% handles structure with handles and user data (see GUIDATA)% 重置清空图片 美滋滋cla(handles.axes1,&apos;reset&apos;);cla(handles.axes2,&apos;reset&apos;);cla(handles.axes3,&apos;reset&apos;);cla(handles.axes4,&apos;reset&apos;);cla(handles.axes5,&apos;reset&apos;);% 重置清空动态txt的文字 美滋滋set(handles.edit1,&apos;string&apos;,&apos;&apos;)set(handles.edit2,&apos;string&apos;,&apos;&apos;)set(handles.edit3,&apos;string&apos;,&apos;&apos;)set(handles.edit4,&apos;string&apos;,&apos;&apos;) 退出按钮：在gui界面右键点击“退出”pushbotton回到代码块callback，编写代码即可1close]]></content>
      <tags>
        <tag>Matlab</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse在主题商城下载安装黑色主题]]></title>
    <url>%2F2018%2F03%2F08%2Feclipse_black_theme%2F</url>
    <content type="text"><![CDATA[eclipse在主题商城下载安装黑色主题 Eclipse配置黑色主题方法： 1、借用国外一个Elipse主题网站分享的主题配置文件来配置一个黑色的主题. 主题网址 2、在这个网站下载自己喜欢的主题,单击主题进入下载页面,建议大家选择EPF格式的进行下载. 3、下载好之后打开Eclipse,单击File菜单下的Import选项 4、在弹出的窗口中,点击General下面的Preferences选项,然后点击Next 5、单击Browse选择你下载的EPF配置文件,然后点击Finish 6、这个时候如果你如果之前选择的是Eclipse默认的主题的话,那么只有代码区变成了黑色,那么你就需要再单击windos下的Preferences选项,然后再打开General下面的Appearance,在Theme选择那个Dark主题,然后点确定就可以了.]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Theme</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客cnzz网站访问量统计]]></title>
    <url>%2F2018%2F03%2F08%2Fhexo_cnzz%2F</url>
    <content type="text"><![CDATA[cnzz网站访问量统计 使用友盟第三方的统计插件，网址：http://www.umeng.com/进入网站先注册账号然后根据下列图片进入添加站点。 添加站点，自己搭建的博客，需要统计访问量的网站(这里加入我的博客网站)，然后点击统计代码进入代码页 代码页有很多样式，我的是红框的演示，纯文字统计，简洁大方，选择其他样式也可以 选择样式，复制样式代码到..\themes\yilia\layout\_partial下的footer.ejs中加入如下代码块&lt;div&gt;和&lt;/div&gt;即可 123&lt;div&gt; 里面是从CNZZ复制的代码 &lt;/div&gt; 代码块&lt;div&gt;和&lt;/div&gt;一定要在&lt;footer&gt;和&lt;/fotter&gt;之间]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>yilia</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客添加背景音乐和音乐歌单(举例网易云音乐)]]></title>
    <url>%2F2018%2F03%2F08%2Fhexo_music_list%2F</url>
    <content type="text"><![CDATA[添加背景音乐 1、 打开网易云音乐首页，然后搜索你要添加的背景音乐 http://music.163.com/ 2、 搜索到歌曲点击生成外链播放器，进去下一个界面 3、 复制外链播放器的代码打开yilia主题下的_partial文件夹下的left-col.ejs文件 复制文件内容到最下端 红线内的iframe框为复制的外链播放器代码，如图红线内，把代码放在div框 例如： &lt;div style=&quot;position:absolute; bottom:120px left:auto; width:85%&quot;&gt; &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=260 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=422428548&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; 这样就可以了 注：调节播放器大小，改变外链播放器的代码块，长度宽度即可 width=260 height=86]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Music</tag>
        <tag>yilia</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab2014a vs2015编译器解决方法]]></title>
    <url>%2F2018%2F03%2F07%2Fmatlab_vs2015%2F</url>
    <content type="text"><![CDATA[准备工作 前提：电脑已经安装1、Matlab版本2014a2、VS版本2015 目标：结合Matlab和VS2015，实现Matlab的GUI文件和.m文件转化为.exe文件，然后可以单独运行.exe文件 首先在Matlab命令行输入1mbuild -setup 报错红色，显示没有选择项，此处没有截图不直观我猜测可能是matlab2014a的破解不完全 解决方案下载资源链接：https://pan.b链aidu.com/s/1hoDxMKFU2l-3ZhTObFetCw 密码：vdlq 然后替换文件 附件下面的将mexopts/下的msvc2015.xml和msvcpp2015.xml复制到Matlab目录下的bin/win64/mexopts下就可以了 首先在Matlab命令行输入1mbuild -setup 然后输入1mex -setup 选项都选择C++的就哦了]]></content>
      <tags>
        <tag>Matlab</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决方案matlab2014a破解不完全，报错Test checkout of feature 'Compiler' failed]]></title>
    <url>%2F2018%2F03%2F07%2Fmatlab_exe%2F</url>
    <content type="text"><![CDATA[解决方案 报错情况： 目标是把.m文件转化为.exe文件，先运行 1mcc -m 你的文件123后缀如果报错 Test checkout of feature ‘Compiler’ failed``` 是因为你的matlab2014a破解不完全。前提是你的电脑已经安装好了VS编译器 2014a的解决办法：下载资源：ht链tps://pan.baidu.com/s/1KNZqVqxMx6f接IaxQULAIq_g密码：cti0 下载后解压，把install.jar以及相应位数的三个文件（compiler.dll，mcc.exe，libmwservices.dll）复制到对应位置替换即可。在matlab安装目录下搜索到文件然后替换，保险起见先把要替换的文件剪切出来，实际上我的操作是成功的，万一万一万一不成功还能复原回去 另外把license.lic改为与MATLAB\licenses文件夹下的那个lic文件同名，复制并替换之。如图所示，我把需要替换的文件都拿了出来，其中license文件是绑定了你的电脑名称，所以需要把新文件改名]]></content>
      <tags>
        <tag>Matlab</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客Yilia主题_缺失模块_解决方案]]></title>
    <url>%2F2018%2F02%2F08%2Fhexo_Yilia%E7%BC%BA%E5%A4%B1%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[hexo博客yilia主题hexo博客yilia主题,左侧栏目有一个全部文章的按钮，刚开始开始报错缺失模块，如下图： 我解决了这个问题着实不容易饶了弯路，但是跟着提示步骤，其实很简单，走起： 1、查看node版本win键+R键打开命令控制台，输入代码 node -v查看node版本，如下图： 只要node的版本高于6.2就行 2、博客根目录下运行命令行1npm i hexo-generator-json-content --save 如果这个包已经存在，会报错，图忘了截了。 但是你需要在theme文件夹的yilia主题文件夹下，找到node——modules文件夹。如果hexo-generator-json-content这个包是存在的就OK，可以进行第三步了，见下图： 3、配置文件博客根目录下，找到_config.yml，打开找一个空白地方复制一下配置信息： 1234567891011121314151617181920212223242526272829303132333435jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 注（重点）：细节处—复制的信息格式要调好1、配置文件内找空白处粘贴文件2、第一行jsonContent: 即下图46行前没有空格47、48、49行前有一个空格剩下的有两个空格 如下图所示： 保存后同步文件在看你的博客，点全部文章按钮 应该是修复了缺失模块这个报错 谢谢 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的简书主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>yilia</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客Yilia主题_more截断文章_多标签添加]]></title>
    <url>%2F2018%2F02%2F08%2Fhexo_more_article%2F</url>
    <content type="text"><![CDATA[Hexo博客Yilia主题more截断文章多标签添加以下均为自己遇到的问题并加以修改或者纠正. 在文章下方可以使用more语句进行截断，这样博客首页只会出现文章的前面一小部分，看起来很清爽简约 或者123language: zh-CN&lt;!--more--&gt; //在需要阶段的地方插入该代码语句aa 在这里，yilia主题会判断含有&lt;!--more--&gt;的位置，然后文章截断两部分，第一部分展示在博客首页，第二部分即上方的aa只能点开展开全文，才能继续阅读文章。 截断效果如下图： 在这里我对yilia主题做了修改 原始效果为： 修改后为：去掉了more按钮，打开文章可以点击文章或者点击展开全文 做法很简单，进入theme目录，打开yilia目录下的_config.yml文件，修改excerpt_link参数： 12excerpt_link：之后的more单词换成空格注：‘excerpt_link： ’。其中：后有一个空格键 修改图如下图 如何给文章加多个标签： 修改如下图，格式为[tag1, tag2] 注：逗号之后要有一个空格。[tag1, tag2]= [tag1+逗号+空格+tag2] 修改如下图所示： 我的个人博客主页，欢迎访问我的CSDN主页，欢迎访问我的简书主页，欢迎访问我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>yilia</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客Yilia主题首页菜单中文乱码两种解决方案]]></title>
    <url>%2F2018%2F02%2F06%2Fhexo_error_chinese%2F</url>
    <content type="text"><![CDATA[hexo-github博客首页菜单中文乱码两种解决方案 方案一：菜单设置成中文显示，编辑博客根目录下的_config.yml文件 设置language字段如下:1language: zh-Hans 或者1language: zh-CN 取决于你的主题theme目录下的language目录下有zh-Hans.yml还是zh-CN.yml 方案二：根目录下的配置文件是_config.yml文件 我们需要打开此文件，然后编辑文字。 但是保存之后的格式可能跟文件本身的格式编码不一样，所以会出现乱码问题。 推荐用sublime，VScode，atom等文本编辑器打开，这三款开源软件写代码也很便利。此处用atom文本编辑器打开编辑，保存后不会出现乱码问题了 最后效果如下： 希望能帮助到各位！我的个人博客文章地址，欢迎访问 我的CSDN文章地址，欢迎访问 我的简书文章地址，欢迎访问 我的GitHub主页，欢迎访问]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[米pad记事本 0828刷好lineage系统]]></title>
    <url>%2F2018%2F01%2F10%2F%E8%AE%B0%E4%BA%8B18_08_28%2F</url>
    <content type="text"><![CDATA[记事本 18-11-2087还是不够简约，入手凯酷84，心情大好 18-10-09红轴 贼鸥 87 舒服 18-10-09贼鸥87键 机械键盘改装，改樱桃红轴，键帽换为PBT键帽，磨砂手感，很不错 18-08-280828平板刷好lineage系统，奈斯，大夫 魔趣系统bug有点多，无故重启，故刷入lineage系统0811版，运行完美 18-07-29 入了一款小米平板，自带系统安卓4.4.4，系统太丑，找了第三方安装包魔趣7.1，升级到安卓7，比miui流畅多了，魔趣大法好 18-07-20纪念自己做的电容笔（右），虽然丑，用着还行，但是精确度比较差，还是买了一个10块的用用。 通过香烟盒里的锡纸连接手与屏幕导电，屏幕上的电极感应，然后确定操作点击屏幕。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更新日志]]></title>
    <url>%2F2018%2F01%2F01%2FUpdateLog%2F</url>
    <content type="text"><![CDATA[博客更新日志 更新日志 [2019-02-24] 更新优化网页，注入压缩静态文件插件， [2019-02-24] 更新随机变换背景图片，但是背景图片加载较慢。 [2019-02-23] 更新本文字数和阅读时间功能更新。 [2019-02-19] 更新更新Valine评论系统，阅读文章次数可见功能。 [2019-02-18] 更新添加并修复站内搜索功能。 [2019-01-30] 更新更新修改Next主题配置信息，可玩性较高。 [2019-01-29] 更新使用Next主题修饰博客 期间主题配置等过程不计 [2018-08-09] 更新使用Yilia主题修饰博客 [2018-08-08] 更新注册并启用aomanhao.top网站 [2017-11-27] 更新博客建立，使用Hexo框架 问题记录，更新需求 [2019-02-24] 更新可以考虑用腾讯云作为新图床以满足图片加载 [2019-02-24] 更新图片加载较慢右侧CSDN没有icon图标 [2019-01-30] 更新网页底部需要一颗心跳动的效果]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页记录小本本]]></title>
    <url>%2F2016%2F04%2F03%2FHtmlNote%2F</url>
    <content type="text"><![CDATA[网页记录小本本留言板记录网页以供后续参考]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
