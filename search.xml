<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo主题Next配置]]></title>
    <url>%2F2019%2F01%2F20%2Ftheme_next%2F</url>
    <content type="text"><![CDATA[Hexo主题Next配置 新建404界面在站点根目录下，输入hexo new page 404，在默认Hexo站点下/source/404/index.md打开新建的404界面，编辑属于自己的404界面，可以显示腾讯公益404界面，代码如下： 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://qzone.qq.com/gy/404/style/404style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/plain&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;/&quot; homePageName=&quot;回到我的主页&quot;&gt; &lt;/script&gt; &lt;script src=&quot;https://qzone.qq.com/gy/404/data.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://qzone.qq.com/gy/404/page.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 静态资源压缩静态资源压缩 在站点目录下安装插件： 1$ npm install gulp -g 12345npm install gulp-minify-css --savenpm install gulp-uglify --savenpm install gulp-htmlmin --savenpm install gulp-htmlclean --savenpm install gulp-imagemin --save 在Hexo站点下添加gulpfile.js文件，文件内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var uglify = require(&apos;gulp-uglify&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);var imagemin = require(&apos;gulp-imagemin&apos;);// 压缩css文件gulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩html文件gulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);// 压缩js文件gulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src([&apos;./public/**/.js&apos;,&apos;!./public/js/**/*min.js&apos;]) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩 public/demo 目录内图片gulp.task(&apos;minify-images&apos;, function() &#123; gulp.src(&apos;./public/demo/**/*.*&apos;) .pipe(imagemin(&#123; optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: false, //类型：Boolean 默认：false 多次优化svg直到完全优化 &#125;)) .pipe(gulp.dest(&apos;./public/uploads&apos;));&#125;);// 默认任务gulp.task(&apos;default&apos;, [ &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;,&apos;minify-images&apos;]); 需要只在每次执行generate命令后执行gulp就可以实现对静态资源的压缩，完成压缩后执行deploy命令同步到服务器： 123hexo ggulphexo d 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用&lt;!--与--&gt;隐藏之间的代码即可，或者直接删除。位置如图： 各版块透明度修改内容板块透明根博客目录themes\next\source\css\_schemes\Pisces\_layout.styl文件.content-wrap标签下background: white修改为：1background: rgba(255,255,255,0.7); //0.7是透明度 菜单栏背景根博客目录themes\next\source\css\_schemes\Pisces\_layout.styl文件.header-inner标签下background: white修改为：1background: rgba(255,255,255,0.7); //0.7是透明度 站点概况背景根博客目录themes\next\source\css\_schemes\Pisces\_sidebar.styl文件.sidebar-inner标签下background: white修改为：1background: rgba(255,255,255,0.7); //0.7是透明度 修改然后根博客目录themes\next\source\css\_schemes\Pisces\_layout.styl文件.sidebar标签下background: $body-bg-color修改为：1background: rgba(255,255,255,0.7); //0.7是透明度 网站底部字数统计具体方法实现 切换到根目录下，然后运行如下代码1npm install hexo-wordcount --save 然后在/themes/next/layout/_partials/footer.swig文件尾部加上：1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 添加侧栏推荐阅读编辑主题配置文件，如下配置即可：12345678# Blog rollslinks_icon: linklinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: Swift 4: https://developer.apple.com/swift/ Objective-C: https://developer.apple.com/documentation/objectivec 博文置顶修改hexo-generator-index插件，把node_modules/hexo-generator-index/lib/generator.js中代码替换为：12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 文章添加Top值，值越大，越靠前：123456789---title: Hexo-NexT主题配置date: 2018-01-20 20:41:08categories: Hexotags:- Hexo- NexTtop: 100--- 网页底部信息隐藏网页底默认最新一次使用，需要取消since注释，设定年份 1234567891011121314151617footer: # Specify the date when the site was setup. # If not defined, current year will be used. since: 2017 # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons/ # `heart` is recommended with animation in red (#ff0000). name: user #设置图标，想修改图标从https://fontawesome.com/v4.7.0/icons获取 # If you want to animate the icon, set it to true. animated: false # Change the color of icon, using Hex Code. color: &quot;#808080&quot; # If not defined, `author` from Hexo main config will be used. copyright: by AomanHao #版权 显示文章阅读进度百分比设置方法：打开themes/next/_config.yml主题配置文件,找到# Scroll percent label in b2t button将scrollpercent:的值,改成true 12# Scroll percent label in b2t button scrollpercent: true 浏览页面的时候显示当前浏览进度如果想把top按钮放在侧边栏,打开themes/next下的_config.yml,搜索关键字b2t,把false改为true 12345# Back to top in sidebar b2t: true # Scroll percent label in b2t button scrollpercent: true 加入valine在线评论设置效果： 设置方法：首先要先去LeanCloud注册一个帐号.然后再创建一个应用. 拿到appid和appkey之后，打开themes/next/_config.yml主题配置文件，查找valine，填入appid和 appkey我的配置: 添加网站已运行时间在themes/layout/_parrials/footer.swing后添加 1234567891011121314151617&lt;span id=&quot;timeDate&quot;&gt;载入天数...&lt;/span&gt;&lt;span id=&quot;times&quot;&gt;载入时分秒...&lt;/span&gt;&lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date(&quot;11/27/2017 12:00:00&quot;);//在此处修改你的建站时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = &quot;0&quot; + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = &quot;0&quot; + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = &quot;0&quot; + snum;&#125; document.getElementById(&quot;timeDate&quot;).innerHTML = &quot; Runing &quot;+dnum+&quot; D &quot;; document.getElementById(&quot;times&quot;).innerHTML = hnum + &quot; H &quot; + mnum + &quot; M &quot; + snum + &quot; S&quot;; &#125; setInterval(&quot;createtime()&quot;,250);&lt;/script&gt; 添加头像打开themes/next下的_config.yml文件，搜索 Sidebar Avatar关键字，去掉avatar前面的# Sidebar Avatarin theme directory(source/images): /images/avatar.jpgin site directory(source/uploads): /uploads/avatar.jpgavatar: http://example.com/avatar.png或者使用本地图片,把图片放入themes/next/source/images下,修改avataravatar: /images/blogLogo.png 添加站内搜索设置效果： 设置方法：安装hexo-generator-searchdb插件1npm install hexo-generator-searchdb --save 编辑_config.yml站点配置文件，新增以下内容到任意位置：12345search: path: search.xml field: post format: html limit: 10000 编辑themes/next/_config.yml主题配置文件，启用本地搜索功能,将local_search:下面的enable:的值，改成true 123# Local searchlocal_search: enable: true]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理_噪声检测]]></title>
    <url>%2F2018%2F12%2F25%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%99%AA%E5%A3%B0%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[噪声检测 噪声检测方法将噪声和信号区分开来是影响去噪效果好坏的重要因素之一。近年来，学者们提出了诸多噪声判断方法，其中较经典的方法包括：开关阈值法、极值法、两级门限法，下面对这三种方法进行介绍，并进行对比。1.1 常见的噪声检测方法（1）开关阈值法开关阈值判断法[1]基本思想是：该方法通过一定的规则将噪声点和信号点进行判断，区分成两种类别来控制开关单元。若该像素点被判断为噪声点，则开关单元与滤波器相连接，即该点经过滤波后输出；若该像素点被判断为信号点，则开关单元对该点保持原像素值输出。开关阈值法的重点在于噪声检测器的设置，其中较为常见的一种开关阈值判断法表示如下： X_(i,j=)\begin{cases} S,|f(i,j)-average(W[x_(i,j)])|]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理_DCT（占坑）]]></title>
    <url>%2F2018%2F10%2F25%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_DCT%2F</url>
    <content type="text"><![CDATA[DCT]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理_图像噪声]]></title>
    <url>%2F2018%2F10%2F25%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E5%99%AA%E5%A3%B0%2F</url>
    <content type="text"><![CDATA[图像噪声 噪声加性噪声一般指热噪声、散弹噪声等，它们与信号的关系是相加，不管有没有信号，噪声都存在。 高斯白噪声包括热噪声和散粒噪声。在通信信道测试和建模中，高斯噪声被用作加性白噪声以产生加性白高斯噪声。 加性高斯白噪声只是白噪声的一种，另有泊松白噪声等,加性高斯白噪声在通信领域中指的是一种各频谱分量服从均匀分布（即白噪声），且幅度服从高斯分布的噪声信号。因其可加性、幅度服从高斯分布且为白噪声的一种而得名。 而乘性噪声一般由信道不理想引起，它们与信号的关系是相乘，信号在它在，信号不在他也就不在。 一般通信中把加性随机性看成是系统的背景噪声； 而乘性随机性看成系统的时变性（如衰落或者多普勒）或者非线性所造成的。 椒盐噪声定义：椒盐噪声又称为双极脉冲噪声，这种噪声表现的特点是噪声像素的灰度值与邻域像素有着明显差异，而其余像素的灰度值保持不变，因此在图像中造成过亮或过暗的像素点。椒盐噪声严重影响图像的视觉质量，给图像的边缘检测、纹理或者特征点提取等造成困难。 去椒盐噪声办法1234567891、中值滤波2、开关中值滤波器 SMF（Switching Median Filter）[参考文献](Detail - preserving median based filters in image rocessing)3、自适应中值滤波器 AMF（Adaptive Median Filter）[参考文献](Adaptive median filters : New algorithms and results)4、自适应中心加权中值滤波器 ACWMF（Adaptive Center Weighted Median Filter） [参考文献](adaptive impulse detection using center Weighted median filter)5、基于决策的算法ＤＢＡ ( Decision Based Algorithm) [参考文献](A new fast and efficient decision Based algorithm for removal of high density impulse noises) 一般会选择先检测再滤波的思路，通过开关机制抑制噪声，上述方法对低噪声水平的椒盐噪声处理效果良好，噪声水平过高无法得到理想的结果。因为基于中值的滤波方法仅考虑图像局部区域像素点的顺序阶信息，没有充分利用像素点之间的相关性或相似性。噪声像素点的估计值可能与真实值有较大偏差，很难保持图像的细节信息。 高斯噪声高斯噪声是指概率密度函数服从高斯分布（即正态分布）的一类噪声。如果一个噪声，它的幅度服从高斯分布，而它的功率谱密度又是分布均匀的，则称它为高斯白噪声。高斯白噪声的二阶矩不想关，一阶矩为常数，是指先后信号在时间上的相关性。高斯白噪声包括热噪声和散粒噪声。高斯噪声完全由其时变平均值和两瞬时的协方差函数来确定，若噪声为平稳的，则平均值与时间无关，而协方差函数则变成仅和所考虑的两瞬时之方差有关的相关函数，它在意义上等效于功率谱密度。高斯噪声可以由大量独立的脉冲产生，从而在任何有限时间间隔内，这些脉冲中的每一个脉冲值与所有脉冲值的总和相比都可以忽略不计]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加相册]]></title>
    <url>%2F2018%2F09%2F23%2FHexo%E7%9B%B8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[相册 实现思路1.在主页上必须有一个可供点击的相册连接2.要用 hexo 生成一个 photos.html 文件3.photos.html 中的图片数据来源?因为这是一个静态页面所有要有一个 json 文件4.json 文件中有含有信息,图片的文件名.5.图片要有一个完整的路径,用github的空间6.Python脚本剪裁、压缩、上传图片到自定义的github备份仓库中不多说废话了,顺着思路逐一解决问题吧 操作步骤1.在主页上必须有一个可供点击的连接BLOG\source目录下创建一个photos目录，目的是存放利用脚本生成的json 文件和渲染文件。 配置 Yilia 主题让其显示出来.yourBlog/themes/yilia/_config.yml文件添加相册 1相册: /photos/ 2.如何生成 photos.html 文件来在github上新建一个仓库，主要用于存储图片，可以通过url访问到，也方便管理，备份图片和其他东西 git clone 到本地，模仿作者的文件目录结构 source文件夹是备份图片，theme是备份yilia配置文件等 min_photos是缩略图文件夹，photos是原图文件夹，blog_photos_copy是渲染文件备份，最后再弄 备份渲染文件，最后再弄 ejs 文件是以后要hexo 文件渲染的文件. ins.js 文件设置自己的东西. 3.修改 ejs 模板文件3.1 index.ejs文件可以不用修改3.2 修改 ins.js 文件的 render()函数.这个函数是用来渲染数据的修改图片的路径地址.minSrc 小图的路径. src 大图的路径.修改为自己的图片路径(github的路径). 12var minSrc = &apos;https://raw.githubusercontent.com/AomanHao/Blog-Back-Up/master/source/min_photos/&apos; + data.link[i];var src = &apos;https://raw.githubusercontent.com/AomanHao/Blog-Back-Up/master/source/photos/&apos; + data.link[i]; 这个链接不是直接的图片url，是需要点“下载”才能看到的url。 github仓库上传的图片文件 下载选项，看网址 黄色画出了链接网址，路径地址.minSrc 小图的路径. src 大图的路径 我的路径有source/min_photos/和source/photos，分别是缩略图（压缩的图快速加载预览）和原图（点击查看图片） 3.3生成 json 文件.这一步是关键的一步,也是最后一步.先用脚本把图片处理成一套大图和一套小图,然后上传的七牛或者 github 上再回头生成这个 json文件.每次更新图片都要执行脚本重新生成 json 文件.这个json 文件会出现在yourBlog/source/photos/data.json 4.处理图片处理脚本试用python语言写的，运行环境也是python python脚本文件原作者GitHub地址：https://github.com/lawlite19/Blog-Back-Up 下载python2或者3，在cmd运行窗口运行python tool.py tool.py是运行主函数，ImageProcess图像处理功能函数，包括裁剪、压缩等 git_operation()方法: 如果你把图片上传到你的 github上这个方法就不用更改了.但是要确保在可以push到github的文件夹里，按照之前操作兴建了博客文件备份仓库 handlephoto()方法:注意: 该脚本对图片的命名规则有要求.最前面是日期，然后用进行分隔；后面是图片的描述信息，注意不要包含_和.符号 5.注意事项5.1最前面是日期，然后用进行分隔；后面是图片的描述信息，注意不要包含和.符号 图片应该这样命名: 2016-10-12_xxx.jpg/png；存放在photos中，然后脚本运行会生成压缩图片，放置在min_photos文件夹中。 5.2 tool.py文件中open里面的设置的是本地博客路径 如D:/GitHub/AomanHao.github.io/source/photos/data.json D:/GitHub/AomanHao.github.io/是你的博客在本地的路径，data.json是图片信息文件 5.3点开图片可以显示，缩略图不显示 下载empty图，下载地址，直接右键另存，保存为“empty.png”。 在你博客的本地仓库source下新建一个文件夹命名为assets,再在assets下新建一个文件夹命名为img。最后把empty.png放到img里面。 我的目录如下： 结尾：在github上新建一个仓库，主要用于存储图片，可以通过url访问到，也方便管理将要放到相册的图片处理成json格式的数据，然后进行访问，这里json的格式需要配合要使用的样式，所以需要处理成特定格式的json数据，下面会给出图片裁剪，因为相册显示的样式最好是正方形的的图片，这里使用脚本处理一下图片压缩，相册显示的图片是压缩后的图片，提高加载的速度，打开后的图片是原图。 问题：当我用中文作为相册名字的时候，无法生成data.json文件，很纳闷，报错 UTF8的编码错误 算了，暂时找不改正的方法，科恩你是python是2.多的原因吧，我的相片都是用了英文命名 参考文章1参考文章2参考文章3]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git配置]]></title>
    <url>%2F2018%2F09%2F19%2FGit%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Git配置 右键菜单配置 Git Bash Here 功能键运行regedit.exe进入注册表，在HKEY_CLASSES_ROOT\Directory\Background\shell中进行设置。 1.新建项Git Bush Here，此时你可以看到在桌面右键会出现“Git Bush Here”菜单。 2.添加Git Bush Icon，在第一步的新建项Git Bush Here下，新建字符串值Icon，然后编辑该值为“C:\Program Files\Git\mingw64\share\git\git-for-windows.ico”，你需要根据你安装的Git 目录进行配置修改。完成此步后，你会发现右键菜单“Git Bush Here”会多出一个Icon。 3.添加Command项。在“Git Bush Here”下再新建项“Command”，将其默认值改为“C:\Program Files\Git\bin\bash.exe —login -i”，这样，你就可以通过右键菜单的方式快速进入Git命令行工具，进行代码版本管理。 git 命令1.git config 该命令允许你获得和设置配置变量；这些变量可以控制Git的外观和操作的各个方面。123使用方法: git config –global user.name “[name]”使用方法: git config –global user.email “[email address]” 2.git init git init命令创建一个空的Git仓库或重新初始化一个现有仓库。1使用方法：git init [repository name] 3.git clone git clone命令将存储库克隆到新目录中。1使用方法：git clone [url] 4.git add git add命令将文件内容添加到索引(将修改添加到暂存区)。也就是将要提交的文件的信息添加到索引库中。1使用方法: git add [file] ; 5.git commit该命令用于将更改记录(提交)到存储库。将索引的当前内容与描述更改的用户和日志消息一起存储在新的提交中。 123使用方法: git commit -m “[ Type in the commit message]”使用方法：git commit -a 在修改文件后,需要使用gitadd把文件加入暂存区,这样gitcommit时才能把已经修改的信息加入版本库,而使用gitcommit-a可以不用再git add。 6.git diff 该命令用于显示提交和工作树等之间的更改。此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。123使用方法: git diff使用方法：git diff –staged gitdiff—staged显示的是暂存区和版本库差异 1使用方法：git diff [first branch] [second branch] 命令显示两个分支之间的差异。 7.git resetgit reset命令用于将当前HEAD复位到指定状态。一般用于撤消之前的一些操作(如:git add,git commit等)。123使用方法: git reset [file]使用方法: git reset [commit] 撤消指定提交后的所有提交，并在本地保留更改。 1使用方法：git reset –hard [commit] 丢弃所有历史记录并返回到指定的提交。 8.git status该命令用于显示工作目录和暂存区的状态。1使用方法: git status 9.git rm该命令用于从工作区和索引中删除文件。1使用方法: git rm [file] 10.git log该命令用于显示提交日志信息。123使用方法: git log使用方法：git log –follow[file] 列出文件的版本历史记录，包括文件的重命名。 11.git show该命令用于显示各种类型的对象。1使用方法: git show [commit] 12.git tag该命令用于创建,列出,删除或验证使用GPG签名的标签对象。1使用方法: git tag [commitID] 13.git branch 该命令列出当前存储库中的所有本地分支。123使用方法: git branch使用方法：git branch [branch name] 创建一个新分支。 1使用方法：git branch -d [branch name] 删除分支 14.git checkout 该命令命令用于从一个分支切换到另一个分支。 使用方法：git checkout [branch name] 使用方法: git checkout -b [branch name] 该命令创建一个新分支并切换过去。 15.git merge该命令用于将两个或两个以上的开发历史加入(合并)一起。 使用方法: git merge [branch name] 16.git remote该命令管理一组跟踪的存储库。 使用方法: git remote add [variable name] [Remote Server Link] 17.git push该命令用于将本地分支的更新,推送到远程主机。 使用方法: git push [variable name] master 使用方法：git push [variable name] [branch] 将分支提交到远程存储库。 使用方法：git push –all [variable name] 将所有分支推送到远程存储库。 使用方法: git push [variable name] :[branch name] 删除远程存储库上的分支。 18.git pull该命令用于从另一个存储库或本地分支获取并集成(整合)。 使用方法: git pull [Repository Link] 19.git stash该命令临时存储所有已修改的跟踪文件。。 使用方法: git stash save 使用方法：git stash pop 可恢复最近隐藏的文件。 使用方法：git stash list 列出所有存储的更改集。 使用方法：git stash drop 移除stash]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VScode配置]]></title>
    <url>%2F2018%2F09%2F19%2FVScode%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[VScode配置 VScode插件Git History（装完输入 git log有惊喜) Git Lens（让本就集成了 git 的 VSC 更加强大 Markdown Preview Enhanced(markdown 预览) Emoji Code Dracula Official 吸血鬼主题，暗黑风格 Code Runner —- 支持多种语言例如： C，C++，Java，JavaSript，PHP，Python，Perl，Perl6 等 Bracket Pair Colorizer 和 Indent Rainbow，这两个插件可以让不同缩减的括号显示不同的颜色。 Auto Close Tag 和 Auto Rename Tag 插件，自动补全标签和联动重名标签 Studio Icons 图标展示，丰富界面 VScode设置中文界面123456781、按f1，搜索 Configore Display Language 设置 zh-cn 关闭软件重启。2、如果重启菜单等还是英文的，在商店查看已安装的插件，把中文插件重新安装一遍，然后重启软件。应用商店搜索插件-chinese(simplified) 参考文章]]></content>
      <tags>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理_灰度变换_直方图]]></title>
    <url>%2F2018%2F09%2F07%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E7%81%B0%E5%BA%A6%E5%8F%98%E6%8D%A2_%E7%9B%B4%E6%96%B9%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[图像处理灰度变换直方图 直方图均衡化 Histogram Equalization假如图像的灰度分布不均匀，其灰度分布集中在较窄的范围内，使图像的细节不够清晰，对比度较低。通常采用直方图均衡化及直方图规定化两种变换，使图像的灰度范围拉开或使灰度均匀分布，从而增大反差，使图像细节清晰，以达到增强的目的。直方图均衡化，对图像进行非线性拉伸，重新分配图像的灰度值，使一定范围内图像的灰度值大致相等。这样，原来直方图中间的峰值部分对比度得到增强，而两侧的谷底部分对比度降低，输出图像的直方图是一个较为平坦的直方图。 均衡化算法直方图的均衡化实际也是一种灰度的变换过程，将当前的灰度分布通过一个变换函数，变换为范围更宽、灰度分布更均匀的图像。也就是将原图像的直方图修改为在整个灰度区间内大致均匀分布，因此扩大了图像的动态范围，增强图像的对比度。通常均衡化选择的变换函数是灰度的累积概率，直方图均衡化算法的步骤： 1、计算原图像的灰度直方图 P(Sk)=nkn，其中n为像素总数，nk为灰度级Sk的像素个数 2、计算原始图像的累积直方图 CDF(Sk)=∑i=0knin=∑i=0kPs(Si)Dj=L⋅CDF(Si)，其中 Dj是目的图像的像素，CDF(Si)是源图像灰度为i的累积分布，L是图像中最大灰度级（灰度图为255）直接应用该方法得到图像的灰度直方图 3\将灰度直方图进行归一化，计算灰度的累积概率；创建灰度变化的查找表应用查找表，将原图像变换为灰度均衡的图像 均衡化过程中，必须要保证两个条件 1、像素无论怎么映射，一定要保证原来的大小关系不变，较亮的区域，依旧是较亮的，较暗依旧暗，只是对比度增大，绝对不能明暗颠倒；2、如果是八位图像，那么像素映射函数的值域应在0和255之间的，不能越界。 综合以上两个条件，累积分布函数是个好的选择，因为累积分布函数是单调增函数（控制大小关系），并且值域是0到1（控制越界问题），所以直方图均衡化中使用的是累积分布函数。 累积分布函数累积分布函数具有一些好的性质，那么如何运用累积分布函数使得直方图均衡化？比较概率分布函数和累积分布函数，前者的二维图像是参差不齐的，后者是单调递增的。直方图均衡化过程中，映射方法是 S_k = \sum_{j=0}^k\frac{n_j}{n} . k=0,1...,L-1$n$是图像素总和，$n_k$是当前灰度级的像素个数，$L$是图像中灰度级总数 操作步骤有: 直方图规定化直方图规定化，就是对原始图像做变换，使得变换后的图像的直方图跟我们规定的一样。 具体步骤如下： 1、首先对原始图像做直方图均衡化，得到每个像素s和累积分布T(s); 2、根据需要的规定化直方图，求累积分布G(Z)； 3、显然，如果累积直方图中有0值，那么是不会分配像素值的，因为0乘以255还是零。 4、对于每一个T（s）（假设其像素值为ss）,找到在G（Z）中与其差值最小的那个G（z）值（假设对应的像素值为zz），那么规定化后就把ss变换为zz。 直方图规定化流程下图： 1、计算原图像的累积直方图 2、计算规定直方图的累积直方图 3、计算两累积直方图的差值的绝对值 4、根据累积直方图差值建立灰度级的映射 局部直方图处理&amp;直方图统计Opencv代码灰度直方图均衡123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128// HistogramGrayEqualizeHist.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;opencv2/core/core.hpp&gt; //cvGetSize cvCreateImage#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/opencv.hpp&gt; //cvResize cvInitMatHeader cvGetMinMaxHistValue cvCvtColor#include &lt;opencv2/imgproc/imgproc.hpp&gt;#ifdef _DEBUG#pragma comment(lib, &quot;opencv_core244d&quot;)#pragma comment(lib, &quot;opencv_highgui244d&quot;)#pragma comment(lib, &quot;opencv_imgproc244d&quot;) //cvResize#else#pragma comment(lib, &quot;opencv_core244d&quot;)#pragma comment(lib, &quot;opencv_highgui244d&quot;)#pragma comment(lib, &quot;opencv_imgproc244d&quot;) //cvResize#endif#define cvQueryHistValue_1D(hist,idx0) ((float)cvGetReal1D( (hist)-&gt;bins, (idx0)))using namespace std; #pragma comment(linker, &quot;/subsystem:\&quot;windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;) void FillWhite(IplImage *pImage) &#123; cvRectangle(pImage, cvPoint(0, 0), cvPoint(pImage-&gt;width, pImage-&gt;height), CV_RGB(255, 255, 255), CV_FILLED); &#125; // 创建灰度图像的直方图 CvHistogram* CreateGrayImageHist(IplImage **ppImage) &#123; int nHistSize = 256; float fRange[] = &#123;0, 255&#125;; //灰度级的范围 float *pfRanges[] = &#123;fRange&#125;; CvHistogram *pcvHistogram = cvCreateHist(1, &amp;nHistSize, CV_HIST_ARRAY, pfRanges); cvCalcHist(ppImage, pcvHistogram); return pcvHistogram; &#125; // 根据直方图创建直方图图像 IplImage* CreateHisogramImage(int nImageWidth, int nScale, int nImageHeight, CvHistogram *pcvHistogram) &#123; IplImage *pHistImage = cvCreateImage(cvSize(nImageWidth * nScale, nImageHeight), IPL_DEPTH_8U, 1); FillWhite(pHistImage); //统计直方图中的最大直方块 float fMaxHistValue = 0; cvGetMinMaxHistValue(pcvHistogram, NULL, &amp;fMaxHistValue, NULL, NULL); //分别将每个直方块的值绘制到图中 int i; for(i = 0; i &lt; nImageWidth; i++) &#123; float fHistValue = cvQueryHistValue_1D(pcvHistogram, i); //像素为i的直方块大小 int nRealHeight = cvRound((fHistValue / fMaxHistValue) * nImageHeight); //要绘制的高度 cvRectangle(pHistImage, cvPoint(i * nScale, nImageHeight - 1), cvPoint((i + 1) * nScale - 1, nImageHeight - nRealHeight), cvScalar(i, 0, 0, 0), CV_FILLED ); &#125; return pHistImage; &#125; int main( int argc, char** argv ) &#123; const char *pstrWindowsSrcTitle = &quot;原图&quot;; const char *pstrWindowsGrayTitle = &quot;灰度图&quot;; const char *pstrWindowsHistTitle = &quot;直方图&quot;; const char *pstrWindowsGrayEqualizeTitle = &quot;灰度图-均衡化后&quot;; const char *pstrWindowsHistEqualizeTitle = &quot;直方图-均衡化后&quot;; // 从文件中加载原图 // IplImage *pSrcImage = cvLoadImage(&quot;./images/yangmi.jpg&quot;, CV_LOAD_IMAGE_UNCHANGED); IplImage *pSrcImage = cvLoadImage(&quot;./images/beauty.png&quot;, CV_LOAD_IMAGE_UNCHANGED); IplImage *pGrayImage = cvCreateImage(cvGetSize(pSrcImage), IPL_DEPTH_8U, 1); IplImage *pGrayEqualizeImage = cvCreateImage(cvGetSize(pSrcImage), IPL_DEPTH_8U, 1); // 灰度图 cvCvtColor(pSrcImage, pGrayImage, CV_BGR2GRAY); // 直方图图像数据 int nHistImageWidth = 255; int nHistImageHeight = 150; int nScale = 2; // 灰度直方图及直方图图像 CvHistogram *pcvHistogram = CreateGrayImageHist(&amp;pGrayImage); IplImage *pHistImage = CreateHisogramImage(nHistImageWidth, nScale, nHistImageHeight, pcvHistogram); // 均衡化 //函数功能：直方图均衡化，该函数能归一化图像亮度和增强对比度 //第一个参数表示输入图像，必须为灰度图（8位，单通道图） //第二个参数表示输出图像 //该函数采用如下法则对输入图像进行直方图均衡化： //1：计算输入图像的直方图H。 //2：直方图归一化，因此直方块和为255。 //3：计算直方图积分，H&apos;(i) = Sum(H(j)) (0&lt;=j&lt;=i)。 //4：采用H&apos;作为查询表：dst(x, y) = H&apos;(src(x, y))进行图像变换。 cvEqualizeHist(pGrayImage, pGrayEqualizeImage); // 均衡化后的灰度直方图及直方图图像 CvHistogram *pcvHistogramEqualize = CreateGrayImageHist(&amp;pGrayEqualizeImage); IplImage *pHistEqualizeImage = CreateHisogramImage(nHistImageWidth, nScale, nHistImageHeight, pcvHistogramEqualize); // 显示 cvNamedWindow(pstrWindowsSrcTitle); cvNamedWindow(pstrWindowsGrayTitle); cvNamedWindow(pstrWindowsGrayEqualizeTitle); cvNamedWindow(pstrWindowsHistTitle); cvNamedWindow(pstrWindowsHistEqualizeTitle); cvShowImage(pstrWindowsSrcTitle,pSrcImage); cvShowImage(pstrWindowsGrayTitle,pGrayImage); cvShowImage(pstrWindowsGrayEqualizeTitle,pGrayEqualizeImage); cvShowImage(pstrWindowsHistTitle,pHistImage); cvShowImage(pstrWindowsHistEqualizeTitle,pHistEqualizeImage); cvWaitKey(0); //回收资源代码… cvDestroyWindow(pstrWindowsSrcTitle); cvDestroyWindow(pstrWindowsGrayTitle); cvDestroyWindow(pstrWindowsGrayEqualizeTitle); cvDestroyWindow(pstrWindowsHistTitle); cvDestroyWindow(pstrWindowsHistEqualizeTitle); cvReleaseImage(&amp;pSrcImage); cvReleaseImage(&amp;pGrayImage); cvReleaseImage(&amp;pGrayEqualizeImage); cvReleaseImage(&amp;pHistImage); cvReleaseImage(&amp;pHistEqualizeImage); return 0; &#125; 直方图规定化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void hist_specify(const Mat &amp;src, const Mat &amp;dst,Mat &amp;result)&#123; Histogram1D hist1D; MatND src_hist = hist1D.getHistogram(src); MatND dst_hist = hist1D.getHistogram(dst); float src_cdf[256] = &#123; 0 &#125;; float dst_cdf[256] = &#123; 0 &#125;; // 源图像和目标图像的大小不一样，要将得到的直方图进行归一化处理 src_hist /= (src.rows * src.cols); dst_hist /= (dst.rows * dst.cols); // 计算原始直方图和规定直方图的累积概率 for (int i = 0; i &lt; 256; i++) &#123; if (i == 0) &#123; src_cdf[i] = src_hist.at&lt;float&gt;(i); dst_cdf[i] = dst_hist.at&lt;float&gt;(i); &#125; else &#123; src_cdf[i] = src_cdf[i - 1] + src_hist.at&lt;float&gt;(i); dst_cdf[i] = dst_cdf[i - 1] + dst_hist.at&lt;float&gt;(i); &#125; &#125; // 累积概率的差值 float diff_cdf[256][256]; for (int i = 0; i &lt; 256; i++) for (int j = 0; j &lt; 256; j++) diff_cdf[i][j] = fabs(src_cdf[i] - dst_cdf[j]); // 构建灰度级映射表 Mat lut(1, 256, CV_8U); for (int i = 0; i &lt; 256; i++) &#123; // 查找源灰度级为ｉ的映射灰度 // 和ｉ的累积概率差值最小的规定化灰度 float min = diff_cdf[i][0]; int index = 0; for (int j = 1; j &lt; 256; j++) &#123; if (min &gt; diff_cdf[i][j]) &#123; min = diff_cdf[i][j]; index = j; &#125; &#125; lut.at&lt;uchar&gt;(i) = static_cast&lt;uchar&gt;(index); &#125; // 应用查找表，做直方图规定化 LUT(src, lut, result);&#125;]]></content>
      <tags>
        <tag>Opencv</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习面试]]></title>
    <url>%2F2018%2F09%2F04%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%B2%BE%E5%8D%8E%2F</url>
    <content type="text"><![CDATA[机器学习面试 SVM： 简单介绍SVM（详细原理）：从分类平面，到求两类间的最大间隔，到转化为求间隔分之一，等优化问题，然后就是优化问题的解决办法，首先是用拉格拉日乘子把约束优化转化为无约束优化，对各个变量求导令其为零，得到的式子带入拉格朗日式子从而转化为对偶问题， 最后再利用SMO（序列最小优化）来解决这个对偶问题。svm里面的c有啥用 SVM的推导，解释原问题和对偶问题，SVM原问题和对偶问题的关系，KKT限制条件，KKT条件用哪些，完整描述；软间隔问题，解释支持向量、核函数（哪个地方引入、画图解释高维映射，高斯核可以升到多少维，如何选择核函数），引入拉格朗日的优化方法的原因，最大的特点，损失函数解释， SVM与LR最大区别，LR和SVM对于outlier的敏感程度分析，逻辑回归与SVM的区别 为什么要把原问题转换为对偶问题？因为原问题是凸二次规划问题，转换为对偶问题更加高效。为什么求解对偶问题更加高效？因为只用求解alpha系数，而alpha系数只有支持向量才非0，其他全部为0.alpha系数有多少个？样本点的个数 加大训练数据量一定能提高SVM准确率吗？ 与感知器的联系和优缺点比较 如何解决多分类问题、可以做回归吗，怎么做 它与其他分类器对比的优缺点，它的速度 机器学习有很多关于核函数的说法，核函数的定义和作用是什么？https://www.zhihu.com/question/24627666 支持向量机(SVM)是否适合大规模数据？https://www.zhihu.com/question/19591450 SVM和逻辑斯特回归对同一样本A进行训练，如果某类中增加一些数据点，那么原来的决策边界分别会怎么变化？https://www.zhihu.com/question/30123068 各种机器学习的应用场景分别是什么？例如，k近邻,贝叶斯，决策树，svm，逻辑斯蒂回归和最大熵模型。https://www.zhihu.com/question/26726794 Linear SVM 和 LR 有什么异同？https://www.zhihu.com/question/26768865 1VM转化为对偶问题后，分类只需要计算与少数几个支持向量的距离，这个在进行复杂核函数计算时优势很明显，能够大大简化模型和计算量。 LR LR推导（伯努利过程，极大似然，损失函数，梯度下降）有没有最优解？ LR可以用核么？可以怎么用？l1和l2正则项是啥？lr加l1还是l2好？加哪个可以用核（加l2正则项，和svm类似，加l2正则项可以用核方便处理） LR可以用来处理非线性问题么？（还是lr啊 只不过是加了核的lr 这里加核是显式地把特征映射到高维 然后再做lr）怎么做？可以像SVM那样么？为什么？ 为什么LR需要归一化或者取对数，为什么LR把特征离散化后效果更好，为什么把特征组合之后还能提升，反正这些基本都是增强了特征的表达能力，或者说更容易线性可分吧 美团技术团队《Logistic Regression 模型简介》https://tech.meituan.com/intro_to_logistic_regression.html SVM和logistic回归分别在什么情况下使用？https://www.zhihu.com/question/21704547 1234567891011121314151617两种方法都是常见的分类算法，svm-统计的方法 LR-几何的方法 区别在于1、（损失函数的目的都是增加对分类影响较大的数据点的权重）逻辑回归采用的是logistical losssvm采用的是hinge loss2、LR~不带核函数的svm特征少，样本数量适中--用svm算法特征多，样本数量少 --用LR或者不带核函数的svm 特征少，样本数量很多--先增加更多的feature，再使用LR算法或者不带核函数的SVM 3、svm对异常点敏感LR对异常点不敏感 逻辑斯蒂回归能否解决非线性分类问题？https://www.zhihu.com/question/29385169 12对特征做非线性变换 比如kernel，最后一层看成是lr 前面看成是提特征。lr的应用场景主要是特征很多的情况LR用kernel容易过拟合，svm不容易过拟合 为什么LR可以用来做CTR预估？https://www.zhihu.com/question/23652394 逻辑回归估计参数时的目标函数 （就是极大似然估计那部分），逻辑回归估计参数时的目标函数 （呵呵，第二次） 逻辑回归估计参数时的目标函数 如果加上一个先验的服从高斯分布的假设，会是什么样（天啦。我不知道，其实就是在后面乘一个东西，取log后就变成加一个东西，实际就变成一个正则项） 逻辑回归估计参数时的目标函数逻辑回归的值表示概率吗？（值越大可能性越高，但不能说是概率） 手推逻辑回归目标函数，正类是1，反类是-1，这里挖了个小坑，一般都是正例是1，反例是0的，他写的时候我就注意到这个坑了，然而写的太快又给忘了，衰，后来他提醒了一下，改了过来，就是极大似然函数的指数不一样，然后说我这里的面试就到这了。 看没看过scikit-learn源码LR的实现？（回头看了一下是调用的liblinear，囧） 为什么LR需要归一化或者取对数，为什么LR把特征离散化后效果更好，为什么把特征组合之后还能提升，反正这些基本都是增强了特征的表达能力，或者说更容易线性可分吧naive bayes和logistic regression的区别http://m.blog.csdn.net/blog/muye5/19409615 LR为什么用sigmoid函数。这个函数有什么优点和缺点？为什么不用其他函数？sigmoid函数由那个指数族分布，加上二项分布导出来的。损失函数是由最大似然估计求出的。了解其他的分类模型吗，问LR缺点，LR怎么推导（当时我真没准备好，写不出来）写LR目标函数，目标函数怎么求最优解（也不会）讲讲LR的梯度下降，梯度下降有哪几种，逻辑函数是啥 12 L1和L212345678910111213L2正则化，为什么L2正则化可以防止过拟合？L1正则化是啥？深度学习里面怎么防止过拟合？（data aug；dropout；multi-task learning）如何防止过拟合，我跟他列举了4中主要防止过拟合方法：Early Stopping、数据集扩充、正则化法以及dropout，还详细跟他说了每种方法原理及使用的场景，并解释我在哪些项目里具体用到了这些方法，机器学习中使用「正则化来防止过拟合」到底是一个什么原理？为什么正则化项就可以防止过拟合？https://www.zhihu.com/question/20700829机器学习中常常提到的正则化到底是什么意思？https://www.zhihu.com/question/20924039什么是正则项，L1范式，L2范式区别是什么，各自用在什么地方？L1 与 L2 的区别以及如何解决 L1 求导困难；L1正则为什么能让系数变为0？L1正则怎么处理0点不可导的情形？（这个谁会？近端梯度下降）L0，L1，L2正则化(如果能推导绝对是加分项，一般人最多能画个等高线，L0是NP问题)其实上面的这些问题基本都能在《李航：统计学习方法》《周志华：机器学习》里面找到，能翻个4，5遍基本就无压力了避免过拟合策略、如何提高模型泛化能力、L1与L2正则区别，优缺点、生成式，判别式模型、深度学习这块了解多少、如何克服过拟合，欠拟合L1 与 L2 的区别以及如何解决 L1 求导困难；L1正则为什么可以把系数压缩成0，坐标下降法的具体实现细节为什么L1正则可以实现参数稀疏，而L2正则不可以？为什么L1很多系数可以被压缩为0，L2是被压缩至接近于0？树模型 决策树：1234567891011121314151617181920212223242526rf ， gbdt 的区别； gbdt ， xgboost 的区别（烂大街的问题最好从底层原理去分析回答）介绍决策树，谈了3种决策树及其区别和适应场景决策树处理连续值的方法；简单介绍决策树几种算法，有什么区别？决策树基本模型介绍？决策树算法中缺失值怎么处理？决策树算法在应用中有什么值得注意的地方。SVM、LR、决策树的对比？GBDT 和 决策森林 的区别？决策树的特性？（3 ）决策树处理连续值的方法；解释下随机森林和gbdt的区别。gbdt的boosting体现在哪里。解释下随机森林节点的分裂策略，以及它和gbdt做分类有什么区别？哪个效果更好些？为什么？哪个更容易过拟合？为什么？ 问了随机森林的损失函数，和lr的优缺点对比， adaboost和随机森林的比较，为了防止随机森林过拟合可以怎么做，是否用过随机森林，怎么用的。随机森林和GBDT的区别？CART（回归树用平方误差最小化准则，分类树用基尼指数最小化准则）GBDT（利用损失函数的负梯度在当前模型的值作为回归问题提升树算法中的残差的近似值，拟合一个回归树）随机森林（Bagging+CART）SVM与随机森林比较改变随机森林的训练样本数据量，是否会影响到随机森林学习到的模型的复杂度Logistics与随机森林比较GBDT与随机森林比较随机森林的学习过程；随机森林中的每一棵树是如何学习的；随机森林学习算法中CART树的基尼指数是什么？RF 与 GBDT 区别，原理优缺点适用场景分析，哪个具备交叉验证功能等接着写一下信息增益的公式。之后就是问机器学习相关算法，说了一下bagging跟boosting，之后问了GBDT（没做过，只能说说大体思路）。（2 ） rf ， gbdt 的区别； gbdt ， xgboost 的区别；说说xgboost、gbdt区别、Tree-based Model如何处理连续型特征。让我把一个完整的数据挖掘流程讲一下，从预处理，特征工程，到模型融合。介绍常用的算法，gbdt和xgboost区别，具体怎么做预处理，特征工程，模型融合常用方式，融合一定会提升吗？gbdt树根据什么分裂（瞎扯的梯度近似残差、梯度下降方向，其实还是信息增益这种东西）gbdt怎么并发（特征选择层面，树层面不能并发）介绍LR、RF、GBDT ，分析它们的优缺点，是否写过它们的分布式代码XGB和GBDT区别与联系也会经常问到：https://www.zhihu.com/question/41354392/answer/128008021?group_id=773629156532445184CART（回归树用平方误差最小化准则，分类树用基尼指数最小化准则）、Logistics（推导）、GBDT（利用损失函数的负梯度在当前模型的值作为回归问题提升树算法中的残差的近似值，拟合一个回归树）在面试过程中主动引导面试官提问，比如面试官让你讲解 gbdt 原理时，这会你可以跟他说，一般说起 gbdt ，我们都会跟 rf 以及 xgboost 一块讲，然后你就可以主动地向面试官输出你的知识；面试并不是死板地你问我答，而是一种沟通交流，所以尽可能地把面试转化成聊天式的对话，多输出自己一些有价值的观点而不是仅仅为了回答面试官的问题；几种树模型的原理和对比，特征选取怎么选？ 为什么信息增益可以用来选特征？信息熵和基尼指数的关系(信息熵在x=1处一阶泰勒展开就是基尼指数)介绍xgboost一下。写下xgboost目标函数。（因为我提到xgboost在目标函数里显式地加入了正则项..血雪崩）怎么调整XGB参数；xgboost原理 K-means1234567891011k-means 聚类的原理以及缺点及对应的改进；kmeans 算法的优缺点。。。。kmeans 的原理，优缺点以及改进；em 与 kmeans 的关系；kmeans 代码；说说 Kmeans 算法， Kmeans 算法 K 怎么设置、适用什么样数据集、怎么评价 Kmeans 聚类结果、 Kmeans 有什么优缺点？你的项目中使用 Kmeans 遇到哪些问题，怎么解决的 ?用 EM 算法推导解释 Kmeans。KMeans的算法伪代码如何判断自己实现的 LR、Kmeans 算法是否正确？如何优化kmeans算法如何用hadoop实现k-means手写k-means的伪代码（就6行） 集成学习123456bagging和boosting是怎么做的和他们的比较详细讨论了样本采样和bagging的问题聊的比较多的是如何知道一个特征的重要性，如何做ensemble哪些方法比较好。聊了聊计算广告方面FM，embedding。常见融合框架原理，优缺点，bagging，stacking，boosting，为什么融合能提升效果是否了解线性加权、bagging、boosting、cascade等模型融合方式K-means起始点http://www.cnki.com.cn/Article/CJFDTotal-DNZS200832067.htm 贝叶斯12345朴素贝叶斯分类器原理以及公式，出现估计概率值为 0 怎么处理（拉普拉斯平滑），缺点；解释贝叶斯公式和朴素贝叶斯分类。贝叶斯分类，这是一类分类方法，主要代表是朴素贝叶斯，朴素贝叶斯的原理，重点在假设各个属性类条件独立。然后能根据贝叶斯公式具体推导。考察给你一个问题，如何利用朴素贝叶斯分类去分类，比如：给你一个人的特征，判断是男是女，比如身高，体重，头发长度等特征的的数据，那么你要能推到这个过程。给出最后的分类器公式。那你说说贝叶斯怎么分类啊？比如说看看今天天气怎么样？我：blabla，，，利用天气的历史数据，可以知道天气类型的先验分布，以及每种类型下特征数据（比如天气数据的特征：温度啊，湿度啊）的条件分布，这样我们根据贝叶斯公式就能求得天气类型的后验分布了。。。。面试官：en（估计也比较满意吧）那你了解关于求解模型的优化方法吗？一般用什么优化方法来解？贝叶斯分类器的优化和特殊情况的处理 深度学习12345678910111213141516解释一下CNN、介绍CNN、卷积公式，以及特点，假设面试官什么都不懂，详细解释 CNN 的原理；问CNN的细节特点，哪些特点使得CNN这么好用，哪些场景用CNN可以，抽象一下这些场景的特征，可以降采样但仍能保持主要信息；局部连接可以保证获取局部信息；权值共享保证高效，DNN和CNN相比有哪些区别，用过RNN么？画一下RNN的图，你在深度学习过程中遇到过哪些问题？如果出现过拟合你怎么办？dropout是什么？它有什么用？你会怎么用它？当全连接跟dropout连着用需要注意什么？你之前过拟合怎么解决的？如果本身training loss就很大你怎么办？如果数据不变，怎么调整网络结构解决这个问题？（batch normalization）梯度消失知道么？为什么会出现梯度消失？dnn和rnn中的梯度消失原理一样么？dnn中是哪个部分导致梯度消失？（激活层如sigmoid）rnn中怎么解决梯度消失问题？（lstm的结构相对普通RNN多了加和，为避免梯度消散提供了可能。线性自连接的memory是关键。）讲一下CNN吧，有哪些重要的特点？CNN可以处理哪些场景？为什么CNN要用权值共享？（每个卷积核相当于一个特征提取器，它的任务是匹配局部图像中的特征，权值共享后，匹配的特征方式都是一样的，提取若干特征后就知道学习的是啥了）CNN里面哪些层？讲一下卷积。卷积的形式是啥样？给定一个输入，算输出的feature map大小。卷积有啥用？池化有啥用？有哪些池化方式？池化除了降采样还有啥用？（就不知道了）还有哪些层你用过？讲讲dropout。dropout内部是怎么实现只让部分信号通过并不更新其余部分对于输入的权值的？讲讲BN（BatchNormalization）为什么好？全连接有什么用处？知道RNN么？讲讲RNN大致的实现思路。知道梯度消失么？为什么会出现梯度消失？RNN里的梯度消失一般怎么处理？细讲下lstm的结构，这样设计为什么好？（门关闭，当前信息不需要，只有历史依赖；门打开，历史和当前加权平均）你觉得梯度消失靠引入一些新的激活层可以完全解决么？为什么？问了做的比赛里面使用tensorflow的细节，LSTM里调参的细节用过哪些库或者工具，mkl，cuda这些会用吗？有一个弱分类器和大量未被标记过的图像数据，如何人工标记图像来对分类器进行提升介绍下RNN和它的优缺点让我推导BP反向传播、随机梯度下降法权重更新公式卷积神经网络结构特点、各参数对模型结果影响、项目进展遇到的难题、推导BP神经网络参数更新方式、随机梯度下降法（SGD）优化函数存在的缺点以及拟牛顿法在优化函数使用上更有优势、修改Caffe开源框架、开源社区代码贡献量就跟我聊了很多行业发展趋势及问题，知道目前深度学习的一个趋势，也了解到最新行业发展动态，改进相机智能化程度，也聊到了美颜相机美颜效果以及小米相机人脸分类、年龄检测等等不足之处，了解到新兴行业大佬商汤科技和旷视科技（face++脸草）在研究的热门方向看到有deep learning相关的项目，就问了deep learning 相关问题：如何减少参数（权值共享、VGG的感受野、GoogLeNet的inception ），激活函数的选择（sigmoid-&gt;ReLu-&gt;LReLU-&gt;PReLU ），为什么之前没有深度网络出现（数据量不够+机器性能），由数据引申到数据不平衡怎么处理（10W正例，1W负例，牛客上有原题），后面问了下DNN原理，应用，瞎扯一通……你了解神经网络吗？我：了解一些，讲感知机，然后是BP网络。简单讲了一下原理。图像处理题：如何找相似图片。我说用感知哈希算法，计算汉明距离，他说这种方法精度不行；我说那就用SIFT算法吧，他说SIFT效果还可以，但计算有点繁重，有没有轻量级的方法？我想起来去年在美图秀秀实习时，曾经做过一种图像滤波算法，有一步是把像素点用K-means聚类。我就说先把图片灰度化，然后用K-means聚类，把聚类后的各个中心点作为一张图片的特征向量如果两张图片的特征向量相近则说明这两张图片相似。貌似我这个答案有点出乎他的意料，他意味深长地说了个“行吧~~~~”（个人觉得颜色直方图匹配是个他期待的常规回答）介绍卷积神经网络，和 DBN 有什么区别？Deep CNN, Deep RNN, RBM的典型应用与局限，看Hinton讲义和Paper去吧神经网络,plsi的推导验证码图片的去噪和提取字符有限状态自动机,然后要我画状态转移图. 聚类12用过哪些聚类算法，解释密度聚类算法。聚类算法中的距离度量有哪些？ 优化12345678梯度下降的优缺点；主要问最优化方面的知识，梯度下降法的原理以及各个变种（批量梯度下降，随机梯度下降法， mini 梯度下降法），以及这几个方法会不会有局部最优问题，牛顿法原理和适用场景，有什么缺点，如何改进（拟牛顿法）常用优化算法：1.梯度下降法：又有随机梯度下降和负梯度下降，2.牛顿法 主要是问了各自的优缺点，速度，能不能得到全局最优解，牛顿法的二次收敛等问你如果有若干个极小值点，如何避免陷入局部最优解。它们间的牛顿学习法、SGD如何训练，如何判断函数凸或非凸？线性回归的梯度下降和牛顿法求解公式的推导最速下降法和共轭梯度法 wolfe条件 最速下降法和共轭梯度法的收敛速度如何判断深刻理解常用的优化方法：梯度下降、牛顿法、各种随机搜索算法（基因、蚁群等等），深刻理解的意思是你要知道梯度下降是用平面来逼近局部，牛顿法是用曲面逼近局部等等。 推荐系统12345678910介绍SVD、SVD++推荐系统的冷启动问题如何解决深度学习在推荐系统上可能有怎样的发挥？推荐系统的算法中最近邻和矩阵分解各自适用场景白板写SVD/SVD++公式，SGD迭代更新p，q矩阵公式，SVD/SVD++优化方法对推荐算法的未来看法；用过什么算法？最好是在项目/实习的大数据场景里用过，比如推荐里用过 CF、LR，我面的推荐，问了各类协同过滤的好与坏。问了一个很有意思的问题，现实应用中的Top-N推荐问题和学术研究中的评分预测问题之间有什么不同。问我ItemCF的工程实现，面对大数据如何实现，又追问了有没有什么工程优化算法。这个问题我没答好，一开始我说了一个MapReduce模型，他问能不能更快一点，我就卡那了。。。最后面试官告诉我，不能只从算法角度分析，要从系统设计分析，利用内存来减小MapReduce的吞吐量。（当然也许从MapReduce那一刻开始我就输了也不一定）推荐系统的算法中最近邻和矩阵分解各自适用场景http://www.doc88.com/p-3961053026557.html PCA12那你对pca了解吗？我：了解啊，面试官：那讲一下pca是用来干嘛的？我：pca啊，可以用来分析主方向啊，降维啊，特征筛选啊，具体方法是用svd分解得到特征值矩阵和特征向量矩阵，然后根据不同的任务对选择特征值或向量进行计算。 EM1采用 EM 算法求解的模型有哪些，为什么不用牛顿法或梯度下降法？ NLP12345用过哪些 NLP 算法项目中用过哪些机器学习算法。海量的 item 算文本相似度的优化方法；解释 word2vec 的原理以及哈夫曼树的改进；word2vec的原理二面面试官主要跟我聊简历上的几个项目，他好像不能理解词向量的形式，反复解释了很多遍，问的问题都比较简单，有TF-IDF,余弦相似度，分词工具等等。然后我说我做过LDA，问我，Dirichlet Distribution的定义和性质，并问我，为什么它和multinomial distribution是共轭的，顺便问了我啥叫共轭分布。 关联分析：1项目中涉及到频繁模式挖掘，于是问了一下如何实现的？ 用的是 Apriori算法，描述他的原理过程，关键字眼：支持度，支持度计数，k项候选频繁项集，怎么从k项到k+1项等，连接剪枝过程。 hadoop12345678简单介绍 MapReduce 原理，有没有看过源码，说说 Map 阶段怎么实现的,MapReduce 实现统计出现次数最多的前 100 个访问 IP.MapReduce 实现统计不重复用户 ID,MapReduce 实现两个数据集求交集。HBase 行健怎么设计,spark 性能一般优化方法,spark streaming 和 storm 区别.给了一张笔试题， 10 道选择，一道大题。选择题是 java 基础知识，大题一个有三问：根据场景写出 Hive 建表语句； Hsql 从表中查询；用MapReduce写好友推荐，在一堆单词里面找出现次数最多的k个用分布式的方法做采样怎么保证采样结果完全符合预期？后面又问了Hadoop,Spark,storm下面的产品，原理，适用场景，写一个 Hadoop 版本的 wordcount。 HMM1234567891011121314151617181920212223242526272829实现 hmm 的状态转移代码；机器学习理论讲机器学习中常用的损失函数有哪些？交叉熵有什么好处？（凸优化问题）判别模型与生成模型的本质区别是什么分类模型和回归模型的区别，分类模型可以做回归分析吗？反过来可以吗？（我回答是分类不可以做回归，回归倒是可以做分类，不知道对不对）k折交叉验证 中k取值多少有什么关系 （我不知道，随便答，然后面试官后面问我知道bias和variance吗？估计是和这两个东西有关， 知乎上有个问题讨论了k值大小与bias和variance的关系）解释局部相关性特征选择的方法；在模型的训练迭代中，怎么评估效果；特征选择方法有哪些(能说出来10种以上加分)，之后和面试官仔细聊了一下特征选择的问题，我介绍了了解的几种基本的特征选择思路（错误率选择、基于熵的选择、类内类间距离的选择）；有没有接触过机器学习的前沿，深度学习看过paper没有？（并没有）如何用尽可能少的样本训练模型同时又保证模型的性能；你读哪些期刊会议的论文？你遇到的比较有意思的算法？生成模型，判别模型线性分类和非线性分类各有哪些模型比较各个模型的Loss function，设计一个结构存取稀疏矩阵 （面试官最后告诉我了一个极度压缩的存法，相同行或列存偏差，我当时没听懂，还不懂装懂，最后还是没记住）PageRank原理，怎么用模型来查找异常用户，我讲了一大堆我的理解，然后面试官一句你怎么不用规则把我噎到了……无监督和有监督算法的区别？经典算法推导(加分项)，原理，各个损失函数之间区别，使用场景，如何并行化，有哪些关键参数什么叫判别模型什么叫生成模型。先针对项目十分细致地询问了各种细节，然后就问我如何处理数据中的噪声点、数据清洗算法（正好自己做了一个算法）、如何选择特征等。校招TST内推，面过了2面，还是跟之前那个有点类似的游戏开发的安全部门，因为我也玩LOL，又问到怎么来判断玩家有没有作弊之类的问题，这次我小心翼翼的说用模型怎么做，用规则怎么做，感觉这次聊的都挺开心的。是否了解A/B Test以及A/B Test结果的置信度特征工程经验是否了解mutual infomation、chi-square、LR前后向、树模型等特征选择方式深刻理解各种算法对应采用的数据结构和对应的搜索方法。比如KNN对应的KD树、如何给图结构设计数据结构？如何将算法map-red化矩阵的各种变换，尤其是特征值相关的知识。分布式的矩阵向量乘的算法线性分类器与非线性分类器的区别及优劣；特征比数据量还大时，选择什么样的分类器？对于维度很高的特征，你是选择线性还是非线性分类器？对于维度极低的特征，你是选择线性还是非线性分类器？如何解决过拟合问题？L1和L2正则的区别，如何选择L1和L2正则？项目中的数据是否会归一化处理，哪个机器学习算法不需要归一化处理并行计算、压缩算法LDA http://www.doc88.com/p-1621945750499.html]]></content>
      <tags>
        <tag>笔面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab背景颜色修改]]></title>
    <url>%2F2018%2F09%2F01%2Fmatlab_%E8%83%8C%E6%99%AF%2F</url>
    <content type="text"><![CDATA[Matlab背景颜色修改 背景将修改内容添加到matlab的matlab.prf文件中，文件路径为在matlab中运行prefdir的结果,直接添加这些内容保存就好。 操作1， 在matlab命令行中运行prefdir， 获取matlab.prf文件所在路径 2， 打开matlab.prf所在路径， 找到matlab.prf文件， 作备份 3， 在新的matlab.prf中修改与color有关的属性 4，重启matlab，修改主题就完成了 主题选择黑色主题123456789101112131415161718192021Editor.VariableHighlighting.Color=C-6931898ColorsText=C-460558Colors_M_SystemCommands=C-448910Editorhighlight-lines=C-11974594Colors_M_Warnings=C-27648Colors_M_Strings=C-1647756Editor.NonlocalVariableHighlighting.TextColor=C-5471745Colors_HTML_HTMLLinks=C-16732805Colors_M_Comments=C-8355712Colors_M_Errors=C-65536Colors_M_UnterminatedStrings=C-5111808ColorsBackground=C-14211038Colors_M_Keywords=C-10036753Color_CmdWinWarnings=C-39936ColorsMLintAutoFixBackground=C-7973573Colors_M_Keywords=C-10036753Editorhighlight-lines=C-13553108Editorhighlight-caret-row-boolean-color=C-2167080ColorsUseSystem=Bfalse 暖色主题123456789101112131415161718Color_CmdWinErrors=C-1703936Color_CmdWinWarnings=C-39936ColorsBackground=C-198941ColorsMLintAutoFixBackground=C-1121868ColorsText=C-16304574ColorsUseMLintAutoFixBackground=BtrueColorsUseSystem=BfalseColors_HTML_HTMLLinks=C-2935166Colors_M_Comments=C-7167583Colors_M_Errors=C-65536Colors_M_Keywords=C-8021760Colors_M_Strings=C-13983336Colors_M_SystemCommands=C-3454186Colors_M_UnterminatedStrings=C-5111808Colors_M_Warnings=C-27648Editor.NonlocalVariableHighlighting.TextColor=C-32640Editor.VariableHighlighting.Color=C-7167583EditorRightTextLimitLineColor=C-3355444 darkmate123456789101112131415161718192021222324252627ColorsUseSystem=BfalseColorsUseMLintAutoFixBackground=BtrueEditor.VariableHighlighting.Automatic=BtrueEditor.NonlocalVariableHighlighting=BtrueEditorCodepadHighVisible=BtrueEditorCodeBlockDividers=BtrueEditorhighlight-caret-row-boolean=BtrueEditorRightTextLineVisible=BtrueEditorRightTextLimitLineWidth=I4 # slightly widerColorsText=C-1118482 # whiteColorsBackground=C-14474461 # carbonColors_M_Keywords=C-26368 # ambraColors_M_Comments=C-10920873 # asfaltoColors_M_Strings=C-6881536 # limeColors_M_UnterminatedStrings=C-202417 # yellowColors_M_SystemCommands=C-16725605 # algaColors_M_Errors=C-53398 # redColors_HTML_HTMLLinks=C-6385153 # violetColors_M_Warnings=C-26368 # ambraColorsMLintAutoFixBackground=C-11184811 # Editor.VariableHighlighting.Color=C-4495617 # purpleEditor.NonlocalVariableHighlighting.TextColor=C-16725760 # greenEditorhighlight-lines=C-15132391 # Editorhighlight-caret-row-boolean-color=C-16777216 # blackEditorRightTextLimitLineColor=C-13948117 # # XML/HTMLEditor.Language.XML.Color.pi-content=C-6425200 darksteel12345678910111213141516171819202122232425262728293031323334353637ColorsUseSystem=BfalseColorsUseMLintAutoFixBackground=BtrueEditor.VariableHighlighting.Automatic=BtrueEditor.NonlocalVariableHighlighting=BtrueEditorCodepadHighVisible=BtrueEditorCodeBlockDividers=BtrueEditorhighlight-caret-row-boolean=BtrueEditorRightTextLineVisible=BtrueEditorRightTextLimitLineWidth=I1ColorsText=C-1ColorsBackground=C-15066598Colors_M_Keywords=C-1208813Colors_M_Comments=C-14114579Colors_M_Strings=C-16724992Colors_M_UnterminatedStrings=C-4210944Colors_M_SystemCommands=C-7123493Colors_M_Errors=C-45747Colors_HTML_HTMLLinks=C-10592257Colors_M_Warnings=C-27648ColorsMLintAutoFixBackground=C-9223357Editor.VariableHighlighting.Color=C-11184786Editor.NonlocalVariableHighlighting.TextColor=C-16735351Editorhighlight-lines=C-14408662Editorhighlight-caret-row-boolean-color=C-12632257EditorRightTextLimitLineColor=C-5723992# TLCEditor.Language.TLC.Color.Colors_M_Keywords=C-16735351# C/C++Editor.Language.C.Color.preprocessor=C-16735351# VHDLEditor.Language.VHDL.Color.operator=C-16735351# VerilogEditor.Language.Verilog.Color.operator=C-16735351# XMLEditor.Language.XML.Color.operator=C-1710454Editor.Language.XML.Color.doctype=C-6578958Editor.Language.XML.Color.pi-content=C-9868801 monokai1234567891011121314151617181920212223242526ColorsUseSystem=BfalseColorsUseMLintAutoFixBackground=BtrueEditor.VariableHighlighting.Automatic=BtrueEditor.NonlocalVariableHighlighting=BtrueEditorCodepadHighVisible=BtrueEditorCodeBlockDividers=BtrueEditorhighlight-caret-row-boolean=BfalseEditorRightTextLineVisible=BtrueEditorRightTextLimitLineWidth=I1ColorsText=C-460560ColorsBackground=C-14211038Colors_M_Keywords=C-448910Colors_M_Comments=C-9080482Colors_M_Strings=C-1647756Colors_M_UnterminatedStrings=C-65536Colors_M_SystemCommands=C-16711936Colors_M_Errors=C-65536Colors_HTML_HTMLLinks=C-16711681Colors_M_Warnings=C-27648ColorsMLintAutoFixBackground=C-11974594Editor.VariableHighlighting.Color=C-10066330Editor.NonlocalVariableHighlighting.TextColor=C-16729641Editorhighlight-lines=C-13421773Editorhighlight-caret-row-boolean-color=C-10066330EditorRightTextLimitLineColor=C-3355444Color_CmdWinWarnings=C-26368 参考github效果：https://github.com/scottclowe/matlab-schemer/tree/master/schemes]]></content>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理推荐资料]]></title>
    <url>%2F2018%2F08%2F31%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E6%8E%A8%E8%8D%90%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[图像处理推荐资料 图像处理与计算机视觉相关的书籍 数学 我们所说的图像处理实际上就是数字图像处理，是把真实世界中的连续三维随机信号投影到传感器的二维平面上，采样并量化后得到二维矩阵。数字图像处理就是二维矩阵的处理，而从二维图像中恢复出三维场景就是计算机视觉的主要任务之一。这里面就涉及到了图像处理所涉及到的三个重要属性：连续性，二维矩阵，随机性。所对应的数学知识是高等数学（微积分），线性代数（矩阵论），概率论和随机过程。这三门课也是考研数学的三个组成部分，构成了图像处理和计算机视觉最基础的数学基础。如果想要更进一步，就要到网上搜搜林达华推荐的数学书目了。 信号处理 图像处理其实就是二维和三维信号处理，而处理的信号又有一定的随机性，因此经典信号处理和随机信号处理都是图像处理和计算机视觉中必备的理论基础。2.1经典信号处理信号与系统(第2版) Alan V.Oppenheim等著 刘树棠译 离散时间信号处理(第2版) A.V.奥本海姆等著 刘树棠译 数字信号处理:理论算法与实现 胡广书 (编者) 2.2随机信号处理现代信号处理 张贤达著 统计信号处理基础:估计与检测理论 Steven M.Kay等著 罗鹏飞等译 自适应滤波器原理(第4版) Simon Haykin著 郑宝玉等译 2.3 小波变换信号处理的小波导引:稀疏方法(原书第3版) tephane Malla著, 戴道清等译 2.4 信息论信息论基础(原书第2版) Thomas M.Cover等著 阮吉寿等译 模式识别Pattern Recognition and Machine Learning Bishop, Christopher M. Springer 模式识别(英文版)(第4版) 西奥多里德斯著 Pattern Classification (2nd Edition) Richard O. Duda等著 Statistical Pattern Recognition, 3rd Edition Andrew R. Webb等著 模式识别(第3版) 张学工著 图像处理与计算机视觉的书籍推荐图像处理，分析与机器视觉 第三版 Sonka等著 艾海舟等译 Image Processing, Analysis and Machine Vision ( 附：这本书是图像处理与计算机视觉里面比较全的一本书了，几乎涵盖了图像视觉领域的各个方面。中文版的个人感觉也还可以，值得一看。) 数字图像处理 第三版 冈萨雷斯等著 Digital Image Processing (附：数字图像处理永远的经典，现在已经出到了第三版，相当给力。我的导师曾经说过，这本书写的很优美，对写英文论文也很有帮助，建议购买英文版的。) 计算机视觉：理论与算法 Richard Szeliski著 Computer Vision: Theory and Algorithm (附：微软的Szeliski写的一本最新的计算机视觉著作。内容非常丰富，尤其包括了作者的研究兴趣，比如一般的书里面都没有的Image Stitching和 Image Matting等。这也从另一个侧面说明这本书的通用性不如Sonka的那本。不过作者开放了这本书的电子版，可以有选择性的阅读。 http://szeliski.org/Book/ Multiple View Geometry in Computer Vision 第二版Harley等著 引用达一万多次的经典书籍了。第二版到处都有电子版的。第一版曾出过中文版的，后来绝版了。网上也可以找到中英文版的电子版。) 计算机视觉：一种现代方法 DA Forsyth等著 Computer Vision: A Modern Approach MIT的经典教材。虽然已经过去十年了，还是值得一读。期待第二版 Machine vision: theory, algorithms, practicalities 第三版 Davies著 (附：为数不多的英国人写的书，偏向于工业应用。) 数字图像处理 第四版 Pratt著 Digital Image Processing (附：写作风格独树一帜，也是图像处理领域很不错的一本书。网上也可以找到非常清晰的电子版。)]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql基础]]></title>
    <url>%2F2018%2F08%2F31%2FMysql%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Mysql基础]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基础]]></title>
    <url>%2F2018%2F08%2F31%2FLinux%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Linux基础 VIM 三个模式 一般指令模式（Command mode）：VIM 的默认模式，可以用于移动游标查看内容； 编辑模式（Insert mode）：按下 “i” 等按键之后进入，可以对文本进行编辑； 指令列模式（Bottom-line mode）：按下 “:” 按键之后进入，用于保存退出等操作。 在指令列模式下，有以下命令用于离开或者保存文件。 命令 作用 :w 写入磁盘 :w! 当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关 :q 离开 :q! 强制离开不保存 :wq 写入磁盘后离开 :wq! 强制写入磁盘后离开 磁盘的文件名Linux 中每个硬件都被当做一个文件，包括磁盘 分区1. MBRMBR 中，第一个扇区最重要，里面有主要开机记录（Master boot record, MBR）及分区表（partition table），其中主要开机记录占 446 bytes，分区表占 64 bytes。 2. GPT不同的磁盘有不同的扇区大小，GPT 第 1 个区块记录了主要开机记录（MBR） 文件属性用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。 使用 ls 查看一个文件时，会显示一个文件的信息，例如 drwxr-xr-x. 3 root root 17 May 6 00:14 .config，对这个信息的解释如下： drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段 3：链接数 root：文件拥有者 root：所属群组 17：文件大小 May 6 00:14：文件最后被修改的时间 .config：文件名 常见的文件类型及其含义有： d：目录 -：文件 l：链接文件 9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。 文件时间有以下三种： modification time (mtime)：文件的内容更新就会更新； status time (ctime)：文件的状态（权限、属性）更新就会更新； access time (atime)：读取文件时就会更新。 孤儿进程一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。 孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。 由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。 僵尸进程一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。 僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。 系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。 要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 所收养，这样 init 就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理_图像插值]]></title>
    <url>%2F2018%2F08%2F28%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E6%8F%92%E5%80%BC%2F</url>
    <content type="text"><![CDATA[图像插值 比较常用的插值算法有这么几种：最邻近插值，双线性二次插值，三次插值，Lanczos插值等等 1，最邻近插值最邻近插值算法也叫做零阶插值算法，主要原理是让输出像素的像素值等于邻域内 离它距离最近的像素值。 这种放大图像的方法叫做最临近插值算法，这是一种最基本、最简单的图像缩放算法，效果也是最不好的，放大后的图像有很严重的马赛克，缩小后的图像有很严重的失真；效果不好的根源就是其简单的最临近插值方法引入了严重的图像失真。 2，双线性二次插值3、三次内插法内插值，外插值两张图像混合时通过内插与外插值方法可以实现图像亮度、对比度、饱和度、填色、锐化等常见的图像处理操作。在两张图像混合时最常见是线性插值方法，使用的混合权重公式如下： Out(x,y) = Src2(x,y) *\alpha + Src1(x,y)(1-\alpha)$\alpha$的范围是[0,1]之间 内插值方法：常见的值属于[0,1]之间。 外插值方法：可以用来生成跟内插值效果相反的图像。 比如内插值模糊图像，通过外插值可以去模糊，外插值可以调节饱和度，可以实现图像一些列的处理比如亮度、饱和度、对比度、锐化调整。 插值算法的类型：一般分为两类: 自适应和非自适应。自适应的方法可以根据插值的内容来改变（尖锐的边缘或者是平滑的纹理），非自适应的方法对所有的像素点都进行同样的处理。 非自适应算法包括: 最邻近方法, 双线性, 双三次, 样条, sinc, lanczos 和其他。由于其复杂度, 这些插值的时候使用从0 to 256 (or more) 邻近像素。 包含越多的邻近像素，他们越精确，但是花费的时间也越长。这些算法可以用来扭曲和缩放照片。 OriginalEnlarged 250%自适应算法包含许多专利，如: Qimage, PhotoZoom Pro, Genuine Fractals和其他。许多应用他们插值的不同版本 (on a pixel-by-pixel basis)当他们检测边缘时 —目标是最小化插值干扰。 最邻近插值最邻近算法在所有插值算法中时间最短，因为它只考虑一个像素点—离待插像素点最近的像素点。 双线性插值双线性插值考虑待插像素最近的 2x2 已知像素点。需要加权四个像素值来求得最终的像素值。这使得插值出来比最邻近插值平滑。 双三次插值 基于双线性插值，考虑最近的 4x4已知像素点 —总共16个像素点。由于离待插像素点的距离不同， 在计算中距离近的像素给出的权重较大。双三次产生的图像比前两次的尖锐，有理想的处理时间和输出质量。因此，在很多图像编辑程序中是标准算法 (包括 Adobe Photoshop), 打印机和相机插值。]]></content>
      <tags>
        <tag>图像插值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客 报错 Cannot read property 'replace' of null]]></title>
    <url>%2F2018%2F08%2F28%2Fhexo_error_replace%2F</url>
    <content type="text"><![CDATA[报错内容-情况报错内容如下123FATAL Cannot read property &apos;replace&apos; of nullTypeError: Cannot read property &apos;replace&apos; of null 如图： 报错情况，执行 hexo clean 清理本地缓存或者 hexo g 生成本地缓存时报此错误 解决方法打开 hexo配置文件，配置123456# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://www.aomanhao.toproot: AomanHao.github.iopermalink: :year/:month/:day/:title/permalink_defaults: root，url属性配置正确，填写自己对应的 参考文章]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客yilia主题首页添加helper-live2d模型插件]]></title>
    <url>%2F2018%2F08%2F23%2Fhexo-helper-live2d%2F</url>
    <content type="text"><![CDATA[插件效果插件的github地址插件作者提供了较为详细的安装步骤，我结合自己操作和图示，提供大家。 效果展示：红框内为2d模型，可以随鼠标移动而变化 Hexo 安装模块:hexo博客根目录选择cmd命令窗口或者git bash 输入以下代码，安装插件 操作：1npm install --save hexo-helper-live2d 下载模型作者提供了三个下载模型的办法，我选择操作比较简单的一种npm 模块名 的方法 作者提供以下模型的模型包，模型包预览地址见下面的链接，选择你想用的模型，记住名字，选择对应的后缀模型包 作者各种模型包展示 12345678910111213141516171819202122live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16 选择好对应的模型，使用 npm install 模型的包名来安装，比如我选择的的是live2d-widget-model-koharu 模型包 操作：在hexo博客根目录选择cmd命令窗口或者git bash 输入以下代码 1npm install live2d-widget-model-koharu 执行安装就完事了 配置请向Hexo的 _config.yml 文件添加配置. 操作：打开个人Hexo博客文件根目录下的 _config.yml 文件，在最后添加一下代码示例: 12345678910111213141516live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-koharu display: position: right width: 150 height: 300 mobile: show: true 你需要配置的是use: live2d-widget-model-koharuuse后为你选择的安装包的全称 插件部署与应用就完成了，接下来就是部署hexo博客和个人主页]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
        <tag>yilia</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理_Retinex图像增强]]></title>
    <url>%2F2018%2F08%2F17%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_Retinex%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[图像处理_Retinex图像增强 单尺度SSR(Single Scale Retinex) 图像$S(x,y)$分解为两个不同的图像：反射图像$R(x,y)$,入射图像$L(x,y)$ 图像可以看做是入射图像和反射图像构成，入射光照射在反射物体上，通过反射物体的反射，形成反射光进入人眼。最后形成的图像$r(x,y)$可以如下公式表示 r(x,y)=logR(x,y)=log\frac{S(x,y)}{L(x,y)}R(x, y)表示了物体的反射性质，即图像内在属性，我们应该最大程度的保留；而L(x, y)表示入射光图像，决定了图像像素能达到的动态范围，我们应该尽量去除。 我们把照射图像假设估计为空间平滑图像，原始图像为S(x, y)，反射图像为R(x, y)，亮度图像为L(x, y)，使用公式 r(x,y)=logR(x,y)=log\frac{S(x,y)}{L(x,y)}或者 r(x,y)=logS(x,y)-log[F(x,y)⨂S(x,y)]其中r(x, y)是输出图像,卷积运算，$F(x, y)$是中心环绕函数 F(x,y)=\lambda*e^{-\frac{x^2+y^2}{c^2}}其中C是高斯环绕尺度，λ是一个尺度，满足$∫∫F(x,y)dxdy=1$ SSR算法中的卷积是对入射图像的计算，其物理意义是通过计算像素点与周围区域在加权平均的作用下，估计图像中照度的变化，并将L(x,y)去除，只保留S(x,y)属性。 多尺度MSR(Multi-Scale Retinex) MSR是在SSR基础上发展来的，优点是可以同时保持图像高保真度与对图像的动态范围进行压缩的同时，MSR也可实现色彩增强、颜色恒常性、局部动态范围压缩、全局动态范围压缩，也可以用于X光图像增强。 r(x,y)=∑_k^Kw_klogS(x,y)-log[F_k(x,y)*S(x,y)]K是高斯中心环绕函数的个数。当K=1时，MSR退化为SSR,K取值通常为3 w1=w2=w3=\frac13 缺点:边缘锐化不足，阴影边界突兀，部分颜色发生扭曲，纹理不清晰，高光区域细节没有得到明显改善，对高光区域敏感度小 带颜色恢复的MSR方法MSRCR(Multi-Scale Retinex with Color Restoration)SSR和MSR普遍都存在明显的偏色问题 MSRCR在MSR的基础上，加入了色彩恢复因子C来调节由于图像局部区域对比度增强而导致颜色失真的缺陷。 改进公式： R_{MSRCR_i}(x,y)=C_i(x,y)R_{MSR_i}(x,y)其中 C_i(x,y)=f[I_i^{'}(x,y)]=f[\frac{I_i(x,y)}{∑_{j=1}^{N}I_j(x,y)}]其中 f[I_i^{'}(x,y)]=βlog[αI_i^{'}(x,y)]=β{log[αI_i^{'}i(x,y)]-log[∑_{j=1}^NI_j(x,y)]}参数说明12345Ii(x, y)表示第i个通道的图像Ci表示第i个通道的彩色回复因子，用来调节3个通道颜色的比例；f(·)表示颜色空间的映射函数；β是增益常数；α是受控制的非线性强度； MSRCR算法利用彩色恢复因子C，调节原始图像中3个颜色通道之间的比例关系，从而把相对较暗区域的信息凸显出来，达到了消除图像色彩失真的缺陷。处理后的图像局部对比度提高，亮度与真实场景相似，在人们视觉感知下，图像显得更加逼真。 参考文章]]></content>
      <tags>
        <tag>Opencv</tag>
        <tag>图像处理</tag>
        <tag>图像增强</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法_动态规划]]></title>
    <url>%2F2018%2F08%2F16%2F%E7%AE%97%E6%B3%95_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[算法_动态规划 求解最优化问题 背包问题1123456789101112131415161718192021222324252627282930313233343536373839404142434445Problem Description: 有 n 个重量和价值分别为Wi,Vi的物品，现从这些物品中挑选出总量不超过 W 的物品，求所有方案中价值总和的最大值。Input:输入包含多组测试用例，每一例的开头为两位整数 n、W（1&lt;=n&lt;=10000,1&lt;=W&lt;=1000），接下来有 n 行，每一行有两位整数 Wi、Vi（1&lt;=Wi&lt;=10000,1&lt;=Vi&lt;=100）。Output:输出为一行，即所有方案中价值总和的最大值。Sample Input:3 41 22 53 7Sample Output:9Java代码：import java.util.Arrays;import java.util.Scanner; public class Main &#123; static Scanner scan = new Scanner(System.in); static int[] v = new int[10001]; static int[] w = new int[10001]; static int[] dp = new int[10001]; public static void main(String[] args) &#123; // TODO Auto-generated method stub while(scan.hasNext())&#123; int n = scan.nextInt(); int W = scan.nextInt(); v = new int[n+1]; w = new int[n+1]; for(int i=1;i&lt;=n;i++)&#123; w[i] = scan.nextInt(); v[i] = scan.nextInt(); &#125; for(int i = 1; i &lt;= n; i++) for(int j = W; j &gt;= 0; j--)&#123; //每次更新容量为j，所能放下最大价值的物品 if(j &gt;= w[i])&#123; //j一定要大于w[i],要不最大容量为j的背包放不下第i件物品 dp[j] = Math.max(dp[j], dp[j-w[i]] + v[i]); //dp[j] 表示最大容量为j的背包所装下物品最大的价值， 这里求的是第i件物品放和不放的价值的最大的价值 &#125; &#125; System.out.println(dp[W]); &#125; &#125;&#125; 背包问题21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * @author miracle *切割钢条问题： *长度：1 2 3 4 5 6 7 8 9 10 *价格：1 5 8 9 10 17 17 20 24 30 *问长度为n的钢条的最多卖多少钱 */public class Solution &#123; int[] prices = &#123;0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30&#125;; int[] dp = new int[prices.length]; public int solve(int[] prices, int n)&#123; if(n == 0) return 0; int max = Integer.MIN_VALUE; for(int i = 1; i &lt;= n; i++)&#123; max = Math.max(max, prices[i] + solve(prices, n - i)); &#125; return max; &#125; public int solveWithMemoUpToBottom(int[] prices, int n)&#123; if(n == 0 || dp[n] &gt; 0) return dp[n]; int max = Integer.MIN_VALUE; for(int i = 1; i &lt;= n; i++)&#123; max = Math.max(max, prices[i] + solve(prices, n - i)); &#125; dp[n] = max; return max; &#125; public int solveBottomToUp(int[] prices, int n)&#123; int[] dp = new int[prices.length]; for(int i = 1; i &lt;= n; i++)&#123; int max = Integer.MIN_VALUE; for(int j = 1; j &lt;= i; j++)&#123; max = Math.max(max, prices[j] + prices[i - j]); &#125; dp[i] = max; &#125; return dp[n]; &#125; public static void main(String args[])&#123; Solution s = new Solution();// System.out.println(s.solve(s.prices, 1));// System.out.println(s.solve(s.prices, 2));// System.out.println(s.solve(s.prices, 3));// System.out.println(s.solve(s.prices, 4));// System.out.println(s.solve(s.prices, 5)); System.out.println(s.solveBottomToUp(s.prices, 1)); System.out.println(s.solveBottomToUp(s.prices, 2)); System.out.println(s.solveBottomToUp(s.prices, 3)); System.out.println(s.solveBottomToUp(s.prices, 4)); System.out.println(s.solveBottomToUp(s.prices, 5)); &#125;&#125; 递归 运算量比较大 O(2^N) 递归，dp，分治的区别递归只是一种编程的思想，只要自己调用自己，就算是递归。 分治，有三步，先分，再各自处理，最后整合。这里也涉及了子问题，这里的子问题是不重叠的，每一个只被处理一次，因此不需要memo。 dp，可以使用递归，而且dp的子问题是重复的。]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10大数据算法排序Java_C++]]></title>
    <url>%2F2018%2F08%2F16%2F10%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8FJava_C%2B%2B%2F</url>
    <content type="text"><![CDATA[10大数据算法排序Java_C++ 冒泡排序 依次比较n与后面的数字，大的放右面，小的放左边Java代码12345678910111213141516171819202122232425/** * 冒泡排序 * 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 * 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 * 针对所有的元素重复以上的步骤，除了最后一个。 * 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 * @param numbers 需要排序的整型数组 */ public static void bubbleSort(int[] numbers) &#123; int temp = 0; int size = numbers.length; for(int i = 0 ; i &lt; size-1; i ++) &#123; for(int j = 0 ;j &lt; size-1-i ; j++) &#123; if(numbers[j] &gt; numbers[j+1]) //交换两数位置 &#123; temp = numbers[j]; numbers[j] = numbers[j+1]; numbers[j+1] = temp; &#125; &#125; &#125; &#125; C++代码1待补充 选择排序 选择n个数组成的数组arr里最大的一个数，放在arr[n-1]，然后维数n-1选择前n-1个数组成的数组，取最大数，放在arr Java代码：1234567891011121314151617181920212223242526272829/** * 选择排序算法 * 在未排序序列中找到最小元素，存放到排序序列的起始位置 * 再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。 * 以此类推，直到所有元素均排序完毕。 * @param numbers */ public static void selectSort(int[] numbers) &#123; int size = numbers.length; //数组长度 int temp = 0 ; //中间变量 for(int i = 0 ; i &lt; size ; i++) &#123; int k = i; //待确定的位置 //选择出应该在第i个位置的数 for(int j = size -1 ; j &gt; i ; j--) &#123; if(numbers[j] &lt; numbers[k]) &#123; k = j; &#125; &#125; //交换两个数 temp = numbers[i]; numbers[i] = numbers[k]; numbers[k] = temp; &#125; &#125; C++代码：1待补充 快速排序及其改进算法C++实现 快速排序可以看成是插入排序的改进，它是一种分治的排序算法 Java代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445public class FastSort&#123; public static void main(String []args)&#123; System.out.println(&quot;Hello World&quot;); int[] a = &#123;12,20,5,16,15,1,30,45,23,9&#125;; int start = 0; int end = a.length-1; sort(a,start,end); for(int i = 0; i&lt;a.length; i++)&#123; System.out.println(a[i]); &#125; &#125; public void sort(int[] a,int low,int high)&#123; int start = low; int end = high; int key = a[low]; while(end&gt;start)&#123; //从后往前比较 while(end&gt;start&amp;&amp;a[end]&gt;=key) //如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较 end--; if(a[end]&lt;=key)&#123; int temp = a[end]; a[end] = a[start]; a[start] = temp; &#125; //从前往后比较 while(end&gt;start&amp;&amp;a[start]&lt;=key)//如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置 start++; if(a[start]&gt;=key)&#123; int temp = a[start]; a[start] = a[end]; a[end] = temp; &#125; //此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，右边的值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用 &#125; //递归 if(start&gt;low) sort(a,low,start-1);//左边序列。第一个索引位置到关键值索引-1 if(end&lt;high) sort(a,end+1,high);//右边序列。从关键值索引+1到最后一个 &#125; &#125; C++代码：cankao12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;using namespace std;int main()&#123; int array[]=&#123;34,65,12,43,67,5,78,10,3,70&#125;,k; int len=sizeof(array)/sizeof(int); cout&lt;&lt;&quot;The orginal arrayare:&quot;&lt;&lt;endl; for(k=0;k&lt;len;k++) cout&lt;&lt;array[k]&lt;&lt;&quot;,&quot;; cout&lt;&lt;endl; quickSort(array,0,len-1); cout&lt;&lt;&quot;The sorted arrayare:&quot;&lt;&lt;endl; for(k=0;k&lt;len;k++) cout&lt;&lt;array[k]&lt;&lt;&quot;,&quot;; cout&lt;&lt;endl; system(&quot;pause&quot;); return 0;&#125; void quickSort(int s[], int low, int high)&#123; if (low&lt; high) &#123; int i = low, j = high, x = s[low]; while (i &lt; j) &#123; while(i &lt; j &amp;&amp; s[j]&gt;= x) // 从右向左找第一个小于x的数 j--; if(i &lt; j) s[i++] = s[j]; while(i &lt; j &amp;&amp; s[i]&lt; x) // 从左向右找第一个大于等于x的数 i++; if(i &lt; j) s[j--] = s[i]; &#125; s[i] = x; quickSort(s, low, i - 1); // 递归调用 quickSort(s, i + 1, high); &#125;&#125; 归并排序 归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。分治思想：合并步骤如下 Java代码：cankao12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package sortdemo;import java.util.Arrays;/** * Created by chengxiao on 2016/12/8. */public class MergeSort &#123; public static void main(String []args)&#123; int []arr = &#123;9,8,7,6,5,4,3,2,1&#125;; sort(arr); System.out.println(Arrays.toString(arr)); &#125; public static void sort(int []arr)&#123; int []temp = new int[arr.length];//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间 sort(arr,0,arr.length-1,temp); &#125; private static void sort(int[] arr,int left,int right,int []temp)&#123; if(left&lt;right)&#123; int mid = (left+right)/2; sort(arr,left,mid,temp);//左边归并排序，使得左子序列有序 sort(arr,mid+1,right,temp);//右边归并排序，使得右子序列有序 merge(arr,left,mid,right,temp);//将两个有序子数组合并操作 &#125; &#125; private static void merge(int[] arr,int left,int mid,int right,int[] temp)&#123; int i = left;//左序列指针 int j = mid+1;//右序列指针 int t = 0;//临时数组指针 while (i&lt;=mid &amp;&amp; j&lt;=right)&#123; if(arr[i]&lt;=arr[j])&#123; temp[t++] = arr[i++]; &#125;else &#123; temp[t++] = arr[j++]; &#125; &#125; while(i&lt;=mid)&#123;//将左边剩余元素填充进temp中 temp[t++] = arr[i++]; &#125; while(j&lt;=right)&#123;//将右序列剩余元素填充进temp中 temp[t++] = arr[j++]; &#125; t = 0; //将temp中的元素全部拷贝到原数组中 while(left &lt;= right)&#123; arr[left++] = temp[t++]; &#125; &#125;&#125; C++代码：cankao1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;const int maxn=500000,INF=0x3f3f3f3f;int L[maxn/2+2],R[maxn/2+2];void merge(int a[],int n,int left,int mid,int right)&#123; int n1=mid-left,n2=right-mid; for(int i=0;i&lt;n1;i++) L[i]=a[left+i]; for(int i=0;i&lt;n2;i++) R[i]=a[mid+i]; L[n1]=R[n2]=INF; int i=0,j=0; for(int k=left;k&lt;right;k++) &#123; if(L[i]&lt;=R[j]) a[k]=L[i++]; else a[k]=R[j++]; &#125;&#125;void mergesort(int a[],int n,int left,int right)&#123; if(left+1&lt;right) &#123; int mid=(left+right)/2; mergesort(a,n,left,mid); mergesort(a,n,mid,right); merge(a,n,left,mid,right); &#125;&#125;int main()&#123; int a[maxn],n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; mergesort(a,n,0,n); for(int i=0;i&lt;n;i++) &#123; if(i) cout&lt;&lt;&quot; &quot;; cout&lt;&lt;a[i]; &#125; cout&lt;&lt;endl; return 0;&#125; 堆排序 http://www.cnblogs.com/MOBIN/p/5374217.html 堆排序主要在于理解堆的构造过程和在输出最大元素后如何对堆进行重新调整 大顶堆：父结点始终&gt;子节点 小顶堆：父结点始终&lt;子节点12345算法思想(以大顶堆为例)：1.将长度为n的待排序的数组进行堆有序化构造成一个大顶堆2.将根节点与尾节点交换并输出此时的尾节点3.将剩余的n -1个节点重新进行堆有序化4.重复步骤2，步骤3直至构造成一个有序序列 我们开始只需要扫描一半的元素（n/2-1 ~ 0）,因为(n/2-1)~0的节点才有子节点 构建有序堆：1、第一次for循环将节点3和它的子节点7 8的元素进行比较，最大者作为父节点（即元素60作为父节点）红色表示交换后的状态2、第二次for循环将节点2和它的子节点5 6的元素进行比较，最大者为父节点（元素80作为父节点）3、第三次for循环将节点1和它的子节点3 4的元素进行比较，最大者为父节点（元素70作为父节点） 调整堆1、堆顶元素80和尾40交换后—&gt;调整堆2、堆顶元素70和尾30交换后—&gt;调整堆。。。完成调整 左右父节点下标:123左：i*2+1右：i*2+2父：(i-1)/2 Java代码：123456789101112131415161718192021222324252627282930313233343536373839404142public class HeapSort &#123;private static void heapSort(int[] arr) &#123;int len = arr.length -1;//堆构造，调整结构，符合大顶堆或者小顶堆for(int i = len/2 ; i &gt;=0; i --)&#123; heapAdjust(arr,i,len);&#125;while (len &gt;=0)&#123;swap(arr,0,len--); //将堆顶元素与尾节点交换后，长度减1，尾元素最大heapAdjust(arr,0,len); //再次对堆进行调整&#125;&#125;public static void heapAdjust(int[] arr,int i,int len)&#123;int left = 2*i+1,right = 2*i+2,largest = i;if(left &lt;= len &amp;&amp; arr[left] &gt; arr[i])largest = left;if(right &lt;= len &amp;&amp; arr[right] &gt; arr[largest])largest = right;if(largest != i) &#123;swap(arr, i, largest);heapAdjust(arr,largest,len);&#125;&#125;public static void swap(int[] arr,int i,int len)&#123;int temp = arr[i];arr[i] = arr[len];arr[len] = temp;&#125;public static void main(String[] args) &#123;int array[] = &#123;20,50,20,40,70,10,80,30,60&#125;;System.out.println(&quot;排序之前：&quot;);for(int element : array)&#123;System.out.print(element+&quot; &quot;);&#125;heapSort(array);System.out.println(&quot;\n排序之后：&quot;);for(int element : array)&#123;System.out.print(element+&quot; &quot;);&#125;&#125;&#125; C++代码：1待补充 插入排序Java代码：1待补充 C++代码：1待补充 桶排序需要求数组中的最大数1、桶排序不在是一种基于比较的排序方法，而是需要待排序列满足以下两个条件： 1、待排序列的值处于一个可枚举的范围内2、待排序列所在可枚举范围不应太大，不然开销会很大。 原理： 假设待排序的数组a中共有N个整数，并且已知数组a中数据的范围[0, MAX)。在桶排序时，创建容量为MAX的桶数组r，并将桶数组元素都初始化为0；将容量为MAX的桶数组中的每一个单元都看作一个”桶”。在排序时，逐个遍历数组a，将数组a的值，作为”桶数组r”的下标。当a中数据被读取时，就将桶的值加1。例如，读取到数组a[3]=5，则将r[5]的值+1。 桶排序适用场景:根据桶排序的特点，桶排序一般适用于一些特定的环境，比如数据范围较为局限或者有一些特定的要求，比如需要通过哈希映射快速获取某些值，需要统计每个数的数量。但是这一切都以确认数据的范围为前提，如果范围跨度过大，则考虑用其他算法。 Java代码：12345678910111213141516171819202122232425262728/// &lt;summary&gt;/// 桶排序//////如果有重复的数字,则需要 List&lt;int&gt;数组,这里举的例子没有重复的数字/// &lt;/summary&gt;/// &lt;param name=&quot;unsorted&quot;&gt;待排数组&lt;/param&gt;/// &lt;param name=&quot;maxNumber&quot;&gt;待排数组中的最大数,如果可以提供的话&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;static int[] bucket_sort(int[] unsorted, int maxNumber = 97)&#123; int[] sorted = new int[maxNumber + 1]; for (int i = 0; i &lt; unsorted.Length; i++) &#123; sorted[unsorted[i]] = unsorted[i]; &#125; return sorted;&#125;static void Main(string[] args)&#123; int[] x = &#123;49、 38 、 35、 97 、 76、 73 、 27、 49 &#125;; var sorted = bucket_sort(x, 97); for (int i = 0; i &lt; sorted.Length; i++) &#123; if (sorted[i] &gt; 0) Console.WriteLine(sorted[i]); &#125; Console.ReadLine();&#125; C++代码：1待补充 Java代码：1待补充 C++代码：1待补充 Java代码：1待补充 C++代码：1待补充 Java代码：1待补充 C++代码：1待补充]]></content>
      <tags>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-梯度消失爆炸]]></title>
    <url>%2F2018%2F08%2F16%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E7%88%86%E7%82%B8%2F</url>
    <content type="text"><![CDATA[机器学习-梯度消失爆炸 梯度消失本层的神经元的激活等于上一层神经元对应的权值进行加权和运算，最后通过一个非线性函数（激活函数）如ReLu，sigmoid等函数，最后得到的结果就是本层神经元的输出，逐层逐神经元通过该操作向前传播，最终得到输出层的结果。 梯度消失的影响：1) 浅层基本不学习，后面几层一直在学习，失去深度的意义。2) 无法收敛。 梯度消失的现象呢？因为通常神经网络所用的激活函数是sigmoid函数这个函数有个特点: 就是能将负无穷到正无穷的数映射到0和1之间，并且对这个函数求导的结果是f′(x)=f(x)(1−f(x))。因此两个0到1之间的数相乘，得到的结果就会变得很小了。神经网络的反向传播是逐层对函数偏导相乘，因此当神经网络层数非常深的时候最后一层产生的偏差就因为乘了很多的小于1的数而越来越小，最终就会变为0，从而导致层数比较浅的权重没有更新 一是在深层网络中，网络层数过多二是采用了不合适的损失函数，比如sigmoid 梯度爆炸就是由于初始化权值过大，前面层会比后面层变化的更快，就会导致权值越来越大，梯度爆炸的现象就发生了。 解决用ReLU激活函数来替代sigmoid函数。 区别：（1）sigmoid函数值在[0,1],ReLU函数值在[0,+无穷]，所以sigmoid函数可以描述概率，ReLU适合用来描述实数；（2）sigmoid函数的梯度随着x的增大或减小和消失，而ReLU不会。 早期多层神经网络如果用sigmoid函数或者hyperbolic tangent作为激活函数，如果不进行pre-training的话，会因为gradient vanishing problem而无法收敛。 而预训练的用处：规则化，防止过拟合；压缩数据，去除冗余；强化特征，减小误差；加快收敛速度。而采用ReLu则不需要进行pre-training。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指Offer算法Code_Java_C++(0820更新)]]></title>
    <url>%2F2018%2F08%2F16%2F%E5%89%91%E6%8C%87Offer%E7%AE%97%E6%B3%95Code_Java_C%2B%2B%2F</url>
    <content type="text"><![CDATA[剑指Offer算法Code_Java_C++ 1在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路：从左下角元素往上查找，右边元素是比这个元素大，上边是的元素比这个元素小。Java代码1234567891011121314151617public class Solution &#123; public boolean Find(int target, int [][] array) &#123; //填写 int row = array.length; int col = array[0].length; int i=row-1,j=0; while(i&gt;=0&amp;&amp;j&lt;=col-1)&#123; if(target&lt;array[i][j])&#123; i--; &#125;else if(target&gt;array[i][j])&#123; j++; &#125;else return true; &#125; return false; &#125;&#125; C++代码123456789101112131415161718class Solution &#123;public: bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123; // array是二维数组，这里没做判空操作 int rows = array.size(); int cols = array[0].size(); int i=rows-1,j=0;//左下角元素坐标 while(i&gt;=0 &amp;&amp; j&lt;cols)&#123;//使其不超出数组范围 if(target&lt;array[i][j]) i--;//查找的元素较少，往上找 else if(target&gt;array[i][j]) j++;//查找元素较大，往右找 else return true;//找到 &#125; return false; &#125;&#125;; 2请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。Java代码：1234567public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; String str1 = str.toString(); String str2 = str1.replace(&quot; &quot;,&quot;%20&quot;); return str2; &#125;&#125; Java代码：1234567891011121314151617181920212223public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; int spacenum = 0;//spacenum为计算空格数 for(int i=0;i&lt;str.length();i++)&#123; if(str.charAt(i)==&apos; &apos;) spacenum++; &#125; int indexold = str.length()-1; //indexold为为替换前的str下标 int newlength = str.length() + spacenum*2;//计算空格转换成%20之后的str长度 int indexnew = newlength-1;//indexold为为把空格替换为%20后的str下标 str.setLength(newlength);//使str的长度扩大到转换成%20之后的长度,防止下标越界 for(;indexold&gt;=0 &amp;&amp; indexold&lt;newlength;--indexold)&#123; if(str.charAt(indexold) == &apos; &apos;)&#123; // str.setCharAt(indexnew--, &apos;0&apos;); str.setCharAt(indexnew--, &apos;2&apos;); str.setCharAt(indexnew--, &apos;%&apos;); &#125;else&#123; str.setCharAt(indexnew--, str.charAt(indexold)); &#125; &#125; return str.toString(); &#125;&#125; c++代码123456789101112131415161718192021class Solution &#123;public: void replaceSpace(char *str,int length) &#123; int count = 0; for (int i=0;i&lt;length;i++)&#123; if (str[i]==&apos; &apos;)&#123; count++; &#125; for (int i=length-1;i&gt;=0;i--)&#123; if (str[i]==&apos; &apos;)&#123; count--; str[i+2*count]=&apos;%&apos;; str[i+2*count+1]=&apos;2&apos;; str[i+2*count+2]=&apos;0&apos;; &#125;else&#123; str[i+2*count]=str[i]; &#125; &#125; &#125; &#125;&#125;; 3输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 Java代码：1234567891011java 递归超简洁版本public class Solution &#123; ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;Integer&gt;(); public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; if(listNode!=null)&#123; this.printListFromTailToHead(listNode.next); arrayList.add(listNode.val); &#125; return arrayList; &#125;&#125; C++代码1234567891011121314class Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; vector&lt;int&gt; value; if (head != NULL)&#123; value.insert(value.begin(),head-&gt;val); while (head-&gt;next !=NULL)&#123; value.insert(value.begin(),head-&gt;next-&gt;val); head = head -&gt;next; &#125; &#125; return value; &#125;&#125;; 4输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 递归思想，每次将左右两颗子树当成新的子树进行处理，中序的左右子树索引很好找，前序的开始结束索引通过计算中序中左右子树的大小来计算，然后递归求解，直到startPre&gt;endPre||startIn&gt;endIn说明子树整理完到。方法每次返回左子树活右子树的根节点1234567 1 / \ 2 3 /\ /4 5 6 \ / 7 8 Java代码：12345678910111213141516171819202122public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; TreeNode root=reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1); return root; &#125; //前序遍历&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125; private TreeNode reConstructBinaryTree(int [] pre,int startPre,int endPre,int [] in,int startIn,int endIn) &#123; if(startPre&gt;endPre||startIn&gt;endIn) return null; TreeNode root=new TreeNode(pre[startPre]); for(int i=startIn;i&lt;=endIn;i++) if(in[i]==pre[startPre])&#123; root.left=reConstructBinaryTree(pre,startPre+1,startPre+i-startIn,in,startIn,i-1); root.right=reConstructBinaryTree(pre,i-startIn+startPre+1,endPre,in,i+1,endIn); break; &#125; return root; &#125;&#125; 5大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 Java代码123456789101112131415public class Solution &#123; public int Fibonacci(int n) &#123; if(n&lt;1)&#123; return n; &#125; int[] ints = new int[n+1]; ints[0] = 0; ints[1] = 1; for(int i = 2; i &lt;= n; i++ )&#123; ints[i] = ints[i-1] + ints[i-2]; &#125; return ints[n]; &#125;&#125; C++代码：1234567891011121314151617class Solution &#123;public: int Fibonacci(int n) &#123; int pre = 0; int last=1; int result =0; if(n&lt;=1)&#123; return n; &#125; for(int i=2; i&lt;=n; i++)&#123; result=pre+last; pre=last; last=result; &#125; return result; &#125;&#125;; 6一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 思路：，f(1) = 1, f(2) = 2, f(3) = 3, f(4) = 5， 可以总结出f(n) = f(n-1) + f(n-2)的规律Java代码：123456789101112131415public class Solution &#123; public int JumpFloor(int target) &#123; int[] ints= new int[target+1]; if(target &lt;=0 )&#123; return 0; &#125;else if(target==1 || target==2)&#123; return target; &#125; ints[0] = 1;ints[1] = 2; for(int i =2; i&lt;=target; i++)&#123; ints[i] = ints[i-1] + ints[i-2]; &#125; return ints[target-1]; &#125;&#125; C++代码1234567891011121314151617class Solution &#123;public: int jumpFloor(int number) &#123; int first = 1;int second = 2; int result = 0; if (number&lt;=0)&#123; return 0; &#125;else if (number==1||number==2)&#123; return number; &#125; for (int i=3; i&lt;=number; i++)&#123; result = first + second; first = second; second = result; &#125; return result; &#125;&#125;; 7输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 思路：1自身左移动，然后跟原数字做与比较，如果对应相同输出为1，否则为0。Java代码：12345678910111213public class Solution &#123; public int NumberOf1(int n) &#123; int count = 0; int flag = 1; while(flag != 0)&#123; if((n &amp; flag) !=0 )&#123; count++; &#125; flag = flag &lt;&lt; 1; &#125; return count; &#125;&#125; C++代码：123456789101112131415class Solution &#123;public: int NumberOf1(int n) &#123; int count = 0; int flag = 1; while(flag != 0)&#123; if((n &amp; flag)!=0)&#123; count++; &#125; flag = flag &lt;&lt; 1; &#125; return count ; &#125; &#125;; 8输入一个链表，反转链表后，输出新链表的表头: 整体反转链表，但是要把断开的节点保存起来，才能继续反转链表Java代码：12345678910111213141516171819202122232425262728293031public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; if(head==null) return null; //head为当前节点，如果当前节点为空的话，那就什么也不做，直接返回null； ListNode pre = null; ListNode next = null; //当前节点是head，pre为当前节点的前一节点，next为当前节点的下一节点 //需要pre和next的目的是让当前节点从pre-&gt;head-&gt;next1-&gt;next2变成pre&lt;-head next1-&gt;next2 //即pre让节点可以反转所指方向，但反转之后如果不用next节点保存next1节点的话，此单链表就此断开了 //所以需要用到pre和next两个节点 //1-&gt;2-&gt;3-&gt;4-&gt;5 //1&lt;-2&lt;-3 4-&gt;5 while(head!=null)&#123; //做循环，如果当前节点不为空的话，始终执行此循环，此循环的目的就是让当前节点从指向next到指向pre //如此就可以做到反转链表的效果 //先用next保存head的下一个节点的信息，保证单链表不会因为失去head节点的原next节点而就此断裂 next = head.next; //保存完next，就可以让head从指向next变成指向pre了，代码如下 head.next = pre; //head指向pre后，就继续依次反转下一个节点 //让pre，head，next依次向后移动一个节点，继续下一次的指针反转 pre = head; head = next; &#125; //如果head为null的时候，pre就为最后一个节点了，但是链表已经反转完毕，pre就是反转后链表的第一个节点 //直接输出pre就是我们想要得到的反转后的链表 return pre; &#125;&#125; C++代码：123456789101112131415161718192021222324class Solution &#123;public: ListNode* ReverseList(ListNode* pHead) &#123; if(pHead == NULL)&#123; return NULL; &#125; ListNode* pNode = pHead;//当前指针 ListNode* pPre = NULL;//链表的前一个指针 ListNode* pNewHead = NULL; while(pNode != NULL)&#123; ListNode* pNext = pNode-&gt;next; if(pNext == NULL)&#123; //尾节点 pNewHead = pNode; &#125; pNode-&gt;next = pPre; pPre = pNode; pNode = pNext; &#125; return pNewHead; &#125;&#125;; 9输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 两两数值对比,merge可以合并两个事物，链表也行，考点在取两个链表比较小的头节点 Java代码：1234567891011121314151617public class Solution &#123; public ListNode Merge(ListNode list1,ListNode list2) &#123; if(list1 == null)&#123; return list2; &#125; if(list2 == null)&#123; return list1; &#125; if(list1.val &lt;= list2.val)&#123; list1.next = Merge(list1.next,list2); return list1; &#125;else&#123; list2.next = Merge(list1,list2.next); return list2; &#125; &#125;&#125; C++代码：12345678910111213141516171819202122class Solution &#123;public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) &#123; if(pHead1 == NULL)&#123; return pHead2; &#125; if(pHead2 == NULL)&#123; return pHead1; &#125; ListNode* NewHead = NULL; if(pHead1-&gt;val &lt;= pHead2-&gt;val)&#123; NewHead = pHead1; NewHead-&gt;next = Merge(pHead1-&gt;next,pHead2); &#125;else&#123; NewHead = pHead2; NewHead-&gt;next = Merge(pHead1,pHead2-&gt;next); &#125; return NewHead; &#125;&#125;; 10 从上往下打印出二叉树的每个节点，同层节点从左至右打印。 Java代码：123456789101112131415161718192021222324/**思路是用arraylist模拟一个队列来存储相应的TreeNode*/public class Solution &#123; public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; arr = new ArrayList&lt;&gt;(); ArrayList&lt;TreeNode&gt; TN = new ArrayList&lt;&gt;(); if(root==null)&#123; return arr; &#125; TN.add(root); while(TN.size()!=0)&#123; TreeNode temp = TN.remove(0); if(temp.left!= null)&#123; TN.add(temp.left); &#125; if(temp.right!= null)&#123; TN.add(temp.right); &#125; arr.add(temp.val); &#125; return arr; &#125;&#125; C++代码：12345678```### 111个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。&gt;思路：两个相同数字异或=0，一个数和0异或还是它本身。&lt;br&gt;我们首先还是先异或，剩下的数字肯定是A、B异或的结果，这个结果的二进制中的1，表现的是A和B的不同的位。我们就取第一个1所在的位数，假设是第3位，接着把原数组分成两组，分组标准是第3位是否为1。如此，相同的数肯定在一个组，因为相同数字所有位都相同，而不同的数，肯定不在一组。然后把这两个组按照最开始的思路，依次异或，剩余的两个结果就是这两个只出现一次的数字。Java代码： public class Solution { public void FindNumsAppearOnce(int[] array, int[] num1, int[] num2) { int length = array.length; if(length == 2){ num1[0] = array[0]; num2[0] = array[1]; return; } int bitResult = 0; for(int i = 0; i &lt; length; ++i){ bitResult ^= array[i]; } int index = findFirst1(bitResult); for(int i = 0; i &lt; length; ++i){ if(isBit1(array[i], index)){ num1[0] ^= array[i]; }else{ num2[0] ^= array[i]; } } } private int findFirst1(int bitResult){ int index = 0; while(((bitResult &amp; 1) == 0) &amp;&amp; index &lt; 32){ bitResult &gt;&gt;= 1; index++; } return index; } private boolean isBit1(int target, int index){ return ((target &gt;&gt; index) &amp; 1) == 1; } }12C++代码： 链接：https://www.nowcoder.com/questionTerminal/e02fdb54d7524710a7d664d082bb7811来源：牛客网 class Solution {public: void FindNumsAppearOnce(vector data,int num1,int num2) { if(data.size()&gt;1; ++index; } num1=num2=0; for(int i=0;i&gt;index; return (num&amp;1); }};1234567 ^=:逐位异或 ### 12最小的k个数输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。Java代码：(快排/最小堆) 链接：https://www.nowcoder.com/questionTerminal/6a296eb82cf844ca8539b57c23e6e9bf来源：牛客网 / 基于堆排序算法，构建最大堆。时间复杂度为O(nlogk)如果用快速排序，时间复杂度为O(nlogn)； 如果用冒泡排序，时间复杂度为O(nk) /import java.util.ArrayList;public class Solution { public ArrayList GetLeastNumbers_Solution(int [] input, int k) { ArrayList list=new ArrayList(); //检查输入的特殊情况 if(input==null || input.length&lt;=0 || input.length=0; len—){ adjustMaxHeapSort(input,len,k-1); } //从第k个元素开始分别与最大堆的最大值做比较，如果比最大值小，则替换并调整堆。 //最终堆里的就是最小的K个数。 int tmp; for(int i=k; i&lt;input.length; i++){ if(input[i]&lt;input[0]){ tmp=input[0]; input[0]=input[i]; input[i]=tmp; adjustMaxHeapSort(input,0,k-1); } } for(int j=0; j&lt;k; j++){ list.add(input[j]); } return list; } public void adjustMaxHeapSort(int[] input, int pos, int length){ int temp; int child; for(temp=input[pos]; 2*pos+1&lt;=length; pos=child){ child=2*pos+1; if(child&lt;length &amp;&amp; input[child]&lt;input[child+1]){ child++; } if(input[child]&gt;temp){ input[pos]=input[child]; }else{ break; } } input[pos]=temp; } }1### 二叉树的景象 题目描述操作给定的二叉树，将其变换为源二叉树的镜像。输入描述:二叉树的镜像定义：源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11 镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 51C++代码： 12345### 13Java代码： public class Solution { public void Mirror(TreeNode root) { if(root == null){ return; } TreeNode temp; if(root!=null){ temp = root.left; root.left = root.right; root.right = temp; } if(root.left!=null){ Mirror(root.left); } if(root.right!=null){ Mirror(root.right); } } }12C++代码： 12345Java代码： 1C++代码： 1234Java代码： 12C++代码： 12345Java代码： 12C++代码： 12345Java代码： 1C++代码： ```]]></content>
      <tags>
        <tag>Java</tag>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode题解]]></title>
    <url>%2F2018%2F08%2F16%2Fleetcode_sum%2F</url>
    <content type="text"><![CDATA[三数之和给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 1 Two Sum5 array、set sort、Two Pointers 8 String to Integer (atoi) 5 string Math15 3Sum 5 array Two Pointers20 Valid Parentheses 5 string Stack21 Merge Two Sorted Lists 5 linked list sort、Two Pointers、merge28 Implement strStr() 5 string Two Pointers、KMP、rolling hash50 Pow(x, n) 5 Binary Search、Math56 Merge Intervals 5 array、linked list、red-black tree sort、merge57 Insert Interval 5 array sort65 Valid Number 5 string Math70 Climbing Stairs 5 DP73 Set Matrix Zeroes 5 array88 Merge Sorted Array 5 array Two Pointers、merge98 Validate Binary Search Tree 5 tree DFS125 Valid Palindrome 5 string Two Pointers127 Word Ladder 5 graph BFS、path2 Add Two Numbers 4 linked list Two Pointers、Math12 Integer to Roman 4 Math13 Roman to Integer 4 Math22 Generate Parentheses 4 string DFS23 Merge k Sorted Lists 4 linked list、heap sort、Two Pointersmerge24 Swap Nodes in Pairs 4 linked list27 Remove Element 4 array Two Pointers46 Permutations 4 array permutation49 Anagrams 4 string、hashtable67 Add Binary 4 string Two Pointers、Math69 Sqrt(x) 4 Binary Search77 Combinations 4 combination78 Subsets 4 array Recursion、combination79 Word Search 4 array DFS91 Decode Ways 4 string Recursion、DP102 Binary Tree Level Order Traversal 4 tree BFS129 Sum Root to Leaf Numbers 4 tree DFS131 Palindrome Partitioning 4 string DFS4 Median of Two Sorted Arrays 3 array Binary Search7 Reverse Integer 3 Math10 Regular Expression Matching 3 string Recursion、DP17 Letter Combinations of a Phone Number 3 string DFS19 Remove Nth Node From End of List 3 linked list Two Pointers26 Remove Duplicates from Sorted Array 3 array Two Pointers29 Divide Two Integers 3 Binary Search33 Search in Rotated Sorted Array 3 array Binary Search34 Search for a Range 3 array Binary Search39 Combination Sum 3 array combination43 Multiply Strings 3 string Two Pointers、Math44 Wildcard Matching 3 string Recursion、DP、greedy51 N-Queens 3 array DFS52 N-Queens II 3 array DFS53 Maximum Subarray 3 array DP62 Unique Paths 3 array DP63 Unique Paths II 3 array DP64 Minimum Path Sum 3 array DP72 Edit Distance 3 string DP74 Search a 2D Matrix 3 array Binary Search81 Search in Rotated Sorted Array II 3 array Binary Search82 Remove Duplicates from Sorted List II 3 linked list Recursion、Two Pointers83 Remove Duplicates from Sorted List 3 linked list86 Partition List 3 linked list Two Pointers93 Restore IP Addresses 3 string DFS94 Binary Tree Inorder Traversal 3 tree、hashtable Recursion、morris、Stack103 Binary Tree Zigzag Level Order Traversal 3 queue、tree BFS、Stack105 Construct Binary Tree from Preorder and Inorder Tr 3 array、tree DFS106 Construct Binary Tree from Inorder and Postorder T 3 array、tree DFS108 Convert Sorted Array to Binary Search Tree 3 tree DFS109 Convert Sorted List to Binary Search Tree 3 linked list Recursion、Two Pointers112 Path Sum 3 tree DFS114 Flatten Binary Tree to Linked List 3 tree Recursion、Stack116 Populating Next Right Pointers in Each Node 3 tree DFS128 Longest Consecutive Sequence 3 array130 Surrounded Regions 3 array BFS、DFS132 Palindrome Partitioning II 3 string DP3 Longest Substring Without Repeating Characters 2 string、hashtable Two Pointers5 Longest Palindromic Substring 2 string9 Palindrome Number 2 Math11 Container With Most Water 2 array Two Pointers18 4Sum 2 array25 Reverse Nodes in k-Group 2 linked list Recursion、Two Pointers31 Next Permutation 2 array permutation35 Search Insert Position 2 array36 Valid Sudoku 2 array37 Sudoku Solver 2 array DFS38 Count and Say 2 string Two Pointers40 Combination Sum II 2 array combination41 First Missing Positive 2 array sort42 Trapping Rain Water 2 array Two Pointers、Stack45 Jump Game II 2 array47 Permutations II 2 array permutation48 Rotate Image 2 array54 Spiral Matrix 2 array55 Jump Game 2 array59 Spiral Matrix II 2 array61 Rotate List 2 linked list Two Pointers66 Plus One 2 array Math68 Text Justification 2 string75 Sort Colors 2 array sort、Two Pointers76 Minimum Window Substring 2 string Two Pointers80 Remove Duplicates from Sorted Array II 2 array Two Pointers84 Largest Rectangle in Histogram 2 array Stack87 Scramble String 2 string Recursion、DP89 Gray Code 2 combination90 Subsets II 2 array Recursion、combination92 Reverse Linked List II 2 linked list Two Pointers97 Interleaving String 2 string Recursion、DP99 Recover Binary Search Tree 2 tree DFS101 Symmetric Tree 2 tree DFS110 Balanced Binary Tree 2 tree DFS113 Path Sum II 2 tree DFS115 Distinct Subsequences 2 string DP117 Populating Next Right Pointers in Each Node II 2 tree DFS124 Binary Tree Maximum Path Sum 2 tree DFS6 ZigZag Conversion 1 string14 Longest Common Prefix 1 string16 3Sum Closest 1 array Two Pointers30 Substring with Concatenation of All Words 1 string Two Pointers32 Longest Valid Parentheses 1 string DP58 Length of Last Word 1 string60 Permutation Sequence 1 permutation、Math71 Simplify Path 1 string Stack85 Maximal Rectangle 1 array DP、Stack95 Unique Binary Search Trees II 1 tree DP、DFS96 Unique Binary Search Trees 1 tree DP100 Same Tree 1 tree DFS104 Maximum Depth of Binary Tree 1 tree DFS107 Binary Tree Level Order Traversal II 1 tree BFS111 Minimum Depth of Binary Tree 1 tree DFS118 Pascal’s Triangle 1 array119 Pascal’s Triangle II 1 array120 Triangle 1 array DP121 Best Time to Buy and Sell Stock 1 array DP122 Best Time to Buy and Sell Stock II 1 array greedy123 Best Time to Buy and Sell Stock III 1 array DP126 Word Ladder II 1]]></content>
      <tags>
        <tag>笔面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面经-概率论算法]]></title>
    <url>%2F2018%2F08%2F16%2F%E9%9D%A2%E7%BB%8F-%E6%A6%82%E7%8E%87%E8%AE%BA%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Q1100人坐飞机，第一个乘客在座位中随便选一个坐下，第100人正确坐到自己坐位的概率是？ Q2给定三个随机变量X,Y,Z，已知X和Y的相关系数(correlation)为0.8，X和Z的相关系数为0.8。问Y和Z的相关系数最大／最小为多少？ 答： |1|0.8|0.8||0.8|1|a||0.8|a|1| Q3几何分布:一个国家重男轻女，只要生了女孩就继续生，直到生出男孩为止，问这个国家的男女比例？ 答： 1比1 因为只要生了女孩就继续生，直到生出男孩为止，影响的是家庭男女孩的比例，国家总人数比例还是1比1 Q4有50个红球，50个蓝球，如何放入两个盒子中使得拿到红球的概率最大 如果要拿两个红的，一个盒子放一个红球，一个盒子放49红，50蓝，取两个红球概率49/99 Q5一根木棍随机折成三段，能组成三角形的概率多大？ 答：任意两边之和大于第三边p=[(1/8)a^2]/[(1/2)a^2]=1/4=0.25 Q6Q7Q8Q9Q10]]></content>
      <tags>
        <tag>笔面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面经—机器学习]]></title>
    <url>%2F2018%2F08%2F15%2F%E9%9D%A2%E7%BB%8F%E2%80%94%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[面经—机器学习 CVTE面经作者：一一后链接：https://www.nowcoder.com/discuss/88069来源：牛客网 1.解释方差 2.PCA的实现过程；推导PCA 3.传统的图像特征有哪些 4.Sift特征为什么能实现尺度不变性（讲sift原理到一半，我发现完全解释不了为啥尺度不变，就停了，尴尬）[参考](https://blog.csdn.net/u014485485/article/details/78681086?locationNum=1&amp;fps=1）123尺度不变性：不管原图尺度是多少，在包含了所有尺度的尺度空间下都能找到那些稳定的极值点，这样就做到了尺度不变！高斯函数是唯一可行的尺度空间核 5.Hough直线检测的原理 6.梯度下降和牛顿法的区别1234567891011牛顿法的优缺点优点：二阶收敛，收敛速度快；缺点：牛顿法是一种迭代算法，每一步都需要求解目标函数的Hessian矩阵的逆矩阵，计算比较复杂。梯度下降法的优化思想是用当前位置负梯度方向作为搜索方向，因为该方向为当前位置的最快下降方向，所以也被称为是”最速下降法“。最速下降法越接近目标值，步长越小，前进越慢梯度下降法的缺点：靠近极小值时收敛速度减慢，；直线搜索时可能会产生一些问题；可能会“之字形”地下降。牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快 7.SVM和Lr的共同点和不同点1234567891011121314151617LR和SVM都是分类算法LR和SVM都是线性分类算法LR和SVM都是监督学习算法LR和SVM都是判别模型LR和SVM在学术界和工业界都广为人知并且应用广泛不同：损失函数LR：逻辑回归方法基于概率理论逻辑回归考虑全局（远离的点对边界线的确定也起作用）对数据不做处理LR必须另外在损失函数上添加正则项SVM：几何间隔最大化原理支持向量机只考虑局部的边界线附近的点，线性SVM不直接依赖于数据分布线性SVM依赖数据表达的距离测度，所以需要对数据先做归一化SVM的损失函数就自带正则 8.rf和Adaboost的异同(优秀的基于决策树的组合算法)123451，相同：二者都是bootsrap自助法选取样本。 2，相同：二者都是要训练很多棵决策树。 3，不同：adaboost后面树的训练，其在变量抽样选取的时候，对于上一棵树分错的样本，抽中的概率会加大。 4，不同：随机森林在训练每一棵树的时候，随机挑选了部分变量作为拆分变量，而不是所有的变量都去作为拆分变量。 5，不同：在预测新数据时，adaboost中所有的树加权投票来决定因变量的预测值，每棵树的权重和错误率有关；随机森林按照所有树中少数服从多数树的分类值来决定因变量的预测值。 9.给出一堆大小不一的矩形框，快速求矩形框的灰度值之和（当时没理解，这不是肯定要遍历么…后来结束后我想这些矩形框可能是重叠的，估计是要问我关于Bing中快速求梯度的算法） 10.有什么要问他的 作业帮提前批机器学习算法岗作者：编程一头牛链接：https://www.nowcoder.com/discuss/90245来源：牛客网 对数据预处理怎么填充的缺失值，哪些判定为异常值，对连续属性进行离散化有什么好处，Logistic回归能处理浮点数吗？多项式组合特征对哪个模型中效果提升最大。这个没答上来，问了面试官，面试官说是Logistic回归里面提升最大，而且组合起来的两个特征也是想出来的，没什么理论支撑。还问了模型的评价指标AUC是如何计算的，ROC曲线的横纵坐标代表了什么含义。XGBoost模型里面参数有哪些？如何发现过拟合。XGBoost模型中对数据进行采样的好处？ 如何最快的找出两个集合中的交集，提出用哈希表的方法，问了这种方法的复杂度，然后又问如果这两个集合都特别大，不能再内存中构建哈希表该如何做？可能是想让我回答多线程相关的内容，但是我不会。如何设计哈希表？期间也问过有编过多线程多进程的代码吗 深信服【机器学习】一面作者：Rnanprince链接：https://www.nowcoder.com/discuss/87283来源：牛客网 【机器学习】一面：1.项目介绍，研究的最成功的地方，我以写的文章为例，涉及到的知识点就问2.笔试的数组求和100怎么做的？没抽到这个题，但是做过；接着我说做了查找重复字符串最大长度，深搜，过了就没想别的方法一个数组，求最长的连续子序列的起始下标，当时没理解明白，其实有歧义，简单说了一下3.自己的哪些方面的优点没有涉及到，介绍一下提到了SVM和决策树，介绍一下什么情况下使用？svm:12345678910111213141516171819202122232425262728293031这个模型的优势是什么？分类效果好；可以有效地处理高维空间的数据；可以有效地处理变量个数大于样本个数的数据；只是使用了一部分子集来进行训练模型，所以SVM模型不需要太大的内存；可以提高泛化能力；无局部极小值问题；他什么情况下表现最好？数据的维度较高；需要模型具有非常强的泛化能力；样本数据量较小时；解决非线性问题；这个模型的缺点是什么？无法处理大规模的数据集，因为该算法需要较长的训练时间；无法有效地处理包含噪声太多的数据集；SVM模型没有直接给出概率的估计值，而是利用交叉验证的方式估计，这种方式耗时较长；对缺失数据非常敏感；对于非线性问题，有时很难找到一个合适的核函数。什么条件下它表现很差？数据集的数据量过大；数据集中的含有噪声；数据集中的缺失较多的数据；对算法的训练效率要求较高；根据我们当前数据集的特点，为什么这个模型适合这个问题。 该项目所提供的样本数据相对较少；该问题是属于非线性问题；数据集经过“独热编码”后，维度较高 决策树：1234567891011121314151617181920212223242526272829303132这个模型的优势是什么？决策树易于实现和理解；对于决策树，数据的准备工作一般比较简单；能够同时处理多种数据类型给定一个决策树模型，可以根据产生的决策树推出相应的逻辑表达式；通过静态测试来对模型的表现进行评价；在相对较短的时间内可以对大量的数据做出非常好的结果；决策树可以很好地扩展到大型数据中，同时决策树的大小独立于数据库的大小；计算复杂度相对较低，结果的输出易于理解，对部分的数据缺失不敏感。他什么情况下表现最好？实例是由“属性-值”对表示的；目标函数具有离散的输出值；训练数据集包含部分错误(决策树对错误有适应性)；训练数据缺少少量属性的实例。这个模型的缺点是什么？易于出现过拟合问题；忽略了数据集中属性之间的相关性；对于类比不一致的样本，决策树的信息增益倾向于那些数据值较多的特征什么条件下它表现很差？决策树匹配的数据过多时；分类的类别过于复杂；数据的属性之间具有非常强的关联。根据我们当前数据集的特点，为什么这个模型适合这个问题。不需要准备太多的训练数据，不需要对数据过多的处理如删除空白值等；易于编码；该问题是非线性问题，决策树能够很好地解决非线性问题；算法的执行效率高，对机器的要求较小。 360浏览器事业部 推荐算法工程师作者：泡了个泡链接：https://www.nowcoder.com/discuss/77924来源：牛客网 二面 1.项目 2.SVM原始问题为什么要转化为对偶问题，为什么对偶问题就好求解，原始问题不能求解么 3.K-means 中我想聚成100类 结果发现只能聚成98类，为什么 4.进程中的内存分段是怎样的 5.每个线程有哪些东西是自己独享的 6.一枚不均匀的硬币，我抛了100次，有70次朝上，那么第101次朝上的概率是多少 这个概率怎么样，公示是如何推导出来的 7.给你个字符串，字符串是个数字，怎么转换为int型，不用库函数的话 8.4个海盗，100个金币，每个人轮流提方案，如果你的方案有半数以上通过，那么久可以，否则就会被杀掉，如果你是第一个人，那么你怎么提方案比较好 9.你的优点是什么 腾讯沈阳现场一面1.项目 2.特征选择方法都有用过哪些 3.随机森林怎么进行特征选择 4.用过哪些机器学习算法 5.加密方法知道哪些 6.MD5可逆么 7.word2vec用过么 8.极大似然估计是什么意思 9.上过哪些课 10.排序算法哪些时间复杂度比较低 11.计算机网络了解多少 阿里 新零售 天猫 算法工程师-机器学习一面先是一个简单的自我介绍；1.然后介绍了项目的框架和主要创新点； 2.说一下随机森林和Adaboost，以及区别 3.说一下GBDT和Adaboost，以及区别 4.说一下LDA的原理 5.对于PCA，会有第一主成分、第二主成分，怎么为什么第一主成分是第一，原因是什么？ 6.PCA的主成分是怎么得到的 3.面向对象的三要素 4.对深度学习了解多少 5.你觉得深度学习的方法和传统机器学习比，有什么大的优势 腾讯提前批作者：IamBright链接：https://www.nowcoder.com/discuss/75166来源：牛客网 女朋友在广州又不想换工作的情况下，微信的机器学习算法工程师是最适合我实习的岗位了，因此最先让腾讯的同学内推了一波，在基本没有准备的情况下，接到了提前批电话一面二面，毫无意外的挂了。 电话一面聊论文，但多数听我在说，没插话什么问题。最后问我第二篇论文里RNN实现的时候有什么trick。问了问凸优化了解吗？传统机器学习了解吗？我答机器学习基本知识都学过，凸优化只了解和机器学习优化算法相关的。也没有继续问细节了。编程题：打印所有子集，我用了迭代，但是写的比较蠢，好在不用调试运行电话二面聊论文，最后问了我跟什么算法做了对比，问我研究的实际意义，产业界现在的水平编程题：打印螺旋矩阵，要我给一个可运行的结果。很简单的题，我一个符号错误调了很久都没发现，这里应该就印象很差了。linux里查看端口被占用的命令，linux不熟，没答上。AUC是什么？我说了是ROC曲线下面积，但是想不起来ROC是啥。我都是做序列数据，没做过二分类问题。LR和SVM的区别。我说了损失函数不同，然后说了SVM通过核技巧可以更好的应对非线性，但是前面好差，这里也没好好组织语言了。提前批挂的没什么话说，就是没准备，好久没做过算法题的情况下，突然出题做就很不顺手。而且机器学习的基础知识都有点忘了，像AUC这种没用过的，基本一问就懵逼。 之后跟工作的同学聊了一下，来牛客刷了刷面经，制定了简单的复习内容和刷题计划。花了一周时间，复习了一下西瓜书前11章和deep learning book前11章，刷了leetcode上三四十道medium的题吧（链表、字符串、迭代、dfs、堆、树、动态规划等每天刷一类题练练手），并且给自己做完2篇论文都准备了面试介绍版，又让同学推了阿里和网易，并进入腾讯笔试流程。 算法、数据挖掘岗面经作者：胖胖胖子链接：https://www.nowcoder.com/discuss/81814来源：牛客网 1.华为回国之后参加的第一次面试就是华为的留学生专场招聘，岗位是大数据开放（华为好像填什么岗位都没差吧~），一共只有两面一面：介绍我的项目经历，我介绍完面试官尴尬的笑了笑说他不是做大数据方向的，也就没问我什么，聊了聊天愉快的过了二面：可能会针对笔试提问，因为面试官问我为什么没参加笔试，然后就问了问职业规划，说大数据方向都在深圳工作，然后就一直问怎么看待华为的加班文化，怎么看待压力之类的大概10天之后就直接把offer发到了邮箱里2.第四范式（二面挂）刚面完华为就参加了第四范式的面试，以为面试就是聊聊天，后来发现真是naive，第四范式的岗位是nlp研究员一面：就写了两个代码，一个是逆时针打印矩阵，一个是leetcode原题count and say，虽然当时还没刷过题但写的都是easy难度，就过了二面：二面面试官是牛津大学的phd，问我是不是distinction我说不是，就感受到了一股失望~讲了讲项目，问的很细，但是都在自己的项目范围内，问完之后又是写代码，一个字符串如何删除不匹配的括号然后输出括号匹配的字符串，比如（abc（），输出（abc）和abc（），哼哼唧唧没写出来就跪了3.招银网络招银网络面试岗位是算法工程师，一共两轮技术面，一轮hr面一面：讲项目，问了决策树ID3，C4.5，CART的区别，讲了SVM的原理，然后写了找两个数的最小公倍数的代码二面：讲项目，然后面试官说他是做C++开发的，问我会不会C++，我说学过但很久没用了，就聊了聊天愉快的过了hr面：略（就谈人生谈理想接不接受调岗） 平安科技招银网络面试岗位是算法工程师，一共两轮技术面，一轮hr面一面：讲项目，问了问当时爬虫有没有用什么框架，然后问为什么文本分类我选择了朴素贝叶斯，然后让我说了一下对word2vec的理解二面：最痛的一次面试，三个面试官，一个问数据结构和数据库：问我知道的数据结构和使用场景，然后口述怎么把单链表变双向链表，讲了一下红黑树，以及红黑树的应用，数据的范式，索引失效的情况，如何优化数据库性能等等。第二个面试官问操作系统和计算机网络：TCP三次握手，四次挥手，第二次挥手和第三次挥手的时间间隔如何界定，TCP拥塞控制，OSI五层模型，每层有什么协议，TCP和UDP的区别，UDP的应用（这个问题我没太理解），ARP协议，python多线程，python3对python2是否有改进。第三个面试官问设计模式和算法：python闭包，bagging/boosting的区别，XGboost特点，tf-idf缺点，单例模式（设计模式我完全不会），怎样设计一个分布式的爬虫。hr面：大概聊了聊对薪资的期望，和工作的部门5.链家链家是参加了牛客的留学生专场，感觉链家的面试官人真的好~岗位是机器学习/数据挖掘工程师，不过链家面试有点坎坷面完前两面才发现我面的大数据开发，其实我想去的是数据挖掘，然后就开始了第三轮面试一面：先写了一个很简单的判断两个二叉树是不是一样的树，然后就说给一台机器内存有限制，然后10台服务器，每个服务器上有一个1G文件，假设文件里单词，如何给这些单词按频率排序，又问了求数据流的中位数，最后是智力题，给你两个一模一样的杯子，假设一共有10层楼，怎样找到杯子摔下来能不碎的最高楼层。二面：面试官先问我职业规划，我说数据挖掘，他就比较懵说他们是大数据开发部门，问我考不考虑，我说还是倾向于做数据挖掘，就开始了面试，问了数据库索引的优缺点，索引失效的情况，然后复合索引如何引用会失效，然后问了ACID，剩下的记不清了，说我基础不错去给我联系数据挖掘的面试官三面：手写LR损失函数，LR/SVM区别，手画word2vec网络结构，bagging，boosting，stacking的区别和联系，如果RF和GBDT达到同样的准确度哪个分裂的树更少为什么，随机梯度下降和梯度下降哪一个更快，XGBoost特点，XGBoost的L1和L2正则化怎么体现，特征工程相关的卡方统计和互信息计算公式，然后写了一个如何用最少的硬币找钱。HR面：介绍了一下链家的福利和部门的发展。6.快手快手4.18的笔试，5.5面试大概是备胎池捞起来了，三轮技术面，一轮hr面一面：介绍项目，边讲项目边提问，然后写了个代码，判断有向图中是否有环二面：介绍项目，边讲项目边提问，问了文本分类问什么朴素贝叶斯比SVM，决策树效果更好，然后分类性能度量，precision，recall，F1 score和ROC AUC对比，写了一个leetcode的flatten nested list iterator三面：只写代码，第一个AABB的字符串输出AB，第二个找数组的最长递增子序列，然后介绍了一下他们做的东西HR面：谈了谈offer 顺丰提前批人工智能岗技术面面经作者：撒泼打滚求Offer链接：https://www.nowcoder.com/discuss/92370来源：牛客网 目标检测了解吗，（了解一点）Faster RCNN跟RCNN有什么区别 SPP， YOLO了解吗（不了解）（后悔没去看看= =） 梯度消失梯度爆炸怎么解决 RNN容易梯度消失，怎么解决（LSTM） LSTM跟RNN有啥区别 传统的机器学习算法了解吗（不怎么了解，说了个KMeans） KMeans讲讲，KMeans有什么缺点，K怎么确定（不会） 卷积层和池化层有什么区别（不是很懂这个问题的点） 防止过拟合有哪些方法 1234567891011121314151、正则化，即在对模型的目标函数（objective function）或代价函数（cost function）加上正则项 随着模型训练的进行，模型的复杂度会增加，此时模型在训练数据集上的训练误差会逐渐减小，但是在模型的复杂度达到一定程度时，模型在验证集上的误差反而随着模型的复杂度增加而增大。此时便发生了过拟合，即模型的复杂度升高。1、early stopping、 迭代次数（epochs）截断的方法（常用 梯度下降法）； 训练数据一次遍历结束，计算指标，指标不增加，停止训练； 记录一个最好的指标，如果之后的10次，20次训练达到的指标都没有之前最好的高，则停止训练。2、数据增强（Data augmentation）、 从数据源采集更多数据 复制原有数据并加上随机噪声 重采样 根据当前数据集估计数据分布参数，使用该分布产生更多数据等3、正则化（Regularization）、 正则化方法是指在进行目标函数或代价函数优化时，在目标函数或代价函数后面加上一个正则项，一般有L1正则与L2正则等。4、Dropout dropout咋回事讲讲 你有什么要问我的吗 联影医疗 Offer作者：吃饭睡觉编论文链接：https://www.nowcoder.com/discuss/52357来源：牛客网 联影医疗 Offer一面1、GBDT和xgboost的区别2、GBDT和LR的区别3、讲项目（为什么用GBDT LR？）4、随便讲一个熟悉的传统图像处理中的特征提取和描述子（sift和sift描述子）二面1、写代码：实现统计图像灰度直方图的代码2、熟悉的聚类算法、k-means原理、混合高斯模型原理3、PCA原理、数学解释（应该是一个最优的线性子空间）4、surf相比sift特征点的优化之处5、写代码：dijkstra最短路径算法6、SVM原理、过拟合怎么解决7、霍夫变换检测直线和圆的原理HR面个人优缺点、拿到的offer、期望薪资、是不是独生子、对联影医疗的了解 VIVO算法作者：MadCoder链接：https://www.nowcoder.com/discuss/94110来源：牛客网 1.评估指标2.在AUC值大时，Log损失也大。请问可能的原因3.梯度消失，梯度爆炸原因及解决4.概率题：8支球队循环赛，前四名晋级。求晋级可能性5.Spark和hadoop实现K-MEANS，及优劣比较]]></content>
      <tags>
        <tag>笔面试</tag>
        <tag>C++</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git_update_error1]]></title>
    <url>%2F2018%2F08%2F01%2Fgit_update_error1%2F</url>
    <content type="text"><![CDATA[github上传文件报错failed to push some refs解决 报错内容，不能推送文件到github上1error: failed to push some refs to github地址 原因是github项目与本地文件夹一些关键文件的确实，比如.git，readme.md文件等等 本地文件夹打开控制命令台解决：1、添加本地文件夹，github项目更新到本地12git add .git pull origin master 2、再上传文件夹到github1git push -u origin master]]></content>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用LaTex添加公式到Hexo博客里]]></title>
    <url>%2F2018%2F07%2F23%2Fhexo_LeTex1%2F</url>
    <content type="text"><![CDATA[使用LaTex添加公式到Hexo博客里 代码编辑器，强烈推荐使用微软的 VS code，相比Atom开启迅速，使用方便，扩展丰富 第一步： 安装Kramedhexo 默认的渲染引擎是 marked，但是 marked 不支持 mathjax。，所以需要更换Hexo的markdown渲染引擎为hexo-renderer-kramed引擎，后者支持mathjax公式输出。12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 第二步：更改文件配置打开/node_modules/hexo-renderer-kramed/lib/renderer.js，更改：123456789101112// Change inline math rulefunction formatText(text) &#123; // Fit kramed&apos;s rule: $$ + \1 + $$ return text.replace(/`\$(.*?)\$`/g, &apos;$$$$$1$$$$&apos;);&#125;为，直接返回text// Change inline math rulefunction formatText(text) &#123; return text;&#125; 第三步: 停止使用 hexo-math，并安装mathjax包卸载hexo-math1npm uninstall hexo-math --save 安装 hexo-renderer-mathjax 包1npm install hexo-renderer-mathjax --save 第四步: 更新 Mathjax 的 配置文件打开/node_modules/hexo-renderer-mathjax/mathjax.html如图所示更改&lt;script&gt;为：即注释掉&lt;script&gt;代码，并把以下代码复制到对应位置1&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt; 第五步: 更改默认转义规则因为LaTeX与markdown语法有语义冲突，所以 hexo 默认的转义规则会将一些字符进行转义，所以我们需要对默认的规则进行修改. 打开/node_modules\kramed\lib\rules\inline.js 1、1escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/, 更改为1escape: /^\\([`*\[\]()# +\-.!_&gt;])/, 2、1em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, 更改为1em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, 第六步: 开启mathjax打开/themes/yilia主题目录下的config.yml文件因为我用的yilia主题，所以路径是/themes/yilia 我们需要在config.yml文件 中开启 Mathjax， 找到 mathjax 字段添加如下代码：(不同的主题配置方法略微有区别)12mathjax: enable: true 或者1mathjax: true 注意的是：，无论是配置文件还是博客文件，配置项跟配置参数均有有一个空格，否则会配置失败例：123mathjax: true（mathjax:空格true）而不是mathjax:true（mathjax:true） 写博客文件时，要开启 Mathjax选项，， 添加以下内容： 1mathjax: true 例如1234title: 特征提取——局部特征date: 2018-07-16 09:39:40tags: [GitHub, Mysql]mathjax: true 如下图所示 通过以上步骤，我们就可以在 hexo 中使用 Mathjax 来书写数学公式。 效果展示： 我的博客主页，欢迎访问我的CSDN主页，欢迎访问我的简书主页，欢迎访问我的GitHub主页，欢迎访问参考文章1参考文章2 https://www.jianshu.com/p/a0aa94ef8ab2]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习_最优化_损失函数]]></title>
    <url>%2F2018%2F07%2F22%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%9C%80%E4%BC%98%E5%8C%96_%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[机器学习最优化损失函数 通常机器学习每一个算法中都会有一个目标函数，算法的求解过程是通过对这个目标函数优化的过程。 在分类或者回归问题中，通常使用损失函数（代价函数）作为其目标函数。损失函数用来评价模型的预测值和真实值不一样的程度，损失函数越好，通常模型的性能越好。不同的算法使用的损失函数不一样。 损失函数分为经验风险损失函数和结构风险损失函数 损失函数 概念 经验风险损失函数 预测结果和实际结果的差别 结构风险损失函数 经验风险损失函数+正则项 θ^∗=argmin(1/N)\sum_i=1^n\L(y_i,f(x_i;θ_i))\+λ\phi(\theta)0-1损失函数和绝对值损失函数原理：预测值和目标值不相等为1，否则为0。绝对值损失函数为： L(Y,f(X))=1, if Y≠f(X)L(Y,f(X))=0, if Y=f(X)感知机就是用的这种损失函数改进：Y-f(X)&lt;阈值T判断相等绝对值损失函数为： L(Y,f(X)=|Y−f(X)|log对数损失函数原理：假设样本服从伯努利分布（0-1）分布，然后求得满足该分布的似然函数，接着用对数求极值。log损失函数的标准形式： L(Y,P(Y|X))=−logP(Y|X)平方损失函数最小二乘法是线性回归的一种方法，它将回归的问题转化为了凸优化的问题。最小二乘法的基本原则是：最优拟合曲线应该使得所有点到回归直线的距离和最小。通常用欧几里得距离进行距离的度量。平方损失的损失函数为： L(Y|f(X))=∑N(Y−f(X))^2指数损失函数AdaBoost就是一指数损失函数为损失函数的。指数损失函数的标准形式： L(Y|f(X))=exp[−yf(x)]Hinge损失函数Hinge损失函数和SVM是息息相关的。在线性支持向量机中，最优化问题可以等价于 1/m\sum_i=1^m\l(wx_i+by_i)+||w||^2其中l(wx_i+by_i) 就是hinge损失函数，后面相当于L2正则项。 Hinge函数的标准形式： L(y)=max(0,1−ty) y的值在-1和+1之间就可以了,使分类器可以更专注于整体的分类误差 参考文章]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>最优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习_分类_adaboost]]></title>
    <url>%2F2018%2F07%2F21%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_adaboost%2F</url>
    <content type="text"><![CDATA[机器学习_分类_adaboost 简介Boosting, 也称为增强学习或提升法，是一种重要的集成学习技术， 能够将预测精度仅比随机猜度略高的弱学习器增强为预测精度高的强学习器。 AdaBoost是英文”Adaptive Boosting”（自适应增强）的缩写 步骤1231）首先，是初始化训练数据的权值分布D1。假设有N个训练样本数据，则每一个训练样本最开始时，都被赋予相同的权值：w1=1/N。2）然后，训练弱分类器hi。具体训练过程中是：如果某个训练样本点，被弱分类器hi准确地分类，那么在构造下一个训练集中，它对应的权值要减小；相反，如果某个训练样本点被错误分类，那么它的权值就应该增大。权值更新过的样本集被用于训练下一个分类器，整个训练过程如此迭代地进行下去。3）最后，将各个训练得到的弱分类器组合成一个强分类器。各个弱分类器的训练过程结束后，加大分类误差率小的弱分类器的权重，使其在最终的分类函数中起着较大的决定作用，而降低分类误差率大的弱分类器的权重，使其在最终的分类函数中起着较小的决定作用。 误差率低的弱分类器在最终分类器中占的权重较大，否则较小。 alpha值是基于每个弱分类器的错误率进行计算,计算出alpha值之后，可以对权重向量进行更新，以使得那些正确分类的样本的权重降低而错分样本的权重升高，直到错误率为0或者弱分类器的数目达到用户的指定值为止 算法过程 参考文章地址 参考文章 数据分类模型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &quot;opencv2/core/core.hpp&quot; #include &quot;opencv2/highgui/highgui.hpp&quot; #include &quot;opencv2/imgproc/imgproc.hpp&quot; #include &quot;opencv2/ml/ml.hpp&quot; #include &lt;iostream&gt; using namespace cv; using namespace std; int main( int argc, char** argv ) &#123; //训练样本 float trainingData[42][2]=&#123; &#123;40, 55&#125;,&#123;35, 35&#125;,&#123;55, 15&#125;,&#123;45, 25&#125;,&#123;10, 10&#125;,&#123;15, 15&#125;,&#123;40, 10&#125;, &#123;30, 15&#125;,&#123;30, 50&#125;,&#123;100, 20&#125;,&#123;45, 65&#125;,&#123;20, 35&#125;,&#123;80, 20&#125;,&#123;90, 5&#125;, &#123;95, 35&#125;,&#123;80, 65&#125;,&#123;15, 55&#125;,&#123;25, 65&#125;,&#123;85, 35&#125;,&#123;85, 55&#125;,&#123;95, 70&#125;, &#123;105, 50&#125;,&#123;115, 65&#125;,&#123;110, 25&#125;,&#123;120, 45&#125;,&#123;15, 45&#125;, &#123;55, 30&#125;,&#123;60, 65&#125;,&#123;95, 60&#125;,&#123;25, 40&#125;,&#123;75, 45&#125;,&#123;105, 35&#125;,&#123;65, 10&#125;, &#123;50, 50&#125;,&#123;40, 35&#125;,&#123;70, 55&#125;,&#123;80, 30&#125;,&#123;95, 45&#125;,&#123;60, 20&#125;,&#123;70, 30&#125;, &#123;65, 45&#125;,&#123;85, 40&#125; &#125;; Mat trainingDataMat(42, 2, CV_32FC1, trainingData); //训练样本的响应值 float responses[42] = &#123;&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;, &apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;,&apos;R&apos;, &apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos;,&apos;B&apos; &#125;; Mat responsesMat(42, 1, CV_32FC1, responses); float priors[2] = &#123;1, 1&#125;; //先验概率 CvBoostParams params( CvBoost::REAL, // boost_type 10, // weak_count 0.95, // weight_trim_rate 15, // max_depth false, // use_surrogates priors // priors ); CvBoost boost; boost.train ( trainingDataMat, CV_ROW_SAMPLE, responsesMat, Mat(), Mat(), Mat(), Mat(), params ); //预测样本 float myData[2] = &#123;55, 25&#125;; Mat myDataMat(2, 1, CV_32FC1, myData); double r = boost.predict( myDataMat ); cout&lt;&lt;endl&lt;&lt;&quot;result: &quot;&lt;&lt;(char)r&lt;&lt;endl; return 0; &#125; 基于的OpenCV的检测Demo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;opencv/highgui.h&gt;#include &lt;opencv/cv.h&gt;#include &lt;opencv2/imgproc/imgproc_c.h&gt;#include &lt;opencv2/objdetect/objdetect.hpp&gt;using namespace cv;int main(int argc, char** argv)&#123; CascadeClassifier stFaceCascade; IplImage *pstImage = NULL; std::vector&lt;Rect&gt; faceRects; if( !stFaceCascade.load(&quot;D:\\ProgramFiles\\develop\\opencv2.4.8\\sources\\data\\lbpcascades\\lbpcascade_frontalface.xml&quot;) ) &#123; printf(&quot;Loading cascade error\n&quot;); return -1; &#125; pstImage = cvLoadImage(&quot;D:\\test.jpg&quot;, CV_LOAD_IMAGE_COLOR); stFaceCascade.detectMultiScale(pstImage, faceRects, //检出结果 1.1, //缩放步长 2, //框融合时的最小检出个数 0|CV_HAAR_SCALE_IMAGE,//标志 |CV_HAAR_FIND_BIGGEST_OBJECT|CV_HAAR_DO_ROUGH_SEARCH|CV_HAAR_DO_CANNY_PRUNING Size(30, 30), //最小人脸尺寸 Size(300, 300) ); //最大人脸尺寸 printf(&quot;Face Num[%d]\n&quot;, faceRects.size()); for( unsigned int j = 0; j &lt; faceRects.size(); j++ ) &#123; cvRectangle(pstImage, cvPoint(faceRects[j].x, faceRects[j].y), cvPoint(faceRects[j].x + faceRects[j].width, faceRects[j].y + faceRects[j].height), cvScalar(0,255,0), 2,8,0); &#125; cvShowImage(&quot;FDWin&quot;, pstImage); cvWaitKey(0); cvReleaseImage(&amp;pstImage); return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习_分类_SVM]]></title>
    <url>%2F2018%2F07%2F20%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_SVM%2F</url>
    <content type="text"><![CDATA[机器学习_分类_SVM 支持向量机（Support Vector Machine, SVM）的基本模型是在特征空间上找到最佳的分离超平面使得训练集上正负样本间隔最大。 二分类问题的有监督学习算法，引入了核方法之后SVM也可以用来解决非线性问题一般SVM有下面三种： 1、硬间隔支持向量机（线性可分支持向量机）：当训练数据线性可分时，可通过硬间隔最大化学得一个线性可分支持向量机。2、软间隔支持向量机：当训练数据近似线性可分时，可通过软间隔最大化学得一个线性支持向量机。3、非线性支持向量机：当训练数据线性不可分时，可通过核方法以及软间隔最大化学得一个非线性支持向量机。 SVM算法认为图1中的分类器A在性能上优于分类器B，其依据是A的分类间隔比B要大 这两条平行虚线正中间的分界线就是在保持当前决策面方向不变的前提下的最优决策面。两条虚线之间的垂直距离就是这个最优决策面对应的分类间隔。 那个具有“最大间隔”的决策面就是SVM要寻找的最优解,而这个真正的最优解对应的两侧虚线所穿过的样本点，就是SVM中的支持样本点，称为支持向量。 对于图1中的数据，A决策面就是SVM寻找的最优解，而相应的三个位于虚线上的样本点在坐标系中对应的向量就叫做支持向量。 基于最大间隔分割数据优点，错误率低，计算开销不大，结果容易解释缺点，对参数调节敏感，原始分类器不加修改只能解决二类问题。 w^{t}x+b为分类函数输人数据给分类器会输出一个类别标签,单位阶跃函数）的函数对w^{t}x+b作用得到f(w^{t}x+b),其中当u&lt;0时输出-1, 反之则输出+1。这是由于-1和+1仅仅相差一个符号，方便数学上的处理。 如果数据点处于正方向（即+1类 ）并且离分隔超平面很远的位置时，w^{t}x+b会是一个很大的正数，同时label*(w^{t}x+b)也会是一个很大的正数。而如果数据点处于负方向（-1类 ）并且离分隔超平面远的位置时，此时由于类别标签为-1，则label*(w^{t}x+b)仍然是一个很大的正数。 目标：找到分类器定义中的w和b。找到具有最小间隔的数据点即支持向量。找到支持向量，对间隔最大化。 SVM的目标函数：分离超平面分类函数为0，支持向量的分类函数为+-1,为了优化目标函数，固定一个优化另外一个，该问题是一个带约束条件的优化问题。这里的约束条件就是label*(w^{t}x+b)=1。注：label*(w^{t}x+b)被称为点到分隔面的函数间隔，label*(w^{t}x+b)*(1/w)称为点到分隔面的几何间隔。求解这个问题需要经过一系列的转换。具体如下： 求$ 1/W$的最大值相当于求$0.5w^2$的最小值，一个凸二次规划问题 12345注：新目标函数约束条件：alpha&gt;=0,所有的aplha*lable=0但是数据未必100%线性可分，引人所谓松弛变量C新目标函数约束条件为：C&gt;alpha&gt;=0,所有的aplha*lable=0 SVM中的主要工作就是求解这些alpha。SMO算法(序列最小优化（SequentialMinimalOptimization ))的目标是求出一系列alpha和b，一旦求出了这些alpha，就很容易计算出权重向量w，并得到分隔超平面。 SMO的工作原理是：每次循环中选择两个alpha进行优化处理，一旦找到一对合适的alpha，那么就增大其中一个，同时减小另一个。选择的alpha要满足在间隔边界之外的条件，而且还没有进行过区间化处理或者不再边界上。 核函数：大部分时候数据并不是线性可分的，这个时候满足这样条件的超平面就根本不存在。在上文中，我们已经了解到了SVM处理线性可分的情况，那对于非线性的数据SVM咋处理呢？对于非线性的情况，SVM 的处理方法是选择一个核函数，通过将数据映射到高维空间，来解决在原始空间中线性不可分的问题。 这是原始数据和原始空间，明显有红蓝两类：通过核函数，将样本数据映射到更高维的空间（在这里，是二维映射到三维）：而后进行分离超平面：再将分割的超平面映射回去：效果图： 核函数的选择变成了支持向量机的最大变数（如果必须得用上核函数，即核化），因此选用什么样的核函数会影响最后的结果。而最常用的核函数有：线性核、多项式核、高斯核、拉普拉斯核、sigmoid核、通过核函数之间的线性组合或直积等运算得出的新核函数。 Opencv代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; #include &lt;opencv2/ml/ml.hpp&gt; using namespace cv; int main() &#123; // Data for visual representation int width = 512, height = 512; Mat image = Mat::zeros(height, width, CV_8UC3); // Set up training data float labels[5] = &#123;1.0, -1.0, -1.0, -1.0,1.0&#125;; Mat labelsMat(5, 1, CV_32FC1, labels); float trainingData[5][2] = &#123; &#123;501, 10&#125;, &#123;255, 10&#125;, &#123;501, 255&#125;, &#123;10, 501&#125;,&#123;501,128&#125; &#125;; Mat trainingDataMat(5, 2, CV_32FC1, trainingData); //设置支持向量机的参数 CvSVMParams params; params.svm_type = CvSVM::C_SVC;//SVM类型：使用C支持向量机 params.kernel_type = CvSVM::LINEAR;//核函数类型：线性 params.term_crit = cvTermCriteria(CV_TERMCRIT_ITER, 100, 1e-6);//终止准则函数：当迭代次数达到最大值时终止 //训练SVM //建立一个SVM类的实例 CvSVM SVM; //训练模型，参数为：输入数据、响应、XX、XX、参数（前面设置过） SVM.train(trainingDataMat, labelsMat, Mat(), Mat(), params); Vec3b green(0,255,0), blue (255,0,0); //显示判决域 for (int i = 0; i &lt; image.rows; ++i) for (int j = 0; j &lt; image.cols; ++j) &#123; Mat sampleMat = (Mat_&lt;float&gt;(1,2) &lt;&lt; i,j); //predict是用来预测的，参数为：样本、返回值类型（如果值为ture而且是一个2类问题则返回判决函数值，否则返回类标签）、 float response = SVM.predict(sampleMat); if (response == 1) image.at&lt;Vec3b&gt;(j, i) = green; else if (response == -1) image.at&lt;Vec3b&gt;(j, i) = blue; &#125; //画出训练数据 int thickness = -1; int lineType = 8; circle( image, Point(501, 10), 5, Scalar( 0, 0, 0), thickness, lineType);//画圆 circle( image, Point(255, 10), 5, Scalar(255, 255, 255), thickness, lineType); circle( image, Point(501, 255), 5, Scalar(255, 255, 255), thickness, lineType); circle( image, Point( 10, 501), 5, Scalar(255, 255, 255), thickness, lineType); circle(image, Point( 501, 128), 5, Scalar(0, 0, 0), thickness, lineType); //显示支持向量 thickness = 2; lineType = 8; //获取支持向量的个数 int c = SVM.get_support_vector_count(); for (int i = 0; i &lt; c; ++i) &#123; //获取第i个支持向量 const float* v = SVM.get_support_vector(i); //支持向量用到的样本点，用灰色进行标注 circle( image, Point( (int) v[0], (int) v[1]), 6, Scalar(128, 128, 128), thickness, lineType); &#125; imwrite(&quot;result.png&quot;, image); // save the image imshow(&quot;SVM Simple Example&quot;, image); // show it to the user waitKey(0); &#125;]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大佬终极面经]]></title>
    <url>%2F2018%2F07%2F19%2F%E5%A4%A7%E4%BD%AC%E7%BB%88%E6%9E%81%E9%9D%A2%E7%BB%8F%2F</url>
    <content type="text"><![CDATA[大佬终极面经 作者：非理性的猫链接：https://www.nowcoder.com/discuss/92930来源：牛客网 去年秋招在准备求职算法岗的过程中，经过一整个秋招的努力，拿了蚂蚁金服、滴滴、宜信大数据、美图几个厂的算法offer，这中间我参考了牛客网很多大神的经验，自己总结了一些经验，写成这篇文章。 一个完整的机器学习工程师的面试过程主要有以下这些环节：自我介绍、项目介绍、算法推导和解释、数据结构与算法题（写代码）。 关于自我介绍，主要就是简单介绍下自己的教育背景，在校期间的研究方向和所做的项目以及在项目中所充当的角色等等，为之后的面试做个铺垫，让面试官从中捕捉点来问。 项目介绍是最为重要的，这也是体现你综合实力的地方，对项目背景、项目实现的方案，项目所实现的东西都要了如指掌，做机器学习的，必然需要准备一到两个重点的机器学习项目，可以是比赛，也可以是实验室项目，关键是项目中间的技术细节都要了如指掌，比如你用了树模型，就得知道所有树模型相关的推导和原理，决不能含糊，一旦你说不太清楚，面试官就会对项目的真实性存疑。参加比赛应该是没有实验室项目的同学最佳的积累经验的途径，比较好的比赛平台有Kaggle、天池大数据、datacastle等 接下来就是机器学习算法原理和推导，这也是要重点去准备的，在面试前得达到，给你一张白纸，你可以把推导的每一步写的清清楚楚的，推导的话面试常考逻辑回归和SVM的推导，关于原理面试官常会问你几个树模型之间的对比等等等，其他的算法比如LR、SVM、EM、Adaboost、PageRank、 FFM、决策树，随机森林， GBDT ， XGBoost 、推荐算法、聚类、CNN、RNN、LSTM、Word2Vec等等，以及他们的适用场景，再如一些机器学习的理论，非平衡问题、过拟合问题，交叉验证问题，模型选择问题，模型融合问题。这一部分我会在文末贴出一个问题集锦，大家按照这个去准备就行。还有必看的书李航的《统计学习方法》、周志华的《机器学习》、项亮的《推荐系统实践》 最后就是写代码了，很多非计算机出身的大都会栽在这个地方，代码写得少，训练不到位，就会导致当场思路不清晰，不知从哪写起，但目前市面上已经有很多专门为这块总结的一些书籍，推荐使用《剑指offer》、《王道程序员求职宝典》等等，有时间的话再刷一下leetcode。排序算法、查找算法、二叉树遍历这些最基本的一定要很顺溜的写下来，其他的就看自己去拓展了，同样的，我也总结了一些笔记供大家参考， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135机器学习机器学习算法系列（40）：机器学习中的数据清洗与特征处理综述机器学习算法系列（39）：实例详解机器学习如何解决问题机器学习算法系列（38）：外卖订单量预测异常报警模型实践机器学习算法系列（37）：外卖O2O的用户画像实践机器学习算法系列（36）：GBDT算法原理深入解析机器学习算法系列（35）：使用Sklearn进行集成学习（实践）机器学习算法系列（34）：使用Sklearn进行集成学习（理论）机器学习算法系列（33）：特征处理（Feature Processing）机器学习算法系列（32）：MapReduce执行流程详解机器学习算法系列（31）：在线最优化求解（online Optimization）机器学习算法系列（30）：Scikit-Learn总结机器学习算法系列（29）：Sparsity and Some Basics of L1 Regularization机器学习算法系列（28）：L1、L2正则化机器学习算法系列（27）：Isolation Forest机器学习算法系列（26）：因子分解机（FM）与场感知分解机（FFM）机器学习算法系列（24）：机器学习中的损失函数机器学习算法系列（25）：最速下降法、牛顿法、拟牛顿法机器学习算法系列（23）：TF-IDF与余弦相似度机器学习算法系列（22）：主成分分析机器学习算法系列（21）：SVD机器学习算法系列（20）：机器学习模型优化四要素机器学习算法系列（19）：机器学习性能评价指标机器学习算法系列（18）：方差偏差权衡（Bias-Variance Tradeoff）机器学习算法系列（17）：非平衡数据处理机器学习算法系列（16）：统计学习概论机器学习算法系列（15）：EM算法机器学习算法系列（14）：关联分析机器学习算法系列（13）：推荐系统（3）—矩阵分解技术机器学习算法系列（13）：推荐系统（2）—基于领域的协同过滤机器学习算法系列（13）：推荐系统（1）—简介机器学习算法系列（12）：SVM（4）—SMO机器学习算法系列（12）：SVM（3）—非线性支持向量机机器学习算法系列（12）：SVM（2）—线性支持向量机机器学习算法系列（12）：SVM（1）—线性可分支持向量机机器学习算法系列（11）：聚类（4）—密度最大值聚类机器学习算法系列（11）：聚类（3）—DBSCAN机器学习算法系列（11）：聚类（2）—Kmeans机器学习算法系列（11）：聚类（1）—简介机器学习算法系列（10）：朴素贝叶斯机器学习算法系列（9）：感知机机器学习算法系列（8）：XgBoost机器学习算法系列（7）：GBDT机器学习算法系列（6）：AdaBoost机器学习算法系列（5）：随机森林机器学习算法系列（4）：决策树机器学习算法系列（3）：逻辑斯谛回归机器学习算法系列（2）：线性回归机器学习算法系列（1）：K近邻自然语言处理自然语言处理系列（10）：自然语言处理的发展与趋势自然语言处理系列（9）：DCNN自然语言处理系列（8）：RCNN自然语言处理系列（7）：TextCNN调参技巧自然语言处理系列（6）：TextCNN自然语言处理系列（5）：FastText自然语言处理系列（4）：深度学习解决大规模文本分类问题自然语言处理系列（3）：中文维基语料词向量训练自然语言处理系列（2）：Word2Vec自然语言处理系列（1）：词向量和语言模型深度学习深度学习系列（12）：pytorch实现卷积神经网络深度学习系列（11）：神经网络防止过拟合的方法深度学习系列（10）：DMC—卷积神经网络分享深度学习系列（9）：Batch Normalization深度学习系列（8）：激活函数深度学习系列（7）：神经网络的优化方法深度学习系列（6）：递归神经网络深度学习系列（5）：长短时记忆网络（LSTM）深度学习系列（4）：循环神经网络（RNN）深度学习系列（3）：卷积神经网络（CNN）深度学习系列（2）：神经网络MNIST实战深度学习系列（1）：神经网络与反向传播算法数据结构与算法数据结构与算法题解（11）：最长回文子串数据结构与算法题解（10）：0-1背包问题与部分背包问题数据结构与算法题解（9）：最长公共子序列和最长公共子串数据结构与算法题解（8）：KMP算法数据结构与算法题解（7）：最短编辑距离数据结构与算法题解（6）：重点掌握数据结构与算法题解（5）：剑指offer解题报告数据结构与算法题解（4）：二叉树题解数据结构与算法题解（3）：字符串题解数据结构与算法题解（2）：数组题解数据结构与算法题解（1）：链表题解数据结构与算法（19）：海量数据处理数据结构与算法（18）：倒排索引数据结构与算法（17）：simhash数据结构与算法（16）：一致性哈希数据结构与算法（15）：布隆过滤器数据结构与算法（14）：最短路算法数据结构与算法（13）：深度优先搜索和广度优先搜索数据结构与算法（12）：排序数据结构与算法（11）：哈希表数据结构与算法（10）：查找数据结构与算法（9）：Trie树数据结构与算法（8）：红黑树数据结构与算法（7）：数据库索引原理及优化数据结构与算法（6）：B树、B+树数据结构与算法（5）：AVL树数据结构与算法（4）：二叉查找树数据结构与算法（3）：二叉树数据结构与算法（2）：栈与队列数据结构与算法（1）：数组与链表JavaJava学习笔记（12）：单例模式Java学习笔记（11）：进程与线程Java学习笔记（10）：QAJava学习笔记（9）：内部类、抽象类、接口Java学习笔记（8）：常用库类、向量与哈希Java学习笔记（7）：深入理解java异常处理机制Java学习笔记（6）：异常处理Java学习笔记（5）：static、final关键字和Object类Java学习笔记（4）：多态Java学习笔记（3）：继承、覆盖、重载Java学习笔记（2）：类与对象Java学习笔记（1）：语法基础Java集合学习手册（11）：Java HashMap源码全剖析Java集合学习手册（10）：hashCode方法与equal方法Java集合学习手册（9）：Java 集合对比Java集合学习手册（8）：Java 集合框架Java集合学习手册（7）：Java LinkedListJava集合学习手册（6）：Java ArrayListJava集合学习手册（5）：Java LinkedHashSetJava集合学习手册（4）：Java LinkedHashMapJava集合学习手册（3）：Java HashTableJava集合学习手册（2）：Java HashSetJava集合学习手册（1）：Java HashMap 以下是我总结的机器学习提问集锦，大家可以在把所有算法过了一遍的基础上把一个个问题都仔细揣摩一遍，加强对算法的理解和延伸。 SVM：12345678910111213简单介绍SVM（详细原理）：从分类平面，到求两类间的最大间隔，到转化为求间隔分之一，等优化问题，然后就是优化问题的解决办法，首先是用拉格拉日乘子把约束优化转化为无约束优化，对各个变量求导令其为零，得到的式子带入拉格朗日式子从而转化为对偶问题， 最后再利用SMO（序列最小优化）来解决这个对偶问题。svm里面的c有啥用SVM的推导，解释原问题和对偶问题，SVM原问题和对偶问题的关系，KKT限制条件，KKT条件用哪些，完整描述；软间隔问题，解释支持向量、核函数（哪个地方引入、画图解释高维映射，高斯核可以升到多少维，如何选择核函数），引入拉格朗日的优化方法的原因，最大的特点，损失函数解释，SVM与LR最大区别，LR和SVM对于outlier的敏感程度分析，逻辑回归与SVM的区别为什么要把原问题转换为对偶问题？因为原问题是凸二次规划问题，转换为对偶问题更加高效。为什么求解对偶问题更加高效？因为只用求解alpha系数，而alpha系数只有支持向量才非0，其他全部为0.alpha系数有多少个？样本点的个数加大训练数据量一定能提高SVM准确率吗？与感知器的联系和优缺点比较如何解决多分类问题、可以做回归吗，怎么做它与其他分类器对比的优缺点，它的速度机器学习有很多关于核函数的说法，核函数的定义和作用是什么？https://www.zhihu.com/question/24627666支持向量机(SVM)是否适合大规模数据？https://www.zhihu.com/question/19591450SVM和逻辑斯特回归对同一样本A进行训练，如果某类中增加一些数据点，那么原来的决策边界分别会怎么变化？https://www.zhihu.com/question/30123068各种机器学习的应用场景分别是什么？例如，k近邻,贝叶斯，决策树，svm，逻辑斯蒂回归和最大熵模型。https://www.zhihu.com/question/26726794Linear SVM 和 LR 有什么异同？https://www.zhihu.com/question/26768865 LR12345678910111213141516LR推导（伯努利过程，极大似然，损失函数，梯度下降）有没有最优解？LR可以用核么？可以怎么用？l1和l2正则项是啥？lr加l1还是l2好？加哪个可以用核（加l2正则项，和svm类似，加l2正则项可以用核方便处理）LR可以用来处理非线性问题么？（还是lr啊 只不过是加了核的lr 这里加核是显式地把特征映射到高维 然后再做lr）怎么做？可以像SVM那样么？为什么？为什么LR需要归一化或者取对数，为什么LR把特征离散化后效果更好，为什么把特征组合之后还能提升，反正这些基本都是增强了特征的表达能力，或者说更容易线性可分吧美团技术团队《Logistic Regression 模型简介》https://tech.meituan.com/intro_to_logistic_regression.htmlSVM和logistic回归分别在什么情况下使用？https://www.zhihu.com/question/21704547逻辑斯蒂回归能否解决非线性分类问题？https://www.zhihu.com/question/29385169为什么LR可以用来做CTR预估？https://www.zhihu.com/question/23652394逻辑回归估计参数时的目标函数 （就是极大似然估计那部分），逻辑回归估计参数时的目标函数 （呵呵，第二次） 逻辑回归估计参数时的目标函数 如果加上一个先验的服从高斯分布的假设，会是什么样（天啦。我不知道，其实就是在后面乘一个东西，取log后就变成加一个东西，实际就变成一个正则项）逻辑回归估计参数时的目标函数逻辑回归的值表示概率吗？（值越大可能性越高，但不能说是概率）手推逻辑回归目标函数，正类是1，反类是-1，这里挖了个小坑，一般都是正例是1，反例是0的，他写的时候我就注意到这个坑了，然而写的太快又给忘了，衰，后来他提醒了一下，改了过来，就是极大似然函数的指数不一样，然后说我这里的面试就到这了。看没看过scikit-learn源码LR的实现？（回头看了一下是调用的liblinear，囧）为什么LR需要归一化或者取对数，为什么LR把特征离散化后效果更好，为什么把特征组合之后还能提升，反正这些基本都是增强了特征的表达能力，或者说更容易线性可分吧naive bayes和logistic regression的区别http://m.blog.csdn.net/blog/muye5/19409615LR为什么用sigmoid函数。这个函数有什么优点和缺点？为什么不用其他函数？sigmoid函数由那个指数族分布，加上二项分布导出来的。损失函数是由最大似然估计求出的。了解其他的分类模型吗，问LR缺点，LR怎么推导（当时我真没准备好，写不出来）写LR目标函数，目标函数怎么求最优解（也不会）讲讲LR的梯度下降，梯度下降有哪几种，逻辑函数是啥 L1和L212345678910111213L2正则化，为什么L2正则化可以防止过拟合？L1正则化是啥？深度学习里面怎么防止过拟合？（data aug；dropout；multi-task learning）如何防止过拟合，我跟他列举了4中主要防止过拟合方法：Early Stopping、数据集扩充、正则化法以及dropout，还详细跟他说了每种方法原理及使用的场景，并解释我在哪些项目里具体用到了这些方法，机器学习中使用「正则化来防止过拟合」到底是一个什么原理？为什么正则化项就可以防止过拟合？https://www.zhihu.com/question/20700829机器学习中常常提到的正则化到底是什么意思？https://www.zhihu.com/question/20924039什么是正则项，L1范式，L2范式区别是什么，各自用在什么地方？L1 与 L2 的区别以及如何解决 L1 求导困难；L1正则为什么能让系数变为0？L1正则怎么处理0点不可导的情形？（这个谁会？近端梯度下降）L0，L1，L2正则化(如果能推导绝对是加分项，一般人最多能画个等高线，L0是NP问题)其实上面的这些问题基本都能在《李航：统计学习方法》《周志华：机器学习》里面找到，能翻个4，5遍基本就无压力了避免过拟合策略、如何提高模型泛化能力、L1与L2正则区别，优缺点、生成式，判别式模型、深度学习这块了解多少、如何克服过拟合，欠拟合L1 与 L2 的区别以及如何解决 L1 求导困难；L1正则为什么可以把系数压缩成0，坐标下降法的具体实现细节为什么L1正则可以实现参数稀疏，而L2正则不可以？为什么L1很多系数可以被压缩为0，L2是被压缩至接近于0？树模型 决策树：1234567891011121314151617181920212223242526rf ， gbdt 的区别； gbdt ， xgboost 的区别（烂大街的问题最好从底层原理去分析回答）介绍决策树，谈了3种决策树及其区别和适应场景决策树处理连续值的方法；简单介绍决策树几种算法，有什么区别？决策树基本模型介绍？决策树算法中缺失值怎么处理？决策树算法在应用中有什么值得注意的地方。SVM、LR、决策树的对比？GBDT 和 决策森林 的区别？决策树的特性？（3 ）决策树处理连续值的方法；解释下随机森林和gbdt的区别。gbdt的boosting体现在哪里。解释下随机森林节点的分裂策略，以及它和gbdt做分类有什么区别？哪个效果更好些？为什么？哪个更容易过拟合？为什么？ 问了随机森林的损失函数，和lr的优缺点对比， adaboost和随机森林的比较，为了防止随机森林过拟合可以怎么做，是否用过随机森林，怎么用的。随机森林和GBDT的区别？CART（回归树用平方误差最小化准则，分类树用基尼指数最小化准则）GBDT（利用损失函数的负梯度在当前模型的值作为回归问题提升树算法中的残差的近似值，拟合一个回归树）随机森林（Bagging+CART）SVM与随机森林比较改变随机森林的训练样本数据量，是否会影响到随机森林学习到的模型的复杂度Logistics与随机森林比较GBDT与随机森林比较随机森林的学习过程；随机森林中的每一棵树是如何学习的；随机森林学习算法中CART树的基尼指数是什么？RF 与 GBDT 区别，原理优缺点适用场景分析，哪个具备交叉验证功能等接着写一下信息增益的公式。之后就是问机器学习相关算法，说了一下bagging跟boosting，之后问了GBDT（没做过，只能说说大体思路）。（2 ） rf ， gbdt 的区别； gbdt ， xgboost 的区别；说说xgboost、gbdt区别、Tree-based Model如何处理连续型特征。让我把一个完整的数据挖掘流程讲一下，从预处理，特征工程，到模型融合。介绍常用的算法，gbdt和xgboost区别，具体怎么做预处理，特征工程，模型融合常用方式，融合一定会提升吗？gbdt树根据什么分裂（瞎扯的梯度近似残差、梯度下降方向，其实还是信息增益这种东西）gbdt怎么并发（特征选择层面，树层面不能并发）介绍LR、RF、GBDT ，分析它们的优缺点，是否写过它们的分布式代码XGB和GBDT区别与联系也会经常问到：https://www.zhihu.com/question/41354392/answer/128008021?group_id=773629156532445184CART（回归树用平方误差最小化准则，分类树用基尼指数最小化准则）、Logistics（推导）、GBDT（利用损失函数的负梯度在当前模型的值作为回归问题提升树算法中的残差的近似值，拟合一个回归树）在面试过程中主动引导面试官提问，比如面试官让你讲解 gbdt 原理时，这会你可以跟他说，一般说起 gbdt ，我们都会跟 rf 以及 xgboost 一块讲，然后你就可以主动地向面试官输出你的知识；面试并不是死板地你问我答，而是一种沟通交流，所以尽可能地把面试转化成聊天式的对话，多输出自己一些有价值的观点而不是仅仅为了回答面试官的问题；几种树模型的原理和对比，特征选取怎么选？ 为什么信息增益可以用来选特征？信息熵和基尼指数的关系(信息熵在x=1处一阶泰勒展开就是基尼指数)介绍xgboost一下。写下xgboost目标函数。（因为我提到xgboost在目标函数里显式地加入了正则项..血雪崩）怎么调整XGB参数；xgboost原理 K-means1234567891011k-means 聚类的原理以及缺点及对应的改进；kmeans 算法的优缺点。。。。kmeans 的原理，优缺点以及改进；em 与 kmeans 的关系；kmeans 代码；说说 Kmeans 算法， Kmeans 算法 K 怎么设置、适用什么样数据集、怎么评价 Kmeans 聚类结果、 Kmeans 有什么优缺点？你的项目中使用 Kmeans 遇到哪些问题，怎么解决的 ?用 EM 算法推导解释 Kmeans。KMeans的算法伪代码如何判断自己实现的 LR、Kmeans 算法是否正确？如何优化kmeans算法如何用hadoop实现k-means手写k-means的伪代码（就6行） 集成学习123456bagging和boosting是怎么做的和他们的比较详细讨论了样本采样和bagging的问题聊的比较多的是如何知道一个特征的重要性，如何做ensemble哪些方法比较好。聊了聊计算广告方面FM，embedding。常见融合框架原理，优缺点，bagging，stacking，boosting，为什么融合能提升效果是否了解线性加权、bagging、boosting、cascade等模型融合方式K-means起始点http://www.cnki.com.cn/Article/CJFDTotal-DNZS200832067.htm 贝叶斯12345朴素贝叶斯分类器原理以及公式，出现估计概率值为 0 怎么处理（拉普拉斯平滑），缺点；解释贝叶斯公式和朴素贝叶斯分类。贝叶斯分类，这是一类分类方法，主要代表是朴素贝叶斯，朴素贝叶斯的原理，重点在假设各个属性类条件独立。然后能根据贝叶斯公式具体推导。考察给你一个问题，如何利用朴素贝叶斯分类去分类，比如：给你一个人的特征，判断是男是女，比如身高，体重，头发长度等特征的的数据，那么你要能推到这个过程。给出最后的分类器公式。那你说说贝叶斯怎么分类啊？比如说看看今天天气怎么样？我：blabla，，，利用天气的历史数据，可以知道天气类型的先验分布，以及每种类型下特征数据（比如天气数据的特征：温度啊，湿度啊）的条件分布，这样我们根据贝叶斯公式就能求得天气类型的后验分布了。。。。面试官：en（估计也比较满意吧）那你了解关于求解模型的优化方法吗？一般用什么优化方法来解？贝叶斯分类器的优化和特殊情况的处理 深度学习12345678910111213141516解释一下CNN、介绍CNN、卷积公式，以及特点，假设面试官什么都不懂，详细解释 CNN 的原理；问CNN的细节特点，哪些特点使得CNN这么好用，哪些场景用CNN可以，抽象一下这些场景的特征，可以降采样但仍能保持主要信息；局部连接可以保证获取局部信息；权值共享保证高效，DNN和CNN相比有哪些区别，用过RNN么？画一下RNN的图，你在深度学习过程中遇到过哪些问题？如果出现过拟合你怎么办？dropout是什么？它有什么用？你会怎么用它？当全连接跟dropout连着用需要注意什么？你之前过拟合怎么解决的？如果本身training loss就很大你怎么办？如果数据不变，怎么调整网络结构解决这个问题？（batch normalization）梯度消失知道么？为什么会出现梯度消失？dnn和rnn中的梯度消失原理一样么？dnn中是哪个部分导致梯度消失？（激活层如sigmoid）rnn中怎么解决梯度消失问题？（lstm的结构相对普通RNN多了加和，为避免梯度消散提供了可能。线性自连接的memory是关键。）讲一下CNN吧，有哪些重要的特点？CNN可以处理哪些场景？为什么CNN要用权值共享？（每个卷积核相当于一个特征提取器，它的任务是匹配局部图像中的特征，权值共享后，匹配的特征方式都是一样的，提取若干特征后就知道学习的是啥了）CNN里面哪些层？讲一下卷积。卷积的形式是啥样？给定一个输入，算输出的feature map大小。卷积有啥用？池化有啥用？有哪些池化方式？池化除了降采样还有啥用？（就不知道了）还有哪些层你用过？讲讲dropout。dropout内部是怎么实现只让部分信号通过并不更新其余部分对于输入的权值的？讲讲BN（BatchNormalization）为什么好？全连接有什么用处？知道RNN么？讲讲RNN大致的实现思路。知道梯度消失么？为什么会出现梯度消失？RNN里的梯度消失一般怎么处理？细讲下lstm的结构，这样设计为什么好？（门关闭，当前信息不需要，只有历史依赖；门打开，历史和当前加权平均）你觉得梯度消失靠引入一些新的激活层可以完全解决么？为什么？问了做的比赛里面使用tensorflow的细节，LSTM里调参的细节用过哪些库或者工具，mkl，cuda这些会用吗？有一个弱分类器和大量未被标记过的图像数据，如何人工标记图像来对分类器进行提升介绍下RNN和它的优缺点让我推导BP反向传播、随机梯度下降法权重更新公式卷积神经网络结构特点、各参数对模型结果影响、项目进展遇到的难题、推导BP神经网络参数更新方式、随机梯度下降法（SGD）优化函数存在的缺点以及拟牛顿法在优化函数使用上更有优势、修改Caffe开源框架、开源社区代码贡献量就跟我聊了很多行业发展趋势及问题，知道目前深度学习的一个趋势，也了解到最新行业发展动态，改进相机智能化程度，也聊到了美颜相机美颜效果以及小米相机人脸分类、年龄检测等等不足之处，了解到新兴行业大佬商汤科技和旷视科技（face++脸草）在研究的热门方向看到有deep learning相关的项目，就问了deep learning 相关问题：如何减少参数（权值共享、VGG的感受野、GoogLeNet的inception ），激活函数的选择（sigmoid-&gt;ReLu-&gt;LReLU-&gt;PReLU ），为什么之前没有深度网络出现（数据量不够+机器性能），由数据引申到数据不平衡怎么处理（10W正例，1W负例，牛客上有原题），后面问了下DNN原理，应用，瞎扯一通……你了解神经网络吗？我：了解一些，讲感知机，然后是BP网络。简单讲了一下原理。图像处理题：如何找相似图片。我说用感知哈希算法，计算汉明距离，他说这种方法精度不行；我说那就用SIFT算法吧，他说SIFT效果还可以，但计算有点繁重，有没有轻量级的方法？我想起来去年在美图秀秀实习时，曾经做过一种图像滤波算法，有一步是把像素点用K-means聚类。我就说先把图片灰度化，然后用K-means聚类，把聚类后的各个中心点作为一张图片的特征向量如果两张图片的特征向量相近则说明这两张图片相似。貌似我这个答案有点出乎他的意料，他意味深长地说了个“行吧~~~~”（个人觉得颜色直方图匹配是个他期待的常规回答）介绍卷积神经网络，和 DBN 有什么区别？Deep CNN, Deep RNN, RBM的典型应用与局限，看Hinton讲义和Paper去吧神经网络,plsi的推导验证码图片的去噪和提取字符有限状态自动机,然后要我画状态转移图. 聚类12用过哪些聚类算法，解释密度聚类算法。聚类算法中的距离度量有哪些？ 优化12345678梯度下降的优缺点；主要问最优化方面的知识，梯度下降法的原理以及各个变种（批量梯度下降，随机梯度下降法， mini 梯度下降法），以及这几个方法会不会有局部最优问题，牛顿法原理和适用场景，有什么缺点，如何改进（拟牛顿法）常用优化算法：1.梯度下降法：又有随机梯度下降和负梯度下降，2.牛顿法 主要是问了各自的优缺点，速度，能不能得到全局最优解，牛顿法的二次收敛等问你如果有若干个极小值点，如何避免陷入局部最优解。它们间的牛顿学习法、SGD如何训练，如何判断函数凸或非凸？线性回归的梯度下降和牛顿法求解公式的推导最速下降法和共轭梯度法 wolfe条件 最速下降法和共轭梯度法的收敛速度如何判断深刻理解常用的优化方法：梯度下降、牛顿法、各种随机搜索算法（基因、蚁群等等），深刻理解的意思是你要知道梯度下降是用平面来逼近局部，牛顿法是用曲面逼近局部等等。 推荐系统12345678910介绍SVD、SVD++推荐系统的冷启动问题如何解决深度学习在推荐系统上可能有怎样的发挥？推荐系统的算法中最近邻和矩阵分解各自适用场景白板写SVD/SVD++公式，SGD迭代更新p，q矩阵公式，SVD/SVD++优化方法对推荐算法的未来看法；用过什么算法？最好是在项目/实习的大数据场景里用过，比如推荐里用过 CF、LR，我面的推荐，问了各类协同过滤的好与坏。问了一个很有意思的问题，现实应用中的Top-N推荐问题和学术研究中的评分预测问题之间有什么不同。问我ItemCF的工程实现，面对大数据如何实现，又追问了有没有什么工程优化算法。这个问题我没答好，一开始我说了一个MapReduce模型，他问能不能更快一点，我就卡那了。。。最后面试官告诉我，不能只从算法角度分析，要从系统设计分析，利用内存来减小MapReduce的吞吐量。（当然也许从MapReduce那一刻开始我就输了也不一定）推荐系统的算法中最近邻和矩阵分解各自适用场景http://www.doc88.com/p-3961053026557.html PCA12那你对pca了解吗？我：了解啊，面试官：那讲一下pca是用来干嘛的？我：pca啊，可以用来分析主方向啊，降维啊，特征筛选啊，具体方法是用svd分解得到特征值矩阵和特征向量矩阵，然后根据不同的任务对选择特征值或向量进行计算。 EM1采用 EM 算法求解的模型有哪些，为什么不用牛顿法或梯度下降法？ NLP12345用过哪些 NLP 算法项目中用过哪些机器学习算法。海量的 item 算文本相似度的优化方法；解释 word2vec 的原理以及哈夫曼树的改进；word2vec的原理二面面试官主要跟我聊简历上的几个项目，他好像不能理解词向量的形式，反复解释了很多遍，问的问题都比较简单，有TF-IDF,余弦相似度，分词工具等等。然后我说我做过LDA，问我，Dirichlet Distribution的定义和性质，并问我，为什么它和multinomial distribution是共轭的，顺便问了我啥叫共轭分布。 关联分析：1项目中涉及到频繁模式挖掘，于是问了一下如何实现的？ 用的是 Apriori算法，描述他的原理过程，关键字眼：支持度，支持度计数，k项候选频繁项集，怎么从k项到k+1项等，连接剪枝过程。 hadoop12345678简单介绍 MapReduce 原理，有没有看过源码，说说 Map 阶段怎么实现的,MapReduce 实现统计出现次数最多的前 100 个访问 IP.MapReduce 实现统计不重复用户 ID,MapReduce 实现两个数据集求交集。HBase 行健怎么设计,spark 性能一般优化方法,spark streaming 和 storm 区别.给了一张笔试题， 10 道选择，一道大题。选择题是 java 基础知识，大题一个有三问：根据场景写出 Hive 建表语句； Hsql 从表中查询；用MapReduce写好友推荐，在一堆单词里面找出现次数最多的k个用分布式的方法做采样怎么保证采样结果完全符合预期？后面又问了Hadoop,Spark,storm下面的产品，原理，适用场景，写一个 Hadoop 版本的 wordcount。 HMM1234567891011121314151617181920212223242526272829实现 hmm 的状态转移代码；机器学习理论讲机器学习中常用的损失函数有哪些？交叉熵有什么好处？（凸优化问题）判别模型与生成模型的本质区别是什么分类模型和回归模型的区别，分类模型可以做回归分析吗？反过来可以吗？（我回答是分类不可以做回归，回归倒是可以做分类，不知道对不对）k折交叉验证 中k取值多少有什么关系 （我不知道，随便答，然后面试官后面问我知道bias和variance吗？估计是和这两个东西有关， 知乎上有个问题讨论了k值大小与bias和variance的关系）解释局部相关性特征选择的方法；在模型的训练迭代中，怎么评估效果；特征选择方法有哪些(能说出来10种以上加分)，之后和面试官仔细聊了一下特征选择的问题，我介绍了了解的几种基本的特征选择思路（错误率选择、基于熵的选择、类内类间距离的选择）；有没有接触过机器学习的前沿，深度学习看过paper没有？（并没有）如何用尽可能少的样本训练模型同时又保证模型的性能；你读哪些期刊会议的论文？你遇到的比较有意思的算法？生成模型，判别模型线性分类和非线性分类各有哪些模型比较各个模型的Loss function，设计一个结构存取稀疏矩阵 （面试官最后告诉我了一个极度压缩的存法，相同行或列存偏差，我当时没听懂，还不懂装懂，最后还是没记住）PageRank原理，怎么用模型来查找异常用户，我讲了一大堆我的理解，然后面试官一句你怎么不用规则把我噎到了……无监督和有监督算法的区别？经典算法推导(加分项)，原理，各个损失函数之间区别，使用场景，如何并行化，有哪些关键参数什么叫判别模型什么叫生成模型。先针对项目十分细致地询问了各种细节，然后就问我如何处理数据中的噪声点、数据清洗算法（正好自己做了一个算法）、如何选择特征等。校招TST内推，面过了2面，还是跟之前那个有点类似的游戏开发的安全部门，因为我也玩LOL，又问到怎么来判断玩家有没有作弊之类的问题，这次我小心翼翼的说用模型怎么做，用规则怎么做，感觉这次聊的都挺开心的。是否了解A/B Test以及A/B Test结果的置信度特征工程经验是否了解mutual infomation、chi-square、LR前后向、树模型等特征选择方式深刻理解各种算法对应采用的数据结构和对应的搜索方法。比如KNN对应的KD树、如何给图结构设计数据结构？如何将算法map-red化矩阵的各种变换，尤其是特征值相关的知识。分布式的矩阵向量乘的算法线性分类器与非线性分类器的区别及优劣；特征比数据量还大时，选择什么样的分类器？对于维度很高的特征，你是选择线性还是非线性分类器？对于维度极低的特征，你是选择线性还是非线性分类器？如何解决过拟合问题？L1和L2正则的区别，如何选择L1和L2正则？项目中的数据是否会归一化处理，哪个机器学习算法不需要归一化处理并行计算、压缩算法LDA http://www.doc88.com/p-1621945750499.html]]></content>
      <tags>
        <tag>笔面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习推荐书]]></title>
    <url>%2F2018%2F07%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8E%A8%E8%8D%90%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[机器学习推荐书 5本深度学习书籍资源推荐 深度学习（Deep Learning）byIan Goodfellow and Yoshua Bengio and Aaron Courville 中文版下载地址：https://github.com/exacity/deeplearningbook-chinese R语言深度学习实践指南（Deep Learning Made Easy with R）by Dr. N.D. Lewis 下载地址：http://download.csdn.net/detail/oscer2016/9829915 深度学习基础（Fundamentals of Deep Learning）by Nikhil Buduma 下载地址：http://www.taodocs.com/p-32598980.html 神经网络和统计学习（Neural networks and statistical learning） by K.-L. Du and M.N.s. Swamy 下载地址：http://download.csdn.net/detail/oscer2016/9829919 神经网络和深度学习（Neural Networks and Deep Learning） by Michael Niels 下载地址：http://download.csdn.net/download/newhotter/9651111 10本机器学习书籍资源推荐 机器学习、神经网络和统计分类（Machine Learning, Neural Networks, and Statistical Classification）by D. Michie, D.J. Spiegelhalter, C.C. Taylor 下载地址：http://www1.maths.leeds.ac.uk/~charles/statlog/ 贝叶斯推理和机器学习（Bayesian Reasoning and Machine Learning）by David Barber 下载地址：http://web4.cs.ucl.ac.uk/staff/D.Barber/pmwiki/pmwiki.php?n=Brml.Online 机器学习的高斯过程（Gaussian Processes for Machine Learning） by Carl Edward Rasmussen and Christopher K. I. Williams，The MIT Press 下载地址：http://www.gaussianprocess.org/gpml/ 信息理论、推理和学习算法（Information Theory, Inference, and Learning Algorithms） by David J.C. MacKay 下载地址：http://www.inference.phy.cam.ac.uk/mackay/itprnn/book.html 统计学习元素（The Elements of Statistical Learning）by Trevor Hastie, Robert Tibshirani, Jerome Friedman 下载地址：http://statweb.stanford.edu/~tibs/ElemStatLearn/printings/ESLII_print10.pdf 机器学习课程（A Course in Machine Learning）by Hal Daumé III 下载地址：http://ciml.info/ 机器学习导论（Introduction to Machine Learning）by Amnon Shashua，Cornell University 下载地址：https://arxiv.org/abs/0904.3664v1 强化学习（Reinforcement Learning） 下载地址：https://www.intechopen.com/books/reinforcement_learning 机器学习导论（Introduction to Machine Learning）- By Nils Nilsson 下载地址：http://ai.stanford.edu/~nilsson/mlbook.html 强化学习（Reinforcement Learning）- MIT Press 下载地址：http://webdocs.cs.ualberta.ca/~sutton/book/the-book.html]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构_二叉树]]></title>
    <url>%2F2018%2F07%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[数据结构_二叉树 树的遍历顺序大体分为三种：前序遍历（先根遍历、先序遍历），中序遍历（中根遍历），后序遍历（后根遍历） 123456二叉树： A / \ B C /\ / D E F 前序遍历前序遍历可以记为根左右。前序遍历的规则：123（1）访问根节点（2）前序遍历左子树（3）前序遍历右子树 前序遍历的输出结果：ABDECF 中序遍历中序遍历可以记为左根右中序遍历的规则：123（1）中序遍历左子树（2）访问根节点（3）中序遍历右子树 中序遍历的输出结果：DBEAFC 后序遍历后序遍历可以记为左右根后序遍历二叉树的规则：123（1）后序遍历左子树（2）后序遍历右子树（3）访问根节点 后序遍历的输出顺序：DEBFCA]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Opencv图像分割]]></title>
    <url>%2F2018%2F07%2F19%2Fopencv_imgseg%2F</url>
    <content type="text"><![CDATA[Opencv图像分割 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* * * 功能：通过灰度图做简单的图像分割,再使用findContours去掉多余的轮廓 * */ #include &lt;vector&gt; #include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt; using namespace cv;using namespace std; void contours(); int main()&#123; contours();&#125; void contours()&#123; //--1.读入图片 Mat image = imread(&quot;horse_hw.jpg&quot;); Mat gray;//mat类型数据存放图片，opencv特有 cvtColor(image,gray,CV_RGB2GRAY); Mat binary; threshold(gray,binary,60,255,THRESH_BINARY_INV); vector&lt;vector&lt;Point&gt; &gt; contours; Mat binary_copy; //因为findcontours函数会改变输入的图像，所以复制一个图像作为函数的输入 binary.copyTo(binary_copy); findContours(binary_copy,contours,CV_RETR_EXTERNAL/*获取外轮廓*/,CV_CHAIN_APPROX_NONE/*获取每个轮廓的每个像素*/); //遍历每一个轮廓，把多余的轮廓去掉 vector&lt;vector&lt;Point&gt; &gt;::const_iterator it=contours.begin(); while(it!=contours.end()) &#123; if(it-&gt;size()&lt;500) it = contours.erase(it); else ++it; &#125; Mat dst(image.size(),CV_8U,Scalar(0)); drawContours(dst,contours,-1/*绘制所有轮廓*/,Scalar(255)/*绘制为白色*/,CV_FILLED/*轮廓全部填充*/); //--4.显示结果(原图和结果图显示在一起) const int width = image.cols; const int height = image.rows; Mat show_image(Size(3*width,height),CV_8UC3); //将image拷贝到显示图片指定位置 image.copyTo(show_image(Rect(0,0,width,height))); //将binary,dst转换为3通道，使得show_image和dst通道数一致，或者使用convertTo()函数做操作 cvtColor(binary,binary,CV_GRAY2RGB); cvtColor(dst,dst,CV_GRAY2RGB); //将binary,dst拷贝image指定位置 binary.copyTo(show_image(Rect(width,0,width,height))); dst.copyTo(show_image(Rect(2*width,0,width,height))); //显示 imshow(&quot;show&quot;,show_image); waitKey(0);&#125;]]></content>
      <tags>
        <tag>Opencv</tag>
        <tag>图像处理</tag>
        <tag>图像分割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-正则化-L1L2]]></title>
    <url>%2F2018%2F07%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%AD%A3%E5%88%99%E5%8C%96-L1L2%2F</url>
    <content type="text"><![CDATA[机器学习-正则化-L1L2 样本数据量大：经验⻛风险最⼩小化 样本数据量小：结构⻛风险最⼩小化==正则化 经验风险最⼩小化（empirical risk minimization）认为经验⻛风险最⼩小的模型是最优的模型，即求解最优化问题 minf ∈ F(1/N)\sum_{i=1}^NL(y_i,f(x_i))样本容量量⾜足够⼤大的时候，经验⻛风险最⼩小化学习效果良好 结构⻛风险=经验⻛风险+模型复杂度的正则化项（regularizer）或罚项（penalty term） minf ∈ F(1/N)\sum_{i=1}^NL(y_i,f(x_i))+\lambda{J(f)}$J(f)$是模型的复杂度，模型$f$越复杂，复杂度$J(f)$越大。$\lambda ≥ 0$是系数，⽤用以权衡经验⻛风险和模型复杂度。 结构风险⼩需要1、经验风险和2、模型复杂度同时⼩ 范数因为非负性：可以做损失函数，正则项 损失函数通常是⼀个有下确界的函数 常用范数：L0 L1:绝对值 ||x||=\sum_{i=1}^{d}{|x_i|}L2；平方再开根号 ||x||_2=(\sum_{i=1}^{d}{|x_i^2|})^{1/2}Lp ||x||_2=(\sum_{i=1}^{d}{|x_i^p|})^{1/p}p=1,曼哈顿距离，L1范数，表示某个向量量中所有元素绝对值的和p=2,欧式距离，L2范数 使用L1正则项，倾向于使参数稀疏化，使用L2正则项，使参数稠密的接近于0。L1正则是菱形，参数的交点都落在坐标轴上，实现稀疏化。L2是圆形， 正则项是为了降低模型的复杂度，从而避免模型区过分拟合训练数据，包括噪声与异常点（outliers）。从另一个角度上来讲，正则化即是假设模型参数服从先验概率，即为模型参数添加先验，只是不同的正则化方式的先验分布是不一样的。这样就规定了参数的分布，使得模型的复杂度降低（试想一下，限定条件多了，是不是模型的复杂度降低了呢），这样模型对于噪声与异常点的抗干扰性的能力增强，从而提高模型的泛化能力。还有个解释便是，从贝叶斯学派来看：加了先验，在数据少的时候，先验知识可以防止过拟合；从频率学派来看：正则项限定了参数的取值，从而提高了模型的稳定性，而稳定性强的模型不会过拟合，即控制模型空间。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-线性回归]]></title>
    <url>%2F2018%2F07%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[机器学习-线性回归 LR模型每个特征变量可以首先映射到⼀一个函数，然后再参与线性计算,模型如下： y = \theta_0 + \theta_1x_1 + \theta_2x_2 + · · · + \theta_nx_n其中$ x_1,x_2,…,x_n$表示自变量（特征分量），$y$表示因变量，$\theta$是权重，$\theta_0$是偏移项（截距）;$\theta_i$越大，说明$x_i$对$y$结果的影响越⼤输入空间映射到特征空间(映射函数$\phi(x)$)，建模.为 h_\theta(x)=\theta^T\phi(x)特征映射相关技术，包括特征哈希、特征学习、Kernel等 目标函数预测值$ h_\theta(x)$与真实值$y$之差越小越好，加入损失函数(平方损失函数): J(\theta)={0.5}\sum_{i=1}^{n}{(h_\theta(x^i)-y^i)^2}求$min{J(\theta)}$损失函数就是$x^i$的预测值$h_\theta(x^i)$与真实值$y^i$之差的平方和 回归模型（尤其是线性回归类）的⽬目标函数通常⽤用平⽅方损失函数来作为优化的⽬目标函数 为什么用误差平方和作为目标函数： 根据中⼼心极限定理理，把那些对结果影响⽐比较⼩小的变量量（假设独⽴立同分布）之和认为服从正态分布是合理理的 如果数据是高斯分布的，输入值$x^i$，预测值$\theta^Tx^i$，真实值$y^i$，误差$\epsilon^{i}$，线性模型为， y^i=\theta^Tx^i+\epsilon^{i}根据中心极限定理，认为变量之和服从高斯分布,即 e^{i} = y^i-\theta^Tx^i则，x,y的条件概率为 p(y^i|x^i;\theta) = \frac{1}{\sqrt{2\pi}\sigma}exp(-\frac{(y^i-\theta^Tx^i)^2}{2\sigma^2})$p(y^i|x^i;\theta)$越大，证明越接近真实值，还要考虑拟合过度以及模型的泛化能力问题 优化目标函数：使目标函数最小12345最小二乘法梯度下降法 批量梯度下降法 随机梯度下降法拉格朗日乘子法 例子 \begin{bmatrix} {a_{11}}&{a_{12}}&{\cdots}&{a_{1n}}\\ {a_{21}}&{a_{22}}&{\cdots}&{a_{2n}}\\ {\vdots}&{\vdots}&{\ddots}&{\vdots}\\ {a_{m1}}&{a_{m2}}&{\cdots}&{a_{mn}}\\ \end{bmatrix}]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习常见算法总结]]></title>
    <url>%2F2018%2F07%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[机器学习常见算法总结 学习方式 概念 监督式学习 从给定的训练数据集中学习出一个函数，当新的数据到来时，可以根据此函数预测结果。训练数据集中的目标由人标注的。常见的算法有回归分析和统计分类 非监督式学习 与监督式学习相比，训练集没有人为标注的结果，常见的算法有聚类 半监督式学习 训练集部分被标识，部分没有被标识。常见的算法有SVM 强化学习 输入数据作为模型的反馈，模型对此作出调整。常见的算法有时间差学习 |机器学习算法分类|概念||—————-|—-||决策树算法|根据数据属性，采用树状结构建立决策模型。常用来解决分类和回归问题。常见算法：CART(Classification And Regression Tree)，ID3，C4.5，随机森林等||回归算法|对连续值预测，如逻辑回归LR等||分类算法|对离散值预测，事前已经知道分类，如k-近邻算法||聚类算法|对离散值预测，事前对分类未知，如k-means算法||神经网络|模拟生物神经网络，可以用来解决分类和回归问题感知器神经网络(Perceptron Neural Network) ，反向传递(Back Propagation)和深度学习（DL）||集成算法 |集成几种学习模型进行学习，将最终预测结果进行汇总Boosting、Bagging、AdaBoost、随机森林 (Random Forest) 等| 机器学习算法分类决策树算法根据数据属性，采用树状结构建立决策模型。常用来解决分类和回归问题。常见算法：CART(Classification And Regression Tree)，ID3，C4.5，随机森林等回归算法对连续值预测，如逻辑回归LR等分类算法对离散值预测，事前已经知道分类，如k-近邻算法聚类算法对离散值预测，事前对分类未知，如k-means算法神经网络模拟生物神经网络，可以用来解决分类和回归问题感知器神经网络(Perceptron Neural Network) ，反向传递(Back Propagation)和深度学习（DL）集成算法集成几种学习模型进行学习，将最终预测结果进行汇总Boosting、Bagging、AdaBoost、随机森林 (Random Forest) 等 SVM1、SVM不太容易过拟合：松弛因子+损失函数形式 SVM的求解方法叫拉格朗日乘子法 有时候如果你非要很明确地分类，那么结果就会像右边的一样 —— 过拟合。明显左边的两个都比过拟合好多了，可是这样就要求允许一些样本不在正确的类上. 目标：找出总损失值最小并且能大概分类的超平面 2、方法选择1231、如果Feature的数量很大，跟样本数量差不多，这时候选用LR或者是Linear Kernel的SVM2、如果Feature的数量比较小，样本数量一般，不算大也不算小，选用SVM+Gaussian Kernel3、如果Feature的数量比较小，而样本数量很多，需要手工添加一些feature变成第一种情况 3、数据维度如果数据特征维度高，svm要使用核函数来求解123Note：拉格朗日对偶没有改变最优解，但改变了算法复杂度：原问题—样本维度；对偶问题–样本数量。线性分类 样本维度&lt;样本数量：原问题求解（liblinear默认）； 非线性–升维—一般导致 样本维度&gt;样本数量：对偶问题求解 朴素贝叶斯朴素贝叶斯的优点：对小规模的数据表现很好，适合多分类任务，适合增量式训练。缺点：对输入数据的表达形式很敏感（离散、连续，值极大极小之类的） 线性回归线性回归试图学得一个线性模型以尽可能准确地预测实值输出标记。均方误差是回归任务中最常用的性能度量，基于均方误差最小化来进行模型求解的方法成为最小二乘法。在线性回归中，最小二乘法就是试图找到一条直线，使得所有样本到直线上的欧式距离之和最小。这个想法和分类问题是正好相反的，分类问题是找到一个分界面离所有样本尽可能远。 优化方法 当x矩阵是列满秩的时候，可以用最小二乘法，但是求矩阵的逆比较慢 机器学习算法选择 没有最好的分类器，只有最合适的分类器。 数据维度越高，随机森林就比AdaBoost强越多，但是整体不及SVM。 数据量越大，神经网络就越强。 1、K近邻典型KNN，它的思路就是——对于待判断的点，找到离它最近的几个数据点，根据它们的类型决定待判断点的类型。它的特点是完全跟着数据走，没有数学模型可言。123适用情景：需要一个特别容易解释的模型的时候。比如需要向用户解释原因的推荐算法。 2、贝叶斯典型的例子是Naive Bayes，核心思路是根据条件概率计算待判断点的类型。是相对容易理解的一个模型，至今依然被垃圾邮件过滤器使用。12345适用情景：需要一个比较容易解释，而且不同维度之间相关性较小的模型的时候。可以高效处理高维数据，虽然结果可能不尽如人意。 3、决策树 (Decision tree)决策树的特点是它总是在沿着特征做切分。随着层层递进，这个划分会越来越细。举个简单的例子，当我们预测一个孩子的身高的时候，决策树的第一层可能是这个孩子的性别。男生走左边的树进行进一步预测，女生则走右边的树。这就说明性别对身高有很强的影响。 12适用情景：同时它也是相对容易被攻击的分类器。这里的攻击是指人为的改变一些特征，使得分类器判断错误。常见于垃圾邮件躲避检测中。因为决策树最终在底层判断是基于单个条件的，攻击者往往只需要改变很少的特征就可以逃过监测。受限于它的简单性，决策树更大的用处是作为一些更有用的算法的基石。 随机森林 (Random forest)随机森林其实算是一种集成算法。它首先随机选取不同的特征(feature)和训练样本(training sample)，生成大量的决策树，然后综合这些决策树的结果来进行最终的分类。 它相对于决策树，在准确性上有了很大的提升，同时一定程度上改善了决策树容易被攻击的特点。 12345适用情景：数据维度相对低（几十维），同时对准确性有较高要求时。因为不需要很多参数调整就可以达到不错的效果，基本上不知道用什么方法的时候都可以先试一下随机森林。 优化问题的求解方法大部分的机器学习算法的本质都是建立优化模型，通过最优化方法对目标函数（或损失函数）进行优化，从而训练出最好的模型。常见的最优化方法有梯度下降法、牛顿法和拟牛顿法、共轭梯度法等等。 1、梯度下降法 优化思想1当目标函数是凸函数时，梯度下降法的解是全局解。一般情况下，其解不保证是全局最优解，梯度下降法的速度也未必是最快的。梯度下降法的优化思想是用当前位置负梯度方向作为搜索方向，因为该方向为当前位置的最快下降方向，所以也被称为是”最速下降法“。最速下降法越接近目标值，步长越小，前进越慢。 缺点梯度下降法的最大问题就是会陷入局部最优，靠近极小值时收敛速度减慢。 2、批量梯度下降法1最小化所有训练样本的损失函数，使得最终求解的是全局的最优解，即求解的参数是使得风险函数最小，但是对于大规模样本问题效率低下。 3、随机梯度下降法1最小化每条样本的损失函数，虽然不是每次迭代得到的损失函数都向着全局最优方向， 但是大的整体的方向是向全局最优解的，最终的结果往往是在全局最优解附近，适用于大规模训练样本情况。 随机梯度下降是通过每个样本来迭代更新一次，如果样本量很大的情况（例如几十万），那么可能只用其中几万条或者几千条的样本，就已经将theta迭代到最优解了，对比上面的批量梯度下降，迭代一次需要用到十几万训练样本，一次迭代不可能最优，如果迭代10次的话就需要遍历训练样本10次。但是，SGD伴随的一个问题是噪音较BGD要多，使得SGD并不是每次迭代都向着整体最优化方向。 4、牛顿法 牛顿法是一种在实数域和复数域上近似求解方程的方法。方法使用函数f (x)的泰勒级数的前面几项来寻找方程f (x) = 0的根。牛顿法最大的特点就在于它的收敛速度很快。 牛顿法比梯度下降法快 牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快。如果更通俗地说的话，比如你想找一条最短的路径走到一个盆地的最底部，梯度下降法每次只从你当前所处位置选一个坡度最大的方向走一步，牛顿法在选择方向时，不仅会考虑坡度是否够大，还会考虑你走了一步之后，坡度是否会变得更大。所以，可以说牛顿法比梯度下降法看得更远一点，能更快地走到最底部。 但是牛顿法要算hessian矩阵的逆，比较费时间。 5、拟牛顿法 拟牛顿法的本质思想是改善牛顿法每次需要求解复杂的Hessian矩阵的逆矩阵的缺陷，它使用正定矩阵来近似Hessian矩阵的逆，从而简化了运算的复杂度。拟牛顿法和最速下降法一样只要求每一步迭代时知道目标函数的梯度。通过测量梯度的变化，构造一个目标函数的模型使之足以产生超线性收敛性。这类方法大大优于最速下降法，尤其对于困难的问题。另外，因为拟牛顿法不需要二阶导数的信息，所以有时比牛顿法更为有效。 6、拉格朗日法 拉格朗日乘数法 拉格朗日乘子法主要用于解决约束优化问题，它的基本思想就是通过引入拉格朗日乘子来将含有n个变量和k个约束条件的约束优化问题转化为含有（n+k）个变量的无约束优化问题。拉格朗日乘子背后的数学意义是其为约束方程梯度线性组合中每个向量的系数。 通过引入拉格朗日乘子建立极值条件，对n个变量分别求偏导对应了n个方程，然后加上k个约束条件（对应k个拉格朗日乘子）一起构成包含了（n+k）变量的（n+k）个方程的方程组问题，这样就能根据求方程组的方法对其进行求解 过拟合： 如果一味的去提高训练数据的预测能力，所选模型的复杂度往往会很高，这种现象称为过拟合。所表现的就是模型训练时候的误差很小，但在测试的时候误差很大。 训练模型很好用，测试时候误差较大 参考]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[特征提取_图像矩阵变换]]></title>
    <url>%2F2018%2F07%2F19%2F%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E5%9B%BE%E5%83%8F%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[特征提取_图像矩阵变换 基本的二维变换可包括缩放、旋转、扭曲，和平移四种 几何运算则可以转换为一些基本的矩阵运算 平移运算不是线性的,使用矩阵乘法再使用矩阵加法来完成此操作 综合这几种基本运算，数学家们将其统一为一个3*3矩阵，存储形式 仿射变换的矩阵的第三列总是（0，0，1），在存储矩阵的时候，大多只存成一个2*3的数组。 复合变换是有顺序的，一般说来，先旋转、再缩放、然后平移]]></content>
      <tags>
        <tag>特征提取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习_分类_KNN_EM]]></title>
    <url>%2F2018%2F07%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_KNN_EM%2F</url>
    <content type="text"><![CDATA[机器学习_分类_KNN_EM K最近邻(kNN，k-NearestNeighbor)分类算法在KNN中，通过计算对象间距离来作为各个对象之间的非相似性指标，避免了对象之间的匹配问题，在这里距离一般使用欧氏距离或曼哈顿距离： 123456789101112步骤：其算法的描述为：1）计算测试数据与各个训练数据之间的距离；2）按照距离的递增关系进行排序；3）选取距离最小的K个点；4）确定前K个点所在类别的出现频率；5）返回前K个点中出现频率最高的类别作为测试数据的预测分类。 KNN算法的优点：123451）简单、有效。 2）重新训练的代价较低（类别体系的变化和训练集的变化，在Web环境和电子商务应用中是很常见的）。 3）计算时间和空间线性于训练集的规模（在一些场合不算太大）。 4）由于KNN方法主要靠周围有限的邻近的样本，而不是靠判别类域的方法来确定所属类别的，因此对于类域的交叉或重叠较多的待分样本集来说，KNN方法较其他方法更为适合。 5）该算法比较适用于样本容量比较大的类域的自动分类，而那些样本容量较小的类域采用这种算法比较容易产生误分。 KNN算法缺点： 123451）KNN算法是懒散学习方法（lazy learning,基本上不学习），一些积极学习的算法要快很多。 2）类别评分不是规格化的（不像概率评分）。 3）输出的可解释性不强，例如决策树的可解释性较强。 4）该算法在分类时有个主要的不足是，当样本不平衡时，如一个类的样本容量很大，而其他类样本容量很小时，有可能导致当输入一个新样本时，该样本的K个邻居中大容量类的样本占多数。该算法只计算“最近的”邻居样本，某一类的样本数量很大，那么或者这类样本并不接近目标样本，或者这类样本很靠近目标样本。无论怎样，数量并不能影响运行结果。可以采用权值的方法（和该样本距离小的邻居权值大）来改进。 5）计算量较大。目前常用的解决方法是事先对已知样本点进行剪辑，事先去除对分类作用不大的样本。 EM算法EM的策略就是先随便给一个条件概率p1(x1|thera)，然后找到一个l(thera)的下界函数r(x1|thera),求r的最大值p2(x2|thera)，再找到经过p2点的下界函数r2(x2|thera)，重复该过程直到收敛到局部最大值。 灰度图分割：参考 point.h文件1234567891011#ifndef POINT_H#define POINT_H//point结构主要用来存储图像中节点的横坐标，纵坐标以及灰度值struct point&#123; int row; int col; double pixVal; point(int row, int col, double pixVal) :row(row),col(col),pixVal(pixVal) &#123;&#125;&#125;;#endif keams.h头文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#ifndef KMEANS_H#define KMEANS_H#include&lt;opencv2\opencv.hpp&gt;#include&lt;random&gt;#include&lt;time.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;list&gt;#include&lt;iostream&gt;#include&lt;math.h&gt;#include&quot;point.h&quot;using namespace cv;using namespace std;class Kmeans&#123;private: //存储所有点 vector&lt;point&gt; points; //存储簇的中心点 vector&lt;point&gt; centers; //存储每个点到相应的簇 vector&lt;point&gt;* clusters; //向量的维数 int dimension; //簇的个数 int k;public: //构造函数 Kmeans(vector&lt;point&gt; points, vector&lt;point&gt; centers, int k, int dimension) &#123; this-&gt;points = points; this-&gt;centers = centers; this-&gt;dimension = dimension; this-&gt;k = k; clusters = new vector&lt;point&gt;[k]; &#125; //析构函数 ~Kmeans() &#123; delete clusters; &#125; //获取簇 vector&lt;point&gt;* getClusters() &#123; return this-&gt;clusters; &#125; //计算两个向量之间的欧式距离 double getDistanceBetweenTwoPoints(const point&amp; point1, const point&amp; point2) &#123; double sum = 0; //double tmp; //for (int i = 0; i &lt; dimension; i++) //&#123; //tmp = pow(point1.pixVal - point2.pixVal,2); //sum += tmp; //&#125; sum = pow(point1.pixVal - point2.pixVal, 2); return sqrt(sum); &#125; //计算每个点到离它最近的簇中心点，结果保存到vector中 vector&lt;int&gt; getClosetClusterCenterLabel() &#123; double min; int label; vector&lt;int&gt; labels; for (int i = 0; i &lt; points.size(); i++) &#123; label = 0; min = getDistanceBetweenTwoPoints(points[i], centers[0]); for (int j = 1; j &lt; centers.size(); j++) &#123; double tmp = getDistanceBetweenTwoPoints(points[i], centers[j]); if (tmp &lt; min) &#123; min = tmp; label = j; &#125; &#125; labels.push_back(label); &#125; return labels; &#125; //将每个点放入它离的最近的中心点对应的簇中 void computeClusters(const vector&lt;int&gt;&amp; labels) &#123; for (int i = 0; i &lt; k; i++) &#123; clusters[i].clear(); &#125; for (int i = 0; i &lt; labels.size(); i++) &#123; int label = labels[i]; clusters[label].push_back(points[i]); &#125; &#125; //重新计算所有簇的中心点的灰度值 void computeCenters() &#123; centers.clear(); for (int i = 0; i &lt; k; i++) &#123; double sum = 0; for (int j = 0; j &lt; clusters[i].size(); j++) &#123; sum += clusters[i][j].pixVal; &#125; double meanVal = sum / clusters[i].size(); point cp(-1, -1, meanVal); centers.push_back(cp); &#125; &#125; //确定新的中心点后重新计算一次cost double computeCost() &#123; double sum = 0; for (int i = 0; i &lt; k; i++) &#123; vector&lt;point&gt; tmpVec=clusters[i]; for (int j = 0; j &lt; tmpVec.size(); j++) &#123; sum += getDistanceBetweenTwoPoints(tmpVec[j], centers[i]); &#125; &#125; return sum / points.size(); &#125; //迭代执行k-means算法的步骤 void kmeans() &#123; double oldCost, newCost; vector&lt;int&gt; labels=getClosetClusterCenterLabel(); computeClusters(labels); newCost = computeCost(); computeCenters(); labels = getClosetClusterCenterLabel(); computeClusters(labels); oldCost = newCost; newCost = computeCost(); while (oldCost != newCost) &#123; oldCost = newCost; computeCenters(); labels = getClosetClusterCenterLabel(); computeClusters(labels); newCost = computeCost(); &#125; cout &lt;&lt;&quot;Final Cost: &quot;&lt;&lt; newCost &lt;&lt; endl; &#125;&#125;;#endif 测试的kmeans.cpp文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &quot;kmeans.h&quot;//图片的存放位置const String imageFolder = &quot;F:\\&quot;;//簇的个数（即k的大小，根据自己需要调整）const int numOfCluster =4;//最大像素值const int MAX_PIX_VALUE = 255;//存放所有点vector&lt;point&gt; points;//存放所有簇中心vector&lt;point&gt; centers;//存放所有点颜色特征(i,j)-&gt;i*rows+jvector&lt;double&gt; pixVec;//读取图像Mat readImage(String imageName)&#123; String imageLoc = imageFolder + imageName; Mat image=imread(imageLoc); return image;&#125;//初始化k-means聚类中心void initializeCenters(const Mat&amp; img)&#123; srand((unsigned)time(NULL)); for (int i = 0; i &lt; numOfCluster; i++) &#123; int randomX = rand() % img.rows; int randomY = rand() % img.cols; uchar pixVal = img.at&lt;uchar&gt;(randomX, randomY); point cp(randomX, randomY, (double)pixVal); centers.push_back(cp); &#125;&#125;//将图像中的所有点装入points中void initializePoints(const Mat&amp; img)&#123; for (int i = 0; i &lt; img.rows; i++) &#123; const uchar* data = img.ptr&lt;uchar&gt;(i); for (int j = 0; j &lt; img.cols; j++) &#123; uchar pixVal = data[j]; point p(i,j, (double)pixVal); points.push_back(p); &#125; &#125;&#125;int main()&#123; String imageName = &quot;lena.jpg&quot;; Mat img = readImage(imageName); cvtColor(img, img, CV_RGB2GRAY);//转化为灰度图像 namedWindow(imageName,WINDOW_NORMAL); imshow(imageName, img); waitKey(0); int rows = img.rows; int cols = img.cols; initializeCenters(img); initializePoints(img); Kmeans* km=new Kmeans(points, centers, numOfCluster, 1); cout &lt;&lt; &quot;---------------k-means start-------------&quot; &lt;&lt; endl; km-&gt;kmeans(); cout &lt;&lt; &quot;---------------k-means end---------------&quot; &lt;&lt;endl; vector&lt;point&gt;* clusters = km-&gt;getClusters(); Mat res(img.rows,img.cols,img.type()); double div = MAX_PIX_VALUE / numOfCluster; for (int i = 0; i &lt; numOfCluster; i++) &#123; vector&lt;point&gt; tmpVec = clusters[i]; for (int j = 0; j &lt; tmpVec.size(); j++) &#123; res.at&lt;uchar&gt;(tmpVec[j].row, tmpVec[j].col) = i*div; &#125; &#125; namedWindow(&quot;kmeansResult&quot;,WINDOW_NORMAL); imshow(&quot;kmeansResult&quot;, res); waitKey(0); imwrite(&quot;./segment_lena.jpg&quot;, res); system(&quot;pause&quot;);&#125; 彩色图像分割：参考 主函数：123456789101112131415161718192021222324252627282930#include &quot;clusterImagePixels.hpp&quot; int main()&#123; Mat testImage = imread(&quot;E:\\testImage\\board.jpg&quot;); if (testImage.empty()) &#123; return -1; &#125; ClusterPixels clusterPix(testImage,3); Mat colorResults = clusterPix.clusterColorImageByKmeans(); Mat grayResult = clusterPix.clusterGrayImageByKmeans(); if (!colorResults.empty()) &#123; hconcat(testImage, colorResults, colorResults); imshow(&quot;clusterImage&quot;, colorResults); &#125; if (!grayResult.empty()) &#123; hconcat(testImage, grayResult, grayResult); imshow(&quot;grayCluster&quot;, grayResult); &#125; if (waitKey() == 27) return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;opencv.hpp&gt;using namespace cv; Scalar colorTab[] = //10个颜色&#123; Scalar(0, 0, 255), Scalar(0, 255, 0), Scalar(255, 100, 100), Scalar(255, 0, 255), Scalar(0, 255, 255), Scalar(255, 0, 0), Scalar(255, 255, 0), Scalar(255, 0, 100), Scalar(100, 100, 100), Scalar(50, 125, 125)&#125;; class ClusterPixels&#123;private: Mat image; //待聚类图像 Mat labels; //聚类后的标签 int clusterCounts; //分类数,不得大于10，只是颜色定义只有10类，并不是算法限制 public: ClusterPixels() :clusterCounts(0)&#123;&#125; ClusterPixels(const Mat&amp; src, int clusters = 5) :clusterCounts(clusters)&#123; image = src.clone(); &#125; void setImage(const Mat&amp; src)&#123; image = src.clone(); &#125;; void setClusters(int clusters)&#123; clusterCounts = clusters; &#125; Mat getLabels() &#123;return labels; &#125;; //返回聚类后的标签 Mat clusterGrayImageByKmeans() &#123; //转换成灰度图 if (image.channels() != 1) cvtColor(image, image, COLOR_BGR2GRAY); int rows = image.rows; int cols = image.cols; //保存聚类后的图片 Mat clusteredMat(rows, cols, CV_8UC3); clusteredMat.setTo(Scalar::all(0)); Mat pixels(rows*cols, 1, CV_32FC1); //pixels用于保存所有的灰度像素 for (int i = 0; i &lt; rows;++i) &#123; const uchar *idata = image.ptr&lt;uchar&gt;(i); float *pdata = pixels.ptr&lt;float&gt;(0); for (int j = 0; j &lt; cols;++j) &#123; pdata[i*cols + j] = idata[j]; &#125; &#125; kmeans(pixels, clusterCounts, labels, TermCriteria(TermCriteria::EPS + TermCriteria::MAX_ITER, 10, 0), 5, KMEANS_PP_CENTERS); for (int i = 0; i &lt; rows;++i) &#123; for (int j = 0; j &lt; cols;++j) &#123; circle(clusteredMat, Point(j,i), 1, colorTab[labels.at&lt;int&gt;(i*cols + j)]); //标记像素点的类别，颜色区分 &#125; &#125; return clusteredMat; &#125; Mat clusterColorImageByKmeans() &#123; assert(image.channels() != 1); int rows = image.rows; int cols = image.cols; int channels = image.channels(); //保存聚类后的图片 Mat clusteredMat(rows, cols, CV_8UC3); clusteredMat.setTo(Scalar::all(0)); Mat pixels(rows*cols, 1, CV_32FC3); //pixels用于保存所有的灰度像素 pixels.setTo(Scalar::all(0)); for (int i = 0; i &lt; rows; ++i) &#123; const uchar *idata = image.ptr&lt;uchar&gt;(i); float *pdata = pixels.ptr&lt;float&gt;(0); for (int j = 0; j &lt; cols*channels; ++j) &#123; pdata[i*cols*channels + j] = saturate_cast&lt;float&gt;(idata[j]); &#125; &#125; kmeans(pixels, clusterCounts, labels, TermCriteria(CV_TERMCRIT_EPS + CV_TERMCRIT_ITER, 10, 0), 5, KMEANS_PP_CENTERS); for (int i = 0; i &lt; rows; ++i) &#123; for (int j = 0; j &lt; cols*channels; j += channels) &#123; circle(clusteredMat, Point(j/channels,i), 1, colorTab[labels.at&lt;int&gt;(i*cols + (j/channels))]); //标记像素点的类别，颜色区分 &#125; &#125; return clusteredMat; &#125;&#125;; opencv3代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &quot;stdafx.h&quot;#include &quot;opencv2\opencv.hpp&quot;#include &lt;iostream&gt;using namespace std;using namespace cv;using namespace cv::ml;int main()&#123; Mat img = imread(&quot;E:/opencv/opencv/sources/samples/data/digits.png&quot;); Mat gray; cvtColor(img, gray, CV_BGR2GRAY); int b = 20; int m = gray.rows / b; //原图为1000*2000 int n = gray.cols / b; //裁剪为5000个20*20的小图块 Mat data,labels; //特征矩阵 for (int i = 0; i &lt; n; i++) &#123; int offsetCol = i*b; //列上的偏移量 for (int j = 0; j &lt; m; j++) &#123; int offsetRow = j*b; //行上的偏移量 //截取20*20的小块 Mat tmp; gray(Range(offsetRow, offsetRow + b), Range(offsetCol, offsetCol + b)).copyTo(tmp); data.push_back(tmp.reshape(0,1)); //序列化后放入特征矩阵 labels.push_back((int)j / 5); //对应的标注 &#125; &#125; data.convertTo(data, CV_32F); //uchar型转换为cv_32f int samplesNum = data.rows; int trainNum = 3000; Mat trainData, trainLabels; trainData = data(Range(0, trainNum), Range::all()); //前3000个样本为训练数据 trainLabels = labels(Range(0, trainNum), Range::all()); //使用KNN算法 int K = 5; Ptr&lt;TrainData&gt; tData = TrainData::create(trainData, ROW_SAMPLE, trainLabels); Ptr&lt;KNearest&gt; model = KNearest::create(); model-&gt;setDefaultK(K); model-&gt;setIsClassifier(true); model-&gt;train(tData); //预测分类 double train_hr = 0, test_hr = 0; Mat response; // compute prediction error on train and test data for (int i = 0; i &lt; samplesNum; i++) &#123; Mat sample = data.row(i); float r = model-&gt;predict(sample); //对所有行进行预测 //预测结果与原结果相比，相等为1，不等为0 r = std::abs(r - labels.at&lt;int&gt;(i)) &lt;= FLT_EPSILON ? 1.f : 0.f; if (i &lt; trainNum) train_hr += r; //累积正确数 else test_hr += r; &#125; test_hr /= samplesNum - trainNum; train_hr = trainNum &gt; 0 ? train_hr / trainNum : 1.; printf(&quot;accuracy: train = %.1f%%, test = %.1f%%\n&quot;, train_hr*100., test_hr*100.); waitKey(0); return 0;&#125;]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++入门]]></title>
    <url>%2F2018%2F07%2F19%2FC%2B%2B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[C++入门 指针入门 指针作用： 引用类型，传递地址，减少内存消耗案例int p &gt;定义变量pint* p &gt;定义指针变量p使用指针，先要定义指针变量12345678#include&lt;stdio.h&gt;int main() &#123; int *p; //int* p &gt;定义指针变量p int a=3; p=&amp;a; //&amp;a是把a的地址赋给指针p，&amp;：取址符a printf(&quot;%d\n&quot;,*p) //输出为3 return 0; &#125; 123&amp; 取变量的地址 &amp;(变量名)* 指针运算符（取值运算） *(变量名)&amp; *互为逆运算 *(&amp;(int i =6))=6 指针变量是存储地址的变量，随机分配例如：123456int *p1;char *nameint x;int *p; p=&amp;x;答：*P=3;p是x的地址，*p是x的值 常用错误：1、指针不能直接复制123456789错误：int *p; p =100;//错误正确：int i, *p, *t;p=&amp;i;t=p;*p *t是指针，把i的地址赋给pt指针（元素地址） 2、不能直接给指针赋值(不能直接变量取值)12int x= 20;printf(&quot;%d,&amp;(*x)); Scanf函数:函数后的参数应该传入指针，不应该是值123int score;printf(&quot;shuru :\n&quot;);scanf(&quot;%d&quot;,score); Swap函数：12345678910111213141516171819#include&lt;stdio.h&gt;void swap(int *x, int *y)&#123; int temp;//中间变量 temp=*x; *x = *y; *y = temp; printf(&quot;x=%d, y=%d \n&quot;, *x, *y);&#125;main()&#123; int i =13, j =45; swap(&amp;i, &amp;j); printf(&quot;i=%d, j=%d\n&quot;,i ,j);&#125;//输出： x=45,y=13 i=45,j=13 二级指针 C语言的参数传递都是值传递，当传传递一个指针给函数的时，其实质上还是值传递，除非使用双指针。只有一个号的时候，我们叫它一级指针。* 两个星号的叫二级指针。 123456789101112131415void swap ( int *a, int *b )&#123; int c; c = *a; *a = *b; *b = c; &#125; int main(int argc, char **argv)&#123; int a,b; a = 16; b = 32; swap( &amp;a, &amp;b); return ( a - b ); &#125; 段代码编译成汇编语言之后，除了会有代码段，数据段，堆栈，那么在调用的时候，会把main函数的参数变量压入main函数的栈帧，然后接着会压入swap函数的局部变量和参数 我们申明 **a之后，其实双指针变量a其实已经存在,内存效果如下12345p中放的是中间桥梁bridge的地址&amp;bridge*p就是中间桥梁bridge的内容(即是目标操作数的地址&amp;income)，**p就是目标操作数中间的bridge是桥梁，中间件使用的，过度吧 双指针主要用在但我们想向一个A函数传递参数的时候，但是我们希望在A内部对参数做任何修改都能保存起来，那么就是用双指针吧。 输入输出流IO库：|头文件|类型||||-|-|-|-||iostream|istream,wistream 从流读取数据|ostream, wostream向流写入数据|iostream. wiostream读写流||fstream|ifstream, wifstream从文件读取数据|ofstream, wofstream向文件写入数据|fstream, wfstream读写文件||sstream|istringstream. wistringstream string 读取数据|ostringstream, wostringstream string 写入数据|stringstream, wstringstream string 读写string| 123类型ifsream和istringstream都继承自istream;类型ofsream和ostringstream都继承自ostream;类型fsream和stringstream都继承自iostream; 1、创建使用文件流对象12345ifstream in(ifile);//构造一个ifstream并打开给定文件ofstream out;//构造输出文件流，未关联任何文件in.close();//关闭文件in.open(ifile + &quot;2&quot;);//打开另一个文件 ifstream,ofstream和fstream是实现文件读写操作的类型 案例12345678910111213141516171819202122#include &lt;iostream&gt; #include &lt;fstream&gt;#include &lt;stdlib.h&gt;#include &lt;vector&gt;using namespace std;int main()&#123; char buffer[256]; ifstream in(&quot;input.txt&quot;);//文件不存在会返回错误 if (! in.is_open())&#123; cout &lt;&lt; &quot;Error opening file&quot;&lt;&lt;endl; exit (1); &#125; vector&lt;string&gt; a; while (!in.eof())&#123; in.getline (buffer,100); //cout &lt;&lt; buffer &lt;&lt; endl; a.push_back(buffer); &#125; for(unsigned int i=0;i&lt;a.size();i++) cout&lt;&lt;a[i]&lt;&lt;endl; return 0;&#125; resize(),reserve()resize()，设置大小（size）;reserve()，设置容量（capacity）;size()是分配容器的内存大小，而capacity()只是设置容器容量大小，但并没有真正分配内存。 ifstreamcankao1、文件打开1ifstream infile(fname,ios::in); 定义ifstream的对象infile,打开文件faname,ios::in是读取 打开文件的方式在ios类(所以流式I/O的基类)中定义 IO流的定义 含义 ios::in 为输入(读)而打开文件 ios::out 为输出(写)而打开文件 ios::ate 初始位置：文件尾 ios::app 所有输出附加在文件末尾 ios::trunc 如果文件已存在则先删除该文件 ios::binary 二进制方式 2、关闭文件：1infile.close 3、文本文件的读写 类ofstream, ifstream 和fstream 是分别从ostream, istream 和iostream 中引申而来的。这就是为什么 fstream 的对象可以使用其父类的成员来访问数据。123456789101112131415161718192021222324252627282930313233343536373839写入内容：#include &lt;fiostream.h&gt; int main () &#123; ofstream out(&quot;out.txt&quot;); if (out.is_open()) &#123; out &lt;&lt; &quot;This is a line.\n&quot;; out &lt;&lt; &quot;This is another line.\n&quot;; out.close(); &#125; return 0; &#125; //结果: 在out.txt中写入： This is a line. This is another line读取内容：// reading a text file #include &lt;iostream.h&gt; #include &lt;fstream.h&gt; #include &lt;stdlib.h&gt; int main () &#123; char buffer[256]; ifstream in(&quot;test.txt&quot;); if (! in.is_open()) &#123; cout &lt;&lt; &quot;Error opening file&quot;; exit (1); &#125; while (!in.eof() ) &#123; in.getline (buffer,100); cout &lt;&lt; buffer &lt;&lt; endl; &#125; return 0; &#125; //结果 在屏幕上输出 This is a line. This is another line``` 状态标识符 bad()如果在读写过程中出错，返回 true 。例如：当我们要对一个不是打开为写状态的文件进行写入时，或者我们要写入的设备没有剩余空间的时候。 fail()除了与bad() 同样的情况下会返回 true 以外，加上格式错误时也返回true ，例如当想要读入一个整数，而获得了一个字母的时候。 eof()如果读文件到达文件末尾，返回true。 good()这是最通用的：如果调用以上任何一个函数返回true 的话，此函数返回 false 。123456要想重置以上成员函数所检查的状态标志，你可以使用成员函数clear()，没有参数。### sizeofsizeof 求对象或者类型的大小`sizeof(array)`&lt;br&gt;[cankao](https://blog.csdn.net/tao20dage/article/details/52372604) 特性0：sizeof是运算符，不是函数特性1：sizeof不能求得void类型的长度特性2：sizeof能求得void类型的指针的长度特性3：sizeof能求得静态分配内存的数组的长度!特性4：sizeof不能求得动态分配的内存的大小!特性5：sizeof不能对不完整的数组求长度！特性6：当表达式作为sizeof的操作数时，它返回表达式的计算结果的类型大小，但是它不对表达式求值！12345678910111213141516### new(std::nothrow) 顾名思义，即不抛出异常，当new一个对象失败时，默认设置该对象为NULL，这样可以方便的通过if(p == NULL) 来判断new操作是否成功 建议在c++代码中，凡是涉及到new操作，都采用new(std::nothrow)，然后if(p==NULL)的方式进行判断 ### vector[cankao](https://blog.csdn.net/duan19920101/article/details/50617190/)&lt;br&gt;在c++中，vector是一个十分有用的容器。作用：它能够像容器一样存放各种类型的对象，简单地说，vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。&lt;br&gt;&gt;1、如果你要表示的向量长度较长（需要为向量内部保存很多数），容易导致内存泄漏，而且效率会很低；&lt;br&gt;2、Vector作为函数的参数或者返回值时，需要注意它的写法： double Distance(vector&lt;int&gt;&amp;a, vector&lt;int&gt;&amp;b) 其中的“&amp;”绝对不能少！！！ c++基本操作 1 、基本操作 (1)头文件#include.(2)创建vector对象，vector vec;(3)尾部插入数字：vec.push_back(a);(4)使用下标访问元素，cout&lt;]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++图像处理程序]]></title>
    <url>%2F2018%2F07%2F19%2FC%2B%2B%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[C++图像处理程序 C++开源项目： Boost.GIL：通用图像库CImg ：用于图像处理的小型开源C++工具包CxImage ：用于加载，保存，显示和转换的图像处理和转换库，可以处理的图片格式包括 BMP, JPEG, GIF, PNG, TIFF, MNG, ICO, PCX, TGA, WMF, WBMP, JBG, J2K。FreeImage ：开源库，支持现在多媒体应用所需的通用图片格式和其他格式。GDCM：Grassroots DICOM 库ITK：跨平台的开源图像分析系统Magick++：ImageMagick程序的C++接口MagickWnd：ImageMagick程序的C++接口OpenCV ： 开源计算机视觉类库tesseract-ocr：OCR引擎VIGRA ：用于图像分析通用C++计算机视觉库VTK ：用于3D计算机图形学，图像处理和可视化的开源免费软件系统。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736/*函数名称：MakegGray() *//*函数类型：void *//*功能：真彩色转化成256色灰度图像。 *//***************************************************************/void MakeColorDib::MakegGray() //灰度变化&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 for(int j=0;j&lt;height;j++) // 每行 for(int i=0;i&lt;DibWidth;i+=3) // 每列 &#123; BYTE* pbyBlue = p_data++; //得到蓝色值 BYTE* pbyGreen = p_data++; //得到绿色值 BYTE* pbyRed = p_data++; //得到红色值 BYTE r = *pbyRed; BYTE g = *pbyGreen; BYTE b = *pbyBlue; //取到原r,g,b中的最大值作为像素三分量值的新值 int gray=0; if(r&gt;g) gray=r; else gray=g; if(gray&lt;b) gray=b; *pbyBlue = gray; //将取到的最大值赋给像素的蓝分量 *pbyGreen = gray; //将取到的最大值赋给像素的绿分量 *pbyRed = gray; //将取到的最大值赋给像素的红分量 &#125;&#125; /***************************************************************//*函数名称：LightAlter(int m_Light) *//*函数类型：void *//*参数：int m_Light，用户给定的阈值 *//*功能：对图像使用阈值法进行亮度调整。 *//***************************************************************/void MakeColorDib::LightAlter(int m_Light) //亮度调整&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 for(int j=0;j&lt;height;j++) // 每行 for(int i=0;i&lt;DibWidth;i++) // 每列 &#123; int a=0; a=int(*p_data*m_Light/100); //调整当前点的亮度 *p_data=a; //判断范围，取得合理的值 if(a&lt;0) *p_data=0; if(a&gt;255) *p_data=255; p_data++; //指向下一指针 &#125;&#125; /***************************************************************//*函数名称：LightReverse() *//*函数类型：void *//*功能：图像的亮度取反。 *//***************************************************************/void MakeColorDib::LightReverse() //亮度取反&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 for(int j=0;j&lt;height;j++) // 每行 for(int i=0;i&lt;DibWidth;i++) // 每列 &#123; int a=*p_data; //取得当前点的值 *p_data=255-a; //取反 p_data++; //指向下一指针 &#125;&#125; /***************************************************************//*函数名称：ContrastAlter(int m_Increment) *//*函数类型：void *//*参数：int m_Increment，用户给定的阈值 *//*功能：对图像使用阈值法调整对比度处理。 *//***************************************************************/void MakeColorDib::ContrastAlter(int m_Increment) ///对比度处理&#123; int nHigh = 255 - m_Increment; //对于极端情况加以处理 if(nHigh &lt; m_Increment) &#123; nHigh = 127; m_Increment = 120; &#125; if(m_Increment &lt; -127) m_Increment = -120; //扩展或压缩区间的长度 int nStretch = 255; if(m_Increment &gt;= 0) nStretch = 255 - 2 * m_Increment; else nStretch = 255 + 2 * m_Increment; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 if(m_Increment &gt;= 0) // m_Increment&gt;=0时 &#123; for(int j=0;j&lt;height;j++) // 每行 for(int i=0;i&lt;DibWidth-3;i+=3) // 每列 &#123; //取得当前点（蓝色）的值，调整 BYTE* pbyBlue = p_data++; if(*pbyBlue&lt;=m_Increment) *pbyBlue=0; else if(*pbyBlue&gt;nHigh) *pbyBlue=255; else *pbyBlue=(BYTE)((((int)*pbyBlue - m_Increment) * 255) / nStretch ); //取得当前点（绿色）的值，调整 BYTE* pbyGreen = p_data++; if(*pbyGreen&lt;=m_Increment) *pbyGreen=0; else if(*pbyGreen&gt;nHigh) *pbyGreen=255; else *pbyGreen=(BYTE)((((int)*pbyGreen - m_Increment) * 255) / nStretch ); //取得当前点（红色）的值，调整 BYTE* pbyRed = p_data++; if(*pbyRed&lt;=m_Increment) *pbyRed=0; else if(*pbyRed&gt;nHigh) *pbyRed=255; else *pbyRed=(BYTE)((((int)*pbyRed - m_Increment) * 255) / nStretch ); &#125; &#125; else // m_Increment &lt; 0 时 &#123; for(int j=0;j&lt;height;j++) for(int i=0;i&lt;DibWidth-3;i+=3) &#123; //取得当前点（蓝色）的值，调整 BYTE* pbyBlue = p_data++; *pbyBlue = (BYTE)((((int)(*pbyBlue) * nStretch) / 255) - m_Increment); //取得当前点（红色）的值，调整 BYTE* pbyGreen = p_data++; *pbyGreen = (BYTE)((((int)(*pbyGreen) * nStretch) / 255) - m_Increment); //取得当前点（红色）的值，调整 BYTE* pbyRed = p_data++; *pbyRed = (BYTE)((((int)(*pbyRed) * nStretch) / 255) - m_Increment); &#125; &#125;&#125; /***************************************************************//*函数名称：Exposal() *//*函数类型：void *//*功能：图像曝光处理。 *//***************************************************************/void MakeColorDib::Exposal() //曝光处理&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 for(int j=0;j&lt;height;j++) // 每行 for(int i=0;i&lt;DibWidth;i++) // 每列 &#123; BYTE* pbydata = p_data++; //取得当前点的值 BYTE a=*pbydata; //传给临时变量 *pbydata=(a&gt;128)?a:(255-a); //调整 &#125; &#125; /***************************************************************//*函数名称：PaintColor(int m_Red,int m_Green,int m_Blue) *//*函数类型：void *//*参数：int m_Red、m_Green、m_Blue，用户给定的红绿蓝值 *//*功能：对图像使用阈值法进行着色处理。 *//***************************************************************/void MakeColorDib::PaintColor(int m_Red,int m_Green,int m_Blue) //着色处理&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 for(int j=0;j&lt;height;j++) // 每行 for(int i=0;i&lt;DibWidth;i+=3) // 每列 &#123; BYTE* pbyBlue = p_data++; //取得当前点（蓝色）的值 BYTE* pbyGreen = p_data++; //取得当前点（绿色）的值 BYTE* pbyRed = p_data++; //取得当前点（红色）的值 BYTE r = *pbyRed; BYTE g = *pbyGreen; BYTE b = *pbyBlue; BYTE gray=(BYTE)(((WORD)r * 59 + (WORD)g * 30 + (WORD)b * 11) / 100); *pbyBlue = (BYTE)((m_Blue * gray) / 255); *pbyGreen = (BYTE)((m_Green * gray) / 255); *pbyRed = (BYTE)((m_Red * gray) / 255); &#125;&#125; /***************************************************************//*函数名称：NeonLight() *//*函数类型：void *//*功能：使图像产生霓虹处理效果。 *//***************************************************************/void MakeColorDib::NeonLight() //霓虹处理&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像 for(int j=0;j&lt;height-4;j++) // 每行 &#123; for(int i=0;i&lt;DibWidth-1;i++) // 每列 &#123; int pby_pt=0; //对像素执行算法 pby_pt=(*(p_data+(height-j-1)*DibWidth+i)-*(p_data+(height-j-1)*DibWidth+i+3)) *(*(p_data+(height-j-1)*DibWidth+i)-*(p_data+(height-j-1)*DibWidth+i+3)) +(*(p_data+(height-j-1)*DibWidth+i)-*(p_data+(height-j-2)*DibWidth+i)) *(*(p_data+(height-j-1)*DibWidth+i)-*(p_data+(height-j-2)*DibWidth+i)); *(p_temp+(height-j-1)*DibWidth+i)=2*int(sqrt(pby_pt)); //判断合法性 if(*(p_temp+(height-j-1)*DibWidth+i)&lt;0) *(p_temp+(height-j-1)*DibWidth+i)=0; if(*(p_temp+(height-j-1)*DibWidth+i)&gt;255) *(p_temp+(height-j-1)*DibWidth+i)=255; &#125; &#125; memcpy(p_data,p_temp,height*DibWidth); // 复制处理后的图像 delete []p_temp; //删除暂时分配内存&#125; /***************************************************************//*函数名称：Smoothness() *//*函数类型：void *//*功能：使图像平滑处理。 *//***************************************************************/void MakeColorDib::Smoothness() //平滑处理&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 int h[3][3];////定义(3x3)矩阵 h[0][0] = 1; h[0][1] = 1; h[0][2] = 1; h[1][0] = 1; h[1][1] = 1; h[1][2] = 1; h[2][0] = 1; h[2][1] = 1; h[2][2] = 1; BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像 for(int j=0;j&lt;height-2;j++) // 每行 &#123; for(int i=0;i&lt;DibWidth-8;i++) // 每列 &#123; double pby_pt=0; //对应的第0行的值乘以矩阵对应值，再相加 pby_pt= h[0][0]*(*(p_data+(height-j-1)*DibWidth+i)) +h[0][1]*(*(p_data+(height-j-1)*DibWidth+i+3)) +h[0][2]*(*(p_data+(height-j-1)*DibWidth+i+6)) //对应的第1行的值乘以矩阵对应值，再相加 +h[1][0]*(*(p_data+(height-j-2)*DibWidth+i)) +h[1][1]*(*(p_data+(height-j-2)*DibWidth+i+3)) +h[1][2]*(*(p_data+(height-j-2)*DibWidth+i+6)) //对应的第2行的值乘以矩阵对应值，再相加 +h[2][0]*(*(p_data+(height-j-3)*DibWidth+i)) +h[2][1]*(*(p_data+(height-j-3)*DibWidth+i+3)) +h[2][2]*(*(p_data+(height-j-3)*DibWidth+i+6)); *(p_temp+(height-j-2)*DibWidth+i+3)=abs(int(pby_pt/9));//取总和的的平均值 &#125; &#125; memcpy(p_data,p_temp,height*DibWidth); // 复制处理后的图像 delete []p_temp;//删除暂时分配内存&#125; /***************************************************************//*函数名称：Embossment() *//*函数类型：void *//*功能：产生图像浮雕处理效果。 *//***************************************************************/void MakeColorDib::Embossment() //浮雕处理&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像 for(int j=0;j&lt;height;j++) // 每行 &#123; for(int i=0;i&lt;DibWidth-4;i++) // 每列 &#123; int pby_pt=0; //对像素得每个分量执行算法 pby_pt=*(p_data+(height-j-1)*DibWidth+i) -*(p_data+(height-j-1)*DibWidth+i+3)+128; *(p_temp+(height-j-1)*DibWidth+i+3)=pby_pt; //检验合法性 if(*(p_temp+(height-j-1)*DibWidth+i+3)&lt;0) *(p_temp+(height-j-1)*DibWidth+i+3)=0; else if(*(p_temp+(height-j-1)*DibWidth+i+3)&gt;255) *(p_temp+(height-j-1)*DibWidth+i+3)=255; &#125; &#125; memcpy(p_data,p_temp,height*DibWidth); // 复制处理后的图像 delete []p_temp; //删除暂时分配内存&#125; /***************************************************************//*函数名称：Spread() *//*函数类型：void *//*功能：图像扩散处理。 *//***************************************************************/void MakeColorDib::Spread() //扩散处理&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像 for(int j=0;j&lt;height-4;j++) // 每行 &#123; for(int i=0;i&lt;DibWidth-14;i++) // 每列 &#123; int m=0,n=0; m=rand()%5; //取得行随机数 n=rand()%5; //取得列随机数 int pby_pt=0; pby_pt=*(p_data+(height-j-1-m)*DibWidth+i+3*n);//得到对应随机像素值 *(p_temp+(height-j-3)*DibWidth+i+6)=pby_pt; &#125; &#125; memcpy(p_data,p_temp,height*DibWidth); // 复制处理后的图像 delete []p_temp; //删除暂时分配内存&#125; /***************************************************************//*函数名称：Sharp() *//*函数类型：void *//*功能：图像锐化处理。 *//***************************************************************/void MakeColorDib::Sharp() //图像锐化&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 BYTE *p_temp=new BYTE[height*DibWidth]; for(int j=0;j&lt;height-1;j++) // 每行 &#123; for(int i=0;i&lt;DibWidth-5;i++) // 每列 &#123; int pby_pt=0; pby_pt= *(p_data+(height-j-2)*DibWidth+i+3) -*(p_data+(height-j-1)*DibWidth+i); *(p_temp+(height-j-2)*DibWidth+i+3)=*(p_data+(height-j-2)*DibWidth+i+3) +abs(int(pby_pt/4)); if(*(p_temp+(height-j-2)*DibWidth+i+3)&gt;255) *(p_temp+(height-j-2)*DibWidth+i+3)=255; &#125; &#125; memcpy(p_data,p_temp,height*DibWidth); // 复制处理后的图像 delete []p_temp; //删除暂时分配内存&#125; /***************************************************************//*函数名称：HighLVBO(int m_GaoTong) *//*函数类型：void *//*参数：int m_GaoTong，用户给定的阈值来选择矩阵 *//*功能：对图像使用阈值法进行高通滤波。 *//***************************************************************/void MakeColorDib::HighLVBO(int m_GaoTong) //高通滤波&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 int h[3][3]; ////定义(3x3)矩阵 if(m_GaoTong==1) &#123; //矩阵1（基本高通） h[0][0] =1; h[0][1] =-2; h[0][2] =1; h[1][0] =-2; h[1][1] =5; h[1][2] =-2; h[2][0] =1; h[2][1] =-2; h[2][2] =1; &#125; else if(m_GaoTong==2) &#123; //矩阵2（中等高通） h[0][0] = 0; h[0][1] = -1; h[0][2] = 0; h[1][0] = -1; h[1][1] = 5; h[1][2] = -1; h[2][0] = 0; h[2][1] = -1; h[2][2] = 0; &#125; else &#123; //矩阵3（过量高通） h[0][0] = -1; h[0][1] = -1; h[0][2] = -1; h[1][0] = -1; h[1][1] = 9; h[1][2] = -1; h[2][0] = -1; h[2][1] = -1; h[2][2] = -1; &#125; BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像 for(int j=0;j&lt;height-2;j++) // 每行 &#123; for(int i=0;i&lt;DibWidth-8;i++) // 每列 &#123; int pby_pt=0; //对应的第0行的值乘以矩阵对应值，再相加 pby_pt= h[0][0]*(*(p_data+(height-j-1)*DibWidth+i)) +h[0][1]*(*(p_data+(height-j-1)*DibWidth+i+3)) +h[0][2]*(*(p_data+(height-j-1)*DibWidth+i+6)) //对应的第1行的值乘以矩阵对应值，再相加 +h[1][0]*(*(p_data+(height-j-2)*DibWidth+i)) +h[1][1]*(*(p_data+(height-j-2)*DibWidth+i+3)) +h[1][2]*(*(p_data+(height-j-2)*DibWidth+i+6)) //对应的第2行的值乘以矩阵对应值，再相加 +h[2][0]*(*(p_data+(height-j-3)*DibWidth+i)) +h[2][1]*(*(p_data+(height-j-3)*DibWidth+i+3)) +h[2][2]*(*(p_data+(height-j-3)*DibWidth+i+6)); *(p_temp+(height-j-2)*DibWidth+i+3)=abs(pby_pt); if(pby_pt&gt;255) //判断是否越界 *(p_temp+(height-j-2)*DibWidth+i+3)=255; &#125; &#125; memcpy(p_data,p_temp,height*DibWidth); // 复制处理后的图像 delete []p_temp; //删除暂时分配内存&#125; /***************************************************************//*函数名称：LowLVBO() *//*函数类型：void *//*功能：实现图像低通滤波(3x3)。 *//***************************************************************/void MakeColorDib::LowLVBO() //低通滤波(3x3)&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 double h[3][3];////定义(3x3)矩阵 h[0][0] = 0.1; h[0][1] = 0.1; h[0][2] = 0.1; h[1][0] = 0.1; h[1][1] = 0.2; h[1][2] = 0.1; h[2][0] = 0.1; h[2][1] = 0.1; h[2][2] = 0.1; BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像 for(int j=0;j&lt;height-2;j++) // 每行 &#123; for(int i=0;i&lt;DibWidth-8;i++) // 每列 &#123; double pby_pt=0; //对应的第0行的值乘以矩阵对应值，再相加 pby_pt= h[0][0]*(*(p_data+(height-j-1)*DibWidth+i)) +h[0][1]*(*(p_data+(height-j-1)*DibWidth+i+3)) +h[0][2]*(*(p_data+(height-j-1)*DibWidth+i+6)) //对应的第0行的值乘以矩阵对应值，再相加 +h[1][0]*(*(p_data+(height-j-2)*DibWidth+i)) +h[1][1]*(*(p_data+(height-j-2)*DibWidth+i+3)) +h[1][2]*(*(p_data+(height-j-2)*DibWidth+i+6)) //对应的第0行的值乘以矩阵对应值，再相加 +h[2][0]*(*(p_data+(height-j-3)*DibWidth+i)) +h[2][1]*(*(p_data+(height-j-3)*DibWidth+i+3)) +h[2][2]*(*(p_data+(height-j-3)*DibWidth+i+6)); *(p_temp+(height-j-2)*DibWidth+i+3)=abs(int(pby_pt)); &#125; &#125; memcpy(p_data,p_temp,height*DibWidth); // 复制处理后的图像 delete []p_temp; //删除暂时分配内存&#125; /***************************************************************/ 函数名称：LowVBObig() 函数类型：void 功能：实现函数低通滤波(5*5)/***************************************************************/void MakeColorDib::LowLVBObig() //低通滤波(5x5)&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 int h[5][5];//定义(5x5)矩阵 h[0][0] = 1; h[0][1] = 1; h[0][2] = 1; h[0][3] = 1; h[0][4] = 1; h[1][0] = 1; h[1][1] = 2; h[1][2] = 2; h[1][3] = 2; h[1][4] = 1; h[2][0] = 1; h[2][1] = 2; h[2][2] = 3; h[2][3] = 2; h[2][4] = 1; h[3][0] = 1; h[3][1] = 2; h[3][2] = 2; h[3][3] = 2; h[3][4] = 1; h[4][0] = 1; h[4][1] = 1; h[4][2] = 1; h[4][3] = 1; h[4][4] = 1; BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像 for(int j=0;j&lt;height-4;j++) // 每行 &#123; for(int i=0;i&lt;DibWidth-14;i++) // 每列 &#123; int pby_pt=0; //对应的第0行的值乘以矩阵对应值，再相加 pby_pt=h[0][0]*(*(p_data+(height-j-1)*DibWidth+i)) +h[0][1]*(*(p_data+(height-j-1)*DibWidth+i+3)) +h[0][2]*(*(p_data+(height-j-1)*DibWidth+i+6)) +h[0][3]*(*(p_data+(height-j-1)*DibWidth+i+9)) +h[0][4]*(*(p_data+(height-j-1)*DibWidth+i+12)) //对应的第1行的值乘以矩阵对应值，再相加 +h[1][0]*(*(p_data+(height-j-2)*DibWidth+i)) +h[1][1]*(*(p_data+(height-j-2)*DibWidth+i+3)) +h[1][2]*(*(p_data+(height-j-2)*DibWidth+i+6)) +h[1][3]*(*(p_data+(height-j-2)*DibWidth+i+9)) +h[1][4]*(*(p_data+(height-j-2)*DibWidth+i+12)) //对应的第2行的值乘以矩阵对应值，再相加 +h[2][0]*(*(p_data+(height-j-3)*DibWidth+i)) +h[2][1]*(*(p_data+(height-j-3)*DibWidth+i+3)) +h[2][2]*(*(p_data+(height-j-3)*DibWidth+i+6)) +h[2][3]*(*(p_data+(height-j-3)*DibWidth+i+9)) +h[2][4]*(*(p_data+(height-j-3)*DibWidth+i+12)) //对应的第3行的值乘以矩阵对应值，再相加 +h[3][0]*(*(p_data+(height-j-4)*DibWidth+i)) +h[3][1]*(*(p_data+(height-j-4)*DibWidth+i+3)) +h[3][2]*(*(p_data+(height-j-4)*DibWidth+i+6)) +h[3][3]*(*(p_data+(height-j-4)*DibWidth+i+9)) +h[3][4]*(*(p_data+(height-j-4)*DibWidth+i+12)) //对应的第4行的值乘以矩阵对应值，再相加 +h[4][0]*(*(p_data+(height-j-5)*DibWidth+i)) +h[4][1]*(*(p_data+(height-j-5)*DibWidth+i+3)) +h[4][2]*(*(p_data+(height-j-5)*DibWidth+i+6)) +h[4][3]*(*(p_data+(height-j-5)*DibWidth+i+9)) +h[4][4]*(*(p_data+(height-j-5)*DibWidth+i+12)); //为了计算方便我们把除以35（矩阵权和）放在求总和之后 *(p_temp+(height-j-3)*DibWidth+i+6)=abs(int(pby_pt/35)); &#125; &#125; memcpy(p_data,p_temp,height*DibWidth); // 复制处理后的图像 delete []p_temp; //删除暂时分配内存&#125; /***************************************************************//*函数名称：ShuiPingGROW() *//*函数类型：void *//*功能：使图像水平增强。 *//***************************************************************/void MakeColorDib::ShuiPingGROW() //水平增强&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 int h[3][1];//定义(3x1)矩阵 h[0][0] = -1; h[1][0] = 2; h[2][0] = -1; BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像 for(int j=0;j&lt;height-2;j++) // 每行 &#123; for(int i=0;i&lt;DibWidth-8;i++) // 每列 &#123; int pby_pt=0; //对应的3行的值乘分别以矩阵对应值，再相加 pby_pt= h[0][0]*(*(p_data+(height-j-1)*DibWidth+i)) +h[1][0]*(*(p_data+(height-j-2)*DibWidth+i)) +h[2][0]*(*(p_data+(height-j-3)*DibWidth+i)); if(pby_pt&gt;20) *(p_temp+(height-j-2)*DibWidth+i)=abs(pby_pt)+100; else *(p_temp+(height-j-2)*DibWidth+i)=abs(pby_pt); &#125; &#125; memcpy(p_data,p_temp,height*DibWidth); // 复制处理后的图像 delete []p_temp; //删除暂时分配内存&#125; /***************************************************************//*函数名称：ChuiZhiGROW() *//*函数类型：void *//*功能：使图像垂直增强。 *//***************************************************************/void MakeColorDib::ChuiZhiGROW() //垂直增强&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 int h[1][3];//定义(1x3)矩阵 h[0][0] = -1; h[0][1] = 2; h[0][2] = -1; BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像 for(int j=0;j&lt;height-2;j++) // 每行 &#123; for(int i=0;i&lt;DibWidth-8;i++) // 每列 &#123; int pby_pt=0; //对应的第0行的值乘以矩阵对应值，再相加 pby_pt= h[0][0]*(*(p_data+(height-j-1)*DibWidth+i)) +h[0][1]*(*(p_data+(height-j-1)*DibWidth+i+3)) +h[0][2]*(*(p_data+(height-j-1)*DibWidth+i+6)); if(pby_pt&gt;20) *(p_temp+(height-j-2)*DibWidth+i)=abs(pby_pt)+100; else *(p_temp+(height-j-2)*DibWidth+i)=abs(pby_pt); &#125; &#125; memcpy(p_data,p_temp,height*DibWidth); // 复制处理后的图像 delete []p_temp; //删除暂时分配内存&#125; /***************************************************************//*函数名称：ShuangXiangGROW() *//*函数类型：void *//*功能：使图像双向增强。 *//***************************************************************/void MakeColorDib::ShuangXiangGROW() //双向增强&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 int h[3][3];//定义(3x3)矩阵 h[0][0] = -1; h[0][1] = -1; h[0][2] = -1; h[1][0] = -1; h[1][1] = 8; h[1][2] = -1; h[2][0] = -1; h[2][1] = -1; h[2][2] = -1; BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像 for(int j=0;j&lt;height-2;j++) // 每行 &#123; for(int i=0;i&lt;DibWidth-8;i++) // 每列 &#123; int pby_pt=0; //对应的第0行的值乘以矩阵对应值，再相加 pby_pt= h[0][0]*(*(p_data+(height-j-1)*DibWidth+i)) +h[0][1]*(*(p_data+(height-j-1)*DibWidth+i+3)) +h[0][2]*(*(p_data+(height-j-1)*DibWidth+i+6)) //对应的第1行的值乘以矩阵对应值，再相加 +h[1][0]*(*(p_data+(height-j-2)*DibWidth+i)) +h[1][1]*(*(p_data+(height-j-2)*DibWidth+i+3)) +h[1][2]*(*(p_data+(height-j-2)*DibWidth+i+6)) //对应的第2行的值乘以矩阵对应值，再相加 +h[2][0]*(*(p_data+(height-j-3)*DibWidth+i)) +h[2][1]*(*(p_data+(height-j-3)*DibWidth+i+3)) +h[2][2]*(*(p_data+(height-j-3)*DibWidth+i+6)); if(pby_pt&gt;20) *(p_temp+(height-j-2)*DibWidth+i)=abs(pby_pt)+100; else *(p_temp+(height-j-2)*DibWidth+i)=abs(pby_pt); &#125; &#125; memcpy(p_data,p_temp,height*DibWidth); // 复制处理后的图像 delete []p_temp; //删除暂时分配内存&#125; /***************************************************************//*函数名称：Mosaic() *//*函数类型：void *//*功能：使图像产生马赛克效果。 *//***************************************************************/void MakeColorDib::Mosaic() //马赛克&#123; BYTE *p_data; //原图数据区指针 int wide,height,DibWidth; //原图长、宽、字节宽 p_data=this-&gt;GetData (); //取得原图的数据区指针 wide=this-&gt;GetWidth (); //取得原图的数据区宽度 height=this-&gt;GetHeight (); //取得原图的数据区高度 DibWidth=this-&gt;GetDibWidthBytes(); //取得原图的每行字节数 BYTE *p_temp=new BYTE[height*DibWidth]; // 暂时分配内存，以保存新图像 for(int j=0;j&lt;height-4;j+=5) // 每行 &#123; for(int i=0;i&lt;DibWidth-14;i+=15) // 每列 &#123; //对应周围(5x5)矩阵蓝色值求和平均 int pby_pt=0; for(int m=0;m&lt;5;m++) for(int n=0;n&lt;15;n+=3) &#123; pby_pt+=*(p_data+(height-j-1-m)*DibWidth+i+n); &#125; for(m=0;m&lt;5;m++) for(int n=0;n&lt;14;n+=3) &#123; *(p_temp+(height-j-1-m)*DibWidth+i+n)=int(pby_pt/25); &#125; //对应周围(5x5)矩阵绿色值求和平均 pby_pt=0; for(m=0;m&lt;5;m++) for(int n=0;n&lt;15;n+=3) &#123; pby_pt+=*(p_data+(height-j-1-m)*DibWidth+i+n+1); &#125; for(m=0;m&lt;5;m++) for(int n=0;n&lt;14;n+=3) &#123; *(p_temp+(height-j-1-m)*DibWidth+i+n+1)=int(pby_pt/25); &#125; //对应周围(5x5)矩阵红色值求和平均 pby_pt=0; for(m=0;m&lt;5;m++) for(int n=0;n&lt;15;n+=3) &#123; pby_pt+=*(p_data+(height-j-1-m)*DibWidth+i+n+2); &#125; for(m=0;m&lt;5;m++) for(int n=0;n&lt;14;n+=3) &#123; *(p_temp+(height-j-1-m)*DibWidth+i+n+2)=int(pby_pt/25); &#125; &#125; &#125; memcpy(p_data,p_temp,height*DibWidth); // 复制处理后的图像 delete []p_temp; //删除暂时分配内存&#125;]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习_分类_决策树]]></title>
    <url>%2F2018%2F07%2F18%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_%E5%86%B3%E7%AD%96%E6%A0%91%2F</url>
    <content type="text"><![CDATA[机器学习分类决策树 决策树算法是借助于树的分支结构实现分类。 叶子节点：存放决策结果非叶子节点：特征属性，及其对应输出，按照输出选择分支决策过程：从根节点出发，根据数据的各个属性，计算结果，选择对应的输出分支，直到到达叶子节点，得到结果 决策树使用自顶向下递归分治法，并采用不回溯的贪心策略。分裂属性的选择算法很多，这里介绍3种常用的算法：信息增益（Information gain）、增益比率（gain ratio）、基尼指数（Gini index）。 我们通过基尼不纯度或者熵来对一个集合进行的有序程度进行量化，然后引入信息增益概念对一次拆分进行量化评价 基尼不纯度基尼不纯度是指将来自集合中的某种结果随机应用于集合中某一数据项的预期误差率。该值越高，说明拆分的越不理想，如果该值为 0，说明完美拆分。 Gini(D)=1−∑_i=(1^m)p_i^2熵用来表示集合的无序程度，熵越大表示集合越混乱 E = -P * log2P 基尼不纯度与熵对比两者主要区别在于，熵到达峰值的过程相对慢一些。因此熵对混乱集合的「判罚」往往更重一些。通常情况下，熵的使用更加频繁。 信息增益（Information Gain）基于香浓的信息论，信息熵表示不确定度，均匀分布时，不确定度最大，此时熵就最大。当选择某个特征对数据集进行分类时，数据集分类后的信息熵会比分类前的小，其差值即为信息增益。信息增益可以衡量某个特征对分类结果的影响大小，越大越好。 信息增益=abs(信息熵（分类后）-信息熵（分类前）) Gain(R)=Info(D)−InfoR(D) 决策树降剪枝 为什么要剪枝训练出得决策树存在过度拟合现象——决策树过于针对训练的数据，专门针对训练集创建出来的分支，其熵值可能会比真实情况有所降低。 如何剪枝人工设置一个信息增益的阀值，自下而上遍历决策树，将信息增益低于该阀值的拆分进行合并 处理缺失数据 决策树模型还有一个很大的优势，就是可以容忍缺失数据。如果决策树中某个条件缺失，可以按一定的权重分配继续往以后的分支走，最终的结果可能有多个，每个结果又一定的概率，即：1最终结果=某个分支的结果 x 该分支的权重(该分支下的结果数/总结果数) 生成算法：ID3和C4.5。1、ID3算法ID3算法可用于划分标称型数据集，没有剪枝的过程，为了去除过度数据匹配的问题，可通过裁剪合并相邻的无法产生大量信息增益的叶子节点（例如设置信息增益阀值）。考虑某个特征后，信息熵减小的多，这个特征就是好的特征(在每层分裂时，选择使得Gain(R)最大的属性作为分裂属性)ID3算法中根据信息增益评估和选择特征，每次选择信息增益最大的特征作为判断模块建立子结点 缺点：1、此公式偏向数据量多的属性，如果样本分布不均，则会导致过拟合。2、不能处理连续分布的数据特征 2、C4.5算法C4.5算法用信息增益率来选择属性，继承了ID3算法的优点优点： 1、克服了用信息增益选择属性时偏向选择取值多的属性的不足；2、在树构造过程中进行剪枝；3、能够完成对连续属性的离散化处理；4、能够对不完整数据进行处理。1C4.5算法产生的分类规则易于理解、准确率较高；但效率低，因树构造过程中，需要对数据集进行多次的顺序扫描和排序C4.5算法在结构与递归上与ID3完全相同，区别只在于选取决决策特征时的决策依据不同，二者都有贪心性质：即通过局部最优构造全局最优 svm:123456789101112131415161718192021222324252627282930313233343536模型在真实世界中也应用场景 支撑向量机用于文本和超文本的分类；用于图像分类；用于手写体识别；这个模型的优势是什么？分类效果好；可以有效地处理高维空间的数据；可以有效地处理变量个数大于样本个数的数据；只是使用了一部分子集来进行训练模型，所以SVM模型不需要太大的内存；可以提高泛化能力；无局部极小值问题；他什么情况下表现最好？数据的维度较高；需要模型具有非常强的泛化能力；样本数据量较小时；解决非线性问题；这个模型的缺点是什么？无法处理大规模的数据集，因为该算法需要较长的训练时间；无法有效地处理包含噪声太多的数据集；SVM模型没有直接给出概率的估计值，而是利用交叉验证的方式估计，这种方式耗时较长；对缺失数据非常敏感；对于非线性问题，有时很难找到一个合适的核函数。什么条件下它表现很差？数据集的数据量过大；数据集中的含有噪声；数据集中的缺失较多的数据；对算法的训练效率要求较高；根据我们当前数据集的特点，为什么这个模型适合这个问题。 该项目所提供的样本数据相对较少；该问题是属于非线性问题；数据集经过“独热编码”后，维度较高 决策树：1234567891011121314151617181920212223242526272829303132这个模型的优势是什么？决策树易于实现和理解；对于决策树，数据的准备工作一般比较简单；能够同时处理多种数据类型给定一个决策树模型，可以根据产生的决策树推出相应的逻辑表达式；通过静态测试来对模型的表现进行评价；在相对较短的时间内可以对大量的数据做出非常好的结果；决策树可以很好地扩展到大型数据中，同时决策树的大小独立于数据库的大小；计算复杂度相对较低，结果的输出易于理解，对部分的数据缺失不敏感。他什么情况下表现最好？实例是由“属性-值”对表示的；目标函数具有离散的输出值；训练数据集包含部分错误(决策树对错误有适应性)；训练数据缺少少量属性的实例。这个模型的缺点是什么？易于出现过拟合问题；忽略了数据集中属性之间的相关性；对于类比不一致的样本，决策树的信息增益倾向于那些数据值较多的特征什么条件下它表现很差？决策树匹配的数据过多时；分类的类别过于复杂；数据的属性之间具有非常强的关联。根据我们当前数据集的特点，为什么这个模型适合这个问题。不需要准备太多的训练数据，不需要对数据过多的处理如删除空白值等；易于编码；该问题是非线性问题，决策树能够很好地解决非线性问题；算法的执行效率高，对机器的要求较小。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理_图像滤波]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2%2F</url>
    <content type="text"><![CDATA[图像滤波 噪声加性噪声一般指热噪声、散弹噪声等，它们与信号的关系是相加，不管有没有信号，噪声都存在。 高斯白噪声包括热噪声和散粒噪声。在通信信道测试和建模中，高斯噪声被用作加性白噪声以产生加性白高斯噪声。 加性高斯白噪声只是白噪声的一种，另有泊松白噪声等,加性高斯白噪声在通信领域中指的是一种各频谱分量服从均匀分布（即白噪声），且幅度服从高斯分布的噪声信号。因其可加性、幅度服从高斯分布且为白噪声的一种而得名。 而乘性噪声一般由信道不理想引起，它们与信号的关系是相乘，信号在它在，信号不在他也就不在。 一般通信中把加性随机性看成是系统的背景噪声； 而乘性随机性看成系统的时变性（如衰落或者多普勒）或者非线性所造成的。 空域滤波空域滤波可以用于非线性滤波，但是频域滤波不能用于非线性滤波 图像滤波 空域 线性滤波 均值滤波 - - - 非线性滤波 中值滤波 双边滤波 滤波模板图像滤波 模板：12345线性平均滤波：1|0 1 0 |-|1 1 1 |5|0 1 0 | 图像锐化 模板：123456789锐化滤波：图像锐化一般是通过微分运算来实现的|-1 0 1||-1 0 1||-1 0 1|| 1 1 1|| 0 0 0||-1 -1 -1| 方向滤波器-sobel算子123456789x轴：|-1 0 1||-2 0 2||-1 0 1|y轴：|-1 -2 -1|| 0 0 0|| 1 2 1| Scharr算子123456789x轴：|-3 0 3||-10 0 10||-3 0 3|y轴：|-3 -10 -3|| 0 0 0|| 3 10 3| 线性空域滤波线性空域滤波指的是像素的输出值是计算该像素邻域内像素值的线性组合线性滤波中滤波模板也称为卷积模板 模板卷积模板卷积的主要步骤包括如下几个步骤， 1) 将模板在图像中进行遍历，将模板中心和各个像素位置重合； 2) 将模板的各个系数与模板对应像素值进行相乘； 3) 将所有的乘积相加，并将求和结果赋值于模板中心对应的像素 延拓模板的行或列就会超出图像之外，因此常常采用延拓的方式解决外边界问题。常用的方法有四种，分别是补零、重复、对称和循环方式。1234补零是指通过补零来扩展图像；重复是指通过复制外边界的值来扩展图像；对称是指通过镜像反射外边界的值来扩展图像；循环是指将图像看成二维周期函数的一个周期来扩展。 均值滤波高斯滤波高斯滤波器宽度(决定着平滑程度)是由参数σ表征的，而且σ和平滑程度的关系是非常简单的．σ越大，高斯滤波器的频带就越宽，平滑程度就越好．通过调节平滑程度参数σ 高斯分布：$h(x,y)=e^-(\frac{x^2+y^2}{2a^2})$ 双边滤波一种非线性的滤波方法，是结合图像的空间邻近度和像素相似度的的一种折中处理。它是一种保持边缘的非迭代平滑滤波方法。中心像素的距离和灰度差值的增大，邻域像素的权系数逐渐减小 优点：保持边缘性能良好，对低频信息滤波良好缺点：不能处理高频信息 假设高斯函数表达式如下： W_ij=\frac{1}{K_i}e^-\frac{(x_j-x_i)^2}{σ^2_G}K是归一化的常量，W是权重，权重只跟像素之间的空间距离有关系。 双边滤波器: W_ij=\frac{1}{K_i}e^-\frac{(x_j-x_i)^2}{σ^2_G}e^-\frac{(I_j-I_i)^2}{σ^2_r}中值滤波中值滤波是统计排序滤波的一种，中值滤波对椒盐噪声效果好；滤波图像边缘信息好，边缘清晰|统计排序滤波||||-|-|-||最大值滤波|有效地滤除椒噪声(黑色)|寻找最亮点，亮化图片||最小值滤波|有效地滤除盐噪声(白色)|寻找最暗点，暗化图片||自适应中值滤波|有效地滤除椒盐噪声|钝化图像、去除噪音| 操作步骤： 1) 将模板在图像中遍历 2) 将模板对应的邻域内像素的灰度值排序 3) 查找中间值，将其赋于模板中心对应的像素 频域滤波可以用图像增强，首先把图像通过傅里叶变换将图像从空间域转换到频率域，频域处理，反傅里叶变换转到空间域 C++代码均值滤波123456789101112131415void meanFilter (unsigned char* corrupted, unsigned char* smooth, int width, int height) &#123; memcpy ( smooth, corrupted, width*height*sizeof(unsigned char) ); for (int j=1;j&lt;height-1;j++) &#123; for (int i=1;i&lt;width-1;i++) &#123; smooth [ j*width+i ] = ( corrupted [ (j-1)*width+(i-1) ] + corrupted [ (j-1)*width+i] + corrupted [ (j-1)*width+(i+1) ] + corrupted [ j*width+(i-1) ] + corrupted [ j*width+i] + corrupted [ j*width+(i+1) ] + corrupted [ (j+1)*width+(i-1) ] + corrupted [ (j+1)*width+i] + corrupted [ (j+1)*width+(i+1) ] ) / 9; &#125; &#125; &#125; 中值滤波1234567891011121314151617181920212223242526272829void medianFilter (unsigned char* corrupted, unsigned char* smooth, int width, int height) &#123; memcpy ( smooth, corrupted, width*height*sizeof(unsigned char) ); for (int j=1;j&lt;height-1;j++) &#123; for (int i=1;i&lt;width-1;i++) &#123; int k = 0; unsigned char window[9]; for (int jj = j - 1; jj &lt; j + 2; ++jj) for (int ii = i - 1; ii &lt; i + 2; ++ii) window[k++] = corrupted[jj * width + ii]; // Order elements (only half of them) for (int m = 0; m &lt; 5; ++m) &#123; int min = m; for (int n = m + 1; n &lt; 9; ++n) if (window[n] &lt; window[min]) min = n; // Put found minimum element in its place unsigned char temp = window[m]; window[m] = window[min]; window[min] = temp; &#125; smooth[ j*width+i ] = window[4]; &#125; &#125; &#125;]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理_边缘检测]]></title>
    <url>%2F2018%2F07%2F16%2F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[图像处理_边缘检测 边缘检测：https://blog.csdn.net/tigerda/article/details/61192943 常见边缘检测算子：Roberts 、Sobel 、Prewitt、Laplacian、Log/Marr、Canny、Kirsch、Nevitia&lt;/br&gt; 一阶微分算子：Roberts 、Sobel 、Prewitt&lt;/br&gt;1234567891011121314151617181920模板：Roberts |1, 0||0,-1|sobel算子|1, 0 , 1||1, 0 , 1||1, 0 , 1|prewitt算子|1, 0 , 1||1, 0 , 1||1, 0 , 1|Sobel各向同性算子: |-1 ,0, 1| |-1,-跟2,-1|Gx=|-跟2,0,跟2| ,Gx=| 0, 0, 0| |-1 ,0, 1| | 1, 跟2, 1| Sobel各向同性算子的权值比普通Sobel算子的权值更准确。为什么？模板的权值是离中心位置越远则权值（看绝对值）影响越小123456789101112计算边缘幅值与方向？以Sobel算子为例。3*3Sobel两个方向的算子在图像上滑动，模板与其覆盖的图像3*3区域9个像素进行卷积，求和后得到此方向的边缘检测幅值。 |-1,0,1| |-1,-2,-1|Gx=|-2,0,2|*f(x,y) ,Gx=| 0, 0, 0|*f(x,y) |-1,0,1| | 1, 2, 1|G^2=Gx^2+Gy^2P=arctan(Gx/Gy)f(x,y)为图像，Gx和Gy分别是水平和竖直方向算子的卷积结果，G则是最终得到的边缘幅值，θ值则是边缘方向。当然G的计算有时简化为G=|Gx|+|Gy| 或者 G=max(|Gx|,|Gy|) 二阶微分算子：Laplacian、Log/Marr123456789101112131415Laplacian算子 |-1,-1,-1| Gx=|-1, 8,-1| |-1,-1,-1| | 0,-1, 0| Gx=|-1, 4,-1| | 0,-1, 0| |-2,-4,-4,-4,-2| |-4, 0, 8, 0,-4| Gx=|-4, 8,24, 8,-4| |-4, 0, 8, 0,-4| |-2,-4,-4,-4,-2|Log边缘检测则是先进行高斯滤波再进行拉普拉斯算子检测 非微分边缘检测算子：Canny 算 子 优缺点比较 Roberts 对具有陡峭的低噪声的图像处理效果较好，但利用 Roberts算子提取边缘的结果是边缘比较粗，因此边缘定位不是很准确。 Sobel 对灰度渐变和噪声较多的图像处理效果比较好， Sobel算子对边缘定位比较准确。 Kirsch 对灰度渐变和噪声较多的图像处理效果较好。 Prewitt 对灰度渐变和噪声较多的图像处理效果较好。 aplacian 对图像中的阶跃性边缘点定位准确，对噪声非常敏感，丢失一部分边缘的方向信息，造成一些不连续的检测边缘。 LoG 算 子 经 常 出 现 双 边 缘 像 素 边 界 ， 而 且 该 检 测 方 法 对 噪 声 比铰 敏 感 ， 所 以 很 少 用 LoG算 子 检 测 边 缘 ， 而 是 用 来 判 断 边 缘 像素是位于图像的明区还是暗区。 Canny 此方法不容易受噪声的干扰，能够检测到真正的弱边缘。在edge函数中，最有效的边缘检测方法是 Canny方法。该方法的优点在于使用两种不同的阈值分别检测强边缘和弱边缘，并且汉当弱边缘与强边缘相连时，才将弱边缘包含在输出图像中。因此，这种方法不容易被噪声“填充”，跟容易检测出真正的弱边缘。]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[特征提取——局部特征]]></title>
    <url>%2F2018%2F07%2F16%2F%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E5%B1%80%E9%83%A8%E7%89%B9%E5%BE%81%2F</url>
    <content type="text"><![CDATA[特征提取——局部特征 LOG,HOG,DOG微分算子在近圆的斑点检测方面效果很好 HOG特征https://blog.csdn.net/coming_is_winter/article/details/72850511https://blog.csdn.net/zouxy09/article/details/7929348/123456总结：Dalal提出的Hog特征提取的过程：把样本图像分割为若干个像素的单元（cell），把梯度方向平均划分为9个区间（bin），在每个单元里面对所有像素的梯度方向在各个方向区间进行直方图统计，得到一个9维的特征向量，每相邻的4个单元构成一个块（block），把一个块内的特征向量联起来得到36维的特征向量，用块对样本图像进行扫描，扫描步长为一个单元。最后将所有块的特征串联起来，就得到了人体的特征。例如，对于64*128的图像而言，每16*16的像素组成一个cell，每2*2个cell组成一个块，因为每个cell有9个特征，所以每个块内有4*9=36个特征，以8个像素为步长，那么，水平方向将有7个扫描窗口，垂直方向将有15个扫描窗口。也就是说，64*128的图片，总共有36*7*15=3780个特征。特征总数： 一个cell有9个特征（9个梯度方向），每个特征cell块里有 num*9个特征，步长像素规格：（列像素数-步长）/步长*（行像素数-步长）/步长，总特征数:（列像素数-步长）/步长*（行像素数-步长）/步长*num*9 LOG特征1图像与某一个二维函数进行卷积运算实际就是求取图像与这一函数的相似性。同理，图像与高斯拉普拉斯函数的卷积实际就是求取图像与高斯拉普拉斯函数的相似性。当图像中的斑点尺寸与高斯拉普拉斯函数的形状趋近一致时，图像的拉普拉斯响应达到最大。 Laplace可以用来检测图像中的局部极值点，但是对噪声敏感，所以在我们对图像进行Laplace卷积之前，我们用一个高斯低通滤波对图像进行卷积，目标是去除图像中的噪声点123456789101112先对图像f(x,y)用方差为σ的高斯核进行高斯滤波，去除图像中的噪点。L(x,y;σ)=f(x,y)∗G(x,y;σ)G(x,y;σ)高斯核然后对图像的拉普拉斯图像则为：∇^2=(∂^2L/∂^x2)+(∂^2L/∂y^2)而实际上有下面等式：∇^2[G(x,y)∗f(x,y)]=∇^2[G(x,y)]∗f(x,y)我们可以先求高斯核的拉普拉斯算子，再对图像进行卷积 使用LoG虽然能较好的检测到图像中的特征点，但是其运算量过大，通常可使用DoG（差分高斯，Difference of Gaussina）来近似计算LoG Haar特征Haar特征分为三类：边缘特征、线性特征、中心特征和对角线特征，组合成特征模板。特征模板内有白色和黑色两种矩形，并定义该模板的特征值为白色矩形像素和减去黑色矩形像素和 Haar-like特征https://blog.csdn.net/zouxy09/article/details/7929570 1234567积分图就是只遍历一次图像就可以求出图像中所有区域像素和的快速算法，大大的提高了图像特征值计算的效率。 积分图主要的思想是将图像从起点开始到各个点所形成的矩形区域像素之和作为一个数组的元素保存在内存中，当要计算某个区域的像素和时可以直接索引数组的元素，不用重新计算这个区域的像素和，从而加快了计算（这有个相应的称呼，叫做动态规划算法）。积分图能够在多种尺度下，使用相同的时间（常数时间）来计算不同的特征，因此大大提高了检测速度。 我们来看看它是怎么做到的。 积分图是一种能够描述全局信息的矩阵表示方法。积分图的构造方式是位置（i,j）处的值ii(i,j)是原图像(i,j)左上角方向所有像素的和： 归一化图像123i¯(x,y)=(i(x,y)−μ)/cσ公式中i¯(x,y)表示归一化之后的图像，而i(x,y)表示原始的图像，其中μ表示图像的均值，而σ表示图像的标准差σ2=(1/N)∑x2−μ2 2是平方 SIFT特征SIFT的全称是Scale Invariant Feature Transform，尺度不变特征变换(物体怎么转，人都能识别)。SIFT特征对旋转、尺度缩放、亮度变化等保持不变性，是一种非常稳定的局部特征。 有4个主要步骤 1、尺度空间的极值检测 搜索所有尺度空间上的图像，通过高斯微分函数来识别潜在的对尺度和选择不变的兴趣点。12345678910$$$L(x,y,σ)=G(x,y,σ)∗I(x,y)$为了有效的在尺度空间检测到稳定的关键点，提出了高斯差分尺度空间（DOG scale-space）。利用不同尺度的高斯差分核与图像卷积生成。构造高斯差分尺度空间(DOG scale-space): $$D(x,y,σ)=(G(x,y,kσ)−G(x,y,σ))∗I(x,y)=L(x,y,kσ)−L(x,y,σ)$$σ 是尺度坐标。σ大小决定图像的平滑程度，大尺度对应图像的概貌特征，小尺度对应图像的细节特征。大的σ值对应粗糙尺度(低分辨率)，反之，对应精细尺度(高分辨率)。对于一幅图像I，建立其在不同尺度(scale)的图像,后面每个采样都是原图的1/4倍。每个点都要与邻域的点，上下相邻尺度的点做比较（9+8+9）26个点作比较（以确保在尺度空间和二维图像空间都检测到极值点）。一个点如果在DOG尺度空间本层以及上下两层的26个领域中是最大或最小值时，就认为该点是图像在该尺度下的一个特征点 2、特征点定位 在每个候选的位置上，通过一个拟合精细模型来确定位置尺度，关键点的选取依据他们的稳定程度。1拟和三维二次函数以精确确定关键点的位置和尺度，同时去除低对比度的关键点和不稳定的边缘响应点(因为DoG算子会产生较强的边缘响应)，以增强匹配稳定性、提高抗噪声能力 用Harris Corner检测参考文章 3、特征方向赋值 基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向，后续的所有操作都是对于关键点的方向、尺度和位置进行变换，从而提供这些特征的不变性。1每个特征点计算一个方向，依照这个方向做进一步的计算， *利用关键点邻域像素的梯度方向分布特性为每个关键点指定方向参数，使算子具备旋转不变性。 m(x,y)=(L(x+1,y)−L(x−1,y))2+(L(x,y+1)−L(x,y−1))2√θ(x,y)=atan2(L(x,y+1)−L(x,y−1)L(x+1,y)−L(x−1,y)每个关键点有三个信息：位置、所处尺度、方向。由此可以确定一个SIFT特征区域。4、特征点描述 在每个特征点周围的邻域内，在选定的尺度上测量图像的局部梯度，这些梯度被变换成一种表示，这种表示允许比较大的局部形状的变形和光照变换。 高斯函数是唯一可行的尺度空间核 尺度空间多分辨率图像金字塔:121、对原始图像进行平滑2、对处理后的图像进行降采样（通常是水平、垂直方向的1/2）降采样后得到一系列不断尺寸缩小的图像。显然，一个传统的金字塔中，每一层的图像是其上一层图像长、高的各一半。多分辨率的图像金字塔虽然生成简单，但其本质是降采样，图像的局部特征则难以保持，也就是无法保持特征的尺度不变性。 高斯尺度空间：12345678图像的模糊程度来模拟人在距离物体由远到近时物体在视网膜上成像过程，距离物体越近其尺寸越大图像也越模糊，这就是高斯尺度空间，使用不同的参数模糊图像（分辨率不变）图像和高斯函数进行卷积运算，图像模糊，使用不同的“高斯核”可得到不同模糊程度的图像L(x,y,σ)=G(x,y,σ)∗I(x,y)其中G(x,y,σ)是高斯核函数G(x,y,σ)=（1/2Πσ^2）e^((x^2+y^2)/(2σ^2)) 构建尺度空间的目的是为了检测出在不同的尺度下都存在的特征点，而检测特征点较好的算子是Δ^2G(高斯拉普拉斯,LoG） DoG特征使用LoG虽然能较好的检测到图像中的特征点，但是其运算量过大，通常可使用DoG（差分高斯，Difference of Gaussina）来近似计算LoG。 DOG可以看作为LOG的一个近似，但是它比LOG的效率更高。设k为相邻两个高斯尺度空间的比例因子，则DoG的定义： 1D(x,y,σ)=[G(x,y,kσ)−G(x,y,σ)]∗I(x,y)=L(x,y,kσ)−L(x,y,σ) L(x,y,σ) 是图像的高斯尺度空间将相邻的两个高斯空间的图像相减就得到了DoG的响应图像 Harris角点特征提取Harris角点检测是一种基于图像灰度的一阶导数矩阵检测方法。检测器的主要思想是局部自相似性/自相关性，即在某个局部窗口内图像块与在各个方向微小移动后的窗口内图像块的相似性。 1、角点可以是两个边缘的角点；&lt;/br&gt;2、角点是邻域内具有两个主方向的特征点；1人眼对角点的识别通常是在一个局部的小区域或小窗口完成的。如果在各个方向上移动这个特征的小窗口，窗口内区域的灰度发生了较大的变化，那么就认为在窗口内遇到了角点。如果这个特定的窗口在图像各个方向上移动时，窗口内图像的灰度没有发生变化，那么窗口内就不存在角点；如果窗口在某一个方向移动时，窗口内图像的灰度发生了较大的变化，而在另一些方向上没有发生变化，那么，窗口内的图像可能就是一条直线的线段。 x^{y^z}=(1+{\rm e}^x)^{-2xy^w}sqrt() 结论：1、增大α的值，将减小角点响应值R，降低角点检测的灵性，减少被检测角点的数量；减小α值，将增大角点响应值R，增加角点检测的灵敏性，增加被检测角点的数量。&lt;/br&gt;2、Harris角点检测算子对亮度和对比度的变化不敏感&lt;/br&gt;3、Harris角点检测算子具有旋转不变性&lt;/br&gt;4、Harris角点检测算子不具有尺度不变性&lt;/br&gt;]]></content>
      <tags>
        <tag>图像处理</tag>
        <tag>特征提取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[opencv_ocr]]></title>
    <url>%2F2018%2F07%2F16%2Fopencv_ocr%2F</url>
    <content type="text"><![CDATA[opencv_ocr]]></content>
      <tags>
        <tag>Opencv</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Opencv_斑点检测]]></title>
    <url>%2F2018%2F07%2F16%2Fopencv_%E6%96%91%E7%82%B9%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[Opencv_斑点检测 opencv中检测Blobs的类为SimpleBlobDetector这个类在opencv中的定义如下：123456789101112131415161718192021222324252627282930313233class SimpleBlobDetector : public FeatureDetector&#123;public:struct Params&#123; Params(); float thresholdStep; float minThreshold; float maxThreshold; size_t minRepeatability; float minDistBetweenBlobs; bool filterByColor; uchar blobColor; bool filterByArea; float minArea, maxArea; bool filterByCircularity; float minCircularity, maxCircularity; bool filterByInertia; float minInertiaRatio, maxInertiaRatio; bool filterByConvexity; float minConvexity, maxConvexity;&#125;;SimpleBlobDetector(const SimpleBlobDetector::Params &amp;parameters = SimpleBlobDetector::Params());protected: ...&#125;; 算法的大致步骤如下： 对[minThreshold,maxThreshold)区间，以thresholdStep为间隔，做多次二值化。对每张二值图片，使用findContours()提取连通域并计算每一个连通域的中心。根据2得到的中心，全部放在一起。一些很接近的点［由theminDistBetweenBlobs控制多少才算接近］被归为一个group,对应一个bolb特征..从3得到的那些点,估计最后的blob特征和相应半径，并以key points返回。同时该支持提取特征的方法，一共有5个选项，这里就不多加描述了，默认是提取黑色圆形的Blob特征。下面是一个示例1234567891011121314151617int main(int argc, char** argv) &#123; Mat image = imread(argv[1]); vector&lt;KeyPoint&gt; keyPoints; SimpleBlobDetector::Params params; SimpleBlobDetector blobDetect(params); blobDetect.create(&quot;SimpleBlob&quot;); blobDetect.detect(image, keyPoints); cout &lt;&lt; keyPoints.size() &lt;&lt; endl; drawKeypoints(image, keyPoints, image, Scalar(255,0,0)); namedWindow(&quot;blobs&quot;); imshow(&quot;blobs&quot;, image); waitKey(); return 0; &#125; 总体来说，OpenCV的斑点检测效果还算不错，但是在有些图像的效果上明显不如LOG算子检测的检测效果]]></content>
      <tags>
        <tag>Opencv</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理_图像增强]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[图像处理_图像增强 图像增强前期知识图像增强是图像模式识别中非常重要的图像预处理过程。图像增强的目的是通过对图像中的信息进行处理，使得有利于模式识别的信息得到增强，不利于模式识别的信息被抑制，扩大图像中不同物体特征之间的差别，为图像的信息提取及其识别奠定良好的基础。图像增强按实现方法不同可分为点增强、空域增强和频域增强。 1、点增强点增强主要指图像灰度变换和几何变换。图像的灰度变换也称为点运算、对比度增强或对比度拉伸，它是图像数字化软件和图像显示软件的重要组成部分。灰度变换是一种既简单又重要的技术，它能让用户改变图像数据占据的灰度范围。一幅输入图像经过灰度变换后将产生一幅新的输出图像，由输入像素点的灰度值决定相应的输出像素点的灰度值。灰度变换不会改变图像内的空间关系。图像的几何变换是图像处理中的另一种基本变换。它通常包括图像的平移、图像的镜像变换、图像的缩放和图像的旋转。通过图像的几何变换可以实现图像的最基本的坐标变换及缩放功能。 2、空域增强图像的空间信息可以反映图像中物体的位置 、形状、大小等特征，而这些特征可以通过一定的物理模式来描述。例如，物体的边缘轮廓由于灰度值变化剧烈一般出现高频率特征，而一个比较平滑的物体内部由于灰度值比较均一则呈现低频率特征。因此，根据需要可以分别增强图像的高频和低频特征。对图像的高频增强可以突出物体的边缘轮廓，从而起到锐化图像的作用。例如，对于人脸的比对查询，就需要通过高频增强技术来突出五宫的轮廓。相应地，对图像的低频部分进行增强可以对图像进行平滑处理，一般用于图像的噪声消除。 3、频域增强图像的空域增强一般只是对数字图像进行局部增强，而图像的频域增强可以对图像进行全局增强。频域增强技术是在数字图像的频率域空间对图像进行滤波，因此需要将图像从空间域变换到频率域，一般通过傅里叶变换实现。在频率域空间的滤波与空域滤波一样可以通过卷积实现，因此傅里叶变换和和卷积理论是频域滤波技术的基础。 图像增强的方法分类： 图像增强方法 实现方法 处理对象 灰度图 （伪）彩色图 - - 处理策略 全局处理 局部处理（ROI ROI，Region of Interest Interest） - - 处理方法 空间域（点域运算，即灰度变换） 空间域（邻域方法，即空域滤波） 频域方法 - - 处理目的 图像锐化 平滑去噪 灰度调整（对比度增强） 图像增强的方法之对比度增强 图像增强方法 实现方法 灰度变换法 线性变换（已实现） 对数变换（已实现） 指数变换（已实现） - - 直方图调整法 直方图均衡化（已实现） 直方图匹配（未实现） 图像对比度增强 图像对比度增强 直接 间接 直方图拉伸 直方图均衡化 1234直方图拉伸 是通过对比度拉伸对直方图进行调整，从而“扩大”前景和背景灰度的差别，以达到增强对比度的目的，这种方法可以利用线性或非线性的方法来实现;直方图均衡化则通过使用累积函数对灰度值进行“调整”以实现对比度的增强。直方图均衡化处理 “中心思想”是把原始图像的灰度直方图从比较集中的某个灰度区间变成在全部灰度范围内的均匀分布。直方图均衡化就是对图像进行非线性拉伸，重新分配图像像素值，使一定灰度范围内的像素数量大致相同。直方图均衡化就是把给定图像的直方图分布改变成“均匀”分布直方图分布。 常用图像增强直方图均衡化 直方图均衡化 优点 处理过亮过暗图像很有效(曝光过度或者曝光不足),刻画更多细节 是一个相当直观的技术并且是可逆操作，如果已知均衡化函数，那么就可以恢复原始的直方图，并且计算量也不大 - - 缺点 处理数据随机，可能会降低信噪比(会增加背景噪声对比度，降低有用信号对比度) c语言代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &quot;fftw3.h&quot;#include &quot;string&quot;#include &quot;vector&quot;#include &lt;windows.h&gt;#include &lt;opencv2/legacy/legacy.hpp&gt;#include &lt;opencv2/nonfree/nonfree.hpp&gt;//opencv_nonfree模块：包含一些拥有专利的算法，如SIFT、SURF函数源码。 #include &quot;opencv2/core/core.hpp&quot;#include &quot;opencv2/features2d/features2d.hpp&quot;#include &quot;opencv2/highgui/highgui.hpp&quot;#include &lt;opencv2/nonfree/features2d.hpp&gt; using namespace cv;using namespace std; class hisEqt&#123;public: hisEqt::hisEqt(); hisEqt::~hisEqt();public: int w; int h; int nlen; int *pHis; float *pdf; //=====求像素分布概率密度==== void getPdf(); //======统计像素个数======= void getHis(unsigned char*imgdata); //==========画统计分布直方图=============== void drawHistogram(const float*pdf,Mat &amp;hist1); //===========直方图均衡化========== void hisBal(); //====直方图均衡化后的图像=== void imgBal(unsigned char* img);&#125;; hisEqt::hisEqt() :nlen(0)&#123; pHis = new int[256 * sizeof(int)]; memset(pHis, 0, 256 * sizeof(int)); pdf = new float[255 * sizeof(float)]; memset(pdf, 0, 255 * sizeof(float));&#125; hisEqt::~hisEqt()&#123; delete[]pHis; delete[]pdf;&#125; //======统计像素个数======= void hisEqt::getHis(unsigned char*imgdata)&#123; for (int i = 0; i&lt;nlen; i++) &#123; pHis[imgdata[i]]++; &#125;&#125; //=====求像素分布概率密度==== void hisEqt::getPdf()&#123; for (int k = 0; k&lt;256; k++) &#123; pdf[k] = pHis[k] / float(nlen); &#125;&#125; //===========直方图均衡化========== void hisEqt::hisBal()&#123; for (int k = 1; k&lt;256; k++) &#123; pdf[k] += pdf[k - 1]; &#125; for (int k = 0; k&lt;256; k++) &#123; pHis[k] = 255 * pdf[k]; &#125;&#125; //====直方图均衡化 void hisEqt::imgBal(unsigned char* img)&#123; for (int i = 0; i&lt;nlen; i++) &#123; img[i] = pHis[img[i]]; &#125;&#125; void hisEqt::drawHistogram(const float *pdf, Mat&amp; hist1)&#123; for (int k = 0; k&lt;256; k++) &#123; if (k % 2 == 0) &#123; Point a(k, 255), b(k, 255 - pdf[k] * 2550); line(hist1, a, b, Scalar(0, 0, 255), 1); &#125; else &#123; Point a(k, 255), b(k, 255 - pdf[k] * 2550); line(hist1, a, b, Scalar(0, 255, 0), 1); &#125; &#125;&#125; int main()&#123; Mat image = imread(&quot;Fig0651(a)(flower_no_compression).tif&quot;); if (!image.data) return -1; Mat hist2(256, 256, CV_8UC3, Scalar(0, 0, 0)); Mat hist1(256, 256, CV_8UC3, Scalar(0, 0, 0)); Mat imgOut = Mat(image.rows, image.cols, CV_8UC3, Scalar(0, 0, 0)); vector&lt;Mat&gt; planes; int chn = image.channels(); if (chn == 3) &#123; split(image, planes); &#125; while (chn) &#123; chn--; unsigned char* imageData = new unsigned char[sizeof(unsigned char)*(image.cols*image.rows)]; memcpy(imageData, planes[chn].data, planes[chn].cols*planes[chn].rows); hisEqt his;//自定义的类 his.nlen = image.rows*image.cols; his.getHis(imageData); his.getPdf(); // //======画原图直方图并保存============ his.drawHistogram(his.pdf, hist1); string pic_name = &quot;hisline&quot;; pic_name = pic_name + to_string(chn); pic_name=pic_name+ &quot;.jpg&quot;; imwrite(pic_name, hist1); his.hisBal(); his.getPdf(); // //======画均衡化后直方图并保存============ his.drawHistogram(his.pdf, hist2); string pic_name0 = &quot;his_balanceline&quot;; pic_name0 = pic_name0 + to_string(chn); pic_name0 = pic_name0 + &quot;.jpg&quot;; imwrite(pic_name0, hist2); // //=====图像均衡化=== his.imgBal(imageData); memcpy(planes[chn].data, imageData, planes[chn].cols*planes[chn].rows); delete[] imageData; imageData = NULL; &#125; merge(planes, imgOut);//单通道合并 imwrite(&quot;result.jpg&quot;, imgOut); return 0;&#125; 指数变换 先做归一化，再指数变换，最后反归一化 S=c*R^r通过合理的选择c和r可以压缩灰度范围，算法以c=1.0/255.0, r=2实现 Opencv代码：123456789101112131415161718192021222324252627void ExpEnhance(IplImage* img, IplImage* dst)&#123; // 由于oldPixel:[1,256],则可以先保存一个查找表 uchar lut[256] =&#123;0&#125;; double temp = 1.0/255.0; for ( int i =0; i&lt;255; i++) &#123; lut[i] = (uchar)(temp*i*i+0.5); &#125; for( int row =0; row &lt;img-&gt;height; row++) &#123; uchar *data = (uchar*)img-&gt;imageData+ row* img-&gt;widthStep; uchar *dstData = (uchar*)dst-&gt;imageData+ row* dst-&gt;widthStep; for ( int col = 0; col&lt;img-&gt;width; col++) &#123; for( int k=0; k&lt;img-&gt;nChannels; k++) &#123; uchar t1 = data[col*img-&gt;nChannels+k]; dstData[col*img-&gt;nChannels+k] = lut[t1]; &#125; &#125; &#125; &#125; 对数变换 低灰度值部分扩展，高灰度值部分压缩,来强调图像低灰度部分 s=c*log_{v+1}(1+v*r)底数为（v+1），实际输入范围为归一化的【0-1】，其输出也为【0-1】。底数越大，对低灰度部分的强调就越强，对高灰度部分的压缩也就越强 matlab代码12345678function dst_img=myLogEnhance(src_img,v) c=1.0; src_img = mat2gray(src_img,[0 255]); g =c*log2(1 + v*src_img)/log2(v+1); %反归一化 max=255; min=0; dst_img=uint8(g*(max-min)+min); 灰度拉伸 灰度拉升可以改善图像的动态范围 s=\frac{1}{1+\frac{m}{r+eps}^E}输入r为【0-1】，其输出s也为【0-1】 线性拉伸三段线性变换 突出感兴趣的目标或者灰度区间，相对抑制那些不感兴趣的灰度区域 1234567891011121314151617181920212223242526272829范围吧%横轴fa=20; fb=80;%纵轴ga=50; gb=230;function dst_img=myLinearEnhance(src_img,fa,fb,ga,gb) [height,width] = size(src_img);dst_img=uint8(zeros(height,width)); src_img=double(src_img); %三段斜率k1=ga/fa; k2=(gb- ga)/(fb- fa);k3=(255- gb)/(255- fb);for i=1:height for j=1:width if src_img(i,j) &lt;= fa dst_img(i,j)= k1*src_img(i,j); elseif fa &lt; src_img(i,j) &amp;&amp; src_img(i,j) &lt;= fb dst_img(i,j)= k2*( src_img(i,j)- fa)+ ga; else dst_img(i,j)= k3*( src_img(i,j)- fb)+ gb; end endenddst_img=uint8(dst_img); 频率域图像增强 傅里叶变换提供了一种从空间域到频域的转换手段，且用傅里叶反变换可以实现从频域到空间域的无损转换，不丢失任何信息 频域图像增强 类型 高通滤波器 突出图像的边界 低通滤波器 抑制图像噪声，改善图像质量 分析频谱图1234567891011121314clc; %清空命令行clear;%清空变量 I1=imread(&apos;beauty.jpg&apos;);subplot(1,2,1);imshow(I1);title(&apos;beauty.jpg&apos;); I2=fft2(I1);%计算二维FFTspectrum =fftshift(I2);%将零点移到中心temp= log(1+ abs(spectrum) ); %对幅值做 对数变换 以压缩动态范围subplot(1,2,2);imshow(temp,[]);title(&apos;FFT&apos;); 低频分量:主要对整副图像的强度的综合度量.灰度变化缓慢的特性高频分量:主要是对图像边缘和轮廓的度量.灰度变化快的特性 幅度图，看图像的频率分布，哪里亮那里暗，低频一般在图像中央如果只保留图像的中心点，则图像的细节会丢失，大致轮廓还在，不同区域好友不同的灰度如果保留远离中心的点，而去掉中心的幅度，则保留着图像的细节，而不同区域的灰度一样 频域低通滤波理想低通滤波器理想低通滤波器并不能很好的兼顾 滤除噪声 与 保留细节 这两个方面 理想低通滤波器：12345678910111213141516171819% 频域低通滤波器 imidealflpf.m%&#123;函数： function ff=imidealflpf(I,freq)函数说明：构造理想的频域低通滤波器（即 滤镜）参数说明：I：为输入原图像 freq:为截止频率返回值： 与I等大的频域滤镜 %&#125; function ff=imidealflpf(I,freq) [M,N]=size(I); ff=ones(M,N); for i=1:M for j=1:N if (sqrt ((i-M/2)^2+ (j-N/2)^2 ) &gt;freq) ff(i,j)=0; %高于截止频率 设为0 end end end 不同截止频率的滤波结果： 高斯低通滤波器12345678910111213141516171819%高斯低通滤波器滤镜 imgaussflpf.m%&#123;函数： function ff=imgaussflpf(I,sigma)函数说明：构造高斯低通滤镜参数说明：I：输入图像 sigma：标准差返回值：与原图像等大的高斯低通滤镜 %&#125; function ff=imgaussflpf(I,sigma)[M,N]=size(I); ff=ones(M,N); for i=1:M for j=1:N ff(i,j)= exp( -((i-M/2)^2+(j-N/2)^2) /2/(sigma^2) ); %高斯函数 end end 高斯滤波结果： 高斯相比于低通滤波，在有效抑制噪声的同时，图像的模糊程度更低 cankao 频域高通滤波器 图像锐化可以通过衰减频域中的低频信号来实现 1234567891011121314151617181920%高斯高通滤波器滤镜 imgaussfhpf.m%&#123;函数： function ff=imgaussfhpf(I,sigma)函数说明：构造高斯高通滤镜参数说明：I：输入图像 sigma：标准差返回值：与原图像等大的高斯高通滤镜 %&#125; function ff=imgaussfhpf(I,sigma)[M,N]=size(I); ff=ones(M,N); for i=1:M for j=1:N ff(i,j)= 1-exp( -((i-M/2)^2+(j-N/2)^2) /2/(sigma^2) ); % 1-(gauss) end end 1、高斯高通滤波器可以较好的提取边缘信息；2、sigma越小，Gauss高通的截止频率越低，通过的低频成分越多，边缘提取越不精确，会包含更多的非边缘信息；（要求太低，多了浑水摸鱼者）3、sigma越大，边缘提取越精确，但可能包含不完整的边缘信息。（要求太高，有了漏网之鱼） 拉普拉斯滤波器1234567891011121314151617181920%laplace滤波器滤镜 imlapf.m%&#123;函数： function ff=imlapf(I)函数说明：构造laplace滤镜参数说明：I：输入图像 返回值：与原图像等大的laplace滤镜 %&#125; function ff=imlapf(I)[M,N]=size(I); ff=ones(M,N); for i=1:M for j=1:N ff(i,j)= -((i-M/2)^2+(j-N/2)^2) % end end 图像处理评价指标基于误差灵敏度评价算法：最简单的质量评价算法就是均方差(Mean Squared Error, MSE)和峰值信噪比(Peak Signal- Noise Ratio, PSNR)。MSE 和 PSNR 计算复杂度小，易于实现，在图像处理领域中广泛应用。但缺点是它们给出的数值与图像的感知质量之间没有必然联系。 峰值信噪比-PSNR图像压缩等领域信号重建质量的评价 MSE为当前图像 X 和参考图像 Y 的均方误差,H、W 分别表示图像的高和宽；n为每像素的比特数，一般取8，即像素灰阶数为256。PSNR的单位是dB，数值越大表示失真越小。 matlab代码：123456789101112131415function pnsr_result = psnr(img_ref,img_in) % img_ref is a high reference quality image % img_in is the denoise image % pnsr_result is the PSNR of the denoise image width = size(img_ref,2); heigh = size(img_ref,1); if( width ~= size(img_in,2) || heigh ~= size(img_in,1) ) disp(&apos;Please check whether the input image and reference image have same size&apos;); return end [a,b]=size(img_ref); XX=double(img_ref) - double(img_in); mse_value = sum(sum( XX.^2 ))/(a*b); pnsr_result = 10*log10( 255*255 / mse_value ); end SSIM信噪比（SNR）信噪比就是有用信号与噪声信号的比值 snr=10*log_{10}\frac{sigma(I2)}{sigma(I2-I1)}12345678910111213141516171819202122function snr=SNR2(I,In)% 计算噪声比% I :original signal% In:noisy signal% snr=10*log10(sigma2(I2)/sigma2(I2-I1)) [~,~,nchannel]=size(I);snr=0;I=double(I);In=double(In);if nchannel==1 Ps=sum(sum((I-mean(mean(I))).^2));%signal power Pn=sum(sum((I-In).^2));%noise power snr=10*log10(Ps/Pn);elseif nchannel==3 for i=1:3 Ps=sum(sum((I(:,:,i)-mean(mean(I(:,:,i)))).^2));%signal power Pn=sum(sum((I(:,:,i)-In(:,:,i)).^2));%noise power snr=snr+10*log10(Ps/Pn); end snr=snr/3;end 基于结构相似度评价算法其他曝光过度问题处理计算当前图像的反相（255-image)，然后取当前图像和反相图像的较小者为当前像素位置的值。 min(image,(255-image))加Masaic算法原理：用中心像素来表示邻域像素Opencv代码：123456789101112131415161718192021222324252627282930313233343536uchar getPixel( IplImage* img, int row, int col, int k)&#123; return ((uchar*)img-&gt;imageData + row* img-&gt;widthStep)[col*img-&gt;nChannels +k];&#125; void setPixel( IplImage* img, int row, int col, int k, uchar val)&#123; ((uchar*)img-&gt;imageData + row* img-&gt;widthStep)[col*img-&gt;nChannels +k] = val;&#125;--// nSize:为尺寸大小，奇数// 将邻域的值用中心像素的值替换void Masic(IplImage* img, IplImage* dst, int nSize)&#123; int offset = (nSize-1)/2; for ( int row = offset; row &lt;img-&gt;height - offset; row= row+offset) &#123; for( int col= offset; col&lt;img-&gt;width - offset; col = col+offset) &#123; int val0 = getPixel(img, row, col, 0); int val1 = getPixel(img, row, col, 1); int val2 = getPixel(img, row, col, 2); for ( int m= -offset; m&lt;offset; m++) &#123; for ( int n=-offset; n&lt;offset; n++) &#123; setPixel(dst, row+m, col+n, 0, val0); setPixel(dst, row+m, col+n, 1, val1); setPixel(dst, row+m, col+n, 2, val2); &#125; &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[特征提取——颜色特征]]></title>
    <url>%2F2018%2F07%2F16%2F%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E9%A2%9C%E8%89%B2%E7%89%B9%E5%BE%81%2F</url>
    <content type="text"><![CDATA[特征提取——颜色特征 颜色直方图OpenCV之颜色空间: 颜色空间RGB（Red 红色，Green 绿色，Blue 蓝色） R的取值范围：0-255 G的取值范围：0-255 B的取值范围：0-255 颜色空间HSV （Hue 色相，Saturation 饱和度，intensity 亮度） H的取值范围：0-179 S的取值范围：0-255 V的取值范围：0-255 颜色空间HLS (Hue 色相，lightness 亮度，Saturation 饱和度) H的取值范围：0-179 L的取值范围：0-255 S的取值范围：0-255 颜色矩这种方法的数学基础在于图像中任何的颜色分布均可以用它的矩来表示。此外，由于颜色分布信息主要集中在低阶矩中，因此仅采用颜色的一阶矩（mean）、二阶矩（variance）和三阶矩（skewness）就足以表达图像的颜色分布。与颜色直方图相比，该方法的另一个好处在于无需对特征进行向量化。图像的颜色矩一共只需要9个分量（3个颜色分量，每个分量上3个低阶矩）颜色矩常和其它特征结合使用，而且一般在使用其它特征前起到过滤缩小范围（narrow down）的作用。 一阶矩(均值,mean),反映图像明暗程度1u=(1/N)sum(Pij) 二阶矩(方差,viarance),反映图像颜色分布范围1a=sqrt(((1/N)sum(Pij-u)^2),2) 三阶矩(斜度,skewness),反映图像颜色分布对称性1a=sqrt(((1/N)sum(Pij-u)^3),3)]]></content>
      <tags>
        <tag>图像处理</tag>
        <tag>特征提取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[特征提取——局部特征-SIFT算法尺度不变性的理解]]></title>
    <url>%2F2018%2F07%2F16%2F%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E5%B1%80%E9%83%A8%E7%89%B9%E5%BE%81_SIFT%2F</url>
    <content type="text"><![CDATA[特征提取——局部特征 参考这个就完事了 局部特征不管原图尺度是多少，在包含了所有尺度的尺度空间下都能找到那些稳定的极值点，这样就做到了尺度不变！ 高斯函数是唯一可行的尺度空间核比如说一张美女图片，想要框出帽子的信息，图像尺寸小时框要这么大，图像尺寸大时，框也要相应调大： 尺度不变性： L(x,y,σ)=G(x,y,σ)*I(x,y)为了有效的在尺度空间检测到稳定的关键点，提出了高斯差分尺度空间（DOG scale-space）。利用不同尺度的高斯差分核与图像卷积生成。构造高斯差分尺度空间(DOG scale-space): D(x,y,σ)=(G(x,y,kσ)-G(x,y,σ))*I(x,y)=L(x,y,kσ)-L(x,y,σ)σ 是尺度坐标。σ大小决定图像的平滑程度，大尺度对应图像的概貌特征，小尺度对应图像的细节特征。大的σ值对应粗糙尺度(低分辨率)，反之，对应精细尺度(高分辨率)。 旋转不变性：123Lowe采用的方法是在生成描述子前将图片旋转到一个特定的方向上，这个方向是根据图片内容得到的，具体就是用在某个半径大小的圆内的像素的梯度信息。sigma取的是1.5*&lt;scale of key point&gt;,r取3*sigma将图片先旋转到主方向，这个方向由于是用相同的信息得到的，所以总是指向同一方。 抵抗噪声：1DoG得到极值点后，去除低对比度的点的点舍弃,在确定主方向和生成描述子时都将梯度模值加进行加权，即是噪声影响了部分点，经过加权统计会抑制变化，不会对全局造成太大影响 参考文章 OpenCV代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// opencv_empty_proj.cpp : 定义控制台应用程序的入口点。// #include &quot;stdafx.h&quot;#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/features2d/features2d.hpp&gt;#include&lt;opencv2/nonfree/nonfree.hpp&gt;#include&lt;opencv2/legacy/legacy.hpp&gt;#include&lt;vector&gt;using namespace std;using namespace cv; int _tmain(int argc, _TCHAR* argv[])&#123; const char* imagename = &quot;img.jpg&quot;; //从文件中读入图像 Mat img = imread(imagename); Mat img2=imread(&quot;img2.jpg&quot;); //如果读入图像失败 if(img.empty()) &#123; fprintf(stderr, &quot;Can not load image %s\n&quot;, imagename); return -1; &#125; if(img2.empty()) &#123; fprintf(stderr, &quot;Can not load image %s\n&quot;, imagename); return -1; &#125; //显示图像 imshow(&quot;image before&quot;, img); imshow(&quot;image2 before&quot;,img2); //sift特征检测 SiftFeatureDetector siftdtc; vector&lt;KeyPoint&gt;kp1,kp2; siftdtc.detect(img,kp1); Mat outimg1; drawKeypoints(img,kp1,outimg1); imshow(&quot;image1 keypoints&quot;,outimg1); KeyPoint kp; vector&lt;KeyPoint&gt;::iterator itvc; for(itvc=kp1.begin();itvc!=kp1.end();itvc++) &#123; cout&lt;&lt;&quot;angle:&quot;&lt;&lt;itvc-&gt;angle&lt;&lt;&quot;\t&quot;&lt;&lt;itvc-&gt;class_id&lt;&lt;&quot;\t&quot;&lt;&lt;itvc-&gt;octave&lt;&lt;&quot;\t&quot;&lt;&lt;itvc-&gt;pt&lt;&lt;&quot;\t&quot;&lt;&lt;itvc-&gt;response&lt;&lt;endl; &#125; siftdtc.detect(img2,kp2); Mat outimg2; drawKeypoints(img2,kp2,outimg2); imshow(&quot;image2 keypoints&quot;,outimg2); SiftDescriptorExtractor extractor; Mat descriptor1,descriptor2; BruteForceMatcher&lt;L2&lt;float&gt;&gt; matcher; vector&lt;DMatch&gt; matches; Mat img_matches; extractor.compute(img,kp1,descriptor1); extractor.compute(img2,kp2,descriptor2); imshow(&quot;desc&quot;,descriptor1); cout&lt;&lt;endl&lt;&lt;descriptor1&lt;&lt;endl; matcher.match(descriptor1,descriptor2,matches); drawMatches(img,kp1,img2,kp2,matches,img_matches); imshow(&quot;matches&quot;,img_matches); //此函数等待按键，按键盘任意键就返回 waitKey(); return 0;&#125;]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像分割-大津法]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2_%E5%A4%A7%E6%B4%A5%E6%B3%95%2F</url>
    <content type="text"><![CDATA[图像分割-大津法 算法介绍最大类间方差法是1979年由日本学者大津提出的，是一种自适应阈值确定的方法，又叫大津法，简称OTSU 算法公式 代码 Opencv249 + vs201012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &quot;stdio.h&quot;#include &quot;cv.h&quot;#include &quot;highgui.h&quot;#include &quot;Math.h&quot;int Otsu(IplImage* src);int main()&#123; IplImage* img = cvLoadImage(&quot;lena.jpg&quot;,0); //获取灰度图像img IplImage* dst = cvCreateImage(cvGetSize(img), 8, 1); int threshold = Otsu(img); //调用大津法求出最佳阈值 printf(&quot;otsu threshold = %d\n&quot;, threshold); cvThreshold(img, dst, threshold, 255, CV_THRESH_BINARY); //用otsu的阈值二值化 cvNamedWindow( &quot;img&quot;, 1 ); cvNamedWindow( &quot;dst&quot;, 1 ); cvShowImage(&quot;img&quot;, img); cvShowImage(&quot;dst&quot;, dst); cvWaitKey(-1); cvReleaseImage(&amp;img); cvReleaseImage(&amp;dst); cvDestroyWindow( &quot;img&quot; ); cvDestroyWindow( &quot;dst&quot; ); return 0;&#125;int Otsu(IplImage* src) &#123; int height=src-&gt;height; int width=src-&gt;width; //histogram float histogram[256] = &#123;0&#125;; for(int i=0; i &lt; height; i++) &#123; unsigned char* p=(unsigned char*)src-&gt;imageData + src-&gt;widthStep * i; for(int j = 0; j &lt; width; j++) &#123; histogram[*p++]++; &#125; &#125; //normalize histogram &amp; average pixel value int size = height * width; float u =0; for(int i = 0; i &lt; 256; i++) &#123; histogram[i] = histogram[i] / size; u += i * histogram[i]; //整幅图像的平均灰度 &#125; int threshold; float maxVariance=0; float w0 = 0, avgValue = 0; for(int i = 0; i &lt; 256; i++) &#123; w0 += histogram[i]; //假设当前灰度i为阈值, 0~i 灰度像素所占整幅图像的比例即前景比例 avgValue += i * histogram[i]; //avgValue/w0 = u0 float t = avgValue/w0 - u; //t=u0-u float variance = t * t * w0 /(1 - w0); if(variance &gt; maxVariance) &#123; maxVariance = variance; threshold = i; &#125; &#125; return threshold; &#125; 代码212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;opencv2/opencv.hpp&gt; #include &lt;cv.h&gt;#include &lt;highgui.h&gt;#include &lt;cxcore.h&gt;using namespace std;using namespace cv;Mat otsuGray(const Mat src) &#123; Mat img = src; int c = img.cols; //图像列数 int r = img.rows; //图像行数 int T = 0; //阈值 uchar* data = img.data; //数据指针 int ftNum = 0; //前景像素个数 int bgNum = 0; //背景像素个数 int N = c*r; //总像素个数 int ftSum = 0; //前景总灰度值 int bgSum = 0; //背景总灰度值 int graySum = 0; double w0 = 0; //前景像素个数占比 double w1 = 0; //背景像素个数占比 double u0 = 0; //前景平均灰度 double u1 = 0; //背景平均灰度 double Histogram[256] = &#123;0&#125;; //灰度直方图 double temp = 0; //临时类间方差 double g = 0; //类间方差 //灰度直方图 for(int i = 0; i &lt; r ; i ++) &#123; for(int j = 0; j &lt;c; j ++) &#123; Histogram[img.at&lt;uchar&gt;(i,j)]++; &#125; &#125; //求总灰度值 for(int i = 0; i &lt; 256; i ++) &#123; graySum += Histogram[i]*i; &#125; for(int i = 0; i &lt; 256; i ++) &#123; ftNum += Histogram[i]; //阈值为i时前景个数 bgNum = N - ftNum; //阈值为i时背景个数 w0 = (double)ftNum/N; //前景像素占总数比 w1 = (double)bgNum/N; //背景像素占总数比 if(ftNum == 0) continue; if(bgNum == 0) break; //前景平均灰度 ftSum += i*Histogram[i]; u0 = ftSum/ftNum; //背景平均灰度 bgSum = graySum - ftSum; u1 = bgSum/bgNum; g = w0*w1*(u0-u1)*(u0-u1); if(g &gt; temp) &#123; temp = g; T = i; &#125; &#125; for(int i=0; i&lt;img.rows; i++) &#123; for(int j=0; j&lt;img.cols; j++) &#123; if((int)img.at&lt;uchar&gt;(i,j)&gt;T) img.at&lt;uchar&gt;(i,j) = 255; else img.at&lt;uchar&gt;(i,j) = 0; &#125; &#125; return img;&#125;]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像处理-图像去雾]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE%2F</url>
    <content type="text"><![CDATA[图像处理-图像去雾 雾图模型I(x)=J(x)t(x)+A(1-t(x))1234I(x) ——待去雾的图像J(x)——无雾图像A——全球大气光成分t——折射率（大气传递系数） 暗通道先验在无雾图像中，每一个局部区域都很有可能会有阴影，或者是纯颜色的东西，又或者是黑色的东西。因此，每一个局部区域都很有可能有至少一个颜色通道会有很低的值。把这个统计规律叫做Dark Channel Prior。 首先求出每个像素RGB分量中的最小值，存入一副和原始图像大小相同的灰度图中，然后再对这幅灰度图进行最小值滤波(林宇中取最小值) 计算折射率 t(x)=1-wmin(minI(y)/A)估计大气光1231.选取暗通道图像暗通道最亮的0.1%的像素（一般来说，这些像素表示雾浓度最大的地方）2.取输入图像里面这些像素对应的像素里面最亮的作为大气光（暗图像最亮的0.1%的像素对应的原图最亮的为大气光） 注：选中的像素未必是全图最亮的，而且要比选取全图最亮的方式鲁棒性更好。 去雾J(x)=I(x)-A/max(t(x),t0) +At0=0.1 流程：1.求图像暗通道 2.利用暗通道计算出折射率 3.利用暗通道估计大气光 4.代回雾图公式去雾]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习_分类_数据聚类]]></title>
    <url>%2F2018%2F07%2F16%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_%E6%95%B0%E6%8D%AE%E8%81%9A%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[机器学习分类数据聚类 K-Means（k-平均或k-均值）可以称的上是知名度最高的一种聚类算法 123456789首先，我们确定要几个的聚类（cluster，也称簇），并为它们随机初始化一个各自的聚类质心点（cluster centroids），它在上图中被表示为“X”。要确定聚类的数量，我们可以先快速看一看已有的数据点，并从中分辨出一些独特的数据。其次，我们计算每个数据点到质心的距离来进行分类，它跟哪个聚类的质心更近，它就被分类到该聚类。需要注意的是，初始质心并不是真正的质心，质心应满足聚类里每个点到它的欧式距离平方和最小这个条件。因此根据这些被初步分类完毕的数据点，我们再重新计算每一聚类中所有向量的平均值，并确定出新的质心。最后，重复上述步骤，进行一定次数的迭代，直到质心的位置不再发生太大变化。当然你也可以在第一步时多初始化几次，然后选取一个看起来更合理的点节约时间。K-Means的优点是速度非常快，因为我们所做的只是计算数据点和质心点之间的距离，涉及到的计算量非常少！因此它的算法时间复杂度只有O(n)。另一方面，K-Means有两个缺点。一是你必须一开始就决定数据集中包含多少个聚类。这个缺点并不总是微不足道的，理想情况下，我们的目标其实是用一种算法来分类这些数据，并从结果中观察出一些规律，而不是限制几个条件强行聚类。二是一开始质心点的选取是随机的，算法可能会初始化出差异巨大的点。这个缺点导致的结果是质心点的位置不可重复且缺乏一致性。K-Medians是与K-Means相关的另一种聚类算法，不同之处在于它使用簇的中值向量来重新计算质心点。该方法对异常值不敏感（因为使用中值），但在较大数据集上运行时速度会慢很多，因为每次计算中值向量，我们都要重新排序。 Mean-Shift聚类12345678Mean shift算法，又称均值漂移算法，这是一种基于核密度估计的爬山算法，可用于聚类、图像分割、跟踪等。它的工作原理基于质心，这意味着它的目标是定位每个簇/类的质心，即先算出当前点的偏移均值，将该点移动到此偏移均值，然后以此为新的起始点，继续移动，直到满足最终的条件（找出最密集的区域）。1、为了理解均值漂移，我们可以像上图一样想象二维空间中的一组数据点，然后先随机选择一个点C，以它为圆心画一个半径为r的圆开始移动。之前提到了，这是个爬山算法，它的核函数会随着迭代次数增加逐渐向高密度区域靠近。2、在每轮迭代中，算法会不断计算圆心到质心的偏移均值，然后整体向质心靠近。漂移圆圈内的密度与数据点数成正比。到达质心后，算法会更新质心位置，并继续让圆圈向更高密度的区域靠近。3、当圆圈到达目标质心后，它发现自己无论朝哪个方向漂移都找不到更多的数据点，这时我们就认为它已经处于最密集的区域。4、这时，算法满足了最终的条件，即退出。Mean-Shift不需要实现定义聚类数量，因为这些都可以在计算偏移均值时得出。这是一个巨大的优势。同时，算法推动聚类中心在向密度最大区域靠近的效果也非常令人满意，这一过程符合数据驱动型任务的需要，而且十分自然直观。如果要说Mean-Shift有什么缺点，那就是对高维球区域的半径r的定义，不同选择可能会产生高度不同的影响。 EM聚类1234567891011均值→质心，方差→椭圆聚类，权重→聚类大小。K-Means算法的主要缺点之一是它直接用了距离质心的平均值。1、首先，我们确定聚类的数量（如K-Means），并随机初始化每个聚类的高斯分布参数。你也可以尝试通过快速查看数据来为初始参数提供更好的猜测，但从上图可以看出，这其实不是很必要，因为算法会很快进行优化。2、其次，根据每个聚类的高斯分布，计算数据点属于特定聚类的概率。如果数据点越接近高斯质心，那它属于该聚类的概率就越高。这很直观，因为对于高斯分布，我们一般假设大部分数据更靠近聚类质心。3、在这些概率的基础上，我们为高斯分布计算一组新的参数，使聚类内数据点的概率最大化。我们用数据点位置的加权和来计算这些新参数，其中权重就是数据点属于聚类的概率。为了可视化这个过程，我们可以看看上面的图片，特别是黄色的聚类。第一次迭代中，它是随机的，大多数黄点都集中在该聚类的右侧。当我们按概率计算加权和后，虽然聚类的中部出现一些点，但右侧的比重依然很高。随着迭代次数增加，黄点在聚类中的位置也完成了“右下→左下”的移动。因此，标准差的变化调整着聚类的形状，以使它能更适合数据点的分布。4、迭代步骤2和步骤3，直至收敛。GMM有两个关键优势。首先它比K-Means更灵活，由于标准差的引入，最后聚类的形状不再局限于圆形，它还可以是大小形状不一的椭圆形——K均值实际上是GMM的一个特例，其中每个聚类的协方差在所有维上都接近0。其次，权重的引入为同一点属于多个聚类找到了解决方案。如果一个数据点位于两个聚类的重叠区域，那我们就可以简单为它定义一个聚类，或者计算它属于X聚类的百分比是多少，属于Y聚类的百分比是多少。简而言之，GMM支持混合“成员”。谈及缺点，和K-Means相比，GMM每一步迭代的计算量比较大。另外，它的求解办法基于EM算法，因此有可能陷入局部极值，需要经过多次迭代。]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习_分类_随机森林]]></title>
    <url>%2F2018%2F07%2F16%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E5%88%86%E7%B1%BB_%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%2F</url>
    <content type="text"><![CDATA[机器学习分类随机森林 它也是最常用的算法之一，随机森林建立了多个决策树，并将它们合并在一起以获得更准确和稳定的预测。随机森林的一大优势在于它既可用于分类，也可用于回归问题 随机森林的主要限制在于使用大量的树会使算法变得很慢，并且无法做到实时预测。一般而言，这些算法训练速度很快，预测十分缓慢。越准确的预测需要越多的树，这将导致模型越慢。在大多数现实世界的应用中，随机森林算法已经足够快，但肯定会遇到实时性要求很高的情况，那就只能首选其他方法。 随机森林和Adaboost，以及区别：bagging 随机森林，不同的分类器是通过串行训练而获得的，每个新分类器都根据已训练出的分类器的性能来进行训练分类器权重相等. boost ：— §是通过集中关注被已有分类器错分的那些数据来获得新的分类器。匕0081丨明分类的结果是基于所有分类器的加权求和结果的，分类器权重并不相等，每个权重代表的是其对应分类器在上一轮迭代中的成功度 说一下GBDT和Adaboost，以及区别 Bagging + 决策树 = 随机森林 2）AdaBoost + 决策树 = 提升树 3）Gradient Boosting + 决策树 = GBDT]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习_最优化_数学]]></title>
    <url>%2F2018%2F07%2F16%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%9C%80%E4%BC%98%E5%8C%96_%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[机器学习最优化数学 泰勒展开式 期望概率加权下的平均值离散型：$E(x)=\sumix_ip_i$连续型：$E(x)=\int{-\infty}^{\infty}xf(x)dx$ 极大似然估计取对数：$lnL(\theta1,\theta_2,…,\theta_k=\sum{i=1}^nlnf(x,\theta_1,\theta_2,…,\theta_k))$求驻点：$\partial{lnL(\theta)}/\partial{\theta_i}=0,i=1,2,…k$ 概率论中心极限定理：设n个随机变量$X_1,X_2,…,X_n$相互独立，均具有相同的数学期望与方差，即$E(X_i)=\mu;D(X_i)=\sigma^2$, Y_n=X_1+X_2+...+X_nZ_n=\frac{Y_n-E(Y_n)}{\sqrt{D(Y_n)}}=\frac{Y_n-n\mu}{\sqrt{n}\sigma}→N(0,1)随机变量$Z_n$为n个随机变量$X_1,X_2,…,X_n$的规范和设从均值为$\mu$、方差为$\sigma^2$（有限）的任意一个总体中抽取样本量为$n$的样本，当$n$充分⼤大时，样本均值的抽样分布$\frac{Y_n}{n}$近似服从于均值为$\mu$、方差为$\sigma^2$的正态分布。 中心极限定理，把那些对结果影响⽐比较小的变量（假设独⽴立同分布）之和认为服从正态分布是合理理的。 高斯分布输入值$x^i$，预测值$\theta^Tx^i$，真实值$y^i$，误差$\epsilon^{i}$ y^i=\theta^Tx^i+\epsilon^{i}根据中心极限定理，认为变量之和服从高斯分布,即 \epsilon^{i} = y^i-\theta^Tx^i则，x,y的条件概率为 p(y^i|x^i;\theta) = \frac{1}{\sqrt{2\pi}\sigma}exp(-\frac{(y^i-\theta^Tx^i)^2}{2\sigma^2})矩阵论最优化]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>最优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux_常用命令]]></title>
    <url>%2F2018%2F07%2F16%2FLinux_commnd%2F</url>
    <content type="text"><![CDATA[Linux_常用命令 主要的目录的有/、/root、/home、/usr、/bin等。其中： ```普通用户的可执行文件，系统的任何用户都可以执行该目录中的命令123456789101112131415```/boot``` 存放Linux操作系统启动时所需要的文件&lt;br&gt;```/dev ```系统中所有设备文件&lt;br&gt;```/etc ```系统中的配置文件&lt;br&gt;```/home ```普通用户的宿主目录，每个用户在该目下都有一个于用户名同名的目录&lt;br&gt;```/mnt ```中的子目录用于系统中可移动设备的挂载点&lt;br&gt;```/root ```超级用户root的宿主目录&lt;br&gt;```/sbin ```系统中的管理命令，普通用户不能执行&lt;br&gt;```/tmp ```系统的临时目录&lt;br&gt;```/usr ```系统应用程序的相关文件&lt;br&gt;```/var ```系统中经常变化的文件如日志文件和用户邮件&lt;br&gt;## 2、 Linux命令进入系统控制台，看到```[root@loca~] 其中#代表当前是root用户登录，如果是$表示当前为普通用户。 cd /home 进入/home目录/root ```进入/root目录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081```cd ..``` 返回上一级目录&lt;br&gt;```cd .``` 当前目录；（.和..可以理解为相对路径；例如cd /hom/test ，cd加完整的路径，可以理解为绝对路径）&lt;br&gt;```ls .``` 查看当前目录所有的文件和目录。&lt;br&gt;```ls -a ``` 查看所有的文件，包括隐藏文件,以.开头的文件。&lt;br&gt;```pwd``` 显示当前所在的目录。&lt;br&gt;```mkdir``` 创建目录，用法mkdir test ，命令后接目录的名称。&lt;br&gt;```rmdir``` 删除空目录&lt;br&gt;```rm``` 删除文件或者目录，用法 rm –rf test.txt (-r表示递归，-f表示强制)。&lt;br&gt;```cp``` 拷贝文件，用法：cp old.txt /tmp/new.txt ，常用来备份；如果拷贝目录需要加 –r参数。&lt;br&gt;```mv ``` 重命名或者移动文件或者目录，用法, mv old.txt new.txt&lt;br&gt;```touch ``` 创建文件，用法，touch test.txt，如果文件存在，则表示修改当前文件时间。&lt;br&gt;```Useradd``` 创建用户，用法 useradd wugk ，userdel删除用户。&lt;br&gt;```Groupadd``` 创建组，用法 groupadd wugk1 ，groupdel删除组。&lt;br&gt;```find 查找文件或目录```，用法 find /home -name “test.txt”,命令格式为:&lt;br&gt;```find 后接查找的目录```，-name指定需要查找的文件名称，名称可以使用*表示所有。&lt;br&gt;```find /home -name &quot;*.txt&quot; ```; 查找/home目录下，所有以.txt结尾的文件或者目录。&lt;br&gt;```vi ``` 修改某个文件，vi有三种模式：命令行模式、文本输入模式、末行模式。默认vi打开一个文件，首先是命令行模式，然后按i进入文本输入模式，可以在文件里写入字符等等信息。写完后，按esc进入命令模式，然后输入:进入末行模式。 例如输入:wq表示保存退出。如果想直接退出，不保存，可以执行:q!， q!叹号表示强制退出。```cat ``` 查看文件内容，用法 cat test.txt 可以看到test.txt内容```more``` 查看文件内容，分页查看，cat是全部查看，如果篇幅很多，只能看到最后的篇幅。可以使用cat和more同时使用,例如： cat test.txt |more 分页显示text内容，|符号是管道符，用于把|前的输出作为后面命令的输入。```echo``` 回显，用法 echo ok，会显示ok，输入什么就打印什么。```echo``` ok &gt; test.txt ；把ok字符覆盖test.txt内容，&gt;表示追加并覆盖的意思。&gt;&gt;两个大于符号，表示追加，echo ok &gt;&gt; test.txt,表示向test.txt文件追加OK字符，不覆盖原文件里的内容。## 2.2 Linux基本命令```shutdown - h now ```立刻关机&lt;br&gt;```shutdown - r now ```重启&lt;br&gt;```reboot``` 重启&lt;br&gt;```clear``` 清除屏幕命令&lt;br&gt;```history``` 查看历史命令记录&lt;br&gt;## 2.3 用户操作命令```su-``` 切换成系统管理员&lt;br&gt;```su``` 用户之间的切换&lt;br&gt;```logout``` 用户注销&lt;br&gt;```useradd A``` 添加用户（root下）&lt;br&gt;```passwd A ``` 设置A的密码&lt;br&gt;```userdel A``` 删除用户&lt;br&gt;```userdel -r A``` 删除用户及其主目录&lt;br&gt;## 2.4 修改用户属性```usermod –g&lt;主组名&gt; -G &lt;组名&gt; -d &lt;用户主目录&gt; -s &lt;用户shell&gt;```&lt;br&gt;在添加用户时，可以指定将该用户添加到哪个组中，同样的用root的管理权限可以改变 某个用户所在的组：usermod -g 组名 用户名可以用 ```usermod -d 目录名 用户名``` 改变该用户登录的初始目录&lt;br&gt;```groupadd &lt;新组名&gt;``` 增加用户组&lt;br&gt;```groupdel &lt;组名&gt;``` 删除用户组&lt;br&gt;修改组成员：直接编辑/etc/group文件，将用户名写到对应的组名的后面```whoami``` 命令的功能在于显示用户自身的用户名。&lt;br&gt;```who``` [选项]：该命令主要用于查看当前在线的用户情况&lt;br&gt;```w``` 用于显示登录到系统的用户情况&lt;br&gt;```finger``` 命令可用于查找和显示用户信息，并且在查找后显示指定账号的相关信息&lt;br&gt;```chfn ``` 命令能够改变系统存储的用户信息## 2.5 设置系统时间1.date命令。可以直接输入date 来查看系统时间&lt;br&gt;2.利用date命令来更改系统时间&lt;br&gt;date MMDDHHMCCYY.SS 指定月月日日时时分分年年年年.秒秒## 2.6 Linux用户管理&gt;在Linux操作系统中，root的权限是最高的，相当于windows的administrator，拥有最高权限，能执行任何命令和操作。&gt;在系统中，通过UID来区分用户的权限级别，UID等于0，表示此用户具有最高权限，也就是管理员。&gt;其他的用户UID依次增加，通过/etc/passwd用户密码文件可以查看到每个用户的独立的UID。Linux命令大全## 一、ls命令|命令|含义||:---:|:---:||ls -a|显示全部文件，包含隐藏文件||ls –F|使用这个参数表示在文件的后面多添加表示文件类型的符号，例如*表示可执行，/表示目录，@表示连结文件，这都是因为使用了-F这个参数。||ls -l|（这个参数是字母L的小写，不是数字1） 使用长格式显示文件内容，如果需要察看更详细的文件资料|||| 421 rwx-rw-r—r—@ 1 aomanhao staff 27197 11 9 15:30 JavaWebSocket.zip1234567891011121314151617181920212223242526272829303132333435363738394041`-rw-r--r--@`第一个栏位，表示文件的属性。Linux的文件基本上分为三个属性：可读（r），可写（w），可执行（x）。但是这里有十个格子可以添（具体程序实现时，实际上是十个bit位）。第一个小格是特殊表示格，表示目录或连结文件等等，d表示目录，例如drwx——;l表示连结文件，如lrwxrwxrwx;如果是以一横“-”表示，则表示这是文件。其余剩下的格子就以每3格为一个单位。因为Linux是多用户多任务系统，所以一个文件可能同时被许多人使用，所以我们一定要设好每个文件的权限，其文件的权限位置排列顺序是（以-rwxr-xr-x为例）： rwx(Owner)r-x(Group)r-x(Other) 这个例子表示的权限是：使用者自己可读，可写，可执行；同一组的用户可读，不可写，可执行；其它用户可读，不可写，可执行。另外，有一些程序属性的执行部分不是X,而是S,这表示执行这个程序的使用者，临时可以有和拥有者一样权力的身份来执行该程序。一般出现在系统管理之类的指令或程序，让使用者执行时，拥有root身份。`1` 第二个栏位，表示文件个数。如果是文件的话，那这个数目自然是1了，如果是目录的话，那它的数目就是该目录中的文件个数了。`aomanhao` 第三个栏位，表示该文件或目录的拥有者。若使用者目前处于自己的Home,那这一栏大概都是它的账号名称。`staff` 第四个栏位，表示所属的组（group）。每一个使用者都可以拥有一个以上的组，不过大部分的使用者应该都只属于一个组，只有当系统管理员希望给予某使用者特殊权限时，才可能会给他另一个组。`27197` 第五栏位，表示文件大小。文件大小用byte来表示，而空目录一般都是1024byte，你当然可以用其它参数使文件显示的单位不同，如使用ls –k就是用kb来显示一个文件的大小单位，不过一般我们还是以byte为主。`15:30 ` 第六个栏位，表示创建日期。以“月，日，时间”的格式表示，如Aug 15 5:46表示8月15日早上5:46分。`JavaWebSocket.zip` 第七个栏位，表示文件名。我们可以用ls –a显示隐藏的文件名。### cd命令|命令|含义||:---:|:---:||cd /| 切换当前目录至dirName||cd .. |退到上层目录||cd ../.. //| 进入当前目录的父目录的父目录。||mkdir| 建立新的目录（如果目录存在会报错）||rmdir| 删除已建立的目录， rmdir 命令只能删除空的文件夹，如果文件夹非空，将不能删除，它也没有-f选项，所以你的命令都是错的。要删除非空的文件夹，可以使用rm命令，加rf两个选项，如：rm -rf sandao||cp |cp命令用来将一个或多个源文件或者目录复制到指定的目的文件或目录。它可以将单个源文件复制成一个指定文件名的具体的文件或一个已经存在的目录下。cp命令还支持同时复制多个文件，当一次复制多个文件时，目标文件参数必须是一个已经存在的目录，否则将出现错误。| -a：此参数的效果和同时指定”-dpR”参数相同；-d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；-f：强行复制文件或目录，不论目标文件或目录是否已存在；-i：覆盖既有文件之前先询问用户；-l：对源文件建立硬连接，而非复制文件；-p：保留源文件或目录的属性；-R/r：递归处理，将指定目录下的所有文件与子目录一并处理；-s：对源文件建立符号连接，而非复制文件；-u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件；-S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀；-b：覆盖已存在的文件目标前将目标文件备份； -v：详细显示命令执行的操作如下，将/home/linlin1下的linlin.c复制到/home/linlin2下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170我们在Linux下使用cp命令复制文件时候，有时候会需要覆盖一些同名文件，覆盖文件的时候都会有提示：需要不停的按Y来确定执行覆盖。文件数量不多还好，但是要是几百个估计按Y都要吐血了，于是折腾来半天总结了一个方法：[html] view plain copycp aaa/* /bbb 复制目录aaa下所有到/bbb目录下，这时如果/bbb目录下有和aaa同名的文件，需要按Y来确认并且会略过aaa目录下的子目录。cp -r aaa/* /bbb 这次依然需要按Y来确认操作，但是没有忽略子目录。cp -r -a aaa/* /bbb 依然需要按Y来确认操作，并且把aaa目录以及子目录和文件属性也传递到了/bbb。cp -r -a aaa/* /bbb 成功，没有提示按Y、传递了目录属性、没有略过目录。img### rm命令 这个命令是用来删除文件的，和dos下面的rm（删除一个空目录）是有区别的，大家千万要注意。rm命令常用的参数有三个： -i,-r,-f。[html] view plain copy-f, –force 忽略不存在的文件，从不给出提示。-i, –interactive 进行交互式删除-r, -R, –recursive 指示rm将参数中列出的全部目录和子目录均递归地删除。-v, –verbose 详细显示进行的步骤​ –help 显示此帮助信息并退出​ –version 输出版本信息并退出 rm –r 目录名：这个操作可以连同这个目录下面的子目录都删除，功能上和rmdir相似。 rm –f 文件名（目录名）：这个操作可以进行强制删除。### mv命令 这个命令的功能是移动目录或文件，引申的功能是给目录或文件重命名。当使用该命令来移动目录时，他会连同该目录下面的子目录也一同移走。-b ：若需覆盖文件，则覆盖前先行备份。-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！-u ：若目标文件已经存在，且 source 比较新，才会更新(update)-t ： –target-directory=DIRECTORY move all SOURCE arguments into DIRECTORY，即指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。mv 原文件（目录）名 新的文件（目录）名。### du，df命令 du命令可以显示目前的目录所占的磁盘空间，df命令可以显示目前磁盘剩余的磁盘空间。如果du命令不加任何参数，那么返回的是整个磁盘的使用情况，如果后面加了目录的话，就是这个目录在磁盘上的使用情况### cat命令​ cat主要有三大功能：1.一次显示整个文件。$ cat filename2.从键盘创建一个文件。$ cat &gt; filename只能创建新文件,不能编辑已有文件.3.将几个文件合并为一个文件： $cat file1 file2 &gt; file参数：-n 或 –number 由 1 开始对所有输出的行数编号-b 或 –number-nonblank 和 -n 相似，只不过对于空白行不编号-s 或 –squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行-v 或 –show-nonprinting它的用法如下： cat text 显示text这个文件； cat file1 file2 依顺序显示file1,file2的内容；img把 text.c和 text1.c的档案内容加上行号（空白行不加）之后将内容附加到 text2.c 里。### more,less命令 这是两个显示一般文本文件的指令。如果一个文本文件太长了超过一个屏幕的画面，用cat来看实在是不理想，就可以试试more和less两个指令。More指令可以使超过一页的文件临时停留在屏幕，等你按任何的一个键以后，才继续显示。而less除了有more的功能以外，还可以用方向键往上或往下的滚动文件，所以你随意浏览，阅读文章时，less是个非常好的选择。more:选项 文件名+n 从笫n行开始显示-n 定义屏幕大小为n行+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示-c 从顶部清屏，然后显示-d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能-l 忽略Ctrl+l（换页）字符-p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似-s 把连续的多个空行显示为一行-u 把文件内容中的下画线去掉在每个档案显示前搜寻该字串lin，然后从该字串前两行之后开始显示工具也是对文件或其它输出进行分页显示的工具，应该说是linux正统查看文件内容的工具，功能极其强大。less 的用法比起 more更加的有弹性。在 more 的时候，我们并没有办法向前面翻， 只能往后面看，但若使用了 less 时，就可以使用 [pageup][pagedown] 等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在 less里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。less 选项 文件名选项-b &lt;缓冲区大小&gt; 设置缓冲区的大小-e 当文件显示结束后，自动离开-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件-g 只标志最后搜索的关键词-i 忽略搜索时的大小写-m 显示类似more命令的百分比-N 显示每行的行号-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来-Q 不使用警告音-s 显示连续空行为一行-S 行过长时间将超出部分舍弃-x &lt;数字&gt; 将“tab”键显示为规定的数字空格/字符串：向下搜索“字符串”的功能?字符串：向上搜索“字符串”的功能n：重复前一个搜索（与 / 或 ? 有关）N：反向重复前一个搜索（与 / 或 ? 有关）b 向后翻一页d 向后翻半页h 显示帮助界面Q 退出less 命令u 向前滚动半页y 向前滚动一行空格键 滚动一行回车键 滚动一页[pagedown]： 向下翻动一页[pageup]： 向上翻动一页img退出按Q向下搜索含lin的字符串img### tail命令​ 也是用于用于查看文件内容tail语法格式：​ tail [ -f ] [ -c Number | -n Number | -m Number | -b Number | -k Number ] [ File ]​ 或者​ tail [ -r ] [ -n Number ] [ File ]使用说明：​ tail 命令从指定点开始将 File 参数指定的文件写到标准输出。如果没有指定文件，则会使用标准输入。 Number变量指定将多少单元写入标准输出。 Number 变量的值可以是正的或负的整数。如果值的前面有+（加号），从文件开头指定的单元数开始将文件写到标准输出。如果值的前面有-（减号），则从文件末尾指定的单元数开始将文件写到标准输出。如果值前面没有 +（加号）或 -（减号），那么从文件末尾指定的单元号开始读取文件。主要参数：-b Number 从 Number 变量表示的 512 字节块位置开始读取指定文件。-c Number 从 Number 变量表示的字节位置开始读取指定文件。-f如果输入文件是常规文件或如果 File 参数指定 FIFO（先进先出），那么 tail命令不会在复制了输入文件的最后的指定单元后终止，而是继续从输入文件读取和复制额外的单元（当这些单元可用时）。如果没有指定 File参数，并且标准输入是管道，则会忽略 -f 标志。tail -f 命令可用于监视另一个进程正在写入的文件的增长。-k Number 从 Number 变量表示的1KB 块位置开始读取指定文件。-m Number 从 Number 变量表示的多字节字符位置开始读取指定文件。使用该标志提供在单字节和双字节字符代码集环境中的一致结果。-n Number 从首行或末行位置来读取指定文件，位置由 Number 变量的符号（+ 或 - 或无）表示，并通过行号 Number 进行位移。-r 从文件末尾以逆序方式显示输出。-r 标志的缺省值是以逆序方式显示整个文件。如果文件大于 20,480 字节，那么-r标志只显示最后的 20,480 字节。 -r 标志只有 与 -n 标志一起时才有效。否则，就会将其忽略。tail -f 命令可用于监视另一个进程正在写入的文件的增长。 特别是在看日志时非常有用，你实时更新了日志，它就实时显示出来img### pwd命令 pwd [–help][–version] 说明：执行pwd指令可立刻得知您目前所在的工作目录的绝对路径名称。imgclear### grep命令用于查找文件中符合字符串的哪行。 参数说明：-a ：将 binary 文件以 text 文件的方式搜寻数据-c ：计算找到 ‘搜寻字符串’ 的次数-i ：忽略大小写的不同，所以大小写视为相同-n ：顺便输出行号-v ：反向选择，亦即显示出没有 ‘搜寻字符串’ 内容的那一行!根据文件内容递归查找目录 grep ‘energywise’ * #在当前目录搜索带’energywise’行的文件grep -r ‘energywise’ * #在当前目录及其子目录下搜索’energywise’行的文件grep -l -r ‘energywise’ * #在当前目录及其子目录下搜索’energywise’行的文件，但是不显示匹配的行，只显示匹配的文件12345678910111213141516171819202122232425262728293031323334353637383940414243grep功能是很强大的，这里只简单说明了一下，有兴趣的同学自己下来研究下吧！$ find -name “.txt” -print 用于查找所有的‘ .txt’文件在当前目录及子目录中$ find -name “[A-Z]*” -print 用于当前目录及子目录中查找文件名以一个大写字母开头的文件$ find /etc -name “host*” -print 在/etc目录中查找文件名以host开头的文件$find -name “[a-z][a-z][0–9][0–9].txt” -print 在当前目录查找文件名以两个小写字母开头，跟着是两个数字，最后是.txt的文件1.在某目录下查找名为“elm.cc”的文件find /home/lijiajia/ -name elm.cc​2.查找文件名中包含某字符（如”elm”）的文件find /home/lijiajia/ -name ‘elm‘find /home/lijiajia/ -name ‘elm*’find /home/lijiajia/ -name ‘*elm’​3.根据文件的特征进行查询find /home/lijiajia/ -amin -10 #查找在系统中最后10分钟访问的文件find /home/lijiajia/ -atime -2 #查找在系统中最后48小时访问的文件find /home/lijiajia/ -empty #查找在系统中为空的文件或者文件夹find /home/lijiajia/ -group cat # 查找在系统中属于groupcat 的文件（试了，命令不对。）find /home/lijiajia/ -mmin -5 # 查找在系统中最后5 分钟里修改过的文件find /home/lijiajia/ -mtime -1 #查找在系统中最后24 小时里修改过的文件find /home/lijiajia/ -nouser #查找在系统中属于作废用户的文件（不明白是什么意思）find /home/lijiajia/ -amin 10 #查找在系统中最后10分钟访问的文件find /home/ftp/pub -user lijiajia #查找在系统中属于lijiajia这个用户的文件(PS:以上都是在 /home/lijiajia/文件夹下进行的操作)​4.使用混合查找方式查找文件find /tmp -size +10000000c -and -mtime +2 #查找/tmp目录中大于10000000字节并且在48小时内修改的某个文件find /tmp -user tom -or -user george #查找/tmp目录中属于tom或者george这两个用户的文件find /tmp ! -usr fred #查找/tmp目录中不属于fred的文件​5.查找并显示文件find /home/lijiajia/ -name ‘elm.cc’ -ls #在目录下查找名为“elm.cc”的文件,并显示这些文件的信息## 一、ls命令|命令|含义||:---:|:---:||ls -a|显示全部文件，包含隐藏文件||ls –F|使用这个参数表示在文件的后面多添加表示文件类型的符号，例如*表示可执行，/表示目录，@表示连结文件，这都是因为使用了-F这个参数。||ls -l|（这个参数是字母L的小写，不是数字1） 使用长格式显示文件内容，如果需要察看更详细的文件资料|||| 421 rwx-rw-r—r—@ 1 aomanhao staff 27197 11 9 15:30 JavaWebSocket.zip1234567891011121314151617181920212223242526272829303132333435363738394041`-rw-r--r--@`第一个栏位，表示文件的属性。Linux的文件基本上分为三个属性：可读（r），可写（w），可执行（x）。但是这里有十个格子可以添（具体程序实现时，实际上是十个bit位）。第一个小格是特殊表示格，表示目录或连结文件等等，d表示目录，例如drwx——;l表示连结文件，如lrwxrwxrwx;如果是以一横“-”表示，则表示这是文件。其余剩下的格子就以每3格为一个单位。因为Linux是多用户多任务系统，所以一个文件可能同时被许多人使用，所以我们一定要设好每个文件的权限，其文件的权限位置排列顺序是（以-rwxr-xr-x为例）： rwx(Owner)r-x(Group)r-x(Other) 这个例子表示的权限是：使用者自己可读，可写，可执行；同一组的用户可读，不可写，可执行；其它用户可读，不可写，可执行。另外，有一些程序属性的执行部分不是X,而是S,这表示执行这个程序的使用者，临时可以有和拥有者一样权力的身份来执行该程序。一般出现在系统管理之类的指令或程序，让使用者执行时，拥有root身份。`1` 第二个栏位，表示文件个数。如果是文件的话，那这个数目自然是1了，如果是目录的话，那它的数目就是该目录中的文件个数了。`aomanhao` 第三个栏位，表示该文件或目录的拥有者。若使用者目前处于自己的Home,那这一栏大概都是它的账号名称。`staff` 第四个栏位，表示所属的组（group）。每一个使用者都可以拥有一个以上的组，不过大部分的使用者应该都只属于一个组，只有当系统管理员希望给予某使用者特殊权限时，才可能会给他另一个组。`27197` 第五栏位，表示文件大小。文件大小用byte来表示，而空目录一般都是1024byte，你当然可以用其它参数使文件显示的单位不同，如使用ls –k就是用kb来显示一个文件的大小单位，不过一般我们还是以byte为主。`15:30 ` 第六个栏位，表示创建日期。以“月，日，时间”的格式表示，如Aug 15 5:46表示8月15日早上5:46分。`JavaWebSocket.zip` 第七个栏位，表示文件名。我们可以用ls –a显示隐藏的文件名。### cd命令|命令|含义||:---:|:---:||cd /| 切换当前目录至dirName||cd .. |退到上层目录||cd ../.. //| 进入当前目录的父目录的父目录。||mkdir| 建立新的目录（如果目录存在会报错）||rmdir| 删除已建立的目录， rmdir 命令只能删除空的文件夹，如果文件夹非空，将不能删除，它也没有-f选项，所以你的命令都是错的。要删除非空的文件夹，可以使用rm命令，加rf两个选项，如：rm -rf sandao||cp |cp命令用来将一个或多个源文件或者目录复制到指定的目的文件或目录。它可以将单个源文件复制成一个指定文件名的具体的文件或一个已经存在的目录下。cp命令还支持同时复制多个文件，当一次复制多个文件时，目标文件参数必须是一个已经存在的目录，否则将出现错误。| -a：此参数的效果和同时指定”-dpR”参数相同；-d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；-f：强行复制文件或目录，不论目标文件或目录是否已存在；-i：覆盖既有文件之前先询问用户；-l：对源文件建立硬连接，而非复制文件；-p：保留源文件或目录的属性；-R/r：递归处理，将指定目录下的所有文件与子目录一并处理；-s：对源文件建立符号连接，而非复制文件；-u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件；-S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀；-b：覆盖已存在的文件目标前将目标文件备份； -v：详细显示命令执行的操作如下，将/home/linlin1下的linlin.c复制到/home/linlin2下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170我们在Linux下使用cp命令复制文件时候，有时候会需要覆盖一些同名文件，覆盖文件的时候都会有提示：需要不停的按Y来确定执行覆盖。文件数量不多还好，但是要是几百个估计按Y都要吐血了，于是折腾来半天总结了一个方法：[html] view plain copycp aaa/* /bbb 复制目录aaa下所有到/bbb目录下，这时如果/bbb目录下有和aaa同名的文件，需要按Y来确认并且会略过aaa目录下的子目录。cp -r aaa/* /bbb 这次依然需要按Y来确认操作，但是没有忽略子目录。cp -r -a aaa/* /bbb 依然需要按Y来确认操作，并且把aaa目录以及子目录和文件属性也传递到了/bbb。cp -r -a aaa/* /bbb 成功，没有提示按Y、传递了目录属性、没有略过目录。img### rm命令 这个命令是用来删除文件的，和dos下面的rm（删除一个空目录）是有区别的，大家千万要注意。rm命令常用的参数有三个： -i,-r,-f。[html] view plain copy-f, –force 忽略不存在的文件，从不给出提示。-i, –interactive 进行交互式删除-r, -R, –recursive 指示rm将参数中列出的全部目录和子目录均递归地删除。-v, –verbose 详细显示进行的步骤​ –help 显示此帮助信息并退出​ –version 输出版本信息并退出 rm –r 目录名：这个操作可以连同这个目录下面的子目录都删除，功能上和rmdir相似。 rm –f 文件名（目录名）：这个操作可以进行强制删除。### mv命令 这个命令的功能是移动目录或文件，引申的功能是给目录或文件重命名。当使用该命令来移动目录时，他会连同该目录下面的子目录也一同移走。-b ：若需覆盖文件，则覆盖前先行备份。-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！-u ：若目标文件已经存在，且 source 比较新，才会更新(update)-t ： –target-directory=DIRECTORY move all SOURCE arguments into DIRECTORY，即指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。mv 原文件（目录）名 新的文件（目录）名。### du，df命令 du命令可以显示目前的目录所占的磁盘空间，df命令可以显示目前磁盘剩余的磁盘空间。如果du命令不加任何参数，那么返回的是整个磁盘的使用情况，如果后面加了目录的话，就是这个目录在磁盘上的使用情况### cat命令​ cat主要有三大功能：1.一次显示整个文件。$ cat filename2.从键盘创建一个文件。$ cat &gt; filename只能创建新文件,不能编辑已有文件.3.将几个文件合并为一个文件： $cat file1 file2 &gt; file参数：-n 或 –number 由 1 开始对所有输出的行数编号-b 或 –number-nonblank 和 -n 相似，只不过对于空白行不编号-s 或 –squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行-v 或 –show-nonprinting它的用法如下： cat text 显示text这个文件； cat file1 file2 依顺序显示file1,file2的内容；img把 text.c和 text1.c的档案内容加上行号（空白行不加）之后将内容附加到 text2.c 里。### more,less命令 这是两个显示一般文本文件的指令。如果一个文本文件太长了超过一个屏幕的画面，用cat来看实在是不理想，就可以试试more和less两个指令。More指令可以使超过一页的文件临时停留在屏幕，等你按任何的一个键以后，才继续显示。而less除了有more的功能以外，还可以用方向键往上或往下的滚动文件，所以你随意浏览，阅读文章时，less是个非常好的选择。more:选项 文件名+n 从笫n行开始显示-n 定义屏幕大小为n行+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示-c 从顶部清屏，然后显示-d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能-l 忽略Ctrl+l（换页）字符-p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似-s 把连续的多个空行显示为一行-u 把文件内容中的下画线去掉在每个档案显示前搜寻该字串lin，然后从该字串前两行之后开始显示工具也是对文件或其它输出进行分页显示的工具，应该说是linux正统查看文件内容的工具，功能极其强大。less 的用法比起 more更加的有弹性。在 more 的时候，我们并没有办法向前面翻， 只能往后面看，但若使用了 less 时，就可以使用 [pageup][pagedown] 等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在 less里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。less 选项 文件名选项-b &lt;缓冲区大小&gt; 设置缓冲区的大小-e 当文件显示结束后，自动离开-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件-g 只标志最后搜索的关键词-i 忽略搜索时的大小写-m 显示类似more命令的百分比-N 显示每行的行号-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来-Q 不使用警告音-s 显示连续空行为一行-S 行过长时间将超出部分舍弃-x &lt;数字&gt; 将“tab”键显示为规定的数字空格/字符串：向下搜索“字符串”的功能?字符串：向上搜索“字符串”的功能n：重复前一个搜索（与 / 或 ? 有关）N：反向重复前一个搜索（与 / 或 ? 有关）b 向后翻一页d 向后翻半页h 显示帮助界面Q 退出less 命令u 向前滚动半页y 向前滚动一行空格键 滚动一行回车键 滚动一页[pagedown]： 向下翻动一页[pageup]： 向上翻动一页img退出按Q向下搜索含lin的字符串img### tail命令​ 也是用于用于查看文件内容tail语法格式：​ tail [ -f ] [ -c Number | -n Number | -m Number | -b Number | -k Number ] [ File ]​ 或者​ tail [ -r ] [ -n Number ] [ File ]使用说明：​ tail 命令从指定点开始将 File 参数指定的文件写到标准输出。如果没有指定文件，则会使用标准输入。 Number变量指定将多少单元写入标准输出。 Number 变量的值可以是正的或负的整数。如果值的前面有+（加号），从文件开头指定的单元数开始将文件写到标准输出。如果值的前面有-（减号），则从文件末尾指定的单元数开始将文件写到标准输出。如果值前面没有 +（加号）或 -（减号），那么从文件末尾指定的单元号开始读取文件。主要参数：-b Number 从 Number 变量表示的 512 字节块位置开始读取指定文件。-c Number 从 Number 变量表示的字节位置开始读取指定文件。-f如果输入文件是常规文件或如果 File 参数指定 FIFO（先进先出），那么 tail命令不会在复制了输入文件的最后的指定单元后终止，而是继续从输入文件读取和复制额外的单元（当这些单元可用时）。如果没有指定 File参数，并且标准输入是管道，则会忽略 -f 标志。tail -f 命令可用于监视另一个进程正在写入的文件的增长。-k Number 从 Number 变量表示的1KB 块位置开始读取指定文件。-m Number 从 Number 变量表示的多字节字符位置开始读取指定文件。使用该标志提供在单字节和双字节字符代码集环境中的一致结果。-n Number 从首行或末行位置来读取指定文件，位置由 Number 变量的符号（+ 或 - 或无）表示，并通过行号 Number 进行位移。-r 从文件末尾以逆序方式显示输出。-r 标志的缺省值是以逆序方式显示整个文件。如果文件大于 20,480 字节，那么-r标志只显示最后的 20,480 字节。 -r 标志只有 与 -n 标志一起时才有效。否则，就会将其忽略。tail -f 命令可用于监视另一个进程正在写入的文件的增长。 特别是在看日志时非常有用，你实时更新了日志，它就实时显示出来img### pwd命令 pwd [–help][–version] 说明：执行pwd指令可立刻得知您目前所在的工作目录的绝对路径名称。imgclear### grep命令用于查找文件中符合字符串的哪行。 参数说明：-a ：将 binary 文件以 text 文件的方式搜寻数据-c ：计算找到 ‘搜寻字符串’ 的次数-i ：忽略大小写的不同，所以大小写视为相同-n ：顺便输出行号-v ：反向选择，亦即显示出没有 ‘搜寻字符串’ 内容的那一行!根据文件内容递归查找目录 grep ‘energywise’ * #在当前目录搜索带’energywise’行的文件grep -r ‘energywise’ * #在当前目录及其子目录下搜索’energywise’行的文件grep -l -r ‘energywise’ * #在当前目录及其子目录下搜索’energywise’行的文件，但是不显示匹配的行，只显示匹配的文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455grep功能是很强大的，这里只简单说明了一下，有兴趣的同学自己下来研究下吧！$ find -name “.txt” -print 用于查找所有的‘ .txt’文件在当前目录及子目录中$ find -name “[A-Z]*” -print 用于当前目录及子目录中查找文件名以一个大写字母开头的文件$ find /etc -name “host*” -print 在/etc目录中查找文件名以host开头的文件$find -name “[a-z][a-z][0–9][0–9].txt” -print 在当前目录查找文件名以两个小写字母开头，跟着是两个数字，最后是.txt的文件1.在某目录下查找名为“elm.cc”的文件find /home/lijiajia/ -name elm.cc​2.查找文件名中包含某字符（如”elm”）的文件find /home/lijiajia/ -name ‘elm‘find /home/lijiajia/ -name ‘elm*’find /home/lijiajia/ -name ‘*elm’​3.根据文件的特征进行查询find /home/lijiajia/ -amin -10 #查找在系统中最后10分钟访问的文件find /home/lijiajia/ -atime -2 #查找在系统中最后48小时访问的文件find /home/lijiajia/ -empty #查找在系统中为空的文件或者文件夹find /home/lijiajia/ -group cat # 查找在系统中属于groupcat 的文件（试了，命令不对。）find /home/lijiajia/ -mmin -5 # 查找在系统中最后5 分钟里修改过的文件find /home/lijiajia/ -mtime -1 #查找在系统中最后24 小时里修改过的文件find /home/lijiajia/ -nouser #查找在系统中属于作废用户的文件（不明白是什么意思）find /home/lijiajia/ -amin 10 #查找在系统中最后10分钟访问的文件find /home/ftp/pub -user lijiajia #查找在系统中属于lijiajia这个用户的文件(PS:以上都是在 /home/lijiajia/文件夹下进行的操作)​4.使用混合查找方式查找文件find /tmp -size +10000000c -and -mtime +2 #查找/tmp目录中大于10000000字节并且在48小时内修改的某个文件find /tmp -user tom -or -user george #查找/tmp目录中属于tom或者george这两个用户的文件find /tmp ! -usr fred #查找/tmp目录中不属于fred的文件​5.查找并显示文件find /home/lijiajia/ -name ‘elm.cc’ -ls #在目录下查找名为“elm.cc”的文件,并显示这些文件的信息## 压缩指令### 1. gzipgzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。经过 gzip 压缩过，源文件就不存在了。有 9 个不同的压缩等级可以使用。可以使用 zcat、zmore、zless 来读取压缩文件的内容。```html$ gzip [-cdtv#] filename-c ：将压缩的数据输出到屏幕上-d ：解压缩-t ：检验压缩文件是否出错-v ：显示压缩比等信息-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6 2. bzip2提供比 gzip 更高的压缩比。 查看命令：bzcat、bzmore、bzless、bzgrep。 12$ bzip2 [-cdkzv#] filename-k ：保留源文件 3. xz提供比 bzip2 更佳的压缩比。 可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。 查看命令：xzcat、xzmore、xzless、xzgrep。 1$ xz [-dtlkc#] filename 打包压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gip、bzip2、xz 将打包文件进行压缩。 123456789101112$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename... ==打包压缩$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件] ==查看$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录] ==解压缩-z ：使用 zip；-j ：使用 bzip2；-J ：使用 xz；-c ：新建打包文件；-t ：查看打包文件里面有哪些文件；-x ：解打包或解压缩的功能；-v ：在压缩/解压缩的过程中，显示正在处理的文件名；-f : filename：要处理的文件；-C 目录 ： 在特定目录解压缩。 使用方式 命令 打包压缩 tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称 查 看 tar -jtv -f filename.tar.bz2 解压缩 tar -jxv -f filename.tar.bz2 -C 要解压缩的目录 九、正则表达式grep使用正则表示式进行全局查找并打印。 123456$ grep [-acinv] [--color=auto] 搜寻字符串 filename-c ： 统计个数-i ： 忽略大小写-n ： 输出行号-v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行--color=auto ：找到的关键字加颜色显示 示例：把含有 the 字符串的行提取出来（注意默认会有 —color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串） 1$ grep -n 'the' regular_express.txt 因为 { 和 } 在 shell 是有特殊意义的，因此必须要使用转义字符进行转义。 1$ grep -n 'go\&#123;2,5\&#125;g' regular_express.txt printf用于格式化输出。它不属于管道命令，在给 printf 传数据时需要使用 $( ) 形式。 1234$ printf '%10s %5i %5i %5i %8.2f \n' $(cat printf.txt) DmTsai 80 60 92 77.33 VBird 75 55 80 70.00 Ken 60 90 70 73.33 awk是由 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 创造，awk 这个名字就是这三个创始人名字的首字母。 awk 每次处理一行，处理的最小单位是字段，每个字段的命名方式为：$n，n 为字段号，从 1 开始，$0 表示一整行。 示例：取出登录用户的用户名和 IP 123456$ last -n 5dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged indmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22)dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12)dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14)dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15) 1$ last -n 5 | awk '&#123;print $1 "\t" $3&#125;' 可以根据字段的某些条件进行匹配，例如匹配字段小于某个值的那一行数据。 1$ awk '条件类型 1 &#123;动作 1&#125; 条件类型 2 &#123;动作 2&#125; ...' filename 示例：/etc/passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。 1234$ cat /etc/passwd | awk &apos;BEGIN &#123;FS=&quot;:&quot;&#125; $3 &lt; 10 &#123;print $1 &quot;\t &quot; $3&#125;&apos;root 0bin 1daemon 2 awk 变量： 变量名称 代表意义 NF 每一行拥有的字段总数 NR 目前所处理的是第几行数据 FS 目前的分隔字符，默认是空格键 示例：显示正在处理的行号以及每一行有多少字段 123456$ last -n 5 | awk '&#123;print $1 "\t lines: " NR "\t columns: " NF&#125;'dmtsai lines: 1 columns: 10dmtsai lines: 2 columns: 10dmtsai lines: 3 columns: 10dmtsai lines: 4 columns: 10dmtsai lines: 5 columns: 9 查看进程1. ps查看某个时间点的进程信息 示例一：查看自己的进程 1# ps -l 示例二：查看系统所有进程 1# ps aux 示例三：查看特定的进程 1# ps aux | grep threadx 2. top实时显示进程信息 示例：两秒钟刷新一次 1# top -d 2 3. pstree查看进程树 示例：查看所有进程树 1# pstree -A 4. netstat查看占用端口的进程 示例：查看特定端口的进程 1# netstat -anp | grep port 进程状态 状态 说明 R running or runnable (on run queue) D uninterruptible sleep (usually I/O) S interruptible sleep (waiting for an event to complete) Z zombie (terminated but not reaped by its parent) T stopped (either by a job control signal or because it is being traced)]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习_概率论_数学基础]]></title>
    <url>%2F2018%2F07%2F16%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%A6%82%E7%8E%87%E8%AE%BA_%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[机器学习_概率论 概念先验概率：A的边缘概率表示为P(A)，B的边缘概率表示为P(B) 联合概率:表示两个事件共同发生的概率。A与B的联合概率表示为P(A∩B)或者P(A,B)。 条件概率（又称后验概率）：事件A在另外一个事件B已经发生条件下的发生概率。条件概率表示为P(A|B)，读作“在B条件下A的概率”,。 123456789考虑一个问题：P(A|B)是在B发生的情况下A发生的可能性。首先，事件B发生之前，我们对事件A的发生有一个基本的概率判断，称为A的先验概率，用P(A)表示；其次，事件B发生之后，我们对事件A的发生概率重新评估，称为A的后验概率，用P(A|B)表示；类似的，事件A发生之前，我们对事件B的发生有一个基本的概率判断，称为B的先验概率，用P(B)表示；同样，事件A发生之后，我们对事件B的发生概率重新评估，称为B的后验概率，用P(B|A)表示。 贝叶斯公式贝叶斯定理 P(B_i|A) = \frac{P(B_i)P(A|B_i)}{\sum_{j=1}^n{P(B_j)}{P(A|B_j)}}贝叶斯公式 P(A|B)=\frac{P(B|A)P(A)}{P(B)}因为联合概率$P(A,B)$ P(A,B)=P(A|B)*P(B)=P(B|A)*P(A)假设B事件是由A1、A2事件导致的 P(B)=P(B|A1)P(A1)+P(B|A2)P(A2)理解：P(规律|现象)=P(现象|规律)P(规律)/P(现象) 案例1假设有两个班级其中1班有男生30人，女生20人；2班有男生25人、女生25人。体育老师抓到一个抽烟的男生，该男生打死也不告诉体育老师是那个班的。问题来了体育老师怎么判断该男生来自那个班？ 先将1班和2班标记为事件A1和事件A2，男生标记为事件B 那么我们所求的就是P(A1丨B)和P(A2丨B) 因为只有2个班那么我们先验概率P(A1)=P(A2)=50%；来自1班男生的概率P(B丨A1)=3/5：来自2班男生的概率P(B丨A2)=1/2 那么我们求出P(B)就可以代入公式得到结果: P(B)=P(B丨A1)P(A1) P(B丨A2)P(A2)=0.55 P(A1丨B)=P(B丨A1)P(A1)/P(B)=0.6*0.5/0.55=55% P(A2丨B)=P(B丨A2)P(A2)/P(B)=0.5*0.5/0.55=45% 由结果我们可以得出：该男生来自1班的概率从50%（先验概率）上升到55%（后验概率） 案例2一种癌症，得了这个癌症的人被检测出为阳性的几率为90%，未得这种癌症的人被检测出阴性的几率为90%，而人群中得这种癌症的几率为1%，一个人被检测出阳性，问这个人得癌症的几率为多少？ 我们用 A 表示事件 “测出为阳性”, 用 $B_1$ 表示“得癌症”, $B_2$ 表示“未得癌症”。 得到以下信息:$P(A|B_1)=0.9$得癌症的人检测阳性 0.9$P(A|B_2)=0.1$得癌症的人检测阴性 0.1$P(B_1)=0.01$得癌症的概率 0.01$P(B_2)=0.99$未得癌症的概率 0.99 计算：人群中检测为阳性且得癌症的几率$P(B_1,A)$，联合概率 P(B_1,A)=P(B_1)*P(A|B_1)=0.01*0.9=0.009检测阳性并且未得癌症概率$P(B_2,A)$，联合概率 P(B_2,A)=P(B_2)*P(A|B_2)=0.99*0.1=0.099目前状态是已经检测除阳性，求患癌症概率$P(B_1|A)$$P(B_1|A)=\frac{0.009}{0.099+0.009}=0.083$未患癌症概率$P(B_2|A)$$P(B_2|A)=\frac{0.099}{0.099+0.009}=0.917$]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习_最优化]]></title>
    <url>%2F2018%2F07%2F16%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E6%9C%80%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[机器学习-最优化-梯度下降-牛顿法等(梯度消失爆炸)) 铺垫微分意义121、函数图像中，某点的切线的斜率2、函数的变化率 梯度意义 梯度就是分别对每个变量进行微分，然后用逗号分割开，梯度是用&lt;&gt;包括起来，说明梯度其实一个向量。121、在单变量的函数中，梯度其实就是函数的微分，代表着函数在某个给定点的切线的斜率2、在多变量函数中，梯度是一个向量，向量有方向，梯度的方向就指出了函数在给定点的上升最快的方向 梯度的方向实际就是函数在此点上升最快的方向！而我们需要朝着下降最快的方向走，自然就是负的梯度的方向，所以此处需要加上负号 梯度下降法（Gradient Descent） 梯度下降法的优化思想是用当前位置负梯度方向作为搜索方向，因为该方向为当前位置的最快下降方向，所以也被称为是”最速下降法“。最速下降法越接近目标值，步长越小，前进越慢 梯度下降法的缺点：12345（1）靠近极小值时收敛速度减慢，；（2）直线搜索时可能会产生一些问题；（3）可能会“之字形”地下降。 \theta^1=\theta^0 - \alpha\nabla(j(\theta)是关于Θ的一个函数，我们当前所处的位置为Θ0点，要从这个点走到J的最小值点$\nabla$ 是梯度,$\alpha$是学习率或者步长 批量梯度下降法将$j(\theta)$对$\theta$求偏导，得到每个$\theta$对应的的梯度：每个参数$\theta$的梯度负方向，来更新每个$\theta$ 优点：它得到的是一个全局最优解缺点：数据量大，计算缓慢 随机梯度下降随机梯度下降是通过每个样本来迭代更新一次，如果样本量很大的情况（例如几十万），那么可能只用其中几万条或者几千条的样本 优点：只用部分数据继续优化，运算量小缺点：损失一部分进度，增加迭代次数 两者关系： 随机梯度下降方法以损失很小的一部分精确度和增加一定数量的迭代次数为代价，换取了总体的优化效率的提升。增加的迭代次数远远小于样本的数量。 总结： 批量梯度下降—最小化所有训练样本的损失函数，使得最终求解的是全局的最优解，即求解的参数是使得风险函数最小，但是对于大规模样本问题效率低下。 随机梯度下降—最小化每条样本的损失函数，虽然不是每次迭代得到的损失函数都向着全局最优方向， 但是大的整体的方向是向全局最优解的，最终的结果往往是在全局最优解附近，适用于大规模训练样本情况。 牛顿法和拟牛顿法牛顿法是一种在实数域和复数域上近似求解方程的方法。牛顿法最大的特点就在于它的收敛速度很快。 单变量例如：方法使用函数$f(x)$的泰勒级数的前面几项来寻找方程$f(x)= 0$的根。 1、选择一个接近函数$ f (x)$零点的 $x_0$，计算相应的$ f (x_0)$ 和切线斜率$f ‘ (x_0)$（这里$f ‘ $表示函数$ f $ 的导数）。然后我们计算穿过点$(x_0, f (x_0))$ 并且斜率为$f ‘(x_0)$的直线和 $x $轴的交点的$x$坐标，也就是求如下方程的解： x*f'(x_0)+f(x_0)-x_0*f'(x_0)=0求得新的$x$坐标$x_1$,$x_1$比$x_0$更加接近收敛值的解，也就是使得$f(x)=0$，单变量迭代公式： x_n+1=x_n-f(x_n)/f'(x_n) 如果$f ‘$ 是连续的，牛顿法必定收敛 多变量的话，需要用到雅可比矩阵和海森矩阵。 总结： 牛顿法的优缺点优点：二阶收敛，收敛速度快；缺点：牛顿法是一种迭代算法，每一步都需要求解目标函数的Hessian矩阵的逆矩阵，计算比较复杂。 牛顿法是二阶收敛，梯度下降是一阶收敛，所以牛顿法就更快 牛顿法就是用一个二次曲面去拟合你当前所处位置的局部曲面，而梯度下降法是用一个平面去拟合当前的局部曲面，通常情况下，二次曲面的拟合会比平面更好，所以牛顿法选择的下降路径会更符合真实的最优下降路径。 Hessian 矩阵非正定（非凸）导致无法收敛；Hessian 矩阵维度过大带来巨大的计算量。 拟牛顿法（Quasi-Newton Methods）拟牛顿法是求解非线性优化问题最有效的方法之一。 拟牛顿法的本质思想是改善牛顿法每次需要求解复杂的Hessian矩阵的逆矩阵的缺陷，它使用正定矩阵来近似Hessian矩阵的逆，从而简化了运算的复杂度。只需要用到一阶导数，不需要计算Hessian矩阵 以及逆矩阵，因此能够更快收敛 正定矩阵：如果$X^TAX&gt;0$判定定理1：对称阵A为正定的充分必要条件是：A的特征值全为正。 判定定理2：对称阵A为正定的充分必要条件是：A的各阶顺序主子式都为正。 判定定理3：任意阵A为正定的充分必要条件是：A合同于单位阵。 拉格朗日乘子法作为一种优化算法，拉格朗日乘子法主要用于解决约束优化问题，它的基本思想就是通过引入拉格朗日乘子来将含有n个变量和k个约束条件的约束优化问题转化为含有（n+k）个变量的无约束优化问题。拉格朗日乘子背后的数学意义是其为约束方程梯度线性组合中每个向量的系数。 典型：求函数$z=f(x,y)$在满足$b(x,y)=0$下的条件极值转化为函数$F(x,y,\alpha)=f(x,y)+\alpha b(x,y)$的无条件极值问题 列题：给定椭球：$x^2/a^2+y^2/b^2+z^2/c^2=1$(约束条件),求内接长方体最大体积，求极值问题，求$f(x,y,z)=8xyz$的最大值用拉格朗日乘子法：转化为 F(x,y,z,\alpha)=f(x,y,z)+\alpha b(x,y,z)=8xyz+\alpha(x^2/a^2+y^2/b^2+z^2/c^2-1)对F(x,y,z,\alpha)求偏导得然后联立三个方程的$bx=ay,az=cx$，带入第四个方程解解为： 共轭梯度法共轭梯度法是介于最速下降法与牛顿法之间的一个方法，它仅需利用一阶导数信息，但克服了最速下降法收敛慢的缺点，又避免了牛顿法需要存储和计算Hesse矩阵并求逆的缺点，共轭梯度法不仅是解决大型线性方程组最有用的方法之一，也是解大型非线性最优化最有效的算法之一。 在各种优化算法中，共轭梯度法是非常重要的一种。其优点是所需存储量小，具有步收敛性，稳定性高，而且不需要任何外来参数。 参考文章参考文章 梯度不稳定什么是梯度不稳定问题：深度神经网络中的梯度不稳定性，前面层中的梯度或会消失，或会爆炸。 原因：前面层上的梯度是来自于后面层上梯度的乘乘积。当存在过多的层次时，就出现了内在本质上的不稳定场景，如梯度消失和梯度爆炸。 后果：训练很难进行，不收敛了1、loss过早地不再下降2、精确度过早地不在提高 梯度消失梯度消失：一是在深层网络中；二是采用了不合适的损失函数，比如sigmoid。sigmoid导数最大为1/4，故只有当abs(w)&gt;4时才可能出现。先前传递误差就很小，前端网络w几乎没什么变化，等于这一层没能学习什么东西，网络层数越多就浪费了 解决方法：1、初始化一个合适的w2、选合适的激励函数 relu、leakrelu、elu等激活函数 relu函数：目前使用最多的激活函数 Relu(x)=max(x,0)函数图像： relu的主要贡献在于：优点：1、— 解决了梯度消失、爆炸的问题2、— 计算方便，计算速度快3、— 加速了网络的训练缺点：1、由于负数部分恒为0，会导致一些神经元无法激活（可通过设置小学习率部分解决）2、输出不是以0为中心的 leakrelu:leakrelu就是为了解决relu的0区间带来的影响 leakrelu=max(k*x,x)函数图像： 爆炸问题梯度爆炸：一般出现在深层网络和权值初始化值太大的情况下。当权值过大，前面层比后面层梯度变化更快，会引起梯度爆炸问题。]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>最优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阈值分割_大津法_分水岭]]></title>
    <url>%2F2018%2F07%2F16%2F%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2_%E5%A4%A7%E6%B4%A5%E6%B3%95_%E5%88%86%E6%B0%B4%E5%B2%AD%2F</url>
    <content type="text"><![CDATA[阈值分割大津法分水岭 大津法(最大类间方差法,Otsu)一种基于全局的二值化算法，它是根据图像的灰度特性,将图像分为前景和背景两个部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &quot;stdio.h&quot;#include &quot;cv.h&quot;#include &quot;highgui.h&quot;#include &quot;Math.h&quot;int Otsu(IplImage* src);int main()&#123; IplImage* img = cvLoadImage(&quot;lena.jpg&quot;,0); //获取灰度图像img IplImage* dst = cvCreateImage(cvGetSize(img), 8, 1); int threshold = Otsu(img); //调用大津法求出最佳阈值 printf(&quot;otsu threshold = %d\n&quot;, threshold); cvThreshold(img, dst, threshold, 255, CV_THRESH_BINARY); //用otsu的阈值二值化 cvNamedWindow( &quot;img&quot;, 1 ); cvNamedWindow( &quot;dst&quot;, 1 ); cvShowImage(&quot;img&quot;, img); cvShowImage(&quot;dst&quot;, dst); cvWaitKey(-1); cvReleaseImage(&amp;img); cvReleaseImage(&amp;dst); cvDestroyWindow( &quot;img&quot; ); cvDestroyWindow( &quot;dst&quot; ); return 0;&#125;int Otsu(IplImage* src) &#123; int height=src-&gt;height; int width=src-&gt;width; //histogram float histogram[256] = &#123;0&#125;; for(int i=0; i &lt; height; i++) &#123; unsigned char* p=(unsigned char*)src-&gt;imageData + src-&gt;widthStep * i; for(int j = 0; j &lt; width; j++) &#123; histogram[*p++]++; &#125; &#125; //normalize histogram &amp; average pixel value int size = height * width; float u =0; for(int i = 0; i &lt; 256; i++) &#123; histogram[i] = histogram[i] / size; u += i * histogram[i]; //整幅图像的平均灰度 &#125; int threshold; float maxVariance=0; float w0 = 0, avgValue = 0; for(int i = 0; i &lt; 256; i++) &#123; w0 += histogram[i]; //假设当前灰度i为阈值, 0~i 灰度像素所占整幅图像的比例即前景比例 avgValue += i * histogram[i]; //avgValue/w0 = u0 float t = avgValue/w0 - u; //t=u0-u float variance = t * t * w0 /(1 - w0); if(variance &gt; maxVariance) &#123; maxVariance = variance; threshold = i; &#125; &#125; return threshold; &#125;]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[特征提取——纹理特征]]></title>
    <url>%2F2018%2F07%2F16%2F%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96_%E7%BA%B9%E7%90%86%E7%89%B9%E5%BE%81%2F</url>
    <content type="text"><![CDATA[特征提取——纹理特征 LBP图像特征图像处理之特征提取（二）之LBP特征简单梳理https://blog.csdn.net/coming_is_winter/article/details/72859957https://blog.csdn.net/zouxy09/article/details/7929531LBP特征理解。http://blog.csdn.net/hqh45/article/details/24501097LBP（Local Binary Pattern，局部二值模式）是一种用来描述图像局部纹理特征的算子；它具有旋转不变性和灰度不变性等显著的优点。它是首先由T. Ojala, M.Pietikäinen, 和 D. Harwood 在1994年提出，用于纹理特征提取。而且，提取的特征是图像的局部的纹理特征；12lbp理论：原始的LBP算子定义为在3*3的窗口内，以窗口中心像素为阈值，将相邻的8个像素的灰度值与其进行比较，若周围像素值大于中心像素值，则该像素点的位置被标记为1，否则为0。这样，3*3邻域内的8个点经比较可产生8位二进制数（通常转换为十进制数即LBP码，共256种），即得到该窗口中心像素点的LBP值，并用这个值来反映该区域的纹理信息。 圆形LBP算子： 半径为R1基本的 LBP算子的最大缺陷在于它只覆盖了一个固定半径范围内的小区域，这显然不能满足不同尺寸和频率纹理的需要。为了适应不同尺度的纹理特征，并达到灰度和旋转不变性的要求，Ojala等对 LBP 算子进行了改进，将 3×3邻域扩展到任意邻域，并用圆形邻域代替了正方形邻域，改进后的 LBP 算子允许在半径为 R 的圆形邻域内有任意多个像素点。从而得到了诸如半径为R的圆形区域内含有P个采样点的LBP算子； 即不断旋转圆形邻域得到一系列初始定义的 LBP值，取其最小值作为该邻域的 LBP 值。 灰度共生矩阵（GLCM，Gray-Level Co-occurrence Matrix）概念： 灰度共生矩阵是涉及像素距离和角度的矩阵函数，它通过计算图像中一定距离和一定方向的两点灰度之间的相关性，来反映图像在方向、间隔、变化幅度及快慢上的综合信息。灰度直方图是对图像上单个像素具有某个灰度进行统计的结果，而灰度共生矩阵是对图像上保持某距离的两像素分别具有某灰度的状况进行统计得到的。 含义：以（1，1）点为例，GLCM（1，1）值为1说明左侧原图只有一对灰度为1的像素水平相邻。GLCM（1，2）值为2，是因为原图有两对灰度为1和2的像素水平相邻。 1234567891011矩阵|1 2 1||2 2 2| |1 2 2|对应GLMC矩阵（最大是2，所以是2*2矩阵）GLCM矩阵: 1 21|0 2| 2|1 6|0(1,1)相邻， 2(1,2)水平相邻， 2(2,1)垂直相邻， 6(2,2)相邻 灰度共生矩阵的特征 1) 角二阶矩（Angular Second Moment, ASM)公式：$ASM = sum(p(i,j)^2)$，其中 $p(i,j) $表示归一后的灰度共生矩阵意义：角二阶矩是图像灰度分布均匀程度和纹理粗细的一个度量，当图像纹理绞细致、灰度分布均匀时，能量值较大，反之，较小。 结论：值大，灰度分布均匀 2) 熵（Entropy, ENT)公式：$ENT=sum[-p(i,j)log(p(i,j))] $意义：描述图像具有的信息量的度量，表明图像的复杂程度，当复杂程度高时，熵值较大，反之则较小。 结论：值大，复杂程度高 3) 反差分矩阵（Inverse Differential Moment, IDM)公式：$IDM=sum[p(i,j)/(1+(i-j)^2)]$意义：反映了纹理的清晰程度和规则程度，纹理清晰、规律性较强、易于描述的，值较大；杂乱无章的，难于描述的，值较小。 结论：值大，纹理清晰、规律性较强 Gabor小波Gabor函数是一个用于边缘提取的线性滤波器 作用：Gabor小波可以方便的提取图像在各个尺度和方向上的纹理信息，同时在一定程度上降低了图像中光照变化和噪声的影响。提取目标的局部空间和频率域信息方面具有良好的特性。特点：1、Gabor小波对于图像的边缘敏感2、对光照不敏感3、对图像旋转有一定适应性 灰度共生矩阵opencv代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151// 0°灰度共生矩阵void getGLCM0(Mat&amp; src, Mat&amp; dst, int gray_level)// 0度灰度共生矩阵&#123; CV_Assert(1 == src.channels()); int height = src.rows; int width = src.cols; dst.create(gray_level, gray_level, CV_32SC1); dst = Scalar::all(0); for (int i = 0; i &lt; height; i++) &#123; int*srcdata = src.ptr&lt;int&gt;(i); for (int j = 0; j &lt; width - 1; j++) &#123; // 同样的像素对，水平相邻 int rows = srcdata[j]; int cols = srcdata[j + 1]; dst.ptr&lt;int&gt;(rows)[cols]++; &#125; &#125; &#125; // 90°灰度共生矩阵void getGLCM90(Mat&amp; src, Mat&amp; dst, int gray_level)&#123; CV_Assert(1 == src.channels()); int height = src.rows; int width = src.cols; dst = Mat(gray_level, gray_level, CV_32SC1, Scalar(0)); for (int i = 0; i &lt; height - 1; i++) &#123; int*srcdata = src.ptr&lt;int&gt;(i); int*srcdata1 = src.ptr&lt;int&gt;(i + 1); for (int j = 0; j &lt; width; j++) &#123; // 同样的像素对，垂直相邻 int rows = srcdata[j]; int cols = srcdata1[j]; dst.ptr&lt;int&gt;(rows)[cols]++; &#125; &#125;&#125; // 45°灰度共生矩阵void getGLCM45(Mat&amp; src, Mat&amp; dst, int gray_level)&#123; CV_Assert(1 == src.channels()); int height = src.rows; int width = src.cols; dst = Mat(gray_level, gray_level, CV_32SC1, Scalar(0)); for (int i = 0; i &lt; height - 1; i++) &#123; int*srcdata = src.ptr&lt;int&gt;(i); int*srcdata1 = src.ptr&lt;int&gt;(i + 1); for (int j = 0; j &lt; width - 1; j++) &#123; // 同样的像素对，45°相邻 int rows = srcdata[j]; int cols = srcdata1[j + 1]; dst.ptr&lt;int&gt;(rows)[cols]++; &#125; &#125;&#125; // 135°灰度共生矩阵void getGLCM135(Mat&amp; src, Mat&amp; dst, int gray_level)&#123; CV_Assert(1 == src.channels()); int height = src.rows; int width = src.cols; dst = Mat(gray_level, gray_level, CV_32SC1, Scalar(0)); for (int i = 0; i &lt; height - 1; i++) &#123; int*srcdata = src.ptr&lt;int&gt;(i); int*srcdata1 = src.ptr&lt;int&gt;(i + 1); for (int j = 1; j &lt; width; j++) &#123; // 同样的像素对，135°相邻 int rows = srcdata[j]; int cols = srcdata1[j - 1]; dst.ptr&lt;int&gt;(rows)[cols]++; &#125; &#125; &#125; // 计算特征值void featureGLCM(Mat&amp;src, double&amp; Asm, double&amp; Ent, double&amp; Con, double&amp; Idm)&#123; CV_Assert(src.channels() == 1); int height = src.rows; int width = src.cols; int total = 0; //求图像所有像素的灰度值的和 for (int i = 0; i &lt; height; i++) &#123; int*srcdata = src.ptr&lt;int&gt;(i); for (int j = 0; j &lt; width; j++) &#123; total += srcdata[j]; &#125; &#125; //图像每一个像素的的值除以像素总和 Mat mean; mean.create(height, width, CV_64FC1); for (int i = 0; i &lt; height; i++) &#123; int*srcdata = src.ptr&lt;int&gt;(i); double*copydata = mean.ptr&lt;double&gt;(i); for (int j = 0; j &lt; width; j++) &#123; copydata[j] = (double)srcdata[j] / (double)total; &#125; &#125; for (int i = 0; i &lt; height; i++) &#123; double*srcdata = mean.ptr&lt;double&gt;(i); for (int j = 0; j &lt; width; j++) &#123; // 能量 Asm += srcdata[j] * srcdata[j]; // 熵(Entropy) if (srcdata[j]&gt;0) Ent -= srcdata[j] * log(srcdata[j]); // 对比度 Con += (double)(i - j)*(double)(i - j)*srcdata[j]; // 逆差矩 Idm += srcdata[j] / (1 + (double)(i - j)*(double)(i - j)); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>图像处理</tag>
        <tag>特征提取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试之九阴真经]]></title>
    <url>%2F2018%2F07%2F15%2FJava_%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Java面试相关 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510谈谈final, finally, finalize的区别： final：：：修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载 finally：：：再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。 finalize：：：方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)：匿名的内部类是没有名字的内部类。不能extends(继承) 其它类，但一个内部类可以作为一个接口，由另一个内部类实现。&amp;和&amp;&amp;的区别： &amp;是位运算符。&amp;&amp;是布尔逻辑运算符。HashMap和Hashtable的区别： 都属于Map接口的类，实现了将惟一键映射到特定的值上。 HashMap 类没有分类或者排序。它允许一个 null 键和多个 null 值。 Hashtable 类似于 HashMap，但是不允许 null 键和 null 值。它也比 HashMap 慢，因为它是同步的。Collection 和 Collections的区别：Collections是个java.util下的类，它包含有各种有关集合操作的静态方法。 Collection是个java.util下的接口，它是各种集合结构的父接口。GC是什么? 为什么要有GC? (基础)： GC是垃圾收集器。Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一： System.gc() Runtime.getRuntime().gc()。String s = new String(&quot;xyz&quot;);创建了几个String Object： 两个对象，一个是“xyx”,一个是指向“xyx”的引用对象s。Math.round(11.5)等於多少? Math.round(-11.5)等於多少： Math.round(11.5)返回（long）12，Math.round(-11.5)返回（long）-11。short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错： short s1 = 1; s1 = s1 + 1;有错，s1是short型，s1+1是int型,不能显式转化为short型。可修改为s1 =(short)(s1 + 1) 。short s1 = 1; s1 += 1正确。sleep() 和 wait() 有什么区别： sleep()方法是使线程停止一段时间的方法。在sleep 时间间隔期满后，线程不一定立即恢复执行。这是因为在那个时刻，其它线程可能正在运行而且没有被调度为放弃执行，除非(a)“醒来”的线程具有更高的优先级 (b)正在运行的线程因为其它原因而阻塞。 wait()是线程交互时，如果线程对一个同步对象x 发出一个wait()调用，该线程会暂停执行，被调对象进入等待状态，直到被唤醒或等待时间到。数组有没有length()这个方法? String有没有length()这个方法： 数组没有length()这个方法，有length的属性。 String有有length()这个方法。Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型： 方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别：Set里的元素是不能重复的，那么用iterator()方法来区分重复与否。equals()是判读两个Set是否相等。 equals()和==方法决定引用值是否指向同一对象equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值。给我一个你最常见到的runtime exception： ArithmeticException, ArrayStoreException, BufferOverflowException, BufferUnderflowException, CannotRedoException, CannotUndoException, ClassCastException, CMMException, ConcurrentModificationException, DOMException, EmptyStackException, IllegalArgumentException, IllegalMonitorStateException, IllegalPathStateException, IllegalStateException, ImagingOpException, IndexOutOfBoundsException, MissingResourceException, NegativeArraySizeException, NoSuchElementException, NullPointerException, ProfileDataException, ProviderException, RasterFormatException, SecurityException, SystemException, UndeclaredThrowableException, UnmodifiableSetException, UnsupportedOperationException。 error和exception有什么区别： error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。 exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。List, Set, Map是否继承自Collection接口： List，Set是。Map不是。abstract class和interface有什么区别： 声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。 接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete class)： 接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承实体类，但前提是实体类必须有明确的构造函数。启动一个线程是用run()还是start()： 启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。构造器Constructor是否可被override： 构造器Constructor不能被继承，因此不能重写Overriding，但可以被重载Overloading。try &#123;&#125;里有一个return语句，那么紧跟在这个try后的finally &#123;&#125;里的code会不会被执行，什么时候被执行，在return前还是后： 会执行，在return前执行。两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对： 不对，有相同的hash code。当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递： 是值传递。Java 编程语言只由值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上： switch（expr1）中，expr1是一个整数表达式。因此传递给 switch 和 case 语句的参数应该是 int、 short、 char 或者 byte。long,string 都不能作用于swtich。编程题: 写一个Singleton出来： Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。 一般Singleton模式通常有几种种形式： 第一种形式：定义一个类，它的构造函数为private的，它有一个static的private的该类变量，在类初始化时实例话，通过一个public的getInstance方法获取对它的引用,继而调用其中的方法。 public class Singleton &#123; private Singleton()&#123;&#125; //在自己内部定义自己一个实例，是不是很奇怪？ //注意这是private 只供内部调用 private static Singleton instance = new Singleton(); //这里提供了一个供外部访问本class的静态方法，可以直接访问 public static Singleton getInstance() &#123; return instance; &#125; &#125; 第二种形式： public class Singleton &#123; private static Singleton instance = null; public static synchronized Singleton getInstance() &#123; //这个方法比上面有所改进，不用每次都进行生成对象，只是第一次 //使用时生成实例，提高了效率！ if (instance==null) instance＝new Singleton(); return instance; &#125; &#125; 其他形式： 定义一个类，它的构造函数为private的，所有方法为static的。 一般认为第一种形式要更加安全些。Hashtable和HashMap的区别： Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现 HashMap允许将null作为一个entry的key或者value，而Hashtable不允许 还有就是，HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。 最大的不同是，Hashtable的方法是Synchronize的，而HashMap不是，在 多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。 Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异作用域public,private,protected,以及不写时的区别： 作用域 当前类 同一package 子孙类 其他package public √ √ √ √ protected √ √ √ × friendly √ √ × × private √ × × × 不写时默认为friendly。ArrayList和Vector的区别,HashMap和Hashtable的区别： 答：就ArrayList与Vector主要从二方面来说. 一.同步性:Vector是线程安全的，也就是说是同步的，而ArrayList是线程序不安全的，不是同步的 二.数据增长:当需要增长时,Vector默认增长为原来一培，而ArrayList却是原来的一半 就HashMap与HashTable主要从三方面来说。 一.历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 二.同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 三.值：只有HashMap可以让你将空值作为一个表的条目的key或value。char型变量中能不能存贮一个中文汉字?为什么： 答：是能够定义成为一个中文的，因为java中以unicode编码，一个char占16个字节，所以放一个中文是没问题的。介绍JAVA中的Collection FrameWork(包括如何写自己的数据结构)： 答：Collection FrameWork如下： Collection ├List │├LinkedList │├ArrayList │└Vector │ └Stack └Set Map ├Hashtable ├HashMap └WeakHashMap Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements） Map提供key到value的映射。jsp有哪些内置对象?作用分别是什么： 答:JSP共有以下9种基本内置组件（可与ASP的6种内部组件相对应）： request 用户端请求，此请求会包含来自GET/POST请求的参数 response 网页传回用户端的回应 pageContext 网页的属性是在这里管理 session 与请求有关的会话期 application servlet 正在执行的内容 out 用来传送回应的输出 config servlet的构架部件 page JSP网页本身 exception 针对错误网页，未捕捉的例外。jsp有哪些动作?作用分别是什么：答:JSP共有以下6种基本动作 jsp:include：在页面被请求的时候引入一个文件。 jsp:useBean：寻找或者实例化一个JavaBean。 jsp:setProperty：设置JavaBean的属性。 jsp:getProperty：输出某个JavaBean的属性。 jsp:forward：把请求转到一个新的页面。 jsp:plugin：根据浏览器类型为Java插件生成OBJECT或EMBED标记。JSP中动态INCLUDE与静态INCLUDE的区别： 答：动态INCLUDE用jsp:include动作实现 &lt;jsp:include page=&quot;included.jsp&quot; flush=&quot;true&quot; /&gt; 它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数 静态INCLUDE用include伪码实现,定不会检查所含文件的变化，适用于包含静态页面 &lt;%@ include file=&quot;included.htm&quot; %&gt;。 两种跳转方式分别是什么?有什么区别： 答：有两种，分别为： &lt;jsp:include page=&quot;included.jsp&quot; flush=&quot;true&quot;&gt; &lt;jsp:forward page= &quot;nextpage.jsp&quot;/&gt; 前者页面不会转向include所指的页面，只是显示该页的结果，主页面还是原来的页面。执行完后还会回来，相当于函数调用。并且可以带参数.后者完全转向新页面，不会再回来。相当于go to 语句。说一说Servlet的生命周期： 答:servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。JAVA SERVLET API中forward() 与redirect()的区别： 答:前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；后者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。所以，前者更加高效，在前者可以满足需要时，尽量使用forward()方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用sendRedirect()方法。Servlet的基本架构： public class ServletName extends HttpServlet &#123; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125; &#125; 可能会让你写一段Jdbc连Oracle的程序,并实现数据查询： 答:程序如下： package hello.ant; import java.sql.*; public class jdbc &#123; String dbUrl=&quot;jdbc:oracle:thin:@127.0.0.1:1521:orcl&quot;; String theUser=&quot;admin&quot;; String thePw=&quot;manager&quot;; Connection c=null; Statement conn; ResultSet rs=null; public jdbc() &#123; try&#123; Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;).newInstance(); c = DriverManager.getConnection(dbUrl,theUser,thePw); conn=c.createStatement(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public boolean executeUpdate(String sql) &#123; try &#123; conn.executeUpdate(sql); return true; &#125; catch (SQLException e) &#123; e.printStackTrace(); return false; &#125; &#125; public ResultSet executeQuery(String sql) &#123; rs=null; try &#123; rs=conn.executeQuery(sql); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return rs; &#125; public void close() &#123; try &#123; conn.close(); c.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; ResultSet rs; jdbc conn = new jdbc(); rs=conn.executeQuery(&quot;select * from test&quot;); try&#123; while (rs.next()) &#123; System.out.println(rs.getString(&quot;id&quot;)); System.out.println(rs.getString(&quot;name&quot;)); &#125; &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; Class.forName的作用?为什么要用： 答：调用该访问返回一个以字符串指定类名的类的对象。Jdo是什么： 答:JDO是Java对象持久化的新的规范，为java data object的简称,也是一个用于存取某种数据仓库中的对象的标准化API。JDO提供了透明的对象存储，因此对开发人员来说，存储数据对象完全不需要额外的代码（如JDBC API的使用）。这些繁琐的例行工作已经转移到JDO产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上。另外，JDO很灵活，因为它可以在任何数据底层上运行。JDBC只是面向关系数据库（RDBMS）JDO更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML以及对象数据库（ODBMS）等等，使得应用可移植性更强。xml有哪些解析技术?区别是什么： 答:有DOM,SAX,STAX等 DOM:处理大型文件时其性能下降的非常厉害。这个问题是由DOM的树结构所造成的，这种结构占用的内Java程序员面试之九阴真经 - wyf0931 - 河伯的地盘存较多，而且DOM必须在解析文件之前把整个文档装入内存,适合对XML的随机访问SAX:不现于DOM,SAX是事件驱动型的XML解析方式。它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺序访问 STAX:Streaming API for XML (StAX)。你在项目中用到了xml技术的哪些方面?如何实现的： 答:用到了数据存贮，信息配置两方面。在做数据交换平台时，将不能数据源的数据组装成XML文件，然后将XML文件压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再同XML文件中还原相关信息进行处理。在做软件配置时，利用XML可以很方便的进行，软件的各种配置参数都存贮在XML文件中。用jdom解析xml文件时如何解决中文问题?如何解析： 答:看如下代码,用编码方式加以解决 package test; import java.io.*; public class DOMTest &#123; private String inFile = &quot;c:\people.xml&quot;; private String outFile = &quot;c:\people.xml&quot;; public static void main(String args[]) &#123; new DOMTest(); &#125; public DOMTest() &#123; try &#123; javax.xml.parsers.DocumentBuilder builder = javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder(); org.w3c.dom.Document doc = builder.newDocument(); org.w3c.dom.Element root = doc.createElement(&quot;老师&quot;); org.w3c.dom.Element wang = doc.createElement(&quot;王&quot;); org.w3c.dom.Element liu = doc.createElement(&quot;刘&quot;); wang.appendChild(doc.createTextNode(&quot;我是王老师&quot;)); root.appendChild(wang); doc.appendChild(root); javax.xml.transform.Transformer transformer = javax.xml.transform.TransformerFactory.newInstance().newTransformer(); transformer.setOutputProperty(javax.xml.transform.OutputKeys.ENCODING, &quot;gb2312&quot;); transformer.setOutputProperty(javax.xml.transform.OutputKeys.INDENT, &quot;yes&quot;); transformer.transform(new javax.xml.transform.dom.DOMSource(doc), new javax.xml.transform.stream.StreamResult(outFile)); &#125; catch (Exception e) &#123; System.out.println (e.getMessage()); &#125; &#125; &#125;``编程用JAVA解析XML的方式： 答:用SAX方式解析XML，XML文件如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;gb2312&quot;?&gt; &lt;person&gt; &lt;name&gt;王小明&lt;/name&gt; &lt;college&gt;信息学院&lt;/college&gt; &lt;telephone&gt;6258113&lt;/telephone&gt; &lt;notes&gt;男,1955年生,博士，95年调入海南大学&lt;/notes&gt; &lt;/person&gt; 事件回调类SAXHandler.java import java.io.*; import java.util.Hashtable; import org.xml.sax.*; public class SAXHandler extends HandlerBase &#123; private Hashtable table = new Hashtable(); private String currentElement = null; private String currentValue = null; public void setTable(Hashtable table) &#123; this.table = table; &#125; public Hashtable getTable() &#123; return table; &#125; public void startElement(String tag, AttributeList attrs) throws SAXException &#123; currentElement = tag; &#125; public void characters(char[] ch, int start, int length) throws SAXException &#123; currentValue = new String(ch, start, length); &#125; public void endElement(String name) throws SAXException &#123; if (currentElement.equals(name)) table.put(currentElement, currentValue); &#125; &#125; JSP内容显示源码,SaxXml.jsp: &lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;剖析XML文件people.xml&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;%@ page errorPage=&quot;ErrPage.jsp&quot; contentType=&quot;text/html;charset=GB2312&quot; %&gt; &lt;%@ page import=&quot;java.io.*&quot; %&gt; &lt;%@ page import=&quot;java.util.Hashtable&quot; %&gt; &lt;%@ page import=&quot;org.w3c.dom.*&quot; %&gt; &lt;%@ page import=&quot;org.xml.sax.*&quot; %&gt; &lt;%@ page import=&quot;javax.xml.parsers.SAXParserFactory&quot; %&gt; &lt;%@ page import=&quot;javax.xml.parsers.SAXParser&quot; %&gt; &lt;%@ page import=&quot;SAXHandler&quot; %&gt; &lt;% File file = new File(&quot;c:\people.xml&quot;); FileReader reader = new FileReader(file); Parser parser; SAXParserFactory spf = SAXParserFactory.newInstance(); SAXParser sp = spf.newSAXParser(); SAXHandler handler = new SAXHandler(); sp.parse(new InputSource(reader), handler); Hashtable hashTable = handler.getTable(); out.println(&quot;&lt;TABLE BORDER=2&gt;&lt;CAPTION&gt;教师信息表&lt;/CAPTION&gt;&quot;); out.println(&quot;&lt;TR&gt;&lt;TD&gt;姓名&lt;/TD&gt;&quot; + &quot;&lt;TD&gt;&quot; + (String)hashTable.get(new String(&quot;name&quot;)) + &quot;&lt;/TD&gt;&lt;/TR&gt;&quot;); out.println(&quot;&lt;TR&gt;&lt;TD&gt;学院&lt;/TD&gt;&quot; + &quot;&lt;TD&gt;&quot; + (String)hashTable.get(new String(&quot;college&quot;))+&quot;&lt;/TD&gt;&lt;/TR&gt;&quot;); out.println(&quot;&lt;TR&gt;&lt;TD&gt;电话&lt;/TD&gt;&quot; + &quot;&lt;TD&gt;&quot; + (String)hashTable.get(new String(&quot;telephone&quot;)) + &quot;&lt;/TD&gt;&lt;/TR&gt;&quot;); out.println(&quot;&lt;TR&gt;&lt;TD&gt;备注&lt;/TD&gt;&quot; + &quot;&lt;TD&gt;&quot; + (String)hashTable.get(new String(&quot;notes&quot;)) + &quot;&lt;/TD&gt;&lt;/TR&gt;&quot;); out.println(&quot;&lt;/TABLE&gt;&quot;); %&gt; &lt;/BODY&gt; &lt;/HTML&gt; EJB与JAVA BEAN的区别： 答:Java Bean 是可复用的组件，对Java Bean并没有严格的规范，理论上讲，任何一个Java类都可以是一个Bean。但通常情况下，由于Java Bean是被容器所创建（如Tomcat）的，所以Java Bean应具有一个无参的构造器，另外，通常Java Bean还要实现Serializable接口用于实现Bean的持久性。Java Bean实际上相当于微软COM模型中的本地进程内COM组件，它是不能被跨进程访问的。Enterprise Java Bean 相当于DCOM，即分布式组件。它是基于Java的远程方法调用（RMI）技术的，所以EJB可以被远程访问（跨进程、跨计算机）。但EJB必须被布署在诸如Webspere、WebLogic这样的容器中，EJB客户从不直接访问真正的EJB组件，而是通过其容器访问。EJB容器是EJB组件的代理，EJB组件由容器所创建和管理。客户通过容器来访问真正的EJB组件。EJB的基本架构： 答:一个EJB包括三个部分: Remote Interface 接口的代码 package Beans; import javax.ejb.EJBObject; import java.rmi.RemoteException; public interface Add extends EJBObject &#123; //some method declare &#125; Home Interface 接口的代码 package Beans; import java.rmi.RemoteException; import jaax.ejb.CreateException; import javax.ejb.EJBHome; public interface AddHome extends EJBHome &#123; //some method declare &#125; EJB类的代码 package Beans; import java.rmi.RemoteException; import javax.ejb.SessionBean; import javx.ejb.SessionContext; public class AddBean Implements SessionBean &#123; //some method declare &#125; MVC的各个部分都有那些技术来实现?如何实现： 答:MVC是Model－View－Controller的简写。&quot;Model&quot; 代表的是应用的业务逻辑（通过JavaBean，EJB组件实现）， &quot;View&quot; 是应用的表示面（由JSP页面产生），&quot;Controller&quot; 是提供应用的处理过程控制（一般是一个Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。J2EE是什么： 答:Je22是Sun公司提出的多层(multi-diered),分布式(distributed),基于组件(component-base)的企业级应用模型(enterpriese application model).在这样的一个应用系统中，可按照功能划分为不同的组件，这些组件又可在不同计算机上，并且处于相应的层次(tier)中。所属层次包括客户层(clietn tier)组件,web层和组件,Business层和组件,企业信息系统(EIS)层。WEB SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释： 答：Web Service描述语言WSDL SOAP即简单对象访问协议(Simple Object Access Protocol)，它是用于交换XML编码信息的轻量级协议。 UDDI 的目的是为电子商务建立标准；UDDI是一套基于Web的、分布式的、为Web Service提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web Service注册，以使别的企业能够发现的访问协议的实现标准。STRUTS的应用(如STRUTS架构) ：答：Struts是采用Java Servlet/JavaServer Pages技术，开发Web应用程序的开放源码的framework。 采用Struts能开发出基于MVC(Model-View-Controller)设计模式的应用构架。 Struts有如下的主要功能： 一.包含一个controller servlet，能将用户的请求发送到相应的Action对象。 二.JSP自由tag库，并且在controller servlet中提供关联支持，帮助开发员创建交互式表单应用。 三.提供了一系列实用对象：XML处理、通过Java reflection APIs自动处理JavaBeans属性、国际化的提示和消息。开发中都用到了那些设计模式?用在什么场合：答：每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心。通过这种方式，你可以无数次地使用那些已有的解决方案，无需在重复相同的工作。主要用到了MVC的设计模式。用来开发JSP/Servlet或者J2EE的相关应用。简单工厂模式等。存储过程和函数的区别：存储过程是用户定义的一系列sql语句的集合，涉及特定表或其它对象的任务，用户可以调用存储过程，而函数通常是数据库已定义的方法，它接收参数并返回某种类型的值并且不涉及特定用户表。事务是什么：事务是作为一个逻辑单元执行的一系列操作，一个逻辑工作单元必须有四个属性，称为 ACID（原子性、一致性、隔离性和持久性）属性，只有这样才能成为一个事务：原子性：事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。一致性：事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。事务结束时，所有的内部数据结构（如 B 树索引或双向链表）都必须是正确的。隔离性：由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。这称为可串行性，因为它能够重新装载起始数据，并且重播一系列事务，以使数据结束时的状态与原始事务执行的状态相同。持久性：事务完成之后，它对于系统的影响是永久性的。该修改即使出现系统故障也将一直保持。游标的作用？如何知道游标已经到了最后：游标用于定位结果集的行，通过判断全局变量@@FETCH_STATUS可以判断是否到了最后，通常此变量不等于0表示出错或到了最后。触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何区别：事前触发器运行于触发事件发生之前，而事后触发器运行于触发事件发生之后。通常事前触发器可以获取事件之前和新的字段值。语句级触发器可以在语句执行前或后执行，而行级触发在触发器所影响的每一行触发一次。bean 实例的生命周期： 对于Stateless Session Bean、Entity Bean、Message Driven Bean一般存在缓冲池管理，而对于Entity Bean和Statefull Session Bean存在Cache管理，通常包含创建实例，设置上下文、创建EJB Object（create）、业务方法调用、remove等过程，对于存在缓冲池管理的Bean，在create之后实例并不从内存清除，而是采用缓冲池调度机制不断重用实例，而对于存在Cache管理的Bean则通过激活和去激活机制保持Bean的状态并限制内存中实例数量。remote接口和home接口主要作用： remote接口定义了业务方法，用于EJB客户端调用业务方法 home接口是EJB工厂用于创建和移除查找EJB实例。客服端调用EJB对象的几个基本步骤：一、 设置JNDI服务工厂以及JNDI服务地址系统属性。二、 查找Home接口。三、 从Home接口调用Create方法创建Remote接口。四、 通过Remote接口调用其业务方法。什么时候用assert： 断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为 true。如果表达式计算为 false，那么系统会报告一个 AssertionError。它用于调试目的： assert(a &gt; 0); // throws an AssertionError if a &lt;= 0 断言可以有两种形式： assert Expression1 ; assert Expression1 : Expression2 ; Expression1 应该总是产生一个布尔值。 Expression2 可以是得出一个值的任意表达式。这个值用于生成显示更多调试信息的 String 消息。 断言在默认情况下是禁用的。要在编译时启用断言，需要使用 source 1.4 标记： javac -source 1.4 Test.java 要在运行时启用断言，可使用 -enableassertions 或者 -ea 标记。 要在运行时选择禁用断言，可使用 -da 或者 -disableassertions 标记。 要系统类中启用断言，可使用 -esa 或者 -dsa 标记。还可以在包的基础上启用或者禁用断言。 可以在预计正常情况下不会到达的任何位置上放置断言。断言可以用于验证传递给私有方法的参数。不过，断言不应该用于验证传递给公有方法的参数，因为不管是否启用了断言，公有方法都必须检查其参数。不过，既可以在公有方法中，也可以在非公有方法中利用断言测试后置条件。另外，断言不应该以任何方式改变程序的状态。是否可以继承String类： String类是final类故不可以继承。面向对象的特征有哪些方面：抽象：抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。继承：继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。多态性：多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。String是最基本的数据类型吗：基本数据类型包括byte、int、char、long、float、double、boolean和short。java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类。String 和StringBuffer的区别：JAVA平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffers来动态构造字符数据。说出ArrayList,Vector, LinkedList的存储性能和特性：ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。同步和异步有何异同，在什么情况下分别使用他们？举例说明。如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。heap和stack有什么区别：栈是一种线形集合，其添加和删除元素的操作应在同一段完成。栈按照后进先出的方式进行处理。堆是栈的一个组成元素。EJB与JAVA BEAN的区别:java Bean 是可复用的组件，对Java Bean并没有严格的规范，理论上讲，任何一个Java类都可以是一个Bean。但通常情况下，由于Java Bean是被容器所创建（如Tomcat）的，所以Java Bean应具有一个无参的构造器，另外，通常Java Bean还要实现Serializable接口用于实现Bean的持久性。Java Bean实际上相当于微软COM模型中的本地进程内COM组件，它是不能被跨进程访问的。Enterprise Java Bean 相当于DCOM，即分布式组件。它是基于Java的远程方法调用（RMI）技术的，所以EJB可以被远程访问（跨进程、跨计算机）。但EJB必须被布署在诸如Webspere、WebLogic这样的容器中，EJB客户从不直接访问真正的EJB组件，而是通过其容器访问。EJB容器是EJB组件的代理，EJB组件由容器所创建和管理。客户通过容器来访问真正的EJB组件。Static Nested Class 和 Inner Class的不同:Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。Java的接口和C++的虚类的相同和不同处:由于Java不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，该类要实现接口里面所有的方法和属性，并且接口里面的属性在默认状态下面都是public static,所有方法默认情况下是public.一个类可以实现多个接口。你所知道的集合类都有哪些？主要方法:最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。 List 适用于按数值索引访问元素的情形。 Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作“键”和“值”），其中每个键映射到一个值。JSP的内置对象及方法:request表示HttpServletRequest对象。它包含了有关浏览器请求的信息，并且提供了几个用于获取cookie, header, 和session数据的有用的方法,response表示HttpServletResponse对象，并提供了几个用于设置送回 浏览器的响应的方法（如cookies,头信息等）. out对象是javax.jsp.JspWriter的一个实例，并提供了几个方法使你能用于向浏览器回送输出结果。 pageContext表示一个javax.servlet.jsp.PageContext对象。它是用于方便存取各种范围的名字空间、servlet相关的对象的API，并且包装了通用的servlet相关功能的方法。 session表示一个请求的javax.servlet.http.HttpSession对象。Session可以存贮用户的状态信息 applicaton 表示一个javax.servle.ServletContext对象。这有助于查找有关servlet引擎和servlet环境的信息 config表示一个javax.servlet.ServletConfig对象。该对象用于存取servlet实例的初始化参数。 page表示从该页面产生的一个servlet实例。线程的基本概念、线程的基本状态以及状态之间的关系：线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，也就是程序本身。Java中的线程有四种状态分别是：运行、就绪、挂起、结束。 JSP的常用指令： &lt;%@page language=”java” contenType=”text/html;charset=gb2312” session=”true” buffer=”64kb” autoFlush=”true” isThreadSafe=”true” info=”text” errorPage=”error.jsp” isErrorPage=”true” isELIgnored=”true” pageEncoding=”gb2312” import=”java.sql.*”%&gt; isErrorPage(是否能使用Exception对象)，isELIgnored(是否忽略表达式) &lt;%@include file=”filename”%&gt;&lt;%@taglib prefix=”c”uri=”http://……”%&gt;四种会话跟踪技术：cookie,url重写,session,隐藏域。简述逻辑操作(&amp;,|,^)与条件操作(&amp;&amp;,||)的区别：区别主要答两点：a.条件操作只能操作布尔型的,而逻辑操作不仅可以操作布尔型,而且可以操作数值型b.逻辑操作不会产生短路。Request对象的主要方法：setAttribute(String name,Object)：设置名字为name的request的参数值getAttribute(String name)：返回由name指定的属性值getAttributeNames()：返回request对象所有属性的名字集合，结果是一个枚举的实例getCookies()：返回客户端的所有Cookie对象，结果是一个Cookie数组getCharacterEncoding()：返回请求中的字符编码方式getContentLength()：返回请求的Body的长度getHeader(String name)：获得HTTP协议定义的文件头信息getHeaders(String name)：返回指定名字的request Header的所有值，结果是一个枚举的实例getHeaderNames()：返回所以request Header的名字，结果是一个枚举的实例getInputStream()：返回请求的输入流，用于获得请求中的数据getMethod()：获得客户端向服务器端传送数据的方法getParameter(String name)：获得客户端传送给服务器端的有name指定的参数值getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例getParameterValues(String name)：获得有name指定的参数的所有值getProtocol()：获取客户端向服务器端传送数据所依据的协议名称getQueryString()：获得查询字符串getRequestURI()：获取发出请求字符串的客户端地址getRemoteAddr()：获取客户端的IP地址getRemoteHost()：获取客户端的名字getSession([Boolean create])：返回和请求相关SessiongetServerName()：获取服务器的名字getServletPath()：获取客户端所请求的脚本文件的路径getServerPort()：获取服务器的端口号removeAttribute(String name)：删除请求中的一个属性J2EE是技术还是平台还是框架：J2EE本身是一个标准，一个为企业分布式应用的开发提供的标准平台。J2EE也是一个框架，包括JDBC、JNDI、RMI、JMS、EJB、JTA等技术。编写 java文件的注意事项：在记事本中编写java文件，在保存时一定要把文件名和扩展名用双引号括起来，否则将默认保存为文本文件，如果要保存的java 文件名为Program1.java,则在保存时在文件名文本框中一定要输入”Program1.java”。如何编译java程序：单击开始|运行命令，在命令行上输入cmd，按回车键（在 window98中输入command，按回车键），即可打开一个命令窗口，将目录转换到编写java源程序所在的目录，输入javac filename.java如何执行java程序：同样在命令窗口中输入java filename。简述synchronized和java.util.concurrent.locks.Lock的异同:主要相同点：Lock能完成synchronized所实现的所有功能主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。EJB的角色和三个对象：一个完整的基于EJB的分布式计算结构由六个角色组成，这六个角色可以由不同的开发商提供，每个角色所作的工作必须遵循Sun公司提供的EJB规范，以保证彼此之间的兼容性。这六个角色分别是EJB组件开发者（Enterprise Bean Provider） 、应用组合者（Application Assembler）、部署者（Deployer）、EJB 服务器提供者（EJB Server Provider）、EJB 容器提供者（EJB Container Provider）、系统管理员（System Administrator）三个对象是Remote（Local）接口、Home（LocalHome）接口，Bean类EJB容器提供的服务：主要提供声明周期管理、代码产生、持续性管理、安全、事务管理、锁和并发行管理等服务。EJB规范规定EJB中禁止的操作有哪些： 1. 不能操作线程和线程API(线程API指非线程对象的方法如notify,wait等)，2. 不能操作awt，3. 不能实现服务器功能，4. 不能对静态属生存取，5. 不能使用IO操作直接存取文件系统，6. 不能加载本地库.，7. 不能将this作为变量和返回，8. 不能循环调用。remote接口和home接口主要作用：remote接口定义了业务方法，用于EJB客户端调用业务方法。home接口是EJB工厂用于创建和移除查找EJB实例bean 实例的生命周期对于：Stateless Session Bean、Entity Bean、Message Driven Bean一般存在缓冲池管理，而对于Entity Bean和Statefull Session Bean存在Cache管理，通常包含创建实例，设置上下文、创建EJB Object（create）、业务方法调用、remove等过程，对于存在缓冲池管理的Bean，在create之后实例并不从内存清除，而是采用缓冲池调度机制不断重用实例，而对于存在Cache管理的Bean则通过激活和去激活机制保持Bean的状态并限制内存中实例数量。EJB的激活机制：以Stateful Session Bean 为例：其Cache大小决定了内存中可以同时存在的Bean实例的数量，根据MRU或NRU算法，实例在激活和去激活状态之间迁移，激活机制是当客户端调用某个EJB实例业务方法时，如果对应EJB Object发现自己没有绑定对应的Bean实例则从其去激活Bean存储中（通过序列化机制存储实例）回复（激活）此实例。状态变迁前会调用对应的ejbActive和ejbPassivate方法。EJB的几种类型：会话（Session）Bean ，实体（Entity）Bean 消息驱动的（Message Driven）Bean ；会话Bean又可分为有状态（Stateful）和无状态（Stateless）两种；实体Bean可分为Bean管理的持续性（BMP）和容器管理的持续性（CMP）两种如何给weblogic指定大小的内存：在启动Weblogic的脚本中（位于所在Domian对应服务器目录下的startServerName），增加set MEM_ARGS=-Xms32m -Xmx200m，可以调整最小内存为32M，最大200M如何设定的weblogic的热启动模式(开发模式)与产品发布模式：可以在管理控制台中修改对应服务器的启动模式为开发或产品模式之一。或者修改服务的启动文件或者commenv文件，增加set PRODUCTION_MODE=true。如何启动时不需输入用户名与密码：修改服务启动文件，增加 WLS_USER和WLS_PW项。也可以在boot.properties文件中增加加密过的用户名和密码.在weblogic管理制台中对一个应用域(或者说是一个网站,Domain)进行jms及ejb或连接池等相关信息进行配置后,实际保存在什么文件中?保存在此Domain的config.xml文件中，它是服务器的核心配置文件。说说weblogic中一个Domain的缺省目录结构?比如要将一个简单的helloWorld.jsp放入何目录下,然的在浏览器上就可打入http://主机:端口号//helloword.jsp就可以看到运行结果了? 又比如这其中用到了一个自己写的javaBean该如何办：Domain目录\服务器目录\applications，将应用目录放在此目录下将可以作为应用访问，如果是Web应用，应用目录需要满足Web应用目录要求，jsp文件可以直接放在应用目录中，Javabean需要放在应用目录的WEB-INF目录的classes目录中，设置服务器的缺省应用将可以实现在浏览器上无需输入应用名。在weblogic中发布ejb需涉及到哪些配置文件：不同类型的EJB涉及的配置文件不同，都涉及到的配置文件包括ejb-jar.xml,weblogic-ejb-jar.xmlCMP实体Bean一般还需要weblogic-cmp-rdbms-jar.xml 如何在weblogic中进行ssl配置与客户端的认证配置或说说j2ee(标准)进行ssl的配置：缺省安装中使用DemoIdentity.jks和DemoTrust.jks KeyStore实现SSL，需要配置服务器使用Enable SSL，配置其端口，在产品模式下需要从CA获取私有密钥和数字证书，创建identity和trust keystore，装载获得的密钥和数字证书。可以配置此SSL连接是单向还是双向的。如何查看在weblogic中已经发布的EJB：可以使用管理控制台，在它的Deployment中可以查看所有已发布的EJBCORBA是什么?用途是什么：CORBA 标准是公共对象请求代理结构(Common Object Request Broker Architecture)，由对象管理组织 (Object Management Group，缩写为 OMG)标准化。它的组成是接口定义语言(IDL), 语言绑定(binding:也译为联编)和允许应用程序间互操作的协议。 其目的为：用不同的程序设计语言书写在不同的进程中运行，为不同的操作系统开发。说说你所熟悉或听说过的j2ee中的几种常用模式?及对设计模式的一些看法： Session Facade Pattern：使用SessionBean访问EntityBean；Message Facade Pattern：实现异步调用；EJB Command Pattern：使用Command JavaBeans取代SessionBean，实现轻量级访问；Data Transfer Object Factory：通过DTO Factory简化EntityBean数据提供特性；Generic Attribute Access：通过AttibuteAccess接口简化EntityBean数据提供特性；Business Interface：通过远程（本地）接口和Bean类实现相同接口规范业务逻辑一致性；ＥＪＢ架构的设计好坏将直接影响系统的性能、可扩展性、可维护性、组件可重用性及开发效率。项目越复杂，项目队伍越庞大则越能体现良好设计的重要性。说说在weblogic中开发消息Bean时的persistent与non-persisten的差别：persistent方式的MDB可以保证消息传递的可靠性,也就是如果EJB容器出现问题而JMS服务器依然会将消息在此MDB可用的时候发送过来，而non－persistent方式的消息将被丢弃。常用的设计模式？说明工厂模式： Java中的23种设计模式：Factory（工厂模式），Builder（建造模式）， Factory Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式）， Facade（门面模式），Adapter（适配器模式）， Bridge（桥梁模式）， Composite（合成模式），Decorator（装饰模式）， Flyweight（享元模式）， Proxy（代理模式），Command（命令模式）， Interpreter（解释器模式）， Visitor（访问者模式），Iterator（迭代子模式）， Mediator（调停者模式）， Memento（备忘录模式），Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibleity（责任链模式）。工厂模式：工厂模式是一种经常被使用到的模式，根据工厂模式实现的类可以根据提供的数据生成一组类中某一个类的实例，通常这一组类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作。首先需要定义一个基类，该类的子类通过不同的方法实现了基类中的方法。然后需要定义一个工厂类，工厂类可以根据条件生成不同的子类实例。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。请对以下在J2EE中常用的名词进行解释(或简单描述):web容器：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使JSP,SERVLET直接更容器中的环境变量接口交互，不必关注其它系统问题。主要有WEB服务器来实现。例如：TOMCAT,WEBLOGIC,WEBSPHERE等。该容器提供的接口严格遵守J2EE规范中的WEB APPLICATION 标准。我们把遵守以上标准的WEB服务器就叫做J2EE中的WEB容器。EJB容器：Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。JNDI：（Java Naming &amp; Directory Interface）JAVA命名目录服务。主要提供的功能是：提供一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。JMS：（Java Message Service）JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。JTA：（Java Transaction API）JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。JAF：（Java Action FrameWork）JAVA安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。RMI/IIOP:（Remote Method Invocation /internet对象请求中介协议）他们主要用于通过远程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI是JAVA特有的。一个“.java”源文件中是否可以包括多个类（不是内部类）？有什么限制：可以。必须只有一个类名与文件名相同。MVC的各个部分都有那些技术来实现?如何实现： MVC是Model－View－Controller的简写。&quot;Model&quot; 代表的是应用的业务逻辑（通过JavaBean，EJB组件实现）， &quot;View&quot; 是应用的表示面（由JSP页面产生），&quot;Controller&quot; 是提供应用的处理过程控制（一般是一个Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用：有两种实现方法，分别是继承Thread类与实现Runnable接口用synchronized关键字修饰同步方法反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被“挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类：字节流，字符流。字节流继承于InputStream \ OutputStream，字符流继承于InputStreamReader \ OutputStreamWriter。在java.io包中还有许多其他的流，主要是为了提高性能和使用方便。java中会存在内存泄漏吗，请简单描述：会。如：int i,i2; return (i-i2); //when i为足够大的正数,i2为足够大的负数。结果会造成溢位，导致错误。java中实现多态的机制是什么：方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收：对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是&quot;可达的&quot;，哪些对象是&quot;不可达的&quot;。当GC确定一些对象为&quot;不可达&quot;时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。静态变量和实例变量的区别：static i = 10; //常量； class A a; a.i =10;//可变什么是java序列化，如何实现java序列化：序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。是否可以从一个static方法内部发出对非static方法的调用：不可以,如果其中包含对象的method()；不能保证对象初始化.写clone()方法时，通常都有一行代码，是什么：Clone 有缺省行为，super.clone();他负责产生正确大小的空间，并逐位复制。在JAVA中，如何跳出当前的多重嵌套循环：用break; return 方法。List、Map、Set三个接口，存取元素时，各有什么特点：List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素,内部排序。Map 保存key-value值，value可多值。J2EE是什么：J2EE是Sun公司提出的多层(multi-diered),分布式(distributed),基于组件(component-base)的企业级应用模型(enterpriese application model).在这样的一个应用系统中，可按照功能划分为不同的组件，这些组件又可在不同计算机上，并且处于相应的层次(tier)中。所属层次包括客户层(clietn tier)组件,web层和组件,Business层和组件,企业信息系统(EIS)层。UML方面：标准建模语言UML。用例图,静态图(包括类图、对象图和包图),行为图,交互图(顺序图,合作图),实现图。说出一些常用的类，包，接口，请各举5个常用的类：常用的类：BufferedReader BufferedWriter FileReader FileWirter String Integer；常用的包：java.lang java.awt java.io java.util java.sql；常用的接口：Remote List Map Document NodeList 开发中都用到了那些设计模式?用在什么场合:每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心。通过这种方式，你可以无数次地使用那些已有的解决方案，无需在重复相同的工作。主要用到了MVC的设计模式。用来开发JSP/Servlet或者J2EE的相关应用。简单工厂模式等。jsp有哪些动作?作用分别是什么： JSP共有以下6种基本动作： jsp:include：在页面被请求的时候引入一个文件。 jsp:useBean：寻找或者实例化一个JavaBean。 jsp:setProperty：设置JavaBean的属性。 jsp:getProperty：输出某个JavaBean的属性。 jsp:forward：把请求转到一个新的页面。 jsp:plugin：根据浏览器类型为Java插件生成OBJECT或EMBED标记。Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)： 可以继承其他类或完成其他接口，在swing编程中常用此方式。应用服务器与WEB SERVER的区别：应用服务器：Weblogic、Tomcat、Jboss； WEB SERVER：IIS、 ApacheBS与CS的联系与区别：C/S是Client/Server的缩写。服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、Informix或 SQL Server。客户端需要安装专用的客户端软件。B/Ｓ是Brower/Server的缩写，客户机上只要安装一个浏览器（Browser），如Netscape Navigator或Internet Explorer，服务器安装Oracle、Sybase、Informix或 SQL Server等数据库。在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现。浏览器通过Ｗeb Server 同数据库进行数据交互。C/S 与 B/S 区别： １． 硬件环境不同: C/S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供连接和数据交换服务； B/S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息自己管理. 有比C/S更强的适应范围, 一般只要有操作系统和浏览器就行 ２． 对安全要求不同 ：C/S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系统采用C/S 结构适宜. 可以通过B/S发布部分可公开信息.B/S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户。３． 对程序架构不同 ： C/S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑. B/S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上. 比C/S有更高的要求 B/S结构的程序架构是发展的趋势, 从MS的.Net系列的BizTalk 2000 Exchange 2000等, 全面支持网络的构件搭建的系统. SUN 和IBM推的JavaBean 构件技术等,使 B/S更加成熟. ４． 软件重用不同： C/S 程序可以不可避免的整体性考虑, 构件的重用性不如在B/S要求下的构件的重用性好. B/S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可以再利用,而不是做在墙上的石头桌子 。５． 系统维护不同 ：C/S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是再做一个全新的系统， B/S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户从网上自己下载安装就可以实现升级. ６． 处理问题不同 ：C/S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应该都是相同的系统，B/S 建立在广域网上, 面向不同的用户群, 分散地域, 这是C/S无法作到的. 与操作系统平台关系最小. ７． 用户接口不同： C/S 多是建立的Window平台上,表现方法有限,对程序员普遍要求较高，B/S 建立在浏览器上, 有更加丰富和生动的表现方式与用户交流. 并且大部分难度减低,减低开发成本. ８．信息流不同 ： C/S 程序一般是典型的中央集权的机械式处理, 交互性相对低，B/S 信息流向可变化, B-B B-C B-G等信息、流向的变化, 更像交易中心。EJB2.0有哪些内容?分别用在什么场合? EJB2.0和EJB1.1的区别：答：规范内容包括Bean提供者，应用程序装配者，EJB容器，EJB配置工具，EJB服务提供者，系统管理员。这里面，EJB容器是EJB之所以能够运行的核心。EJB容器管理着EJB的创建，撤消，激活，去活，与数据库的连接等等重要的核心工作。JSP,Servlet,EJB,JNDI,JDBC,JMS.....CORBA是什么?用途是什么： 答：CORBA 标准是公共对象请求代理结构(Common Object Request Broker Architecture)，由对象管理组织 (Object Management Group，缩写为 OMG)标准化。它的组成是接口定义语言(IDL), 语言绑定(binding:也译为联编)和允许应用程序间互操作的协议。 其目的为： 用不同的程序设计语言书写 在不同的进程中运行 为不同的操作系统开发 应该对oracle有所了解，对一些数据库的名词，应该知道词的解释:分页一 前提 希望最新的纪录在开头给你的表建立查询： 表：mytable 查询：create or replace view as mytable_view from mytable order by id desc 其中，最好使用序列号create sequence mytable_sequence 来自动增加你的纪录id号 二 源程序 &lt;%String sConn=&quot;你的连接&quot; Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;); Connection conn=DriverManager.getConnection(sConn,&quot;你的用户名&quot;,&quot;密码&quot;); Statement stmt=conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE); Statement stmtcount=conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE); ResultSet rs=stmt.executeQuery(&quot;select * from mytable_view&quot;); String sqlcount=&quot;select count(*) from mytable_view&quot;; ResultSet rscount=stmtcount.executeQuery(sqlcount); int pageSize=你的每页显示纪录数； int rowCount=0; //总的记录数 while (rscount int pageCount; //总的页数 int currPage; //当前页数 String strPage; strPage=request.getParameter(&quot;page&quot;); if (strPage==null)&#123; currPage=1; &#125; else&#123; currPage=Integer.parseInt(strPage); if (currPage&lt;1) currPage=1; &#125; pageCount=(rowCount+pageSize-1)/pageSize; if (currPage&gt;pageCount) currPage=pageCount; int thepage=(currPage-1)*pageSize; int n=0; rs.absolute(thepage+1); while (n&lt;(pageSize)&amp;&amp;!rs %&gt; &lt;%rs.close(); rscount.close(); stmt.close(); stmtcount.close(); conn.close(); %&gt; //下面是 第几页等 &lt;form name=&quot;sinfo&quot; method=&quot;post&quot; action=&quot;sbinfo_index.jsp?condition=&lt;%=condition%&gt;&amp;type=&lt;%=type%&gt;&quot; onSubmit=&quot;return testform(this)&quot;&gt; 第&lt;%=currPage%&gt;页 共&lt;%=pageCount%&gt;页 共&lt;%=rowCount%&gt;条 &lt;%if(currPage&gt;1)&#123;%&gt;&lt;a href=&quot;sbinfo_index.jsp?condition=&lt;%=condition%&gt;&amp;type=&lt;%=type%&gt;&quot;&gt;首页&lt;/a&gt;&lt;%&#125;%&gt; &lt;%if(currPage&gt;1)&#123;%&gt;&lt;a href=&quot;sbinfo_index.jsp?page=&lt;%=currPage-1%&gt;&amp;condition=&lt;%=condition%&gt;&amp;type=&lt;%=type%&gt;&quot;&gt;上一页&lt;/a&gt;&lt;%&#125;%&gt; &lt;%if(currPage&lt;pageCount)&#123;%&gt;&lt;a href=&quot;sbinfo_index.jsp?page=&lt;%=currPage+1%&gt;&amp;condition=&lt;%=condition%&gt;&amp;type=&lt;%=type%&gt;&quot;&gt;下一页&lt;/a&gt;&lt;%&#125;%&gt; &lt;%if(pageCount&gt;1)&#123;%&gt;&lt;a href=&quot;sbinfo_index.jsp?page=&lt;%=pageCount%&gt;&amp;condition=&lt;%=condition%&gt;&amp;type=&lt;%=type%&gt;&quot;&gt;尾页&lt;/a&gt;&lt;%&#125;%&gt; 跳到&lt;input type=&quot;text&quot; name=&quot;page&quot; size=&quot;4&quot; style=&quot;font-size:9px&quot;&gt;页 &lt;input type=&quot;submit&quot; name=&quot;submit&quot; size=&quot;4&quot; value=&quot;GO&quot; style=&quot;font-size:9px&quot;&gt; &lt;/form&gt; 希望大家喜欢！！！！！！ Java 的通信编程，编程题(或问答)，用JAVA SOCKET编程，读服务器几个字符，再写入本地显示： 答:Server端程序: package test; import java.net.*; import java.io.*; public class Server &#123; private ServerSocket ss; private Socket socket; private BufferedReader in; private PrintWriter out; public Server() &#123; try &#123; ss=new ServerSocket(10000); while(true) &#123; socket = ss.accept(); String RemoteIP = socket.getInetAddress().getHostAddress(); String RemotePort = &quot;:&quot;+socket.getLocalPort(); System.out.println(&quot;A client come in!IP:&quot;+RemoteIP+RemotePort); in = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line = in.readLine(); System.out.println(&quot;Cleint send is :&quot; + line); out = new PrintWriter(socket.getOutputStream(),true); out.println(&quot;Your Message Received!&quot;); out.close(); in.close(); socket.close(); &#125; &#125;catch (IOException e) &#123; out.println(&quot;wrong&quot;); &#125; &#125; public static void main(String[] args) &#123; new Server(); &#125; &#125; Client端程序: package test; import java.io.*; import java.net.*; public class Client &#123; Socket socket; BufferedReader in; PrintWriter out; public Client() &#123; try &#123; System.out.println(&quot;Try to Connect to 127.0.0.1:10000&quot;); socket = new Socket(&quot;127.0.0.1&quot;,10000); System.out.println(&quot;The Server Connected!&quot;); System.out.println(&quot;Please enter some Character:&quot;); BufferedReader line = new BufferedReader(new InputStreamReader(System.in)); out = new PrintWriter(socket.getOutputStream(),true); Out 文件读写的基本类：答：File Reader 类和FileWriter类分别继承自Reader类和Writer类。FileReader类用于读取文件，File Writer类用于将数据写入文件，这两各类在使用前，都必须要调用其构造方法创建相应的对象，然后调用相应的read()或 write()方法。托普集团程序员面试试一、选择题(每题1分，共20分)1． 下列那种语言是面向对象的（C）A. C B. PASCAL C. C++ D. FORTRAN772．在 Windows9x 下，可以进入 MS-D0S 方式。当在 DOS 提示符下键入 ( B ) 命令后，系统将退出 MS-DOS方式，返回到 WIndows 方式。 A. CLOSE B. EXIT C. QUIT D. RETURN3．下面哪些是面向对象的基本特性：( ABC)A 多态 B 继承 C 封装 D 接口4．在C++中经常要进行异常处理，下面哪些是异常处理常用到的关键词：(ABC) A try B catch C throw D break E contiue5．数据库技术中的“脏数据&apos;,是指（C）的数据。A.错误B.回返C.未提交D.未提交的随后又被撤消6．TCP/IP是一种（A,B）A.标准 B.协议 C.语言 D.算法7． 下面有关计算机操作系统的叙述中，不正确的是(B ) A 操作系统属于系统软件 B 操作系统只负责管理内存储器，而不管理外存储器 C UNIX 是一种操作系统 D 计算机的处理器、内存等硬件资源也由操作系统管理8．微机上操作系统的作用是( D) A 解释执行源程序 B 编译源程序 C 进行编码转换 D 控制和管理系统资源9．下列存储器中存取速度最快的是( A) A 内存 B 硬盘 C 光盘 D 软盘10．在计算机中，—个字节是由多少个二进制位组成的(B ) A. 4 B. 8 C. 16 D. 2411. 存储16×16点阵的一个汉字信息，需要的字节数为( A )A 32 B 64 C 128 D 25612. 以下选项中合法的字符常量是（BC）A.&quot;B&quot; B. &apos;\010&apos; C. 68 D. D13. 假定x和y为double型，则表达式x=2,y=x+3/2的值是（D）A. 3.500000 B. 3 C. 2.000000 D. 3.00000014. 以下合法的赋值语句是（BCD）//In C++ ,choice D also is correct, but in C language, D is wrong.A. x=y=100 B. d--; C. x+y; D. c=int(a+b);15. 设正x、y均为整型变量，且x=10 y=3，则以下语句pprintf(&quot;%d,%d\n&quot;,x--,--y); 的输出结果是（D）A.10,3 B. 9,3 C. 9,2 D.10,216. x、y、z被定义为int型变量，若从键盘给x、y、z输入数据，正确的输入语句是（B）A .INPUT x、y、z; B. scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);C. scanf(&quot;%d%d%d&quot;,x,y,z); D. read(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);17.以下数组定义中不正确的是（D）A) int a[2][3]; B) int b[][3]=&#123;0,1,2,3&#125;;C) int c[100][100]=&#123;0&#125;; D) int d[3][]=&#123;&#123;1,2&#125;,&#123;1,2,3&#125;,&#123;1,2,3,4&#125;&#125;;18. 以下程序的输出结果是（A）main()&#123; int a[4][4]=&#123;&#123;1,3,5&#125;,&#123;2,4,6&#125;,&#123;3,5,7&#125;&#125;;printf(&quot;%d%d%d%d\n&quot;,a[0][3],a[1][2],a[2][1],a[3][0];&#125;A) 0650 B) 1470 C) 5430 D) 输出值不定19 以下程序的输出结果是（B）main()&#123;char st[20]= &quot;hello\0\t\\\&quot;;printf(%d %d \n&quot;,strlen(st),sizeof(st));&#125;A) 9 9 B) 5 20 C) 13 20 D) 20 2020. 当调用Windows API函数InvalidateRect,将会产生什么消息（A）A:WM_PAINT B:WM_CREATE C:WM_NCHITTEST D:WM_SETFOCUS二、填空题(每题3分，共30分)1．请列举当前一些当前流行的数据库引擎,SQL SERVER,ORACLE,BDE,Microsoft Jet。2． 为了将当前盘当前目录中的所有文本文件（扩展名为.TXT）的内容打印输出，正确的单条DOS命令为COPY *.TXT PRN。3． 计算机网络分为局域网和广域网，因特网属于广域网。4. 设y是int型变量，请写出判断y为奇效的关系表达y%2！=0。5. 设有以下程序:main()&#123; int n1,n2;scanf(&quot;%d&quot;,&amp;n2);while(n2!=0)&#123; n1=n2%10;n2=n2/10;printf(&quot;%d&quot;,n1);&#125;&#125;程序运行后，如果从键盘上输入1298；则输出结果为8921。6．以下程序运行后的输出结果是:9876 876main()&#123; char s[ ]=&quot;9876&quot;,*p;for ( p=s ; p&lt;s+2 ; p++) printf(&quot;%s\n&quot;, p);&#125;7．以下函数的功能是：求x的y次方，请填空。double fun( double x, int y)&#123; int i;double z;for(i=1, z=x; i&lt;y;i++) z=z* x ;return z;&#125;8．以下程序段打开文件后，先利用fseek函数将文件位置指针定位在文件末尾，然后调用ftell函数返回当前文件位置指针的具体位置，从而确定文件长度，请填空。FILE *myf; long f1;myf= fopen (&quot;test.t&quot;,&quot;rb&quot;);fseek(myf,0,SEEK_END); f1=ftell(myf);fclose(myf);printf(&quot;%d\n&quot;,f1);9. 以下程序输出的最后一个值是120。int ff(int n)&#123; static int f=l;f=f*n;return f;&#125;main()&#123; int i;for(I=1;I&lt;=5;I++ printf(&quot;%d\n&quot;,ff(i));)10. 以下程序运行后的输出结果是52 main()&#123; int i=10, j=0;do&#123; j=j+i; i--;while(i&gt;2);printf(&quot;%d\n&quot;,j);&#125;三、判断题(每题2分，共20分) 1：动态链结库不能静态调用。 错误 2：UDP是面向无连接的网络连接 正确 3：ASP是一种数据库引擎 错误 4：队列是先进后出。 错误 5：Weblogic是分布式应用服务器。 正确 6：TCP,UDP都是传输层的协议。 正确 7: 两个线程不能共存于同一地址空间 错误 8: JAVA是一种跨平台的开发工具 正确 9．在WINDOWS操作系统中对外设是以文件的方式进行管理 正确 10. 虚拟内存实际是创建在硬盘上的 正确四、问答题(每题10分，共30分)１． 写出从数据库表Custom中查询No、Name、Num1、Num2并将Name以姓名显示、计算出的和以总和显示的SQL。SELECT No , Name AS ‘姓名’ ，Num1 ，Num2，（Num1+Num2） AS ‘总和’FROM Custom2. 何为“事务处理”，谈谈你对它的理解事务处理是指一个单元的工作，这些工作要么全做，要么全部不做。作为一个逻辑单元，必须具备四个属性：自动性、一致性、独立性和持久性。自动性是指事务必须是一个自动的单元工作，要么执行全部数据的修改，要么全部数据的修改都不执行。一致性是指当事务完成时，必须使所有数据都具有一致的状态。在关系型数据库中，所有的规则必须应用到事务的修改上，以便维护所有数据的完整性。所有的内部数据结构，在事务结束之后，必须保证正确。独立性是指并行事务的修改必须与其他并行事务的修改相互独立。一个事务看到的数据要么是另外一个事务修改这些事务之前的状态，要么是第二个事务已经修改完成的数据，但是这个事务不能看到正在修改的数据。3. 常用的数据结构有哪些？请枚举一些。（不少于5个）链表、堆栈、二叉树、队列、图、堆，集合。4. 什么是OOP？什么是类？请对比类和对象实例之间的关系。OOP是Object_oriented Programming(面向对象编程)的缩写。这主要是为了区别于以前的面向过程的程序设计！指的是用对象的观点来组织与构建系统，它综合了功能抽象和数据抽象，这样可以减少数据之间的耦合性和代码的出错几率。使用面向对象编程技术可以使得软件开发者按照现实世界里人们思考问题的模式编写代码,可以让软件开发者更好地利用代码直接表达现实中存在的对象,将问题空间直接映射到解空间!类：即class 在面向对象的程序设计中，专门用“类”来表示用户定义的抽象数据类型（user_defined abstract type）。它将具有相同状态、操作和访问机制的多个对象进行了抽象。类具有继承、数据隐藏和多态三种主要特性。利用类的这三种特性可以更好地表示现实世界中事物。类是同一类对象实例的共性的抽象，对象是类的实例化。对象通常作为计算机模拟思维，表示真实世界的抽象，一个对象就像一个软件模块，可以为用户提供一系列的服务--可以改变对象的状态、测试、传递消息等。类定义了对象的实现细节或数据结构。类是静态的，对象是动态的，对象可以看作是运行中的类。类负责产生对象，可以将类当成生产对象的工厂（Object factory）.5. 有一组数字（3，10，6，8，98，22），请编程排序（升降序皆可），语言不限，算法不限，但须注明是何种算法。//下面使用简单的冒泡法进行排序！ #include &quot;iostream.h&quot; template&lt;class type&gt; class CBubble&#123;private: type *pArray; int size;public:CBubble(type a[],int sizeArray);void sort();void display();&#125;;template &lt;class type&gt; CBubble&lt;type&gt;::CBubble(type a[],int sizeArray)&#123; pArray=a; size=sizeArray/sizeof(type);&#125;template&lt;class type&gt;void CBubble&lt;type&gt;::sort()&#123; type temp; for(int i=0;i&lt;size-1;i++) for(int j=0;j&lt;size-1-i;j++) if(pArray[j]&gt;pArray[j+1])//升序&#123;temp=pArray[j+1];pArray[j+1]=pArray[j];pArray[j]=temp;&#125;&#125;template&lt;class type&gt;void CBubble&lt;type&gt;::display()&#123;for(int i=0;i&lt;size;i++)cout&lt;&lt;pArray[i]&lt;&lt;endl;&#125;void main(void)&#123;int a[]=&#123;3,10,6,8,98,22&#125;;CBubble&lt;int&gt; intData(a,sizeof(a));cout&lt;&lt;&quot;The original data are :&quot;&lt;&lt;endl;intData.display();intData.sort();cout&lt;&lt;&quot;After sorting ,the data are:&quot;&lt;&lt;endl;intData.display();&#125; SQLhttp://www.jactiongroup.net/reference/html/index.html //书http://blog.csdn.net/hbuzhang/archive/2004/12/07/207202.aspx //书connection connconn.setAuto(false)//表示手动提交conn.commit// 提交conn.rollback();//事务回滚 -内联接use pubsselect a.au_fname, a.au_lname, p.pub_name from authors a inner join publishers p on a.city = p.city order by p.pub_name asc, a.au_lname asc, a.au_fname asc--左外联接use pubs select a.au_fname, a.au_lname, p.pub_name from authors a left join publishers pon a.city = p.city order by p.pub_name asc, a.au_lname asc, a.au_fname asc-使用子查询USE pubs GO SELECT distinct pub_name FROM publishers WHERE pub_id IN (SELECT pub_idFROM titlesWHERE type = &apos;business&apos;) GO--如果平均价格少于 $30，WHILE 循环就将价格加倍，然后选择最高价。--如果最高价少于或等于 $50，WHILE 循环重新启动并再次将价格加倍。--该循环不断地将价格加倍直到最高价格超过 $50 ` USE pubs GOWHILE (SELECT AVG(price) FROM titles) &lt; $30BEGIN UPDATE titles SET price = price * 2 SELECT MAX(price) FROM titles IF (SELECT MAX(price) FROM titles) &gt; $50 BREAK ELSE CONTINUEEND --如果平均价格少于 $30，WHILE 循环就将价格加倍，然后选择最高价。--如果最高价少于或等于 $50，WHILE 循环重新启动并再次将价格加倍。--该循环不断地将价格加倍直到最高价格超过 $50USE pubsGOWHILE (SELECT AVG(price) FROM titles) &lt; $30BEGIN UPDATE titles SET price = price * 2 SELECT MAX(price) FROM titles IF (SELECT MAX(price) FROM titles) &gt; $50 BREAK ELSE CONTINUEENDCREATE PROCEDURE au_info @lastname varchar(40), @firstname varchar(20) AS SELECT au_lname, au_fname, title, pub_name FROM authors a INNER JOIN titleauthor ta ON a.au_id = ta.au_id INNER JOIN titles t ON t.title_id = ta.title_id INNER JOIN publishers p ON t.pub_id = p.pub_id WHERE au_fname = @firstname AND au_lname = @lastnameGOEXECUTE au_info &apos;Dull&apos;, &apos;Ann&apos;--或者EXECUTE au_info @lastname = &apos;Dull&apos;, @firstname = &apos;Ann&apos;--创建存储过程CREATE PROCEDURE titles_sum @TITLE varchar(40),@SUM money OUTPUTASSELECT @SUM = SUM(price)FROM titlesWHERE title LIKE @TITLEGODECLARE @TOTALCOST moneyEXECUTE titles_sum &apos;The%&apos;, @TOTALCOST OUTPUTselect @TOTALCOSTgoCREATE PROCEDURE Oakland_authorsAS SELECT au_fname, au_lname, address, city, zipFROM authorsWHERE city = &apos;Oakland&apos;and state = &apos;CA&apos;ORDER BY au_lname, au_fnameGO--sp_helptext Oakland_authorsALTER PROCEDURE Oakland_authorsAS SELECT au_fname, au_lname, address, city, zipFROM authorsWHERE state = &apos;CA&apos;ORDER BY au_lname, au_fnameGO--sp_helptext Oakland_authors--提交事务后，所有书籍支付的版税增加 10%。begin transaction MyTransactionupdate royschedset royalty = royalty * 1.10commit transaction MyTransaction--rollback transaction MyTransactionselect royalty from roysched--select @@trancount--1.创建试验实验表create table temptrigger( id_temp varchar(2) not null primary key, temp_name varchar(10) null, temp_age int null)goinsert temptrigger values(&apos;01&apos;,&apos;张三&apos;,&apos;10&apos;) insert temptrigger values(&apos;02&apos;,&apos;李四&apos;,&apos;11&apos;) insert temptrigger values(&apos;03&apos;,&apos;王五&apos;,&apos;12&apos;) insert temptrigger values(&apos;04&apos;,&apos;赵六&apos;,&apos;11&apos;) select * from temptrigger go--2.创建insert , update触发器create trigger temptrigger_modifyon temptriggerfor insert,updateasbegin if (select temp_age from inserted) &gt; 15 begin rollback transaction print &apos;年龄不能超过15岁！&apos; endend--insert temptrigger values(&apos;04&apos;,&apos;大朋&apos;,&apos;17&apos;) --insert temptrigger values(&apos;05&apos;,&apos;大朋&apos;,&apos;17&apos;) --insert temptrigger values(&apos;05&apos;,&apos;大朋&apos;,&apos;14&apos;) --update temptrigger set temp_age=&apos;18&apos; where id_temp = &apos;01&apos;--update temptrigger set temp_age=&apos;9&apos; where id_temp = &apos;01&apos;-3.创建delete 触发器：drop trigger temptrigger_deletecreate trigger temptrigger_deleteon temptriggerfor deleteasbegin print @@rowcount if @@rowcount &gt; 1 begin rollback transaction print &apos;一次删除记录不能多于1条&apos; endend --delete from temptrigger--delete from temptrigger where id_temp=&apos;01&apos;--创建聚集索引create clustered index clindx_titleid on roysched(title_id)--sp_help roysched--创建非聚集索引create nonclustered index unclindx_titleid on roysched(title_id)--sp_help roysched--查看索引统计dbcc show_statistics(roysched,titleidind)--更新索引统计update statistics authors--重建索引dbcc dbreindex(&apos;roysched&apos;,unclindx_titleid)--删除索引drop index roysched.unclindx_titleid-sp_help roysched1--创建ssn(社会保险号)的基于varchar的自定义数据类型。--用于存储11位社会保险号（999-99-999）的列。该列不能为null：use pubs exec sp_addtype ssn , &apos;varchar(11)&apos; , &apos;NOT NULL&apos;--查看创建的数据类型--sp_help ssn--使用创建的数据类型create table mytable( myid varchar(2) primary key, myssn ssn) 4-删除创建的数据类型--drop table mytable--exec sp_droptype ssn ?批是包含一个或多个 Transact-SQL 语句的组，从应用程序一次性地发送到 Microsoft SQL Server 执行。批作为一个整体执行，以GO命令结束。批处理是客户端作为一个单元发出的一个或多个 SQL 语句的集合。每个批处理编译为一个执行计划。触发器：触发器是在对表进行插入、更新或删除操作时自动执行的存储过程?触发器通常用于强制业务规则?触发器可以确保数据的完整性和一致性事务：是用户定义的一个操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位(构成单一逻辑工作单元的操作集合)如果某一事务成功，则在该事务中进行的所有数据更改均会提交，成为数据库中的永久组成部分。如果事务遇到错误且必须取消或回滚，则所有数据更改均被清除?锁 ：是在多用户环境中对数据访问的限制封锁就是事务 T 在对某个数据对象（如表、记录等）操作之前，先向系统发出请求，对其加锁。加锁后事务 T 就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象。（锁蕴含的基本概念是用户需要对表的排它访问）?从程序员的角度看：分为乐观锁和悲观锁。乐观锁：完全依靠数据库来管理锁的工作。悲观锁：程序员自己管理数据或对象上的锁处理。子查询：一个 SELECT 语句嵌套在另一个 SELECT 语句中。索引：是一个数据库对象，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单,然后根据指定的排序次序排列这些指针 —优点提高查询执行的速度。 强制实施数据的唯一性。 提高表之间联接的速度。 缺点 存储索引要占用磁盘空间。数据修改需要更长的时间，因为索引也要更新。 ?视图?：是一种虚拟表，通常是作为来自一个或多个表 的行或列的子集创建的。?视图本质上讲，就是保存在数据库中的select查询?视图并不是数据库中存储的数据值的集合。?对最终用户的好处– 结果更容易理解– 获得数据更容易?对开发人员的好处– 限制数据检索更容易– 维护应用程序更方便存储过程：使用一个名称存储的预编译T-SQL语句和流程控制语句的集合?由数据库开发人员或数据库管理员编写?用来执行管理任务或应用复杂的业务规则 优点?执行速度更快?首次运行时，进行优化和编译得到执行计划并将该计划存储在系统表中，以后直接运行。?实现多个程序共享应用程序逻辑?组件式编程?能够屏蔽数据库的结构，实现更高的安全性?减少网络流通量数据库设计和建模必要性：好的数据库结构有利于：-节省数据的存储空间-能够保证数据的完整性-方便进行数据库应用系统的开发?设计不好的数据库结构将导致-数据冗余、存储空间浪费-内存空间浪费不管数据库的大小和复杂程度如何，可以用下列基本步骤来设计数据库：–收集信息–标识对象–设计数据模型–标识每个对象 存储的信息类型–标识对象之间的关系数据模型：是一种标识实体类型及其实体间联系的模型。典型的数据模型由网状模型、层次模型和关系模型。什么是规范化：从关系数据库的表中，除去冗余数据的过程称为规范化。—精简数据库的结构—从表中删除冗余的列—标识所有依赖于其它数据的数据三级范式：第一范式的定义： 如果一个表中没有重复组（即行与列的交叉点上只有一个值，而不是一组值），则这个表属于第一范式（常记成1NF）。简而言之：&quot;每一字段只存储一个值&quot;。例如:职工号，姓名，电话号码组成一个表（一个人可能有一个办公室电话 和一个家里电话号码） 第二范式的定义：如果一个表属于1NF，任何属性只依赖于关键字，则这个表属于第二范式（常记成2NF ）。简而言之：必须先符合1NF的条件，且每一行都能被唯一的识别。 第三范式的定义：将1NF转换成2NF的方法是添加主键。学号,课程名,成绩第三范式的定义：如果一个表属于2NF，且不包含传递依赖性，则这个表是第三范式（常记成3NF）。满足3NF的表中不包含传递依赖。简而言之：没有一个非关键属性依赖于另一个非关键属性。学号，课程号，成绩，学分学号，姓名，所在系，系名称，系地址.什么是类与对象：所谓对象就是真实世界中的实体，对象与实体是一一对应的，也就是说现实世界中每一个实体都是一个对象，它是一种具体的概念。类是具备某些共同特征的实体的集合，它是一种抽象的概念，用程序设计的语言来说，类是一种抽象的数据类型，它是对所具有相同特征实体的抽象。属性与方法：不同对象具有相同特点，就可能抽象为一定的类，那么这些特点基本上可以分为两类，一类是描述对象静态状态的，就是对象的属性，在程序设计中，可以称之为变量；另一类是描述对象的动作，就是对象的方法，在程序设计中我们称之为函数。属性和方法是一个对象所具备的两大基本要素，也是我们后面编程工作的核心。什么是封装：只要有足够的方法，就没必要直接去操作对象属性，只要调用这些方法就可以实现要完成的任务，这种现象称为封装，它通过对象方法对其属性的操作把对象属性封装在一个对象内部，对象与外界打交道全部通过其自身的方法来实现，有效的把对象属性隐藏在对象内部。编写 java文件的注意事项：在记事本中编写java文件，在保存时一定要把文件名和扩展名用双引号括起来，否则将默认保存为文本文件，如果要保存的java 文件名为Program1.java,则在保存时在文件名文本框中一定要输入”Program1.java”。如何编译java程序：单击开始|运行命令，在命令行上输入cmd，按回车键（在 window98中输入command，按回车键），即可打开一个命令窗口，将目录转换到编写java源程序所在的目录，输入`javac filename.java`如何执行java程序：同样在命令窗口中输入`java filename，`基本数据类型：Java的数据类型可以划分为4大类：整数，浮点数，字符型，布尔型。其中整数可以划分为：byte,short,int,long.浮点数可以划分为float,double]]></content>
      <tags>
        <tag>Java</tag>
        <tag>笔面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记事本]]></title>
    <url>%2F2018%2F07%2F12%2FNotePad%2F</url>
    <content type="text"><![CDATA[import java.awt.*; import java.awt.event.; import java.text.; import java.util.; import java.io.; import javax.swing.undo.; import javax.swing.border.; import javax.swing.; import javax.swing.text.; import javax.swing.event.;import java.awt.datatransfer.; public class Notepad extends JFrame implements ActionListener,DocumentListener{ //菜单 JMenu fileMenu,editMenu,formatMenu,viewMenu,helpMenu; //右键弹出菜单项 JPopupMenu popupMenu; JMenuItem popupMenu_Undo,popupMenu_Cut,popupMenu_Copy,popupMenu_Paste,popupMenu_Delete,popupMenu_SelectAll; //“文件”的菜单项 JMenuItem fileMenu_New,fileMenu_Open,fileMenu_Save,fileMenu_SaveAs,fileMenu_PageSetUp,fileMenu_Print,fileMenu_Exit; //“编辑”的菜单项 JMenuItem editMenu_Undo,editMenu_Cut,editMenu_Copy,editMenu_Paste,editMenu_Delete,editMenu_Find,editMenu_FindNext,editMenu_Replace,editMenu_GoTo,editMenu_SelectAll,editMenu_TimeDate; //“格式”的菜单项 JCheckBoxMenuItem formatMenu_LineWrap; JMenuItem formatMenu_Font; //“查看”的菜单项 JCheckBoxMenuItem viewMenu_Status; //“帮助”的菜单项 JMenuItem helpMenu_HelpTopics,helpMenu_AboutNotepad; //“文本”编辑区域 JTextArea editArea; //状态栏标签 JLabel statusLabel; //系统剪贴板 Toolkit toolkit=Toolkit.getDefaultToolkit(); Clipboard clipBoard=toolkit.getSystemClipboard(); //创建撤销操作管理器(与撤销操作有关) protected UndoManager undo=new UndoManager(); protected UndoableEditListener undoHandler=new UndoHandler(); //其他变量 String oldValue;//存放编辑区原来的内容，用于比较文本是否有改动 boolean isNewFile=true;//是否新文件(未保存过的) File currentFile;//当前文件名 //构造函数开始 public Notepad() { super(“Java记事本”); //改变系统默认字体 Font font = new Font(“Dialog”, Font.PLAIN, 12); java.util.Enumeration keys = UIManager.getDefaults().keys(); while (keys.hasMoreElements()) { Object key = keys.nextElement(); Object value = UIManager.get(key); if (value instanceof javax.swing.plaf.FontUIResource) { UIManager.put(key, font); } } //创建菜单条 JMenuBar menuBar=new JMenuBar(); //创建文件菜单及菜单项并注册事件监听 fileMenu=new JMenu(“文件(F)”); fileMenu.setMnemonic(‘F’);//设置快捷键ALT+F fileMenu_New=new JMenuItem(&quot;新建(N)&quot;); fileMenu_New.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_N,InputEvent.CTRL_MASK)); fileMenu_New.addActionListener(this); fileMenu_Open=new JMenuItem(&quot;打开(O)...&quot;); fileMenu_Open.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O,InputEvent.CTRL_MASK)); fileMenu_Open.addActionListener(this); fileMenu_Save=new JMenuItem(&quot;保存(S)&quot;); fileMenu_Save.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S,InputEvent.CTRL_MASK)); fileMenu_Save.addActionListener(this); fileMenu_SaveAs=new JMenuItem(&quot;另存为(A)...&quot;); fileMenu_SaveAs.addActionListener(this); fileMenu_PageSetUp=new JMenuItem(&quot;页面设置(U)...&quot;); fileMenu_PageSetUp.addActionListener(this); fileMenu_Print=new JMenuItem(&quot;打印(P)...&quot;); fileMenu_Print.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_P, InputEvent.CTRL_MASK)); fileMenu_Print.addActionListener(this); fileMenu_Exit=new JMenuItem(&quot;退出(X)&quot;); fileMenu_Exit.addActionListener(this); //创建编辑菜单及菜单项并注册事件监听 editMenu=new JMenu(&quot;编辑(E)&quot;); editMenu.setMnemonic(&#39;E&#39;);//设置快捷键ALT+E //当选择编辑菜单时，设置剪切、复制、粘贴、删除等功能的可用性 editMenu.addMenuListener(new MenuListener() { public void menuCanceled(MenuEvent e)//取消菜单时调用 { checkMenuItemEnabled();//设置剪切、复制、粘贴、删除等功能的可用性 } public void menuDeselected(MenuEvent e)//取消选择某个菜单时调用 { checkMenuItemEnabled();//设置剪切、复制、粘贴、删除等功能的可用性 } public void menuSelected(MenuEvent e)//选择某个菜单时调用 { checkMenuItemEnabled();//设置剪切、复制、粘贴、删除等功能的可用性 } }); editMenu_Undo=new JMenuItem(&quot;撤销(U)&quot;); editMenu_Undo.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Z,InputEvent.CTRL_MASK)); editMenu_Undo.addActionListener(this); editMenu_Undo.setEnabled(false); editMenu_Cut=new JMenuItem(&quot;剪切(T)&quot;); editMenu_Cut.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_X,InputEvent.CTRL_MASK)); editMenu_Cut.addActionListener(this); editMenu_Copy=new JMenuItem(&quot;复制(C)&quot;); editMenu_Copy.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_C,InputEvent.CTRL_MASK)); editMenu_Copy.addActionListener(this); editMenu_Paste=new JMenuItem(&quot;粘贴(P)&quot;); editMenu_Paste.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_V,InputEvent.CTRL_MASK)); editMenu_Paste.addActionListener(this); editMenu_Delete=new JMenuItem(&quot;删除(D)&quot;); editMenu_Delete.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_DELETE,0)); editMenu_Delete.addActionListener(this); editMenu_Find=new JMenuItem(&quot;查找(F)...&quot;); editMenu_Find.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F,InputEvent.CTRL_MASK)); editMenu_Find.addActionListener(this); editMenu_FindNext=new JMenuItem(&quot;查找下一个(N)&quot;); editMenu_FindNext.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F3,0)); editMenu_FindNext.addActionListener(this); editMenu_Replace = new JMenuItem(&quot;替换(R)...&quot;,&#39;R&#39;); editMenu_Replace.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_H, InputEvent.CTRL_MASK)); editMenu_Replace.addActionListener(this); editMenu_GoTo = new JMenuItem(&quot;转到(G)...&quot;,&#39;G&#39;); editMenu_GoTo.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_G, InputEvent.CTRL_MASK)); editMenu_GoTo.addActionListener(this); editMenu_SelectAll = new JMenuItem(&quot;全选&quot;,&#39;A&#39;); editMenu_SelectAll.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_A, InputEvent.CTRL_MASK)); editMenu_SelectAll.addActionListener(this); editMenu_TimeDate = new JMenuItem(&quot;时间/日期(D)&quot;,&#39;D&#39;); editMenu_TimeDate.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F5,0)); editMenu_TimeDate.addActionListener(this); //创建格式菜单及菜单项并注册事件监听 formatMenu=new JMenu(&quot;格式(O)&quot;); formatMenu.setMnemonic(&#39;O&#39;);//设置快捷键ALT+O formatMenu_LineWrap=new JCheckBoxMenuItem(&quot;自动换行(W)&quot;); formatMenu_LineWrap.setMnemonic(&#39;W&#39;);//设置快捷键ALT+W formatMenu_LineWrap.setState(true); formatMenu_LineWrap.addActionListener(this); formatMenu_Font=new JMenuItem(&quot;字体(F)...&quot;); formatMenu_Font.addActionListener(this); //创建查看菜单及菜单项并注册事件监听 viewMenu=new JMenu(&quot;查看(V)&quot;); viewMenu.setMnemonic(&#39;V&#39;);//设置快捷键ALT+V viewMenu_Status=new JCheckBoxMenuItem(&quot;状态栏(S)&quot;); viewMenu_Status.setMnemonic(&#39;S&#39;);//设置快捷键ALT+S viewMenu_Status.setState(true); viewMenu_Status.addActionListener(this); //创建帮助菜单及菜单项并注册事件监听 helpMenu = new JMenu(&quot;帮助(H)&quot;); helpMenu.setMnemonic(&#39;H&#39;);//设置快捷键ALT+H helpMenu_HelpTopics = new JMenuItem(&quot;帮助主题(H)&quot;); helpMenu_HelpTopics.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F1,0)); helpMenu_HelpTopics.addActionListener(this); helpMenu_AboutNotepad = new JMenuItem(&quot;关于记事本(A)&quot;); helpMenu_AboutNotepad.addActionListener(this); //向菜单条添加&quot;文件&quot;菜单及菜单项 menuBar.add(fileMenu); fileMenu.add(fileMenu_New); fileMenu.add(fileMenu_Open); fileMenu.add(fileMenu_Save); fileMenu.add(fileMenu_SaveAs); fileMenu.addSeparator(); //分隔线 fileMenu.add(fileMenu_PageSetUp); fileMenu.add(fileMenu_Print); fileMenu.addSeparator(); //分隔线 fileMenu.add(fileMenu_Exit); //向菜单条添加&quot;编辑&quot;菜单及菜单项 menuBar.add(editMenu); editMenu.add(editMenu_Undo); editMenu.addSeparator(); //分隔线 editMenu.add(editMenu_Cut); editMenu.add(editMenu_Copy); editMenu.add(editMenu_Paste); editMenu.add(editMenu_Delete); editMenu.addSeparator(); //分隔线 editMenu.add(editMenu_Find); editMenu.add(editMenu_FindNext); editMenu.add(editMenu_Replace); editMenu.add(editMenu_GoTo); editMenu.addSeparator(); //分隔线 editMenu.add(editMenu_SelectAll); editMenu.add(editMenu_TimeDate); //向菜单条添加&quot;格式&quot;菜单及菜单项 menuBar.add(formatMenu); formatMenu.add(formatMenu_LineWrap); formatMenu.add(formatMenu_Font); //向菜单条添加&quot;查看&quot;菜单及菜单项 menuBar.add(viewMenu); viewMenu.add(viewMenu_Status); //向菜单条添加&quot;帮助&quot;菜单及菜单项 menuBar.add(helpMenu); helpMenu.add(helpMenu_HelpTopics); helpMenu.addSeparator(); helpMenu.add(helpMenu_AboutNotepad); //向窗口添加菜单条 this.setJMenuBar(menuBar); //创建文本编辑区并添加滚动条 editArea=new JTextArea(20,50); JScrollPane scroller=new JScrollPane(editArea); scroller.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS); this.add(scroller,BorderLayout.CENTER);//向窗口添加文本编辑区 editArea.setWrapStyleWord(true);//设置单词在一行不足容纳时换行 editArea.setLineWrap(true);//设置文本编辑区自动换行默认为true,即会&quot;自动换行&quot; //this.add(editArea,BorderLayout.CENTER);//向窗口添加文本编辑区 oldValue=editArea.getText();//获取原文本编辑区的内容 //编辑区注册事件监听(与撤销操作有关) editArea.getDocument().addUndoableEditListener(undoHandler); editArea.getDocument().addDocumentListener(this); //创建右键弹出菜单 popupMenu=new JPopupMenu(); popupMenu_Undo=new JMenuItem(&quot;撤销(U)&quot;); popupMenu_Cut=new JMenuItem(&quot;剪切(T)&quot;); popupMenu_Copy=new JMenuItem(&quot;复制(C)&quot;); popupMenu_Paste=new JMenuItem(&quot;粘帖(P)&quot;); popupMenu_Delete=new JMenuItem(&quot;删除(D)&quot;); popupMenu_SelectAll=new JMenuItem(&quot;全选(A)&quot;); popupMenu_Undo.setEnabled(false); //向右键菜单添加菜单项和分隔符 popupMenu.add(popupMenu_Undo); popupMenu.addSeparator(); popupMenu.add(popupMenu_Cut); popupMenu.add(popupMenu_Copy); popupMenu.add(popupMenu_Paste); popupMenu.add(popupMenu_Delete); popupMenu.addSeparator(); popupMenu.add(popupMenu_SelectAll); //文本编辑区注册右键菜单事件 popupMenu_Undo.addActionListener(this); popupMenu_Cut.addActionListener(this); popupMenu_Copy.addActionListener(this); popupMenu_Paste.addActionListener(this); popupMenu_Delete.addActionListener(this); popupMenu_SelectAll.addActionListener(this); //文本编辑区注册右键菜单事件 editArea.addMouseListener(new MouseAdapter() { public void mousePressed(MouseEvent e) { if(e.isPopupTrigger())//返回此鼠标事件是否为该平台的弹出菜单触发事件 { popupMenu.show(e.getComponent(),e.getX(),e.getY());//在组件调用者的坐标空间中的位置 X、Y 显示弹出菜单 } checkMenuItemEnabled();//设置剪切，复制，粘帖，删除等功能的可用性 editArea.requestFocus();//编辑区获取焦点 } public void mouseReleased(MouseEvent e) { if(e.isPopupTrigger())//返回此鼠标事件是否为该平台的弹出菜单触发事件 { popupMenu.show(e.getComponent(),e.getX(),e.getY());//在组件调用者的坐标空间中的位置 X、Y 显示弹出菜单 } checkMenuItemEnabled();//设置剪切，复制，粘帖，删除等功能的可用性 editArea.requestFocus();//编辑区获取焦点 } });//文本编辑区注册右键菜单事件结束 //创建和添加状态栏 statusLabel=new JLabel(&quot; 按F1获取帮助&quot;); this.add(statusLabel,BorderLayout.SOUTH);//向窗口添加状态栏标签 //设置窗口在屏幕上的位置、大小和可见性 this.setLocation(100,100); this.setSize(650,550); this.setVisible(true); //添加窗口监听器 addWindowListener(new WindowAdapter() { public void windowClosing(WindowEvent e) { exitWindowChoose(); } }); checkMenuItemEnabled(); editArea.requestFocus(); }//构造函数Notepad结束 //设置菜单项的可用性：剪切，复制，粘帖，删除功能 public void checkMenuItemEnabled() { String selectText=editArea.getSelectedText(); if(selectText==null) { editMenu_Cut.setEnabled(false); popupMenu_Cut.setEnabled(false); editMenu_Copy.setEnabled(false); popupMenu_Copy.setEnabled(false); editMenu_Delete.setEnabled(false); popupMenu_Delete.setEnabled(false); } else { editMenu_Cut.setEnabled(true); popupMenu_Cut.setEnabled(true); editMenu_Copy.setEnabled(true); popupMenu_Copy.setEnabled(true); editMenu_Delete.setEnabled(true); popupMenu_Delete.setEnabled(true); } //粘帖功能可用性判断 Transferable contents=clipBoard.getContents(this); if(contents==null) { editMenu_Paste.setEnabled(false); popupMenu_Paste.setEnabled(false); } else { editMenu_Paste.setEnabled(true); popupMenu_Paste.setEnabled(true); } }//方法checkMenuItemEnabled()结束 //关闭窗口时调用 public void exitWindowChoose() { editArea.requestFocus(); String currentValue=editArea.getText(); if(currentValue.equals(oldValue)==true) { System.exit(0); } else { int exitChoose=JOptionPane.showConfirmDialog(this,&quot;您的文件尚未保存，是否保存？&quot;,&quot;退出提示&quot;,JOptionPane.YES_NO_CANCEL_OPTION); if(exitChoose==JOptionPane.YES_OPTION) { //boolean isSave=false; if(isNewFile) { String str=null; JFileChooser fileChooser=new JFileChooser(); fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY); fileChooser.setApproveButtonText(&quot;确定&quot;); fileChooser.setDialogTitle(&quot;另存为&quot;); int result=fileChooser.showSaveDialog(this); if(result==JFileChooser.CANCEL_OPTION) { statusLabel.setText(&quot; 您没有保存文件&quot;); return; } File saveFileName=fileChooser.getSelectedFile(); if(saveFileName==null||saveFileName.getName().equals(&quot;&quot;)) { JOptionPane.showMessageDialog(this,&quot;不合法的文件名&quot;,&quot;不合法的文件名&quot;,JOptionPane.ERROR_MESSAGE); } else { try { FileWriter fw=new FileWriter(saveFileName); BufferedWriter bfw=new BufferedWriter(fw); bfw.write(editArea.getText(),0,editArea.getText().length()); bfw.flush(); fw.close(); isNewFile=false; currentFile=saveFileName; oldValue=editArea.getText(); this.setTitle(saveFileName.getName()+&quot; - 记事本&quot;); statusLabel.setText(&quot; 当前打开文件:&quot;+saveFileName.getAbsoluteFile()); //isSave=true; } catch(IOException ioException){ } } } else { try { FileWriter fw=new FileWriter(currentFile); BufferedWriter bfw=new BufferedWriter(fw); bfw.write(editArea.getText(),0,editArea.getText().length()); bfw.flush(); fw.close(); //isSave=true; } catch(IOException ioException){ } } System.exit(0); //if(isSave)System.exit(0); //else return; } else if(exitChoose==JOptionPane.NO_OPTION) { System.exit(0); } else { return; } } }//关闭窗口时调用方法结束 //查找方法 public void find() { final JDialog findDialog=new JDialog(this,&quot;查找&quot;,false);//false时允许其他窗口同时处于激活状态(即无模式) Container con=findDialog.getContentPane();//返回此对话框的contentPane对象 con.setLayout(new FlowLayout(FlowLayout.LEFT)); JLabel findContentLabel=new JLabel(&quot;查找内容(N)：&quot;); final JTextField findText=new JTextField(15); JButton findNextButton=new JButton(&quot;查找下一个(F)：&quot;); final JCheckBox matchCheckBox=new JCheckBox(&quot;区分大小写(C)&quot;); ButtonGroup bGroup=new ButtonGroup(); final JRadioButton upButton=new JRadioButton(&quot;向上(U)&quot;); final JRadioButton downButton=new JRadioButton(&quot;向下(U)&quot;); downButton.setSelected(true); bGroup.add(upButton); bGroup.add(downButton); /*ButtonGroup此类用于为一组按钮创建一个多斥（multiple-exclusion）作用域。 使用相同的 ButtonGroup 对象创建一组按钮意味着“开启”其中一个按钮时，将关闭组中的其他所有按钮。*/ /*JRadioButton此类实现一个单选按钮，此按钮项可被选择或取消选择，并可为用户显示其状态。 与 ButtonGroup 对象配合使用可创建一组按钮，一次只能选择其中的一个按钮。 （创建一个 ButtonGroup 对象并用其 add 方法将 JRadioButton 对象包含在此组中。）*/ JButton cancel=new JButton(&quot;取消&quot;); //取消按钮事件处理 cancel.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { findDialog.dispose(); } }); //&quot;查找下一个&quot;按钮监听 findNextButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { //&quot;区分大小写(C)&quot;的JCheckBox是否被选中 int k=0,m=0; final String str1,str2,str3,str4,strA,strB; str1=editArea.getText(); str2=findText.getText(); str3=str1.toUpperCase(); str4=str2.toUpperCase(); if(matchCheckBox.isSelected())//区分大小写 { strA=str1; strB=str2; } else//不区分大小写,此时把所选内容全部化成大写(或小写)，以便于查找 { strA=str3; strB=str4; } if(upButton.isSelected()) { //k=strA.lastIndexOf(strB,editArea.getCaretPosition()-1); if(editArea.getSelectedText()==null) k=strA.lastIndexOf(strB,editArea.getCaretPosition()-1); else k=strA.lastIndexOf(strB, editArea.getCaretPosition()-findText.getText().length()-1); if(k&gt;-1) { //String strData=strA.subString(k,strB.getText().length()+1); editArea.setCaretPosition(k); editArea.select(k,k+strB.length()); } else { JOptionPane.showMessageDialog(null,&quot;找不到您查找的内容！&quot;,&quot;查找&quot;,JOptionPane.INFORMATION_MESSAGE); } } else if(downButton.isSelected()) { if(editArea.getSelectedText()==null) k=strA.indexOf(strB,editArea.getCaretPosition()+1); else k=strA.indexOf(strB, editArea.getCaretPosition()-findText.getText().length()+1); if(k&gt;-1) { //String strData=strA.subString(k,strB.getText().length()+1); editArea.setCaretPosition(k); editArea.select(k,k+strB.length()); } else { JOptionPane.showMessageDialog(null,&quot;找不到您查找的内容！&quot;,&quot;查找&quot;,JOptionPane.INFORMATION_MESSAGE); } } } });//&quot;查找下一个&quot;按钮监听结束 //创建&quot;查找&quot;对话框的界面 JPanel panel1=new JPanel(); JPanel panel2=new JPanel(); JPanel panel3=new JPanel(); JPanel directionPanel=new JPanel(); directionPanel.setBorder(BorderFactory.createTitledBorder(&quot;方向&quot;)); //设置directionPanel组件的边框; //BorderFactory.createTitledBorder(String title)创建一个新标题边框，使用默认边框（浮雕化）、默认文本位置（位于顶线上）、默认调整 (leading) 以及由当前外观确定的默认字体和文本颜色，并指定了标题文本。 directionPanel.add(upButton); directionPanel.add(downButton); panel1.setLayout(new GridLayout(2,1)); panel1.add(findNextButton); panel1.add(cancel); panel2.add(findContentLabel); panel2.add(findText); panel2.add(panel1); panel3.add(matchCheckBox); panel3.add(directionPanel); con.add(panel2); con.add(panel3); findDialog.setSize(410,180); findDialog.setResizable(false);//不可调整大小 findDialog.setLocation(230,280); findDialog.setVisible(true); }//查找方法结束 //替换方法 public void replace() { final JDialog replaceDialog=new JDialog(this,&quot;替换&quot;,false);//false时允许其他窗口同时处于激活状态(即无模式) Container con=replaceDialog.getContentPane();//返回此对话框的contentPane对象 con.setLayout(new FlowLayout(FlowLayout.CENTER)); JLabel findContentLabel=new JLabel(&quot;查找内容(N)：&quot;); final JTextField findText=new JTextField(15); JButton findNextButton=new JButton(&quot;查找下一个(F):&quot;); JLabel replaceLabel=new JLabel(&quot;替换为(P)：&quot;); final JTextField replaceText=new JTextField(15); JButton replaceButton=new JButton(&quot;替换(R)&quot;); JButton replaceAllButton=new JButton(&quot;全部替换(A)&quot;); JButton cancel=new JButton(&quot;取消&quot;); cancel.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { replaceDialog.dispose(); } }); final JCheckBox matchCheckBox=new JCheckBox(&quot;区分大小写(C)&quot;); ButtonGroup bGroup=new ButtonGroup(); final JRadioButton upButton=new JRadioButton(&quot;向上(U)&quot;); final JRadioButton downButton=new JRadioButton(&quot;向下(U)&quot;); downButton.setSelected(true); bGroup.add(upButton); bGroup.add(downButton); /*ButtonGroup此类用于为一组按钮创建一个多斥（multiple-exclusion）作用域。 使用相同的 ButtonGroup 对象创建一组按钮意味着“开启”其中一个按钮时，将关闭组中的其他所有按钮。*/ /*JRadioButton此类实现一个单选按钮，此按钮项可被选择或取消选择，并可为用户显示其状态。 与 ButtonGroup 对象配合使用可创建一组按钮，一次只能选择其中的一个按钮。 （创建一个 ButtonGroup 对象并用其 add 方法将 JRadioButton 对象包含在此组中。）*/ //&quot;查找下一个&quot;按钮监听 findNextButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { //&quot;区分大小写(C)&quot;的JCheckBox是否被选中 int k=0,m=0; final String str1,str2,str3,str4,strA,strB; str1=editArea.getText(); str2=findText.getText(); str3=str1.toUpperCase(); str4=str2.toUpperCase(); if(matchCheckBox.isSelected())//区分大小写 { strA=str1; strB=str2; } else//不区分大小写,此时把所选内容全部化成大写(或小写)，以便于查找 { strA=str3; strB=str4; } if(upButton.isSelected()) { //k=strA.lastIndexOf(strB,editArea.getCaretPosition()-1); if(editArea.getSelectedText()==null) k=strA.lastIndexOf(strB,editArea.getCaretPosition()-1); else k=strA.lastIndexOf(strB, editArea.getCaretPosition()-findText.getText().length()-1); if(k&gt;-1) { //String strData=strA.subString(k,strB.getText().length()+1); editArea.setCaretPosition(k); editArea.select(k,k+strB.length()); } else { JOptionPane.showMessageDialog(null,&quot;找不到您查找的内容！&quot;,&quot;查找&quot;,JOptionPane.INFORMATION_MESSAGE); } } else if(downButton.isSelected()) { if(editArea.getSelectedText()==null) k=strA.indexOf(strB,editArea.getCaretPosition()+1); else k=strA.indexOf(strB, editArea.getCaretPosition()-findText.getText().length()+1); if(k&gt;-1) { //String strData=strA.subString(k,strB.getText().length()+1); editArea.setCaretPosition(k); editArea.select(k,k+strB.length()); } else { JOptionPane.showMessageDialog(null,&quot;找不到您查找的内容！&quot;,&quot;查找&quot;,JOptionPane.INFORMATION_MESSAGE); } } } });//&quot;查找下一个&quot;按钮监听结束 //&quot;替换&quot;按钮监听 replaceButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { if(replaceText.getText().length()==0 &amp;&amp; editArea.getSelectedText()!=null) editArea.replaceSelection(&quot;&quot;); if(replaceText.getText().length()&gt;0 &amp;&amp; editArea.getSelectedText()!=null) editArea.replaceSelection(replaceText.getText()); } });//&quot;替换&quot;按钮监听结束 //&quot;全部替换&quot;按钮监听 replaceAllButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { editArea.setCaretPosition(0); //将光标放到编辑区开头 int k=0,m=0,replaceCount=0; if(findText.getText().length()==0) { JOptionPane.showMessageDialog(replaceDialog,&quot;请填写查找内容!&quot;,&quot;提示&quot;,JOptionPane.WARNING_MESSAGE); findText.requestFocus(true); return; } while(k&gt;-1)//当文本中有内容被选中时(k&gt;-1被选中)进行替换，否则不进行while循环 { //&quot;区分大小写(C)&quot;的JCheckBox是否被选中 //int k=0,m=0; final String str1,str2,str3,str4,strA,strB; str1=editArea.getText(); str2=findText.getText(); str3=str1.toUpperCase(); str4=str2.toUpperCase(); if(matchCheckBox.isSelected())//区分大小写 { strA=str1; strB=str2; } else//不区分大小写,此时把所选内容全部化成大写(或小写)，以便于查找 { strA=str3; strB=str4; } if(upButton.isSelected()) { //k=strA.lastIndexOf(strB,editArea.getCaretPosition()-1); if(editArea.getSelectedText()==null) k=strA.lastIndexOf(strB,editArea.getCaretPosition()-1); else k=strA.lastIndexOf(strB, editArea.getCaretPosition()-findText.getText().length()-1); if(k&gt;-1) { //String strData=strA.subString(k,strB.getText().length()+1); editArea.setCaretPosition(k); editArea.select(k,k+strB.length()); } else { if(replaceCount==0) { JOptionPane.showMessageDialog(replaceDialog, &quot;找不到您查找的内容!&quot;, &quot;记事本&quot;,JOptionPane.INFORMATION_MESSAGE); } else { JOptionPane.showMessageDialog(replaceDialog,&quot;成功替换&quot;+replaceCount+&quot;个匹配内容!&quot;,&quot;替换成功&quot;,JOptionPane.INFORMATION_MESSAGE); } } } else if(downButton.isSelected()) { if(editArea.getSelectedText()==null) k=strA.indexOf(strB,editArea.getCaretPosition()+1); else k=strA.indexOf(strB, editArea.getCaretPosition()-findText.getText().length()+1); if(k&gt;-1) { //String strData=strA.subString(k,strB.getText().length()+1); editArea.setCaretPosition(k); editArea.select(k,k+strB.length()); } else { if(replaceCount==0) { JOptionPane.showMessageDialog(replaceDialog, &quot;找不到您查找的内容!&quot;, &quot;记事本&quot;,JOptionPane.INFORMATION_MESSAGE); } else { JOptionPane.showMessageDialog(replaceDialog,&quot;成功替换&quot;+replaceCount+&quot;个匹配内容!&quot;,&quot;替换成功&quot;,JOptionPane.INFORMATION_MESSAGE); } } } if(replaceText.getText().length()==0 &amp;&amp; editArea.getSelectedText()!= null) { editArea.replaceSelection(&quot;&quot;); replaceCount++; } if(replaceText.getText().length()&gt;0 &amp;&amp; editArea.getSelectedText()!= null) { editArea.replaceSelection(replaceText.getText()); replaceCount++; } }//while循环结束 } });//&quot;替换全部&quot;方法结束 //创建&quot;替换&quot;对话框的界面 JPanel directionPanel=new JPanel(); directionPanel.setBorder(BorderFactory.createTitledBorder(&quot;方向&quot;)); //设置directionPanel组件的边框; //BorderFactory.createTitledBorder(String title)创建一个新标题边框，使用默认边框（浮雕化）、默认文本位置（位于顶线上）、默认调整 (leading) 以及由当前外观确定的默认字体和文本颜色，并指定了标题文本。 directionPanel.add(upButton); directionPanel.add(downButton); JPanel panel1=new JPanel(); JPanel panel2=new JPanel(); JPanel panel3=new JPanel(); JPanel panel4=new JPanel(); panel4.setLayout(new GridLayout(2,1)); panel1.add(findContentLabel); panel1.add(findText); panel1.add(findNextButton); panel4.add(replaceButton); panel4.add(replaceAllButton); panel2.add(replaceLabel); panel2.add(replaceText); panel2.add(panel4); panel3.add(matchCheckBox); panel3.add(directionPanel); panel3.add(cancel); con.add(panel1); con.add(panel2); con.add(panel3); replaceDialog.setSize(420,220); replaceDialog.setResizable(false);//不可调整大小 replaceDialog.setLocation(230,280); replaceDialog.setVisible(true); }//&quot;全部替换&quot;按钮监听结束 //&quot;字体&quot;方法 public void font() { final JDialog fontDialog=new JDialog(this,&quot;字体设置&quot;,false); Container con=fontDialog.getContentPane(); con.setLayout(new FlowLayout(FlowLayout.LEFT)); JLabel fontLabel=new JLabel(&quot;字体(F)：&quot;); fontLabel.setPreferredSize(new Dimension(100,20));//构造一个Dimension，并将其初始化为指定宽度和高度 JLabel styleLabel=new JLabel(&quot;字形(Y)：&quot;); styleLabel.setPreferredSize(new Dimension(100,20)); JLabel sizeLabel=new JLabel(&quot;大小(S)：&quot;); sizeLabel.setPreferredSize(new Dimension(100,20)); final JLabel sample=new JLabel(&quot;张选仲的记事本-ZXZ&#39;s Notepad&quot;); //sample.setHorizontalAlignment(SwingConstants.CENTER); final JTextField fontText=new JTextField(9); fontText.setPreferredSize(new Dimension(200,20)); final JTextField styleText=new JTextField(8); styleText.setPreferredSize(new Dimension(200,20)); final int style[]={Font.PLAIN,Font.BOLD,Font.ITALIC,Font.BOLD+Font.ITALIC}; final JTextField sizeText=new JTextField(5); sizeText.setPreferredSize(new Dimension(200,20)); JButton okButton=new JButton(&quot;确定&quot;); JButton cancel=new JButton(&quot;取消&quot;); cancel.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { fontDialog.dispose(); } }); Font currentFont=editArea.getFont(); fontText.setText(currentFont.getFontName()); fontText.selectAll(); //styleText.setText(currentFont.getStyle()); //styleText.selectAll(); if(currentFont.getStyle()==Font.PLAIN) styleText.setText(&quot;常规&quot;); else if(currentFont.getStyle()==Font.BOLD) styleText.setText(&quot;粗体&quot;); else if(currentFont.getStyle()==Font.ITALIC) styleText.setText(&quot;斜体&quot;); else if(currentFont.getStyle()==(Font.BOLD+Font.ITALIC)) styleText.setText(&quot;粗斜体&quot;); styleText.selectAll(); String str=String.valueOf(currentFont.getSize()); sizeText.setText(str); sizeText.selectAll(); final JList fontList,styleList,sizeList; GraphicsEnvironment ge=GraphicsEnvironment.getLocalGraphicsEnvironment(); final String fontName[]=ge.getAvailableFontFamilyNames(); fontList=new JList(fontName); fontList.setFixedCellWidth(86); fontList.setFixedCellHeight(20); fontList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION); final String fontStyle[]={&quot;常规&quot;,&quot;粗体&quot;,&quot;斜体&quot;,&quot;粗斜体&quot;}; styleList=new JList(fontStyle); styleList.setFixedCellWidth(86); styleList.setFixedCellHeight(20); styleList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION); if(currentFont.getStyle()==Font.PLAIN) styleList.setSelectedIndex(0); else if(currentFont.getStyle()==Font.BOLD) styleList.setSelectedIndex(1); else if(currentFont.getStyle()==Font.ITALIC) styleList.setSelectedIndex(2); else if(currentFont.getStyle()==(Font.BOLD+Font.ITALIC)) styleList.setSelectedIndex(3); final String fontSize[]={&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;11&quot;,&quot;12&quot;,&quot;14&quot;,&quot;16&quot;,&quot;18&quot;,&quot;20&quot;,&quot;22&quot;,&quot;24&quot;,&quot;26&quot;,&quot;28&quot;,&quot;36&quot;,&quot;48&quot;,&quot;72&quot;}; sizeList=new JList(fontSize); sizeList.setFixedCellWidth(43); sizeList.setFixedCellHeight(20); sizeList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION); fontList.addListSelectionListener(new ListSelectionListener() { public void valueChanged(ListSelectionEvent event) { fontText.setText(fontName[fontList.getSelectedIndex()]); fontText.selectAll(); Font sampleFont1=new Font(fontText.getText(),style[styleList.getSelectedIndex()],Integer.parseInt(sizeText.getText())); sample.setFont(sampleFont1); } }); styleList.addListSelectionListener(new ListSelectionListener() { public void valueChanged(ListSelectionEvent event) { int s=style[styleList.getSelectedIndex()]; styleText.setText(fontStyle[s]); styleText.selectAll(); Font sampleFont2=new Font(fontText.getText(),style[styleList.getSelectedIndex()],Integer.parseInt(sizeText.getText())); sample.setFont(sampleFont2); } }); sizeList.addListSelectionListener(new ListSelectionListener() { public void valueChanged(ListSelectionEvent event) { sizeText.setText(fontSize[sizeList.getSelectedIndex()]); //sizeText.requestFocus(); sizeText.selectAll(); Font sampleFont3=new Font(fontText.getText(),style[styleList.getSelectedIndex()],Integer.parseInt(sizeText.getText())); sample.setFont(sampleFont3); } }); okButton.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { Font okFont=new Font(fontText.getText(),style[styleList.getSelectedIndex()],Integer.parseInt(sizeText.getText())); editArea.setFont(okFont); fontDialog.dispose(); } }); JPanel samplePanel=new JPanel(); samplePanel.setBorder(BorderFactory.createTitledBorder(&quot;示例&quot;)); //samplePanel.setLayout(new FlowLayout(FlowLayout.CENTER)); samplePanel.add(sample); JPanel panel1=new JPanel(); JPanel panel2=new JPanel(); JPanel panel3=new JPanel(); //JPanel panel4=new JPanel(); //JPanel panel5=new JPanel(); //panel1.add(fontLabel); //panel1.add(styleLabel); //panel1.add(sizeLabel); //panel2.add(fontText); //panel2.add(new JScrollPane(fontList));//JList不支持直接滚动，所以要让JList作为JScrollPane的视口视图 //panel2.setLayout(new GridLayout(2,1)); //panel3.add(styleText); //panel3.add(new JScrollPane(styleList)); //panel3.setLayout(new GridLayout(2,1)); //panel4.add(sizeText); //panel4.add(new JScrollPane(sizeText)); //panel4.setLayout(new GridLayout(2,1)); //panel5.add(okButton); //panel5.add(cancel); //con.add(panel1); //con.add(panel2); //con.add(panel3); //con.add(panel4); //con.add(panel5); panel2.add(fontText); panel2.add(styleText); panel2.add(sizeText); panel2.add(okButton); panel3.add(new JScrollPane(fontList));//JList不支持直接滚动，所以要让JList作为JScrollPane的视口视图 panel3.add(new JScrollPane(styleList)); panel3.add(new JScrollPane(sizeList)); panel3.add(cancel); con.add(panel1); con.add(panel2); con.add(panel3); con.add(samplePanel); fontDialog.setSize(350,340); fontDialog.setLocation(200,200); fontDialog.setResizable(false); fontDialog.setVisible(true); } //public void menuPerformed(MenuEvent e) //{ checkMenuItemEnabled();//设置剪切、复制、粘贴、删除等功能的可用性 //} public void actionPerformed(ActionEvent e) { //新建 if(e.getSource()==fileMenu_New) { editArea.requestFocus(); String currentValue=editArea.getText(); boolean isTextChange=(currentValue.equals(oldValue))?false:true; if(isTextChange) { int saveChoose=JOptionPane.showConfirmDialog(this,&quot;您的文件尚未保存，是否保存？&quot;,&quot;提示&quot;,JOptionPane.YES_NO_CANCEL_OPTION); if(saveChoose==JOptionPane.YES_OPTION) { String str=null; JFileChooser fileChooser=new JFileChooser(); fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY); //fileChooser.setApproveButtonText(&quot;确定&quot;); fileChooser.setDialogTitle(&quot;另存为&quot;); int result=fileChooser.showSaveDialog(this); if(result==JFileChooser.CANCEL_OPTION) { statusLabel.setText(&quot;您没有选择任何文件&quot;); return; } File saveFileName=fileChooser.getSelectedFile(); if(saveFileName==null || saveFileName.getName().equals(&quot;&quot;)) { JOptionPane.showMessageDialog(this,&quot;不合法的文件名&quot;,&quot;不合法的文件名&quot;,JOptionPane.ERROR_MESSAGE); } else { try { FileWriter fw=new FileWriter(saveFileName); BufferedWriter bfw=new BufferedWriter(fw); bfw.write(editArea.getText(),0,editArea.getText().length()); bfw.flush();//刷新该流的缓冲 bfw.close(); isNewFile=false; currentFile=saveFileName; oldValue=editArea.getText(); this.setTitle(saveFileName.getName()+&quot; - 记事本&quot;); statusLabel.setText(&quot;当前打开文件：&quot;+saveFileName.getAbsoluteFile()); } catch (IOException ioException) { } } } else if(saveChoose==JOptionPane.NO_OPTION) { editArea.replaceRange(&quot;&quot;,0,editArea.getText().length()); statusLabel.setText(&quot; 新建文件&quot;); this.setTitle(&quot;无标题 - 记事本&quot;); isNewFile=true; undo.discardAllEdits(); //撤消所有的&quot;撤消&quot;操作 editMenu_Undo.setEnabled(false); oldValue=editArea.getText(); } else if(saveChoose==JOptionPane.CANCEL_OPTION) { return; } } else { editArea.replaceRange(&quot;&quot;,0,editArea.getText().length()); statusLabel.setText(&quot; 新建文件&quot;); this.setTitle(&quot;无标题 - 记事本&quot;); isNewFile=true; undo.discardAllEdits();//撤消所有的&quot;撤消&quot;操作 editMenu_Undo.setEnabled(false); oldValue=editArea.getText(); } }//新建结束 //打开 else if(e.getSource()==fileMenu_Open) { editArea.requestFocus(); String currentValue=editArea.getText(); boolean isTextChange=(currentValue.equals(oldValue))?false:true; if(isTextChange) { int saveChoose=JOptionPane.showConfirmDialog(this,&quot;您的文件尚未保存，是否保存？&quot;,&quot;提示&quot;,JOptionPane.YES_NO_CANCEL_OPTION); if(saveChoose==JOptionPane.YES_OPTION) { String str=null; JFileChooser fileChooser=new JFileChooser(); fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY); //fileChooser.setApproveButtonText(&quot;确定&quot;); fileChooser.setDialogTitle(&quot;另存为&quot;); int result=fileChooser.showSaveDialog(this); if(result==JFileChooser.CANCEL_OPTION) { statusLabel.setText(&quot;您没有选择任何文件&quot;); return; } File saveFileName=fileChooser.getSelectedFile(); if(saveFileName==null || saveFileName.getName().equals(&quot;&quot;)) { JOptionPane.showMessageDialog(this,&quot;不合法的文件名&quot;,&quot;不合法的文件名&quot;,JOptionPane.ERROR_MESSAGE); } else { try { FileWriter fw=new FileWriter(saveFileName); BufferedWriter bfw=new BufferedWriter(fw); bfw.write(editArea.getText(),0,editArea.getText().length()); bfw.flush();//刷新该流的缓冲 bfw.close(); isNewFile=false; currentFile=saveFileName; oldValue=editArea.getText(); this.setTitle(saveFileName.getName()+&quot; - 记事本&quot;); statusLabel.setText(&quot;当前打开文件：&quot;+saveFileName.getAbsoluteFile()); } catch (IOException ioException) { } } } else if(saveChoose==JOptionPane.NO_OPTION) { String str=null; JFileChooser fileChooser=new JFileChooser(); fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY); //fileChooser.setApproveButtonText(&quot;确定&quot;); fileChooser.setDialogTitle(&quot;打开文件&quot;); int result=fileChooser.showOpenDialog(this); if(result==JFileChooser.CANCEL_OPTION) { statusLabel.setText(&quot;您没有选择任何文件&quot;); return; } File fileName=fileChooser.getSelectedFile(); if(fileName==null || fileName.getName().equals(&quot;&quot;)) { JOptionPane.showMessageDialog(this,&quot;不合法的文件名&quot;,&quot;不合法的文件名&quot;,JOptionPane.ERROR_MESSAGE); } else { try { FileReader fr=new FileReader(fileName); BufferedReader bfr=new BufferedReader(fr); editArea.setText(&quot;&quot;); while((str=bfr.readLine())!=null) { editArea.append(str); } this.setTitle(fileName.getName()+&quot; - 记事本&quot;); statusLabel.setText(&quot; 当前打开文件：&quot;+fileName.getAbsoluteFile()); fr.close(); isNewFile=false; currentFile=fileName; oldValue=editArea.getText(); } catch (IOException ioException) { } } } else { return; } } else { String str=null; JFileChooser fileChooser=new JFileChooser(); fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY); //fileChooser.setApproveButtonText(&quot;确定&quot;); fileChooser.setDialogTitle(&quot;打开文件&quot;); int result=fileChooser.showOpenDialog(this); if(result==JFileChooser.CANCEL_OPTION) { statusLabel.setText(&quot; 您没有选择任何文件 &quot;); return; } File fileName=fileChooser.getSelectedFile(); if(fileName==null || fileName.getName().equals(&quot;&quot;)) { JOptionPane.showMessageDialog(this,&quot;不合法的文件名&quot;,&quot;不合法的文件名&quot;,JOptionPane.ERROR_MESSAGE); } else { try { FileReader fr=new FileReader(fileName); BufferedReader bfr=new BufferedReader(fr); editArea.setText(&quot;&quot;); while((str=bfr.readLine())!=null) { editArea.append(str); } this.setTitle(fileName.getName()+&quot; - 记事本&quot;); statusLabel.setText(&quot; 当前打开文件：&quot;+fileName.getAbsoluteFile()); fr.close(); isNewFile=false; currentFile=fileName; oldValue=editArea.getText(); } catch (IOException ioException) { } } } }//打开结束 //保存 else if(e.getSource()==fileMenu_Save) { editArea.requestFocus(); if(isNewFile) { String str=null; JFileChooser fileChooser=new JFileChooser(); fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY); //fileChooser.setApproveButtonText(&quot;确定&quot;); fileChooser.setDialogTitle(&quot;保存&quot;); int result=fileChooser.showSaveDialog(this); if(result==JFileChooser.CANCEL_OPTION) { statusLabel.setText(&quot;您没有选择任何文件&quot;); return; } File saveFileName=fileChooser.getSelectedFile(); if(saveFileName==null || saveFileName.getName().equals(&quot;&quot;)) { JOptionPane.showMessageDialog(this,&quot;不合法的文件名&quot;,&quot;不合法的文件名&quot;,JOptionPane.ERROR_MESSAGE); } else { try { FileWriter fw=new FileWriter(saveFileName); BufferedWriter bfw=new BufferedWriter(fw); bfw.write(editArea.getText(),0,editArea.getText().length()); bfw.flush();//刷新该流的缓冲 bfw.close(); isNewFile=false; currentFile=saveFileName; oldValue=editArea.getText(); this.setTitle(saveFileName.getName()+&quot; - 记事本&quot;); statusLabel.setText(&quot;当前打开文件：&quot;+saveFileName.getAbsoluteFile()); } catch (IOException ioException) { } } } else { try { FileWriter fw=new FileWriter(currentFile); BufferedWriter bfw=new BufferedWriter(fw); bfw.write(editArea.getText(),0,editArea.getText().length()); bfw.flush(); fw.close(); } catch(IOException ioException) { } } }//保存结束 //另存为 else if(e.getSource()==fileMenu_SaveAs) { editArea.requestFocus(); String str=null; JFileChooser fileChooser=new JFileChooser(); fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY); //fileChooser.setApproveButtonText(&quot;确定&quot;); fileChooser.setDialogTitle(&quot;另存为&quot;); int result=fileChooser.showSaveDialog(this); if(result==JFileChooser.CANCEL_OPTION) { statusLabel.setText(&quot; 您没有选择任何文件&quot;); return; } File saveFileName=fileChooser.getSelectedFile(); if(saveFileName==null||saveFileName.getName().equals(&quot;&quot;)) { JOptionPane.showMessageDialog(this,&quot;不合法的文件名&quot;,&quot;不合法的文件名&quot;,JOptionPane.ERROR_MESSAGE); } else { try { FileWriter fw=new FileWriter(saveFileName); BufferedWriter bfw=new BufferedWriter(fw); bfw.write(editArea.getText(),0,editArea.getText().length()); bfw.flush(); fw.close(); oldValue=editArea.getText(); this.setTitle(saveFileName.getName()+&quot; - 记事本&quot;); statusLabel.setText(&quot; 当前打开文件:&quot;+saveFileName.getAbsoluteFile()); } catch(IOException ioException) { } } }//另存为结束 //页面设置 else if(e.getSource()==fileMenu_PageSetUp) { editArea.requestFocus(); JOptionPane.showMessageDialog(this,&quot;对不起，此功能尚未实现！更多请看http://pan.muyi.so&quot;,&quot;提示&quot;,JOptionPane.WARNING_MESSAGE); }//页面设置结束 //打印 else if(e.getSource()==fileMenu_Print) { editArea.requestFocus(); JOptionPane.showMessageDialog(this,&quot;对不起，此功能尚未实现！更多请看http://pan.muyi.so&quot;,&quot;提示&quot;,JOptionPane.WARNING_MESSAGE); }//打印结束 //退出 else if(e.getSource()==fileMenu_Exit) { int exitChoose=JOptionPane.showConfirmDialog(this,&quot;确定要退出吗?&quot;,&quot;退出提示&quot;,JOptionPane.OK_CANCEL_OPTION); if(exitChoose==JOptionPane.OK_OPTION) { System.exit(0); } else { return; } }//退出结束 //编辑 //else if(e.getSource()==editMenu) //{ checkMenuItemEnabled();//设置剪切、复制、粘贴、删除等功能的可用性 //} //编辑结束 //撤销 else if(e.getSource()==editMenu_Undo || e.getSource()==popupMenu_Undo) { editArea.requestFocus(); if(undo.canUndo()) { try { undo.undo(); } catch (CannotUndoException ex) { System.out.println(&quot;Unable to undo:&quot; + ex); //ex.printStackTrace(); } } if(!undo.canUndo()) { editMenu_Undo.setEnabled(false); } }//撤销结束 //剪切 else if(e.getSource()==editMenu_Cut || e.getSource()==popupMenu_Cut) { editArea.requestFocus(); String text=editArea.getSelectedText(); StringSelection selection=new StringSelection(text); clipBoard.setContents(selection,null); editArea.replaceRange(&quot;&quot;,editArea.getSelectionStart(),editArea.getSelectionEnd()); checkMenuItemEnabled();//设置剪切，复制，粘帖，删除功能的可用性 }//剪切结束 //复制 else if(e.getSource()==editMenu_Copy || e.getSource()==popupMenu_Copy) { editArea.requestFocus(); String text=editArea.getSelectedText(); StringSelection selection=new StringSelection(text); clipBoard.setContents(selection,null); checkMenuItemEnabled();//设置剪切，复制，粘帖，删除功能的可用性 }//复制结束 //粘帖 else if(e.getSource()==editMenu_Paste || e.getSource()==popupMenu_Paste) { editArea.requestFocus(); Transferable contents=clipBoard.getContents(this); if(contents==null)return; String text=&quot;&quot;; try { text=(String)contents.getTransferData(DataFlavor.stringFlavor); } catch (Exception exception) { } editArea.replaceRange(text,editArea.getSelectionStart(),editArea.getSelectionEnd()); checkMenuItemEnabled(); }//粘帖结束 //删除 else if(e.getSource()==editMenu_Delete || e.getSource()==popupMenu_Delete) { editArea.requestFocus(); editArea.replaceRange(&quot;&quot;,editArea.getSelectionStart(),editArea.getSelectionEnd()); checkMenuItemEnabled(); //设置剪切、复制、粘贴、删除等功能的可用性 }//删除结束 //查找 else if(e.getSource()==editMenu_Find) { editArea.requestFocus(); find(); }//查找结束 //查找下一个 else if(e.getSource()==editMenu_FindNext) { editArea.requestFocus(); find(); }//查找下一个结束 //替换 else if(e.getSource()==editMenu_Replace) { editArea.requestFocus(); replace(); }//替换结束 //转到 else if(e.getSource()==editMenu_GoTo) { editArea.requestFocus(); JOptionPane.showMessageDialog(this,&quot;对不起，此功能尚未实现！更多请看http://pan.muyi.so&quot;,&quot;提示&quot;,JOptionPane.WARNING_MESSAGE); }//转到结束 //时间日期 else if(e.getSource()==editMenu_TimeDate) { editArea.requestFocus(); //SimpleDateFormat currentDateTime=new SimpleDateFormat(&quot;HH:mmyyyy-MM-dd&quot;); //editArea.insert(currentDateTime.format(new Date()),editArea.getCaretPosition()); Calendar rightNow=Calendar.getInstance(); Date date=rightNow.getTime(); editArea.insert(date.toString(),editArea.getCaretPosition()); }//时间日期结束 //全选 else if(e.getSource()==editMenu_SelectAll || e.getSource()==popupMenu_SelectAll) { editArea.selectAll(); }//全选结束 //自动换行(已在前面设置) else if(e.getSource()==formatMenu_LineWrap) { if(formatMenu_LineWrap.getState()) editArea.setLineWrap(true); else editArea.setLineWrap(false); }//自动换行结束 //字体设置 else if(e.getSource()==formatMenu_Font) { editArea.requestFocus(); font(); }//字体设置结束 //设置状态栏可见性 else if(e.getSource()==viewMenu_Status) { if(viewMenu_Status.getState()) statusLabel.setVisible(true); else statusLabel.setVisible(false); }//设置状态栏可见性结束 //帮助主题 else if(e.getSource()==helpMenu_HelpTopics) { editArea.requestFocus(); JOptionPane.showMessageDialog(this,&quot;路漫漫其修远兮，吾将上下而求索。&quot;,&quot;帮助主题&quot;,JOptionPane.INFORMATION_MESSAGE); }//帮助主题结束 //关于 else if(e.getSource()==helpMenu_AboutNotepad) { editArea.requestFocus(); JOptionPane.showMessageDialog(this, &quot;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;\n&quot;+ &quot; 编写者：沐伊科技 \n&quot;+ &quot; 编写时间：2016-06-09 \n&quot;+ &quot; 更多教程：http://pan.muyi.so (网盘资源教程应有尽有哦!) \n&quot;+ &quot; e-mail：llqqxf@163.com \n&quot;+ &quot; 一些地方借鉴他人，不足之处希望大家能提出意见，谢谢！ \n&quot;+ &quot;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;\n&quot;, &quot;记事本&quot;,JOptionPane.INFORMATION_MESSAGE); }//关于结束 }//方法actionPerformed()结束 //实现DocumentListener接口中的方法(与撤销操作有关) public void removeUpdate(DocumentEvent e) { editMenu_Undo.setEnabled(true); } public void insertUpdate(DocumentEvent e) { editMenu_Undo.setEnabled(true); } public void changedUpdate(DocumentEvent e) { editMenu_Undo.setEnabled(true); }//DocumentListener结束 //实现接口UndoableEditListener的类UndoHandler(与撤销操作有关) class UndoHandler implements UndoableEditListener { public void undoableEditHappened(UndoableEditEvent uee) { undo.addEdit(uee.getEdit()); } } //main函数开始 public static void main(String args[]) { Notepad notepad=new Notepad(); notepad.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//使用 System exit 方法退出应用程序 }//main函数结束 }]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Mysql</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构相关_6_16]]></title>
    <url>%2F2018%2F07%2F10%2FMavenPeizhi%2F</url>
    <content type="text"><![CDATA[Maven项目配置 pom.xml配置 配置编码格式为UTF-8123456&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt; &lt;spring.version&gt;5.0.6.RELEASE&lt;/spring.version&gt;//配置统一版本号&lt;/properties&gt; 配置编程环境版本 maven配置1234567891011121314&lt;build&gt; &lt;finalName&gt;pp&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Mysql</tag>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习—聚类降维]]></title>
    <url>%2F2018%2F07%2F09%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E9%99%8D%E7%BB%B4_GMM_KMEANS%2F</url>
    <content type="text"><![CDATA[机器学习—聚类降维 机器学习—Kmeans聚类属于无监督学习，朴素贝叶斯、SVM等都是有类别标签y的，即已经给出了样本的分类 12345671、随机给K个聚类质心 v2、重复下面过程直到收敛2.1对于每一个样例i，计算其应该属于的类 隶属度 ：zi=argmin||xi−μj||^2求距离近的2.2 聚类中心 u= 其聚类精度明显优于传统的随机选择种子的方法，且计算速度也比较快。而对于更大型的数据集，kmeans++需要进一步扩展，才能获取更好的表现，即kmeans是高度可扩展的。 机器学习—GMM常用作聚类，可以运动目标检测。 高斯混合模型（Gaussian Mixed Model）指的是多个高斯分布函数的线性组合，理论上GMM可以拟合出任意类型的分布，通常用于解决同一集合下的数据包含多个不同的分布的情况（或者是同一类分布但参数不一样，或者是不同类型的分布，比如正态分布和伯努利分布） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 基于混合高斯模型的运动目标检测// Author： http://blog.csdn.net/icvpr #include &lt;iostream&gt;#include &lt;string&gt; #include &lt;opencv2/opencv.hpp&gt; int main(int argc, char** argv)&#123; std::string videoFile = &quot;../test.avi&quot;; cv::VideoCapture capture; capture.open(videoFile); if (!capture.isOpened()) &#123; std::cout&lt;&lt;&quot;read video failure&quot;&lt;&lt;std::endl; return -1; &#125; cv::BackgroundSubtractorMOG2 mog; cv::Mat foreground; cv::Mat background; cv::Mat frame; long frameNo = 0; while (capture.read(frame)) &#123; ++frameNo; std::cout&lt;&lt;frameNo&lt;&lt;std::endl; // 运动前景检测，并更新背景 mog(frame, foreground, 0.001); // 腐蚀 cv::erode(foreground, foreground, cv::Mat()); // 膨胀 cv::dilate(foreground, foreground, cv::Mat()); mog.getBackgroundImage(background); // 返回当前背景图像 cv::imshow(&quot;video&quot;, foreground); cv::imshow(&quot;background&quot;, background); if (cv::waitKey(25) &gt; 0) &#123; break; &#125; &#125; return 0;&#125; EM算法：第一步先求出要估计参数的粗略值。第二步使用第一步的值最大化似然函数。因此要先求出GMM的似然函数。]]></content>
      <tags>
        <tag>Opencv</tag>
        <tag>C++</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式_7_5]]></title>
    <url>%2F2018%2F07%2F05%2Fmodel_danli_7_5%2F</url>
    <content type="text"><![CDATA[设计模式—单例模式 单例模式是设计模式中比较简单的一种。适合于一个类只有一个实例的情况，比如窗口管理器，打印缓冲池和文件系统，它们都是原型的例子。典型的情况是，那些对象的类型被遍及一个软件系统的不同对象访问，因此需要一个全局的访问. 单例模式你可以： 123一、确保一个类只有一个实例被建立 二、提供了一个对对象的全局访问指针 三、在不影响单例类的客户端的情况下允许将来有多个实例 经典的单例模式有三种，懒汉式、饿汉式和 登记式。 懒汉式的特点是延迟加载，比如配置文件，采用懒汉式的方法，顾名思义，懒汉么，很懒的，配置文件的实例直到用到的时候才会加载。 饿汉式的特点是一开始就加载了，如果说懒汉式是“时间换空间”，那么饿汉式就是“空间换时间”，因为一开始就创建了实例。]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Mysql</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机视觉——]]></title>
    <url>%2F2018%2F07%2F05%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%2F</url>
    <content type="text"><![CDATA[计算机视觉]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown 基本用法(常用)]]></title>
    <url>%2F2018%2F07%2F01%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[markdown 基本用法 一级标题用”&lt;/h数字&gt;”或者多个”#”隔开 &lt;h1&gt;一级标题&lt;/h1&gt; # 一级标题 二级标题 &lt;h2&gt;二级标题&lt;/h2&gt; ## 二级标题 以此类推 代码块 四个空格后开始写代码（空空空空zxcvbasdfgqwert） 或者用12 AAA ``` (四个空格两个字节)zxcvbasdfgqwert 斜体 文字两端使用1个"*"或者"_"夹起来 *a* *a* 或者 _a_ --- 粗体 文字两端使用2个"*"或者"_"夹起来 --- 分隔线 三个"*"或者"-" *** --- --- 无序列表 使用加号”+”或是减号”-“作为列表标记： 可乐 雪碧 +（空格）可乐 +（空格）雪碧 emoji表情Markdown文档支持文中插入emoji表情 比如： :laughing: 表示:laughing::heart: 表示:heart:其他emoji的地址如下链接：emoji地址]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git上传文件到Github]]></title>
    <url>%2F2018%2F07%2F01%2Fgit_git2github%2F</url>
    <content type="text"><![CDATA[准备工作： 1、电脑装有Git2、GitHub 已有仓库 1、克隆GitHub仓库，到本地 文件夹右键选择Git Bash Here，输入代码 1Git clone git@github.com:用户名/仓库名.git 2、放置代码内容到第一步下载的文件夹里 3、执行代码 123git add .git commit -m &quot;情况说明&quot;git push origin master 4、上传成功]]></content>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git入门]]></title>
    <url>%2F2018%2F06%2F25%2Fgit%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[git入门 场景1：我要开始一个新项目，想用git管理代码（待更新）注册账号第一步，我们需要先注册github帐号。 第二步，新建项目，填上项目名称，git地址等信息以后，就可以新建一个项目了。 第三步，填加ssh的key，添加key的作用是允许你的电脑访问git仓库。如果git项目是私有的，那么就要指定谁可以访问谁不能访问。我们把自己计算机上的ssh key添加到git项目上，就表示我们电脑里的key能访问了，可以理解成key的白名单。配置方法如下： 邮箱地址填注册git时用的邮箱，然后按3个回车。-t rsa -C "xxx@happymmall.com"```123### 在git.oschina的项目里添加公钥，查看公钥内容：```cat ~/.ssh/id_rsa.pub 第四步，从远程拉下代码，这git项目就算建好了。 使用项目的ssh形式的地址clone xxx```12345##场景2：我要开始开发了，要怎么玩？进入开发前，要先了解`git`的分支使用规范。当我们项目`clone`下来以后，默认会处在`master`分支上，也就是`git`的默认分支。通常我们是不在这个分支上做开发的，如果更规范一点，`master`分支会对开发人员设置成只读的，最终由上线人员把要上线的代码合并到`master`分支上。这时候我们就要做一个自己的开发分支。执行如下：### 切换到master分支```git checkout master 拉取最新代码pull```123### 以master分支为基础，新建本地分支，新分支名以mmall_v1.0为例```git checkout -b mmall_v1.0 在远程建立对应的分支，只有新建分支时需要执行这步，以后只需要git pushpush --set-upstream origin mmall_v1.0```1234567然后就可以在新分支上开始写代码。##场景3：我要在一个已有的分支上开发点东西因为是已有分支，就不用自己新建了，直接切换到指定分支，这里还是以`mmall_v1.0`为例。### 切换分支```git checkout mmall_v1.0 拉取当前分支最新代码pull```12345然后还是一样的，就可以进入开发了。##场景4：开发到一定程度，想看看改动了什么内容### 看文件的改动```git status 看文件内容的变动diff```123## 场景5：代码开发完成了，想提交代码### 首先是追踪变更的文件```git add . 然后提交到本地commit -am '我是提交的说明'```123### 提交到远程```git push 场景6：当前分支代码都开发完了，准备提交上线在上线的时候，一般是由管理员或发布人员把开发分支的代码合并到master分支上，上线前我们要先把远程master最新的代码合并到我们的分支上再提交，才能保证我们的开发分支版本高于master分支。如果不这么干，有多个人开发的话，就有可能造成A发布了一个版本，等B发布的时候会把A发布的内容冲掉。 合并远程分支merge origin master```12345### 注意：如果发现merge的结果里有CONFLICT，就表示当前分支和远程master分支有文件冲突，我们要手动解决一下冲突再做一次提交才可以。### 没冲突或解决完冲突后，提交到当前分支的远程```git push merge完成后，就可以做提交了，通常使用pull request提交合并到master分支的请求，管理员合并后，我们的分支内容就可以上线了。 作者：Rosen_Gao链接：http://www.imooc.com/article/19060来源：慕课网本文原创发布于慕课网 ，转载请注明出处，谢谢合作]]></content>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构相关_6_16]]></title>
    <url>%2F2018%2F06%2F16%2Fd_struct_6_16%2F</url>
    <content type="text"><![CDATA[数据结构相关 取数组中的元素复杂度o(1) 数据的逻辑结构分为线性结构和非线性结构。常用的线性结构有：线性表，栈，队列，双队列，数组，串。常见的非线性结构有：二维数组，多维数组，广义表，树(二叉树等)，图。 一个n*n的对称矩阵，如果以行主序存储，每一个元素占一个单元， 则其需要的最少需要的存储空间为（(n+1)×n/2），重点是对称矩阵 非空的广义表中的元素或者是一个不可分割的原子,或者是一个非空的广义表]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Mysql</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java相关小知识_6_15]]></title>
    <url>%2F2018%2F06%2F15%2FJava_6_16%2F</url>
    <content type="text"><![CDATA[实体完整性要求每个表都有唯一标识符，每一个表中的主键字段不能为空或者重复的值。 参照完整性要求关系中不允许引用不存在的实体。设定相应的更新删除插入规则来更新参考表。 Java语言使用的是1234567891011121314151617181920212223242526272829303132---HashMap不能保证元素的顺序，HashMap能够将键设为null，也可以将值设为null，与之对应的是Hashtable，(注意大小写：不是HashTable)，Hashtable不能将键和值设为null，否则运行时会报空指针异常错误。&lt;br&gt;HashMap线程不安全，Hashtable线程安全---for循环的执行顺序：&lt;br&gt;for(条件1;条件2;条件3) &#123; //语句&#125;执行顺序是条件1-&gt;条件2-&gt;语句-&gt;条件3-&gt;条件2-&gt;语句-&gt;条件3-&gt;条件2........如果条件2为true，则一直执行。如果条件2位false，则for循环结束---java1.8后，抽象类中的抽象方法和非抽象方法在不加修饰符的情况下，都是默认的default---substring 方法将返回一个包含从 start 到最后（不包含 end ）的子字符串的字符串。（左闭右开）---### 在为传统面向对象语言的程序做单元测试的时候,经常用到mock对象。Mock对象通过反射数。请问反射最大程度破坏了面向对象的以下哪个特性？ ：封装性mock对象：也成为伪对象，在测试中的利用mock对象来代替真实对象，方便测试的进行。&lt;br&gt;java的封装性：指的是将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，通过该类提供的方法实现对内部信息的操作访问。&lt;br&gt;反射机制：在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法;对于任意一个对象，都能够调用它的任意一个方法和属性。&lt;br&gt;反射破坏代码的封装性，破坏原有的访问修饰符访问限制 ---### try-catch-finally执行顺序&lt;br&gt;&gt;博文try-catch-finally执行顺序详解：http://qing0991.blog.51cto.com/1640542/1387200try块中抛出异常，try、catch和finally中都有return语句 public static int WithException(){ int i=10; try{ System.out.println(“i in try block is ： “+i); i = i/0; return —i; } catch(Exception e){ System.out.println(“i in catch - form try block is ： “+i); —i; System.out.println(“i in catch block is ： “+i); return —i; } finally{ System.out.println(“i in finally - from try or catch block is—“+i); —i; System.out.println(“i in finally block is—“+i); return —i; } }12执行结果： ============WithException================== i in try block is ： 10 i in catch - form try block is ： 10 i in catch block is ： 9 i in finally - from try or catch block is—8 i in finally block is—7 6```===============================执行顺序： 抛出异常后，执行catch块，在catch块的return的—i执行完后，并不直接返回而是执行finally，因finally中有return语句，所以，执行，返回结果6。 结论： try块中抛出异常，try、catch和finally中都有return语句，返回值是finally中的return。 总体结论： 结论一： return语句并不是函数的最终出口，如果有finally语句，这在return之后还会执行finally（return的值会暂存在栈里面，等待finally执行后再返回）结论二： finally里面不建议放return语句，根据需要，return语句可以放在try和catch里面和函数的最后。可行的做法有四：（1）return语句只在函数最后出现一次。（2）return语句仅在try和catch里面都出现。（3）return语句仅在try和函数的最后都出现。（4）return语句仅在catch和函数的最后都出现。注意，除此之外的其他做法都是不可行的，编译器会报错 Statement在JDBC中相当于SQL语句的载体Statement—-是最基本的用法，采用字符串拼接的方式，存在注入漏洞PreparedStatement—-对Statement中的SQL语句进行预编译，同时检查合法性，效率高CallableStatement—接口扩展 PreparedStatement，用来调用存储过程,它提供了对输出和输入/输出参数的支持。CallableStatement 接口还具有对 PreparedStatement 接口提供的输入参数的支持。BatchedStatement—不是标准的Statement类]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Mysql</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库相关_6_15]]></title>
    <url>%2F2018%2F06%2F15%2Fsql_6_15%2F</url>
    <content type="text"><![CDATA[关系规范化中的删除操作异常是不该删除的数据被删除 关系规范化中的删除操作失败是应该删除的数据未被删除 数据库中通常采用is NULL和is not NULL进行比较不用=等于号 插图矩形框：表示实体，在框中记入实体名。菱形框：表示联系，在框中记入联系名。椭圆形框：表示实体或联系的属性，将属性名记入框中。对于主属性名，则在其名称下划一下划线。连线：实体与属性之间；实体与联系之间；联系与属性之间用直线相连，并在直线上标注联系的类型。（对于一对一联系，要在两个实体连线方向各写1； 对于一对多联系，要在一的一方写1，多的一方写N；对于多对多关系，则要在两个实体连线方向各写N,M。) 一个m：n联系转换为一个关系模式，关系的码为各实体码的组合；一个1：n联系转换为一个关系模式，关系的码为n端实体的码；一个1：1联系转换为一个关系模式，关系的码为任意一端实体的码。 满足最低程度要求的范式属于第一范式，简称1NF；在第一范式中进一步满足一些要求的关系属于第二范式，简称2NF，依次类推，还有3NF、BCNF、4NF、5NF，这些都是关系范式。对关系模式的属性间的函数依赖加以不同的限制就形成了不同的范式。这些范式是递进的，即如果是一个关系是1NF的，它比不是1NF的关系要好；同样，2NF的关系比1NF的关系要好等等，范式越高、规范化程度越高，关系模式就越好。总而言之： 满足第三范式（3NF）必须先满足第二范式（2NF）。满足第二范式（2NF）必须先满足第一范式（1NF）。]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Mysql</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库相关_6_15]]></title>
    <url>%2F2018%2F06%2F15%2Fsql_6_16%2F</url>
    <content type="text"><![CDATA[数据库系统达到了数据独立性是因为采用了三级模式结构 人们为数据库设计了一个严谨的体系结构，数据库领域公认的标准结构是三级模式结构，它包括外模式、概念模式、内模式，有效地组织、管理数据，提高了数据库的逻辑独立性和物理独立性。用户级对应外模式，概念级对应概念模式，物理级对应内模式，使不同级别的用户对数据库形成不同的视图。 级别 模式 用户级 外模式 概念级 概念模式 物理级 内模式 所谓视图，就是指观察、认识和理解数据的范围、角度和方法，是数据库在用户“眼中”的反映，很显然，不同层次（级别）用户所“看到”的数据库是不相同的。 索引顺序查找又称为分块查找，是介于顺序查找和二分查找之间的一种查找方法 MySQL有多种存储引擎，每种存储引擎有各自的优缺点，可以择优选择使用： MyISAM、InnoDB、MERGE、MEMORY(HEAP)、BDB(BerkeleyDB)、EXAMPLE、FEDERATED、ARCHIVE、CSV、BLACKHOLE。 MySQL支持数个存储引擎作为对不同表的类型的处理器。MySQL存储引擎包括处理事务安全表的引擎和处理非事务安全表的引擎： MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。MyISAM在所有MySQL配置里被支持，它是默认的存储引擎，除非你配置MySQL默认使用另外一个引擎。 MEMORY存储引擎提供“内存中”表。MERGE存储引擎允许集合将被处理同样的MyISAM表作为一个单独的表。就像MyISAM一样，MEMORY和MERGE存储引擎处理非事务表，这两个引擎也都被默认包含在MySQL中。 注释：MEMORY存储引擎正式地被确定为HEAP引擎。 InnoDB和BDB存储引擎提供事务安全表。BDB被包含在为支持它的操作系统发布的MySQL-Max二进制分发版里。InnoDB也默认被包括在所 有MySQL 5.1二进制分发版里，你可以按照喜好通过配置MySQL来允许或禁止任一引擎。 EXAMPLE存储引擎是一个“存根”引擎，它不做什么。你可以用这个引擎创建表，但没有数据被存储于其中或从其中检索。这个引擎的目的是服务，在 MySQL源代码中的一个例子，它演示说明如何开始编写新存储引擎。同样，它的主要兴趣是对开发者。 NDB Cluster是被MySQL Cluster用来实现分割到多台计算机上的表的存储引擎。它在MySQL-Max 5.1二进制分发版里提供。这个存储引擎当前只被Linux, Solaris, 和Mac OS X 支持。在未来的MySQL分发版中，我们想要添加其它平台对这个引擎的支持，包括Windows。 ARCHIVE存储引擎被用来无索引地，非常小地覆盖存储的大量数据。 CSV存储引擎把数据以逗号分隔的格式存储在文本文件中。 BLACKHOLE存储引擎接受但不存储数据，并且检索总是返回一个空集。 FEDERATED存储引擎把数据存在远程数据库中。在MySQL 5.1中，它只和MySQL一起工作，使用MySQL C Client API。在未来的分发版中，我们想要让它使用其它驱动器或客户端连接方法连接到另外的数据源。 比较常用的是MyISAM和InnoBD]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Mysql</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库相关_6_8]]></title>
    <url>%2F2018%2F06%2F08%2Fsql_6_8%2F</url>
    <content type="text"><![CDATA[数据库的设计总体上分为6个阶段： 1、 需求分析阶段 准确了解用户的需求，撰写需求说明 2、概念设计阶段 它是整个数据库设计的关键，通过对用户需求进行综合，归纳与抽象，形成一个独立于具体DBMS的概念模型。E-R图的设计在此阶段。 3、逻辑结构设计阶段 将概念结果转换为某个DBMS所支持的数据模型。也就是指E-R图和关系模型的转换，具体为将实体，实体的属性和实体之间的联系转换为关系模式。 4、数据库物理设计阶段 为逻辑结果选取一个最适合应用环境的物理结构，包括存储结构和存取方法。 5、数据库实施阶段 此阶段利用SQL语句实现逻辑结构设计和物理设计阶段的内容，包括建立数据库，编制与调试应用程序等。 6、数据库运行和维护阶段 运行过程中不断的调整，修改和优化数据库系统。 聚集索引 一种索引，该索引中键值的逻辑顺序决定了表中相应行的物理顺序。 聚集索引确定表中数据的物理顺序。聚集索引类似于电话簿，后者按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。 聚集索引对于那些经常要搜索范围值的列特别有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。聚簇索引的顺序就是数据的物理存储的顺序，叶子节点就是数据节点。物理排序只有一种，所以聚簇索引只有一种,当索引值唯一时，使用聚集索引查找特定的行也很有效率。 非聚集索引 一种索引，该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。 索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块 下面的表总结了何时使用聚集索引或非聚集索引（很重要）： 动作描述 使用聚集索引 使用非聚集索引 列经常被分组排序 应 应 返回某范围内的数据 应 不应 一个或极少不同值 不应 不应 小数目的不同值 应 不应 大数目的不同值 不应 应 频繁更新的列 不应 应 外键列 应 应 主键列 应 应 频繁修改索引列 不应 应 对数据库的操作都是在事务中进行的。 事务事务是指一组相互依赖的操作行为。事务中的操作是不可分割的工作单元，由一组在业务逻辑上相互依赖的SQL语句组成，有ACID特征。 Atomic（原子性）：事务中包含的操作被看做一个逻辑单元，这个逻辑单元中的操作要么全部成功，要么全部失败。 Consistency（一致性）：只有合法的数据可以被写入数据库，否则事务应该将其回滚到最初状态。 Isolation（隔离性）：事务允许多个用户对同一个数据进行并发访问，而不破坏数据的正确性和完整性。同时，并行事务的修改必须与其他并行事务的修改相互独立。 Durability（持久性）：事务结束后，事务处理的结果必须能够得到固化。 数据库中有多个事务同时存在，就是事务并发，此时就不能保证事务隔离性，SQL-92定义了事务隔离级别，描述了给定事务的行为对其它并发执行事务的暴露程度，或者说是一个事务必须与其它事务进行隔离的程度。隔离级别由低到高为： Read Uncommitted，Read Committed，Repeatable Read， Serializable隔离级别越高，越能保证数据的完整性和一致性，但对并发性能的影响也越大 DML（data manipulation language） 它们是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言 DDL（data definition language） DDL比DML要多，主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用 DCL（Data Control Language） 是数据库控制功能。是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL]]></content>
      <tags>
        <tag>GitHub</tag>
        <tag>Mysql</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决连接MySQL，报错10061，系统错误5]]></title>
    <url>%2F2018%2F06%2F04%2Fdatabase_3%2F</url>
    <content type="text"><![CDATA[1.解决连接MySQL，报错10061，系统错误5 mysql登录不上去，报错10061，百度后得，mysql服务未启动。。 方法一、选择dos窗口命令行打开mysql输入代码 1net start mysql 报错，如图所示。系统错误 5 解决办法：使用管理员身份运行cmd.exe成功了，如下图 方法二、手工启动计算机-&gt;右键-&gt;管理-&gt;计算机管理找到mysql，右键启动]]></content>
      <tags>
        <tag>Mysql</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简历投递信息-0907更新]]></title>
    <url>%2F2018%2F05%2F20%2F%E7%AE%80%E5%8E%86%E6%8A%95%E9%80%92%2F</url>
    <content type="text"><![CDATA[简历投递信息-持续更新 公司 招聘类型 招聘职位 工作地点 面试地点 简历截止日期 投递状态 目前情况 京东 校招 算法工程师 成都（北京,上海,深圳,武汉,南京） 西安 暂无 已投 vivo 校招内推 图像算法工程师 杭州 远程面试 8月9-15日 8月8日18:00 已投 简历挂 ThoughtWorks 校招内推 算法工程师 西安（北京、上海、深圳、成都、武汉） 西安 10月 已投 一面挂 虹软 提前批内推 图像处理算法工程师 (杭州市,上海市,南京市) 暂无 7月31日 已投 初面待定 海康威视 提前批 算法工程师（图像处理）产品研发中心(J11423) 杭州 暂无 暂无 已投 一面挂 海康威视 秋招 算法工程师（图像处理）产品研发中心(J11423) 杭州 西安 暂无 已投 海康威视 秋招 图像算法工程师（图像处理\视频编解码\3D视觉）(J11720) 杭州 西安 暂无 已投 大华 校招 智能算法工程师 西安（杭州，上海，北京） 暂无 暂无 已投 二面挂 浦发银行 校招 信息科技岗（系统开发方向) 西安 西安 暂无 已投 面试挂 腾讯 校招 计算机视觉方向 成都（深圳总部北京上海广州合肥） 西安 暂无 已投 汇顶科技 提前批内推 算法工程师-图像方向 成都（上海，深圳） 暂无 暂无 已投 笔试中 阿里巴巴 校招 算法工程师-图像图形(应届生） 成都（上海,深圳,北京,广州,杭州） 远程 暂无 已投 顺丰科技 校招 视觉算法工程师 深圳 西安 暂无 已投 中国网安 校招 暂无 成都 暂无 暂无 已投 海信 校招提前批 图像处理工程师 青岛 西安 7月31日 已投 offer 诺瓦电子 校招提前批 算法工程师 西安 西安 无 已投 二面挂 诺瓦电子 校招 算法工程师 西安 西安 无 已投 一面中 中科光电精密工程有限公司 校招 图像工程师 西安 西安 无 全志科技 校招 算法设计工程师 西安 西安 无 已投 笔试挂 多益网络 校招 人工智能及大数据研发工程师 广州 西安 无 已投 未笔试 字节跳动 校招内推 多媒体开发工程师 上海 西安 无 已投 笔试挂 虎牙 校招内推 机器学习工程师 广州 西安 无 已投 笔试挂 快手 校招内推 图像增强算法工程师 杭州 西安 无 已投 视频面 搜狗 校招 图像研究员/图像理解研究员 杭州 西安 无 已投 未笔试 招商网络科技 校招 算法工程师 成都(杭州，深圳) 西安 无 已投 一面 招商信用卡 校招 IT类(AI) 上海 西安 无 已投 笔试中 中兴 校招 软开/软测/MTK经理 西安 西安 无 已投 offer 华为 校招 软开/资料开发 西安 西安 无 已投 瑞芯微电子 校招 图像算法/camera工程师 福州 西安 无 已投 上海昕健医疗 校招 医学图像算法工程师 上海 西安 无 已投 笔试挂 奥比中光 校招 ISP/图像压缩算法/计算机视觉工程师 深圳（西安） 西安 无 已投 简历挂 北云科技 校招 信号处理算法工程师 上海 西安 无 已投 顶像技术 校招 算法工程师 杭州 西安 无 已投 福瑞泰克 校招 AI算法工程师 杭州 西安 无 已投 国自机器人 校招 算法工程师 杭州 西安 无 已投 新大陆 校招 算法工程师 福州 西安 无 已投 无锡信捷 校招 视觉算法工程师 无锡 西安 无 已投 初试 公安三所 校招 图像算法工程师 上海 西安 无 已投 翔仪恒昌 校招 算法研发工程师 上海 西安 无 已投 联发科技 校招 图像处理工程师 深圳 西安 无 已投 迈瑞医疗 校招 医学图像处理与人工智能研究工程师/软测 深圳 西安 无 已投 笔试挂 联影医疗 校招 图像处理算法研究工程师 深圳 西安 无 已投 联咏科技 校招 图像算法/软开/机器视觉 西安 西安 无 已投 笔试挂 豪威科技 校招 图像算法开发 武汉 西安 无 已投 中科创达 校招 算法工程师 成都 西安 无 已投 笔试中 飞依诺科技 校招 算法工程师 苏州 西安 无 已投 数码视讯 校招 Java/视频算法 西安 西安 无 已投 笔试挂 oppo 校招 Java后端 深圳 西安 无 已投 瑞晟微电子 校招 视频算法工/软开程师 苏州 西安 无 已投 捷视飞通 校招 算法研究工程师 成都 西安 无 已投 笔试 迅雷 校招 后台开发工程师 西安 西安 无 已投 神州航天 校招 后台开发工程师java 西安 西安 无 已投 亿高医疗 校招 研发工程师 南京 西安 无 已投 联想 校招 图像视频处理及计算机视觉研发工程师 深圳 西安 无 已投 宇视科技 校招 ISP图像处理工程师 西安 西安 无 已投 简历挂 烽火星空 校招 图像算法工程师 西安 西安 无 已投 比亚迪 校招 图像处理 西安 西安 无 已投 电科29所 校招 无 成都 西安 无 已投 笔试中 中国兵器工业集团212研究所 校招 图像处理 西安 西安 无 已投 中国兵器工业集团205研究所 校招 图像处理 西安 西安 无 已投 北方光电 校招 图像处理 西安 西安 无 已投 航天自动化研究所 校招 图像处理 西安 西安 无 已投 长岭科技 校招 图像处理 西安 西安 无 已投 天和防务 校招 图像处理 西安 西安 无 已投 晟昕科技 校招 图像处理 西安 西安 无 已投 面试 未尔锐创科技 校招 仿真开发 西安 西安 无 已投 开立生物医疗 校招 图像算法 武汉/深圳 西安 无 已投 未笔试 闻泰 校招 图像算法 西安 西安 无 已投 未笔试 (A)京东算法工程师（数据与算法类）campus.jd.com12345678910工作地点：北京,上海,深圳,武汉,成都,南京职位方向：技术方向公司： 京东集团, 京东金融, 京东商城, 京东物流岗位描述：1-2019年毕业，本科及以上学历2-研究及应用前沿互联网技术，如机器学习、深度学习、数据挖掘、推荐、搜索、自然语言处理、分布式并行算法、复杂网络、图像识别、计算机视觉、语音等3-至少熟悉java, c++，python中的一种开发语言4-良好的逻辑思维能力，良好的沟通能力、团队合作精神和学习能力（Java工程师有西安工作） (B)vivo图像算法工程师 https://hr.vivo.com/wt/vivo/web/index?brandCode=vivo12345678910111213141516岗位概况工作地点：杭州市学历要求：硕士研究生招聘人数：60职位类型：研发类岗位职责：1、根据公司对手机摄像头产品和技术的规划，设计并实现相应的图像处理、计算机视觉、机器学习和模式识别等算法； 2、负责算法的实现效果和性能优化； 3、对相关领域的最新学术论文、行业、竞争对手等使用的图像技术进行长期的跟踪和梳理。任职要求：1、硕士及以上学历，图像处理、计算机视觉、机器学习和模式识别等相关专业； 2、熟悉图像处理、计算机视觉、机器学习和模式识别等相关知识，具有相关项目的开发经验； 3、有深厚的数学功底和较强的算法实现能力，熟悉C/C++，具有良好的代码质量和风格； 4、发表过高水平的图像、视觉、机器学习和模式识别等相关学术论文/专利； 5、熟练的英文文献阅读能力； 6、严谨踏实，责任心强，条理清楚，善于学习总结，有良好的团队精神和沟通协调能力。 (C)ThoughtWorks算法工程师 https://join.thoughtworks.cn/12345678910工作地点: 北京、上海、深圳、西安、成都、武汉ThoughtWorks需要你：精通Python、Java、Scala、Matlab、SPSS、R、SAS等任意一种程序设计语言或工具；拥有应用数学、机器学习、模式识别、人工智能、数据挖掘、信号处理、自动化控制、系统工程、信息管理、数理统计等相关专业；有搜索引擎、精准营销、用户画像、推荐算法、异常检测、数据挖掘、图像识别、语音识别等相关项目经验；良好的业务理解能力和沟通技巧，具备很强的抗压能力和团队合作能力，可以出差；如果你愿意提交：已经发表过的论文，毕业论文、研究课题的成果，那就更好啦。ThoughtWorks期望你：参与过基于数据的统计、分析、挖掘，建模的课程与项目；参与过与机器学习相关的项目（课题研究或实习项目）。 （D）虹软图像处理算法工程师 http://job.arcsoft.com.cn/JobList.aspx?flag=2 123456789101112工作地点：杭州市,上海市,南京市招聘人数：若干薪资范围：面议发布时间：2018-07-30截止时间：-工作职责：图像处理算法研究任职资格：1、硕士及以上学历，图像处理、计算机视觉、模式识别相关专业研究方向； 2、熟悉当前流行的计算机视觉与模式分类理论以及常用的统计和学习方法：PCA、Boosting、SVM、Neural Net、Regression等；3、熟悉常用特征提取方法：Haar、Gabor、LBP、SIFT、HOG等； 深厚的数学功底与算法理论研究能力； 4、精通C/C++； 有2年以上图像处理和增强方面的独立研发能力及项目经验者优先； 熟悉深度学习理论并有项目实践者优先； 或发表过图像算法相关学术论文/专利者优先； （E）海康威视(E1)算法工程师（图像处理）产品研发中心(J11423) http://campus.hikvision.com/1234567891011121314工作性质： 全职 薪资范围： 面议 招聘人数： 若干 发布时间： 2018-07-16/08-07截止时间： 工作地点: 浙江省-杭州市工作职责:负责图像处理模块的算法设计，并在相关平台上实现。任职资格：1、计算机、电子信息、信号处理、图像处理类专业，硕士以上学历；2、精通C语言，掌握Matlab，熟悉OpenCV 等图像工具；3、熟悉图像处理或模式识别相关算法处理；4、对红外图像的非均匀性校正、细节增强、去噪、测温等相关算法有一定了解；5、具有较强的文献获取能力，英文文献检索和阅读能力；6、有红外图像算法处理经验者优先。 (E2)图像算法工程师（图像处理\视频编解码\3D视觉）(J11720)1234567891011121314151617工作性质： 全职 薪资范围： 面议 招聘人数： 若干 发布时间： 2018-08-07截止时间： 工作地点: 浙江省-杭州市工作职责:负责图像处理算法的研究、设计与实现。任职资格：1、硕士研究生及以上学历，计算机、通信、自控、光电、生仪等相关专业。 2、有较好数学基础，较强的图像处理算法设计与开发能力； 3、掌握c/c++、python等编程语言，能编程实现相关算法；4、较强的论文检索，英文专业文献阅读能力；5、良好的沟通与协作能力。具备以下经验之一者优先：1、 了解深度学习，在图像处理领域进行过深度学习相关研究与实现；2、 具备较丰富的图像处理、计算成像、3D视觉、视频编解码研究经历；3、 具备较丰富的雷达信号处理研究经历。 （F）大华2019届智能算法工程师 http://dahua.zhiye.com/Campus12345678910111213141516招聘类别： 校园招聘 工作性质： 全职 薪资范围： 面议 招聘人数： 若干发布时间： 2018-07-09 截止时间： 工作地点: 浙江省-杭州市,陕西省-西安市,上海市,北京市工作职责:负责视频和图像相关智能算法的调研、设计、开发和维护工作。任职资格：1、硕士及以上学历；2、熟悉计算机视觉、图像处理、模式识别和机器学习等领域相关知识；3、熟悉C或C++，Python开发语言，具有良好的英语阅读能力和数学功底，能够根据相关文献进行代码实现；4、至少了解目标检测、目标跟踪、目标识别、事件检测、图像检索等算法中的一种，有相关项目经验优先；5、熟悉至少一种深度学习框架，包括Caffe、TensorFlow等，对深度学习的底层实现有初步理解，有相关项目经验优先；6、有人脸识别/智能交通/结构化/行为分析/字符识别等相关项目经验者优先；有深度学习框架开发经验者优先；有X86/ARM/DSP/GPU等汇编优化经验者优先；获得国内/国际赛事重要奖项者优先；7、具备良好的沟通表达能力和团队合作意识，诚实守信，且积极主动，有责任心和事业心。 (G) 浦发银行123信息科技岗（系统开发方向)若干 本科及以上计算机与信息技术、软件工程、信息与通信工程、电子科学与技术等相关专业 （H）腾讯计算机视觉方向 https://join.qq.com/post.php?fid=93&amp;pid=1123456789101112131415161718计算机视觉方向岗位描述:腾讯拥有上亿量级的产品数据围、适宜年轻人的企业文化，、极其丰富的产品场景、超大规模的计算资源、全谱领域的深厚技术积累、追求极致的创新氛可为您提供充分的专业发挥空间，让您有可能做出影响整个互联网行业发展的优秀成果。该岗位主要职责包括但不限于：1、负责图像或见须相关算法的研究与开发，包括深度学习以及常用机器学习方法在机器视觉中的应用； 2 、负责计算机视觉相关的技术研发工作，包括但不限于：图像检测、图像分类、图像分割、图像跟踪、视频语义分析、人压识别与分析、车辆与人员的检测识别与跟踪、图像 Z 视频搜索、页面分析与自动合成、 OCR 等算法与系统研发领域； 3 、负责深度学习、图像理解、机器学习等前沿技术的研发储备和平台建设，结合未来实际应用场景，提供技术解决方案。岗位要求：1、计算机、应用数学、模式试别、人工智能、自控、统计学、运筹学、生物信息、物理学屋子计算、神经科学、社会学介臼理学等专业，图像处理、模式识别、机器学习相关研究方向，本科及以上，博士优先； 2 、熟练掌握计算机视觉和图像处理泪关的基本算法及应用； 3 、较强的算法实现能力，熟练掌握 c/c++编程，熟悉 shell/python/Matlab至少一种编程语言；4 、在计算机视觉、模式识别等学术会议或者期刊上发表论文、相关国际比赛获奖、及有相关专利者优先。注：该岗位“招聘城市”在简历投递截止日前会有部分调整，请密切关注，腾讯公司对招聘信息保留最终解释权工作地点:深圳总部北京上海广州成都合肥招聘城市：西安广州上海杭州北京南京深圳武汉合肥新加坡远程面试 (I)汇顶科技算法工程师-图像方向 http://goodix.zhiye.com/1234567891011工作职责:1. 参与公司核心产品的研发，负责业界前沿产品的算法开发。2. 负责图象处理、模式识别、机器学习类算法开发；3. 负责算法设计相关代码规范建设、自动化单元测试。任职资格：1. 数学理论基础扎实，掌握常用的图象处理、模式识别理论；2. 熟练掌握常用算法仿真、分析工具；3. 信号处理、通信、电子、数学相关专业硕士及以上学历；4. 英语六级以上，良好的沟通表达能力。 （J）阿里巴巴算法工程师-图像图形(应届生）https://job.alibaba.com/zhaopin/index.htm1234567891011121314151617岗位描述Job Description阿里巴巴集团拥有海量的图像/视频数据，强大的计算能力和巨大的市场空间。我们需要你具有计算机视觉或图形学相关基础知识和视觉分析、诊断、搜索、合成等方面的实践经验。我们期待追求卓越、自我驱动、聪明、乐观、自省、皮实的优秀人士加入阿里巴巴，共同开创视觉技术的新格局。 具体职责包括但不限于： 1、负责图像/视频的分析、诊断、搜索、合成等方面的算法研究和产品开发，包括图像检测、图像分类、图像分割、图像跟踪、视频语义分析、人脸识别与分析、车辆与人员的检测识别与跟踪、工业与医学诊断、图像/视频搜索、页面分析与自动合成、OCR等算法与系统研发 2、负责图像/视频相关算法的研究与开发，包括深度学习以及常用机器学习方法在机器视觉中的应用 3、负责虚拟现实与增强现实相关算法的研究与开发，包括图像匹配、视觉SLAM、实时SFM、真实感渲染等前沿技术的探索研发岗位要求Qualifications1、本科及以上学历，硕士博士优先，计算机、数学、通信等相关专业 2、熟悉深度学习、图像/视频分析与处理、三维重建与绘制、游戏开发等相关领域技术和应用，有大量实践经验者优先 3、有科研能力并有成果发表在国际顶级会议、期刊者优先 4、极佳的工程实现能力，熟练掌握C/C++、Java、Python等至少一门语言 5、良好的数据分析能力和逻辑分析能力 6、良好的团队合作精神，能够做到优秀、严谨、皮实、乐观工作地点Location上海市(Shanghai),深圳市(Shenzhen),成都市(Chengdu),北京市(Beijing),广州市(Guangzhou),杭州市(Hangzhou)参加面试的城市或地区Interview City or Region远程(Remote Interviews) (K)顺丰科技视觉算法工程师 http://campus.sf-tech.com.cn/campusRecruitment/Jobs.html?p=296063541991234567891011121314151617职位名称：视觉算法工程师工作地点：深圳可面试城市：广州、深圳、北京、上海、武汉、长沙、西安、成都、重庆、哈尔滨、南京、香港、海外招聘人数：20工作职责：顺丰拥有极其丰富的物流领域的图像和视频数据，叠加极具前瞻性的业务需求，可为您提供充分的专业发挥空间，让您有可能做出影响整个物流行业发展的优秀成果。你的主要职责包括但不限于：1、 广泛深入的理解各类场景下的图像和视频数据；2、 负责视觉算法和模型开发，包括但不限于：视觉算法原型设计，深度神经网络模型设计与优化；3、 对机器学习尤其是深度学习前沿问题进行探索与研究，结合未来实际应用场景，提供全面的技术解决方案。任职要求：1、掌握常见的计算机视觉、图像处理、机器学习算法；2、具备扎实的编程基础，熟悉常用数据结构与算法；3、熟练使用python、matlab、c/c++至少一种；4、有较强的文献阅读和算法实现能力；5、有以下相关经验优先：有过三维重建、SLAM或目标跟踪/检测等相关项目经历优先;具备深度学习实际项目经验的优先；有使用opencl 、caffe、tensorflow等库的经验的优先；有realsense和kinnect等深度摄像头应用经验优先；开源社区参与者和贡献者优先。 (L)中国网安职位暂时没有 http://cetcsc.cetc.com.cn/12345678910111213需求专业：1.软件工程、计算机应用等相关专业；2.信息安全、密码学、应用数学相关专业；3.通信与信息系统、信号与信息处理、电路与系统、电子信息工程等相关专业；4.控制科学与工程、结构设计、机械设计与制造、机电工程、工业自动化等相关专业；5.应用光学、光学工程、光电技术、天线与微波技术、电磁场与微波技术等相关专业；6.市场营销等相关专业。 (M)海信图像工程师 http://hisense.zhiye.com/cdetail/350195418123456789101112131415161718192021222324招聘类别：校园招聘工作性质：全职工作地点：青岛市 薪资范围：面议招聘人数：若干发布时间：2018-07-13截止时间：工作职责：1. 负责海信全球市场家用电视产品、激光产品、商用显示器的图像质量开发，保证电视图像质量的竞争力及先进性，同时确保产品按项目进度有效执行，解决产品规划、开发、生产、销售等环节的产品图像质量问题；2. 进行图像质量提升相关算法研究，并与海信芯片公司合作实现算法实现和应用；3. 进行显示器图像质量相关性研究，并根据产品图像质量提升需求对显示器相关技术指标进行规划、论证；4. 跟踪行业内图像质量新技术的发展并开展技术预研，包括显示、芯片及图像处理算法相关的研究及对外合作；5. 研究并建立不同显示产品（技术）的图像质量评测和开发规范，维护图像质量开发流程；6. 为产品的市场推广提供图像质量相关技术方案和技术支持；7. 产品图像质量市场跟踪及改进，提升用户满意度及推荐值。任职资格：1. 硕士及以上学历；2. 计算机、信息科学、电子等及相关专业；3. 良好的英文能力；4. 良好的学习及沟通交流能力，熟悉matlab；5. 了解机器学习算法，了解深度学习算法；6. 有过图像处理项目经验优先。 (N) 诺瓦电子http://novastar.zhiye.com/123456789101112算法工程师 (未申请)招聘类别： 校园招聘 工作性质： 全职 薪资范围： 面议 发布时间： 2018-08-16工作地点:陕西省-西安市工作职责:参与视频处理、先进显示、计算机视觉、人工智能、云计算、分布式计算等前沿技术预研，致力于用核心技术解决行业难题，成为行业的引领者。任职资格：1、2019届毕业生，研究生及以上学历；2、具有扎实的数学功底，理解并掌握概率论、矩阵论、最优化方法等数学方法；3、熟练使用Matlab/C++/Python中的一种，具备进行算法仿真验证的经验和能力；4、对图像处理、视频处理、机器学习有一定的基础，并具有浓厚兴趣，致力于从事相关工作；5、具备总结和归纳开发成果的文档编写能力，英语读写熟练，有丰富的英文文献阅读经验。 (O)西安中科光电精密工程有限公司http://www.yingjiesheng.com/job-003-820-766.html1234567891011121314151617181920212223242526图像处理工程师：3名(薪资15000-20000元/月)任职资格：1、电子信息、自动控制、图像处理、模式识别等相关专业重点院校硕士及以上学历；2、具备较强的逻辑分析和动手能力，具备相关算法、软件设计、调试能力；3、熟练掌握C/C 等编程语言，具有比较规范的编程习惯和较强的编程调试能力，熟悉opencv cuda库优先,掌握深度学习、三维形貌测量相关者优先；4、有良好的沟通、学习能力与团队合作精神。岗位要求：1、图像算法软件设计、编写及调试；2、编写软件算法设计相关的各类型文件。社招：职位名称：图像处理工程师职位类型：全职工作经验：1年以上学历要求：硕士招聘人数：2名发布时间：2016-06-26职位描述薪资7500-9500元/月1、图像算法软件设计、编写及调试；2、编写软件算法设计相关的各类型文件。招聘要求1、电子信息、自动控制、应用数学、图像处理相关专业重点院校硕士及以上学历； 2、具备较强的逻辑分析和动手能力，具备相关算法、软件设计、调试能力； 3、熟练掌握C/C++等编程语言，具有比较规范的编程习惯和较强的编程调试能力； 4、有良好的沟通、学习能力与团队合作精神。联 系 人：赵先生联系电话：029-68590682电子邮件：zkgdhr@126.com (P)全志科技http://zhaopin.allwinnertech.com/home1234567891011NO.19007 算法设计工程师 (未申请)招聘类别： 校园招聘 工作性质： 全职 招聘人数： 若干 发布时间： 2018-08-06工作地点:广东省-珠海市,陕西省-西安市职位类型：工作职责:负责从事相关领域的算法预研、算法开发、验证与支持等工作。任职资格：1、 硕士、博士学历，通信、电子、计算机、信息工程、模式识别、数学、物理等相关专业；2、 掌握Matlab 及C语言编程；3、 有音频、视频、图像等算法实现基础；4、 无线通信系统算法要求掌有数字接收机的基带算法实现基础。 (Q)多益网络https://xz.duoyi.com/jobs/index.html#type=program_type&amp;id=57aaeefd34c4050001b94e9f1234567891011121314人工智能及大数据研发工程师岗位职责：研发大数据分析处理平台，研究数据挖掘算法技术及应用、人工智能领域相关算法等，开发自然语言处理、图像识别等方向的相关应用，面向游戏及其他领域产品提供大数据解决方案。岗位要求：2019届毕业生，数学或计算机相关专业；计算机基础知识扎实，精通算法设计/数据结构，熟悉JAVA或C/C++语言编程；熟悉机器学习常用算法，熟悉Linux/Unix平台上的开发环境；在以下某一领域有一定经验：数据挖掘、自然语言处理、图像识别、语音识别；优秀的学习能力，善于探索钻研。岗位说明：招聘人数： 广州若干人 内推笔试第二批2018-09-06 10:00 (R)字节跳动https://job.bytedance.com/campus/position1234567891011多媒体开发工程师 - 图像/音频/视频工作城市： 北京岗位描述：1、支持公司所有业务的多媒体研发工作；2、负责图像、音视频编解码实现与优化;3、负责图像、音视频算法研究与实现。岗位要求：1、本科及以上学历，硕士以上学历，计算机、数字图像处理、信号处理、数学、多媒体等相关专业 ；2、熟悉常见的图像处理算法或者音视频编解码和算法，有一定数学功底； 3、具有扎实的编程功底，良好的设计能力和编程习惯；4、积极乐观，责任心强，工作认真细致，具备良好的服务意识，具有良好的团队沟通与协作能力。 (S)虎牙http://hr.huya.com/12345678910111213141516（2019届校招）机器学习工程师 重要职位工作地点： 广州市 学 历：硕士研究生及以上工作类型： 全职 招聘人数：若干 发布时间：2018-08-02职位描述1. 负责虎牙直播的图像识别业务工作； 2. 负责目标检测、分割、识别的算法研发、验证与开发； 3. 负责神经网络的构建、开发和优化。任职要求1. 2019届计算机、数学及相关专业，硕士及以上学历； 2. 有图像处理\模式识别\计算机视觉\机器学习相关背景； 3. 精通c\c++，具有较强的编程能力；熟悉matlab\python ； 4. 熟悉opencv、caffe等计算机视觉库； 5. 熟悉Linux平台者优先考虑； 6. 亲自实现过SVM、神经网络等机器学习算法，有深入研究者优先考虑； 7. 在人脸识别\\物体检测\OCR\图像语义分割等视觉领域做过实际项目优先考虑； 8. 在国内外顶级计算机视觉会议和期刊上发表过论文的优先考虑。 (T)快手123456789101112131415161718图像增强算法工程师1 、 针 对 移 动 短 视 频 的 特 点 ， 利 用 深 度 学 习 技 朮 ，在拍摄、云端、播放环节进行图像优化处理，增強视频、封面图片的主观清晰度和美感；2、 参与建立快手的视频和图像增強算法研发和质量评估体系。@任职资格1 、 计 算 机 、 多 媒 体 通 信 、 信 号 处 理 等 相 关 专 业 ，硕士及以上学历；2、 精通图像处理算法，深度学习技朮基本原理，有美颜、降噪、弱光增強、防抖、去雾、超分辨率、插帧等算法研发经验者优先；3、 能够利用Matlab进行算法原型设计，利用OpenGL /Metal等平台接口进行相关算法优化 ；4、 深入理解计算摄影学，光#成像、数字影像技朮、数字信号处理的基本原理和业界发展方向者优先。 (U)搜狗http://campus.sogou.com/post.html1234567891011121314151617图像研究员（杭州）岗位说明负责图像算法技术研究和产品化，包括OCR、人脸检测和验证、物体识别和分类等方向。任职资格1.了解常用的图像处理算法；2.对模式识别算法有深入的认识和理解，有实际研发的经验；3.有使用深度学习算法的项目经验。图像理解研究员岗位说明参与图像理解相关技术的研发，包括识图搜索、拍照购物、相似图搜索、图片搜索、图像细粒度分类、物体识别等。任职资格1.对机器学习有较深入的理解；2.有图像处理、深度学习相关工作经历；3.有良好的分析问题解决问题的能力。 (V)迈瑞医疗http://mindray2018campus.shixiseng.com/index.html12345678910111213141516RD04 超声系统研究工程师（深圳）工作职责：负责产品系统研发中的信号处理算法研究。职位要求：1、硕士或以上学历，生物医学工程、自动化、计算机、信号处理及相关专业；2、具有扎实的信号处理知识基础，丰富的信号处理算法研究和开发的经历，在多普勒信号分析或者射频信号分析取得突出业绩；3、具有医用成像设备，雷达或者水声信号处理研发经验者优先考虑。RD05 医学图像处理与人工智能研究工程师（深圳）工作职责：负责超声影像产品图像后处理功能与人工智能算法研究和产品开发工作。职位要求：1、硕士或以上学历，生物医学工程、计算机、信号处理、应用数学、自动化等相关专业；2、具有扎实的图像处理算法基础，丰富的图像处理算法研究和开发经历；3、在模式识别/深度学习/3D可视化的一方面或多个方面有取得突出的业绩；4、具有医学图像处理研发经验者优先。 (W)招商网络科技http://cmbnt.cmbchina.com/2019campus/index.html算法工程师123456789101112岗位描述：1、推动人工智能在招商银行服务、营销、风控、运营等领域的建设，参与智能客服、智能推荐、反欺诈、舆情监控、人脸识别、OCR、量化分析等一个或多个方向的应用；2、负责机器学习、深度学习在部分技术领域的研究，推动深度学习、自然语言处理、人机交互、知识图谱、计算机视觉、生物特征识别等技术在银行各项经营管理中应用。岗位要求：1、全日制硕士及以上学历，计算机、数学相关专业2019届毕业生，在校成绩优秀；2、熟悉机器学习或深度学习算法，至少对一种算法有深入研究，在大规模机器学习、模式识别、自然语言处理、语音交互、图像处理等领域有实践经验者优先；3、具备扎实的编程能力，精通Java/Scala/Python/C++/C中一种编程语言；4、精通数据结构与优化算法，了解MySQL、HiveQL等数据库操作优先；5、在重大会议或期刊有发表机器学习相关文章、ACM等竞赛获奖者优先；6、积极向上，有团队合作能力，热爱新技术，乐于创新；7、思想品德端正，身体健康，无重大病史。 (X)招商银行信用卡中心 http://cmbcc.zhiye.com/home123456789101112131415161718IT类（AI方向）(J10660) (未申请)需求部门： 招商银行信用卡中心 薪资范围： 面议 招聘人数： 10 截止时间： 2018-10-05工作地点: 上海市工作职责:1.负责语义识别、计算机视觉、图像处理、语音识别等相关算法研究；2.负责人工智能算法项目的实施及优化；3.对业界新应用和技术进展进行跟踪研究。任职资格：1.2019年应届毕业生，全日制本科及以上学历，计算机、信息技术、数学及其相关专业，有机器学习或深度学习研究背景；2.熟悉自然语言处理、计算机视觉、图像处理、语音识别等任一种人工智能领域相关理论和算法，并具备一定的工程项目实践经验；3.在统计或机器学习、文本分类或聚类、海量数据处理、分布式计算等方面有一定的理论功底和实践经验；4.熟悉 Linux环境下的Java和Python编程，有很强的算法实现能力；5.对于原型开发和产品开发中可能遇到的各种新的技术和框架，能迅速熟悉使用，有良好的沟通表达能力，良好的分析解决问题的能力。 (Y)中兴 http://job.zte.com.cn/recruitment-list12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849软件开发工程师 应届生 留学生发布时间2018年08月15日工作地点成都/河源/南京/三亚/上海/深圳/天津/武汉/西安/燕郊/重庆/长沙学历本科及以上职位类型研发类主要职责1、从事通讯产品相关软件开发2、进行软件详细设计，代码编写，单元测试，集成测试、系统测试等3、进行软件代码的维护和改进工作4、完成测试方案规划及测试用例设计和执行工作5、完成部门安排的其它研发相关工作任职要求1、计算机软件、通信、自动化、应用数学、应用物理等相关专业，本科及以上学历2、掌握C/C++或者Java编程语言，对面向过程或面向对象软件开发有一定认识3、掌握软件工程概念，熟悉软件开发、测试流程4、工作有热情、积极，学习能力强，具有一定的创造力，具有较好的沟通及协作能力，能承受一定的压力5、英语四级及以上，能熟练阅读及翻译相关技术文档6、具有通讯相关软件研发经验者优先考虑软件测试工程师（无线） 应届生发布时间2018年08月15日工作地点南京/上海/深圳/西安学历本科及以上职位类型研发类主要职责1、从事软件系统测试工作，工作内容主要为测试设计和测试执行2、把握市场需求，进行软件需求分析，根据用户需求制定测试方案，开发测试用例3、制定产品软件阶段性的测试计划，执行软件功能测试和产品性能测试，提交测试报告4、对测试的故障进行跟踪并协助故障的分析和定位，提供产品改进建议5、开发自动化测试脚本和自动化用例，负责自动化测试环境维护与自动化故障的分析和定位6、负责产品软件的场测、认证测试，并协助对问题的分析解决7、后续发展：技术方向包括软件测试专家、自动化测试专家、测试架构师等，管理方向包括测试经理、测试项目总工、研发项目经理、项目总监、产品经理、行业咨询师等任职要求专业方向要求：计算机科学技术、软件工程、网络工程、信息安全、数学与应用数学、通信工程、电子工程、大数据、机器学习、模式识别、人工智能、物联网等相关专业和研究方向岗位技能要求：1、熟悉C/C++或Java/go/python/scala等任一编程语言2、有操作系统、数据库、存储管理与规划、安全管理与规划经验者优先3、有开源平台开发经历，熟悉或热衷开源和工具的开发与应用者优先4、熟悉测试技术、原理和实践经验者优先MKT经理-技术 应届生 留学生发布时间2018年08月15日工作地点深圳/南京/西安/上海/北京/天津/成都/重庆/武汉/长沙/国内办事处/海外学历本科及以上职位类型营销类主要职责1、负责综合项目投标，包括标前引导，投标组织，技术方案，项目澄清和谈判，合同签订等2、负责对收集到的对手产品和商务信息的整理分析工作；负责与其他接口部门就对手各层面信息（包括技术指标、对应产品、路标规划等）整理分析工作；负责对重点市场产品的盈利和价格分析工作3、负责产品商务支撑工作（包括产品商务策略、商务价格的分析和建议）；负责产品项目盈利提升工作4、负责产品经营业绩分析工作；负责将产品线产品策略有效推进、落地、运用以产生最大化效益5、负责技术线客户公关，建立和维护技术线客户良好客户关系，完成推进储备项目的相关工作6、负责技术营销活动及品牌活动的策划、支撑、组织及实施，比如workshop，宣讲交流，样板点参观等任职要求1、通信及电子、计算机等相关专业本科及以上学历2、具备一定的外语（包括英语或小语种）听、说、读、写能力3、对商务、财务、法务知识有一定了解4、具备快速学习能力和开放心态，有良好的组织策划、沟通协调、推动落实能力 (Z)联想 https://talent.lenovo.com.cn/resume/jdlist/1430 1234567891011121314151617图像视频处理及计算机视觉研发工程师选择语言 首页我的申请我的简历个人中心项目类型： 普通校招学历要求：本科工作地点：深圳职位类别：研发类所属部门：LCIG招聘人数：1人职位描述：岗位职责：负责图像视频处理及计算机视觉在垂直领域的研究和产品化。包括但不限于图像的底层、中层及高层的处理，即像素级的增强、区域的分割到语义的理解。 岗位要求：1、计算机、电子等方向硕士或以上学历；2、丰富的图像视频处理实际工作经验；3、很强的动手能力，熟悉相关算法和开源工具包。 (AA)阿里巴巴https://www.xiaoyuanzhao.com/company/xri_gx2idmx3dswg#112345678岗位4：算法工程师-运筹优化1.本科及以上学历，硕士博士优先，计算机，运筹学，数学，工业工程，统计学或相关专业 2.熟悉机器学习或者运筹学等领域的算法应用和理论，有科研能力并有成果发表在国际会议、期刊者优先 3.较强的逻辑分析能力和数学建模能力 4.较好的编程能力，熟练掌握Java，C/C++，Python等至少一门语言 5.良好的团队合作精神，能够做到优秀，严谨，皮实，乐观 6.有强烈求知欲，对人工智能领域及相关技术领域有热情 (BB)歌尔股份 https://www.xiaoyuanzhao.com/company/xri_idbmjvjewgwf#11算法开发 计算机、数学、控制、声学、电子、软件工程相关 50 潍坊、青岛、北京、上海、南京 (CC)云丛科技校园12345研究院（重庆/上海/广州）图像算法工程师硕士及以上，专业不限，热爱AI行业，有编程基础 诺基亚华诺（子公司） https://www.xiaoyuanzhao.com/job/xit_iplultehvcrc123456789101112131415161718业务算法开发职位性质：全职 学历要求：本科,硕士 招聘人数：若干人专业要求：计算机相关专业，电子信息科学类，电气信息类，理学工作城市：南京 合肥 杭州职位描述：无线通信领域优化解决方案制定、大数据平台业务设计实现和交付：1、掌握无线通信基础知识，具备无线解决方案输出能力；2、通过大数据方法挖掘优化问题，指导输出相关解决方案；3、基于公司大数据平台架构，对客户需求实现业务分解，算法设计并模块化交付4、具备对设计业务模块实现测试验证，具有输出专题报告能力职位要求： 1、本科及以上学历，理工科专业2、性格开朗，乐于与人交流，团队合作能力强3、学习能力强，能承受一定的工作压力4、具有良好的英语读写能力，具备Python、数据库等软件基础 亚控 http://www.kingview.com/contact.php?pid=100003612345678910111213（三）算法工程师1、招聘要求：1）硕士或博士学历；2）控制、运筹等理工科相关专业； 3）具有离散行业排产或流程行业调度算法研究者优先；4）工作勤奋，有团队精神，能承担一定的工作压力； 2、岗位职责：负责研究指定行业的信息化系统的调度模型并建立相应仿真算法。3、工作地点：全国4、年薪：面议 上海昕健医疗2019校园https://www.xiaoyuanzhao.com/company/xri_wlsoedlo0ct5#11234567891011121314151617181920212223职位名称 工作地点 学历要求 招聘人数(人)医学图像算法工程师 （全职/实习） 上海市嘉定区 本科及以上 7岗位职责：1. 负责医学图像分割，配准相关算法研究、实现和改进；2. 负责算法详细说明文档的编写，算法相关文件的规范化输出；3. 对临床医学图像问题的反馈进行分析，根据临床需求进行算法调整。任职要求：1. 具备较强的算法工程化能力，有算法优化或代码优化经验者更佳；2. 擅长使用C/C++编程，快速实现以及改进相关图像分析算法；3. 有较强的团队合作意识和良好的逻辑分析能力；4. 图像处理理论基础扎实，熟悉医学图像处理算法优先；5. 有开发CT、MRI图像分割算法经验者优先；6. 熟悉医学影像心脏、肝脏和血管等软组织分割算法者优先 operahttps://www.xiaoyuanzhao.com/company/xri_5yy3xbshupl4#1123456789101112131415161718192021222324252627282930在招职位： 算法工程师-2019年毕业工作内容：1、推荐算法- 负责推荐系统算法策略的建设与不断优化；- 分析基础数据，挖掘用户兴趣、内容价值，增强推荐系统的预测能力。2、用户画像- 基于海量用户行为，开发用户画像数据挖掘模型；- 负责用户画像数据准备、标签开发与标签评测。3、图像及视频理解- 负责视频理解的算法研发工作，对千万级视频进行识别和理解。4、NLP- 利用自然语言处理技术对海量数据进行深度理解。我们希望你是什么样的人？1、2019年毕业，计算机相关专业，研究生及以上学历；2、有持续的学习能力、优秀的团队合作意识，缜密的逻辑思维；3、具备 Linux/Unix 环境开发经验，掌握 C/C++或 Java 高级编程语言，会使用至少一种脚本语言；4、有扎实的数学、数据结构及算法功底，熟悉机器学习、数据挖掘、NLP、图像及视频处理中一项或多项。加分项：1、有ACM竞赛经历，并取得优异成绩的同学优先；2、有大数据、机器学习、人工智能、深度学习、自然语言、图像和视频理解相关经验优先。注：薪资：本科-硕士-博士4k-10k，博士：400/天 点我达https://www.xiaoyuanzhao.com/job/xit_ahd2oqtyufck12345678910111213141516171819202122232425届校-算法职位性质：全职 学历要求：硕士,博士 招聘人数：若干人专业要求：不限工作城市：杭州岗位职责：1、专注于大数据之上的机器学习算法研究与应用，提升平台的数据挖掘和使用能力；2、进行接单策略、实时订单打包算法、实时订单压力计算、多个订单的路径规划、出餐时间预测、送达时间预测、多渠道运力平衡等内容的研究。 岗位要求：1、2019届毕业生，计算机、电子工程、自动化、数学等相关专业硕士、博士学历；2、编程基础扎实，熟悉常用算法与数据结构，至少熟悉一门编程语言并有开发经验，如C++/Java/Scala/Python等；3、有机器学习、数据挖掘、计算机视觉与图像处理、语音识别与合成、自然语言处理、统计学/最优化理论、分布式计算、自动控制等至少一个方向相关基础，有相关项目经验者优先；4、了解海量数据处理技术，有使用Hadoop/Hive/Spark等大数据平台分析海量数据的能力和经验者优先；5、踏实勤奋，自我驱动，善于沟通，动手能力强，视野开阔，具有创造性思维。 北云科技校园https://www.xiaoyuanzhao.com/company/xri_vlr474bq2dkr#11234567891011121314信号处理算法工程师 3 年薪8-12万 一、任职资格：1、计算机、电子通信、导航与制导、自动化等专业研究生及以上学历；2、具备良好的导航信号处理或图像信号处理的理论功底；3、精通Matlab仿真、精通C语言；4、了解FPGA(verilog)开发，了解数据结构与算法设计；5、有信号处理领域相关SCI论文者优先；二、岗位职责：负责导航或图像处理相关算法设计、仿真与验证。 奥比中光https://app.mokahr.com/campus_apply/orbbec#/job/08523588-b053-4199-9787-c930a92a6718?_k=tyq2xn 123456789101112131415161718计算机视觉工程师XLAB算法类广东 深圳市 等2个地点更多资料发布时间：2018-08-08职位描述仅针对2019年应届生，欢迎提前实习岗位职责：1. 负责深度图像生成算法研发；2. 负责三维光学测量原型系统开发。任职要求：1. 熟练使用C/C++、Python、Java中至少一门语言；2. 对数据结构和算法设计有较深理解；3. 强烈的上进心和求知欲，良好的逻辑思维能力，良好的团队合作精神；4. 计算机、电子信息、机器学习、数据挖掘、测绘遥感等相关专业。具有以下条件者优先：1. 在学术期刊和重要会议上发表文章，或申请发明专利；2. 计算机视觉、模式识别、机器学习、数据挖掘等领域有实际项目经验。 纵目科技 https://www.xiaoyuanzhao.com/company/xri_18nr15qxi8zk#1123456789101112岗位6：ADAS视觉算法工程师涉及工作内容：1、开发汽车高级辅助驾驶系统的计算机视觉算法我们希望您具备：1、硕士及以上专业，计算机、通信等相关专业2、有扎实的图像分析和模式识别理论基础，精通目标检测、跟踪、识别等常见的计算机视觉处理任务；3、有扎实的数学基础，精通常见的几何、统计和机器学习技术；4、熟悉物体（行人、人脸、车辆等目标）检测、跟踪与识别的基本算法；5、精通C/C++；熟悉Python、Matlab；6、具有良好的英文阅读能力；7、具有良好的团队合作意识、沟通能力、协调能力，能够承担工作压力；8、可接受2019/2020届毕业生提前实习，优秀者可放宽至本科 瑞芯微电子 https://www.xiaoyuanzhao.com/company/xri_okpmddyrkfae#11234567891011121314151617181920212223242526272829303132333435363738算法类（一）图像算法工程师 岗位职责：1. 设计与实现针对color image pipeline的图像处理算法，如图像去噪，图像宽动态等；2. 设计与实现针对视频后处理的图像处理算法，如高质量图像缩放，HDR等；3. 利用计算光学、模式识别、人工智能等方法实现复杂图像处理，如特征提取、特征跟踪、多帧合成等；4. 设计与实现基于图像处理算法的应用系统，如图像去雾增强、图像融合等；5. 在嵌入式平台上对特定算法模块进行研究、仿真、开发和测试，并根据测试结果对算法模块进行优化和改进。工作地点：福州、杭州招聘人数：10 （二）视觉算法工程师 岗位职责：1. 针对双目/结构光/TOF相机的标定及校正；2. 针对双目/结构光/TOF相机精密测量三维重建算法及相关应用技术研发；3. 深度图/点云构建及增强技术研发；4. 针对Visual SLAM的相关技术研发，熟悉ORBSLAM、特征提取和优化、图优化等V-SLAM常用技术；5. 在嵌入式平台上对特定算法模块进行研究、仿真、开发和测试，并根据测试结果对算法模块进行优化和改进。工作地点：福州招聘人数：5 福瑞泰克校园https://www.xiaoyuanzhao.com/company/xri_ludop9ywfdhm#11234567891011121314151617181920212223AI视觉算法工程师 （杭州）薪资：12K - 17K岗位描述：1.负责车辆、行人、车道线识别等高层视觉算法开发2.负责算法的需求定义、软件开发、测试方案3.负责算法性能评估4.参与算法硬件化移植岗位要求：1.全日制硕士以上学历，数学、物理、自动化、电子信息工程等专业2.学习过算法、数据结构、计算机图形、图像等相关课程3.英文能力较强，能够阅读国外专业文献4.熟练使用C/C++ 浙江国自机器技术有限公司https://www.xiaoyuanzhao.com/company/xri_pqe4g9lfnfyy#112345678910111213算法工程师 岗位职责1、负责机器人定位导航或图像处理算法的研究和设计；2、负责相应算法的实现、测试、及产品化；3、跟踪相关领域的技术发展趋势，参与新技术的研究。 任职资格1、本科及以上学历，计算机、自动化及其相关专业；2、熟练掌握C++开发语言，熟悉数据结构知识，有一定的数学建模、优化计算能力；3、良好的学习能力与英文文献查阅能力。 顶象技术 https://www.xiaoyuanzhao.com/company/xri_qhgzzaurkega#1123456789101112131415161718192021222324252627算法职位性质：全职 学历要求：硕士,博士 招聘人数：人专业要求：统计学类，计算机相关专业，电子信息科学类，工学工作城市：杭州岗位职责：运用大量的算法和数据挖掘技术解决关键的业务问题，涵盖人工智能技术，除了机器学习、语音对话交互外、自然语言处理、图像图形、运筹优化等；岗位要求：1、本科以上学历、硕士博士优先。具有很强的逻辑分析能力，对数据敏感；2、具有一定的数据建模实践经验，扎实的编程基础，精通至少一门编程语言；3、熟悉常用机器学习算法，对信息检索、自然语言处理、图像处理、语音处理等相关领域的应用问题有大量实践经验者优先；4、有实际成果并发表在国际顶级会议、期刊者优先；5、拥有海量数据处理经验者、熟悉Map-Reduce模型者优先；6、擅长与商业伙伴的交流沟通，具有优秀的报告讲解能力及沟通能力优先；7、能够积极创新，乐于面对挑战，负责敬业；8、优秀的团队合作精神；诚实，勤奋，严谨。 福建新大陆自动识别技术有限公司 https://www.xiaoyuanzhao.com/company/xri_ginwb98pcd0u#1 1234567技术研发类（1）算法工程师（5人）【工作地点】福州【任职要求】硕士及以上学历；计算机、自动化、电子信息等相关专业；图像处理、机器视觉等研究方向；在校期间有相关研发课题或发表相关论文者优先。 广州南方智能技术有限公司https://www.xiaoyuanzhao.com/company/xri_vdtsim2koqqb#11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253算法工程师岗位职责：1、参与自主平台底层研发；2、根据项目、产品和分析、模型需求，完成数据研究、建模工作；3、完成分析工作，挖掘数据价值，促进项目、产品和运营场景落地；4、完成产品设计、建模、验证、实现、更新、优化及管理工作；岗位要求：1、具有计算机图形学基础知识2、熟悉常用的GIS算法（如道格拉斯算法、矢量求交、九交模型等）；3、熟练掌握数据结构、熟悉常用的空间索引算法、并对矢量的几何的九交模型有研究；4、作为团队成员，要和其他团队成员及团队主动沟通，以公司整体目标为导向；5、具备良好的沟通能力，并能够主动协调资源，推动工作进行；6、具备独立的数据分析能力和良好的逻辑思维能力，能够从海量数据中发现有价值的规律，能够根据实际情况来分析和解决问题。 JAVA开发工程师岗位职责：1、参与公司的web平台与应用项目开发；2、参与架构设计、概要设计等，按照标准规范撰写系统分析、设计文档；3、参与接口、业务的代码实现；4、参与内部测试、部署、实施等工作；岗位要求：1、计算机应用或软件相关专业优先，本科及以上学历；2、了解java应用开源；技术（Spring MVC、Spring、hibernate、RabbitMQ、redis、Mongodb等），有相关技术应用经验更佳；3、了解oracle、MySql等数据库，熟悉编写SQL脚本；4、热爱软件开发，对技术有极客追求，逻辑思维严谨，理解能力好；5、具备良好的编码习惯和质量意识，具有团队合作精神和沟通技巧、工作认真细致、责任心强。6、具备良好的沟通和学习能力，有团队意识； 信捷电气股份有限公司校园https://www.xiaoyuanzhao.com/company/xri_gawjysphutgq#1123456789101112131415161718192021四、视觉算法工程师 5人岗位职责：1、负责机器视觉算法部分研发；2、对项目进行可行性分析，并完成相关的实验；3、进行相关图像定位、测量、匹配、识别等。任职资格：1、专业要求：计算机、软件工程、数学等相关专业；2、结合实际的机器视觉项目，能独立完成算法的仿真和实现；3、有较好的数学基础和英语阅读能力；4、有一定的编程能力，熟悉C/C++，matlab,opencv，halcon；5、有较好的沟通能力和团队合作意识。 东软1234567891011121314151617181920在招职位： （一）研发类:1、算法工程师工作地点：沈阳、大连为主 职位职责：1）负责知识服务平台产品的算法以及产品研发工作；2）负责面向具体业务场景的创新智能应用研发、数据分析PoC 实施；3）负责主持涉及算法技术的方案规划、客户交流。职位要求：1）2019届应届毕业生，硕士及以上学历，计算机、软件工程、自动化、电子、电信、数学等相关专业；2）熟练掌握 JAVA Web 开发技术，了解熟悉常用 Web 开发组件，如 Structs2，Spring 等；3）熟练使用 sql、Python、R 等数据分析语言与工具；4）热爱并致力于未来从事大数据分析与机器学习算法研发工作。 公安3所校园https://www.xiaoyuanzhao.com/company/xri_wsqmxdjrs9yf#11234567891011121314151617图像算法工程师岗位要求1. 熟悉基本的图像处理和模式识别理论技术，熟练使用OpenCV等开发库；2. 熟悉深度学习技术及深度学习的开源框架，如Caffe、TensorFlow等，有使用相关技术的项目经验 者优先考虑；3. 精通C/C++、Python、Java、Shell等一种以上编程语言，动手能力强，有CUDA开发经验者优先考虑。岗位职责1. 负责图像视频智能识别算法的实现与开发；2. 算法的验证，优化与测试；3. 从事智能识别产品中的算法模块设计及开发工作。 科大讯飞https://www.xiaoyuanzhao.com/company/xri_9l3kyfa3mflc#1 北京翔仪恒昌科技有限公司https://www.xiaoyuanzhao.com/company/xri_2lwnvuoco5mk#112345678910111213141516171819202122232425三、 算法研发工程师岗位职责：1. 负责图像处理/视觉导航/卫星导航/飞行动力学/飞行控制等方面的算法研究和开发工作2. 根据产品功能定义，设计并开发应用和服务功能3. 根据产品功能需求，进行代码的修改和移植工作4. 编写方案设计文档、文档等技术开发文档岗位要求：1. 自动控制、惯性导航、卫星导航、图像处理、电子工程、计算机类专业，大学本科以上学历。欢迎应届生（需要在本公司进行学习和培训）和资深技术人员2. 工作敬业，学习能力强，有较强的独立钻研能力3. 熟悉C/C 语言开发，有良好的编程思想和习惯4. 熟悉无人机飞行原理、导航和控制原理，对新技术敏感度高5. 具有良好的代码阅读、分析和移植能力6. 有相关开发经验优先考虑 联发科技http://mediatek.zhaopin.com/job.html12345678910111213141516图像处理工程师 来 自：联发科技—深圳分公司 公司行业：电子技术/半导体/集...公司规模：10000人以上公司类型：外商独资工作地点： 深圳-南山区 职位类别：语音/视频/图形开发招聘人数：10人发布时间：2018-08-07职位性质：全职立即投递职位描述公司介绍岗位职责：在这里，你将有机会接触最前沿的商用图像技术，负责MTK所有芯片的图像处理相关工作，包括：1. 优化MTK芯片图像算法在海内外客户项目的效果及性能；2. 调查并评估海内外客户对MTK芯片图像处理的新需求，并客制化开发算法。任职要求：1. 电子信息、通信、自动化等硕士学历，图像处理/计算机视觉/模式识别等相关专业或研究方向优先；2. 基础扎实，熟练掌握C/C++编程语言，有良好的编码习惯；3. 英语CET6或以上，有良好的科技英语读写能力；4. 具有较强的工作主动性、独立性和学习能力，善于沟通，乐于团队合作和接受挑战。 迅雷http://campus.xunlei.com/position.html123456789101112后台开发工程师工作地点深圳 北京 西安面试城市请选择岗位职责从事迅雷下载、直播、云计算、智能硬件、高性能区块链等产品的核心技术研发，使用最优秀的架构设计及算法实现，在高性能数据传输网络、视频/图像处理、分布式计算、云存储、大数据挖掘等领域，为海量互联网用户提供稳定、安全、高效和可靠的专业后台支撑体系。任职要求本科及以上学历，计算机、数学、通信相关专业；熟练的工程实践能力，熟练掌握C/C++、Java、PHP等至少一门语言；全面而扎实的计算机系统基础知识，对分布式系统、视频/图像处理、嵌入式系统、高性能传输网络、云存储、区块链等至少一个领域有强烈的兴趣和深入的钻研能力；强烈的好奇心、进取心，勇敢探索未知领域的决心与强悍的学习能力 瑞芯微电子http://www.rock-chips.com/a/cn/jobs/shehuizhaopin/index.html 12345678910111213图像算法工程师岗位职责：1．设计与实现针对color image pipeline的图像处理算法，如de-bayer，3A等；2．设计与实现基于图像处理算法的应用系统，如图像融合、拼接、目标识别处理、定位处理等；3．利用计算光学，模式识别等算法实现复杂图像处理等；4．在嵌入式平台上对特定算法模块进行研究、仿真、开发和测试，并根据测试结果对算法模块进行优化和改进。职位要求：1. 本科及以上学历，光电,信号处理相关专业；2. 熟悉matlab和c语言；3. 具有较强的实际动手能力、学习能力和论文检索，英文专业文献阅读能力，有基本的英语口语能力；4. 身体健康，具有良好的责任心与沟通能力。5. 有光学背景优先；工作地点：福州、杭州 豪威科技http://campus.51job.com/2019/ovt/position_c.html#27 1234567891011121314图像算法开发Position Overview:开发及研究图像/视频处理算法，计算机视觉以及模式识别。Responsibilities:1. 基于传感器和相关应用开发图像/视频处理，计算机视觉及模式识别类算法2. 改进现有算法以获得更好的效果，或者降低实现消耗以满足产品/市场的不同需求3. 协同工作将算法在硬件/固件/其他软件平台上实现4. 编写算法技术文档5. 协同工作以支持客户Requirements:1. 有相关领域图像视频类算法开发处理经验2. 相关专业硕士及以上3. 熟练的C/C++及Matlab编程能力4. 有OpenCV等相关开源图像/视频算法处理经验 联影医疗http://campus.51job.com/uih2019/lyzn.html12345678工作职责：超声系统后处理图像优化、高级应用算法（造影、图像融合、实时3D/4D）研究；或者负责开发手术计划相关算法，包括三维建模，多模态融合，手术路径规划等。任职要求：1.熟悉以下医学图像后处理算法之一：成像算法、重建算法、分割算法、配准算法、模式识别算法纹理分析算法等，或者精通计算流体力学算法；2.有医学图像后处理算法开发经验者优先；3.硕士及以上学历，博士优先。联影武汉工作地：武汉 中科创达https://www.xiaoyuanzhao.com/company/xri_nyc9mhkbev8p#1123456789101112131415算法工程师岗位职责: 1.参与公司最前沿技术的预研 2.进行算法原型的开发 3.完成最牛气的产品从需求到落地的全过程 任职资格: 1.统招硕士研究生及以上学历，理工科专业 2.热爱编程，熟练掌握C/C++编程语言，熟悉Python者优先考虑 3.有很强的数学及逻辑思维能力 4.研究背景来自人工智能，模式识别，进化计算，数字图像处理，计算机图形学，建模与优化理论等方向 5.工作地点：北京、上海、深圳、成都 飞依诺科技（苏州）https://www.xiaoyuanzhao.com/company/xri_ufvcu65ieutx#112345算法工程师硕士及以上5生物医学工程、通信工程苏州工业园区 数码视讯https://www.xiaoyuanzhao.com/company/xri_othcea7kq3vx#11234567891011121314151617岗位需求：北京：模式识别算法、视频算法、通信算法、AI嵌入式、FPGA、Linux软件、硬件设计、Java、C 、Android、测试；产品经理、解决方案工程师；财务管培生、HR管培生深圳：C 、Android、Linux软件、嵌入式、硬件设计武汉：嵌入式、Java、测试西安：视频算法、FPGA、Linux软件、硬件设计、C 、Java全国：销售精英、技术支持全球：英语销售、俄语销售、西语销售、葡语销售、项目经理、技术支持同时开通实习生岗位，欢迎投递硕士择优解决京户、博士承诺解决京户，鼓励不同城市间自由选择 瑞晟微电子http://www.realsil.com.cn/Home12345678910111213141516171819202122232425262728视频算法工程师(MM)多媒体事业处苏州 算法类硕士应届招聘 2 人任职要求电子、信息、计算机、光电、控制相关专业岗位职责视频算法开发软件开发工程师(MM)多媒体事业处苏州 软件开发类\Software硕士应届招聘 4 人任职要求 电子、计算机、通信相关专业，硕士学历；熟悉c/c++；熟练掌握常用数据结构；熟悉linux，有嵌入式系统开发经验为佳；熟悉android framework为优；有责任心，具备团队合作精神；良好的英文阅读能力。岗位职责1. 嵌入式软件开发2. 图像处理算法及应用程 捷视飞通http://campus.51job.com/ifreecom.com/position.html123算法研究工程师 6 多媒体音频处理算法、视频处理算法、分布式网络通讯、数据分析、通讯安全等互联网相关技术具有较深的研究和专业积累；硕士及以上学历； 深圳雷鸟络科技https://www.xiaoyuanzhao.com/company/xri_ydh2ddyepibt#1123456789101112131、软件开发工程师（JAVA）工作职责1. 从事TV、AV、互联网相关产品相关软件、企业应用软件或联网设计开发工作；2. 进行软件详细设计，代码编写，单元测试，集成测试、系统测试等；3. 进行软件代码的维护和改进工作；4. 完成部门安排的其它研发相关工作。任职资格1. 本科，计算机相关专业；2.数理逻辑性强，对软件设计有兴趣，有软件小项目开发经验优先；掌握JAVA等编程语言，对面向过程或面向对象软件开发有一定认识；3.学习能力强，逻辑思维强，良好的沟通协调能力。（本科年薪15W起，硕士年薪20W起） 神州航天https://www.xiaoyuanzhao.com/company/xri_4kwfginuob1x#112345678研发工程师-Java计算机、自动化、控制等相关专业1）2018年应届毕业生；2）硕士及以上学历；3）目标岗位相关专业；4）优秀的沟通能力，适应性强；5）优秀的学习能力；6）有相关实习经验优先考虑。 亿高医疗https://www.xiaoyuanzhao.com/company/xri_7iaczsnr88ii#1hr@njeco.com.cn12345研发学术类研发工程师电子、自动化、软件相关专业南京6人 宇视科技https://talent.uniview.com/wt/uniview/web/index/campus 12345678910111213ISP图像处理工程师（西安）工作地点： 西安市 学 历：本科及以上工作类型： 正式员工 招聘人数：若干 发布时间：2018-08-31职位描述负责监控摄像机 ISP（图像处理）软件与算法开发任职要求1、2019年毕业博士、硕士或本科生，计算机、自动化、图像处理、光学工程、模式识别、数学等相关专业； 2、英语听说读写能力全面，CET-4以上； 3、熟悉 ISP（图像处理）或光学成像相关技术，有扎实的数学功底，掌握 C/C++、MATLAB 编程能力； 4、有较强的技术文献收集、理解能力，良好的英文阅读能力； 5、在以下某一方向有研究者优先：数字图像处理（自动曝光、自动白平衡、自动聚焦、降噪、宽动态、图像增强等）、光学成像（镜头、电机、补光等）； 6、责任心强，良好的学习能力及团队合作精神，愿意接受挑战和承受工作压力。 联咏科技http://campus.51job.com/novatek2019/p2.html 123456789101112职位描述职位描述：算法设计、开发、验证(满足以下任一即可)1. 视频、图像处理算法(Image/Video Processing)2. 视频、图像压缩算法(Codec &amp; Embedded Video Compression)3. 神经网络和机器学习算法(Deep Neural Network &amp; Machine Learning)4. 并行计算及算法并行优化(Parallel Computing、CUDA、OpenCL、Halide etc.)职位要求：1. 电子、通信、计算机、应用数学、应用物理等相关专业，硕士及以上学历2. 熟悉C/C++、MATLAB3. 熟悉OpenCL、CUDA，有相关项目经验者尤佳4. 熟悉数字图像处理、人工智能方面的理论及技术 烽火星空https://www.xiaoyuanzhao.com/company/xri_1jgl0mbtz6tm#112345算法（图像、语音、自然语言）南京、西安图像、人脸、语音识别、人工智能、深度学习、自然语言处理。 电科29所http://www.hrcetc29.com/campus.html 中国兵器工业集团212研究所中国兵器工业集团205研究所北方光电航天自动化研究所长岭科技天和防务晟昕科技未尔科技12345678910111213141516职位描述1、负责红外方向的仿真项目实施和软件开发工作；2、参与客户沟通交流，提取客户需求，并撰写解决方案。职位要求1、计算机图形或者光电工程相关专业研究生学历，数学、物理功底好者优先；2、熟悉可见光、红外传感器的理论及工作原理，2年以上红外成像相关仿真建模工作经验；3、熟悉计算机图形学的基本理论，熟悉图像处理；4、熟悉或者熟练掌握 C/C++，具有计算机视觉算法经验者优先；5、英语四级以上，具备良好的英文读写能力；6、具有良好的沟通能力、团队合作能力、学习能力及创新能力。简历投递：career@vire.cn 开立生物医疗http://job.xidian.edu.cn/html/zpxx/bxqzph/53499.html1234567891011121314151617任职要求：1、硕士及以上学历（优秀本科生亦可考虑），电子/通信工程、信号/图像处理、生物医学工程及、自动化、计算机、数学类、光学类等相关专业； 2、有计算机图形学基础，或有计算机图像处理和识别技术基础；3、熟悉掌握下述至少一种专业技能、编程语言：（1），Matlab开发工具；（2），C/C++编程；（3），verilog-HDL/VHDL硬件编程；（4），cuda编程或OpenGL GlSL编程，熟悉VTK和OpenCV编程。4、有二维图像处理或者三维图像处理项目/课题经验者优先；5、具备较强的承压能力，有良好的沟通能力，团队合作意识强。工作职责：承担下述一项或多项工作：（1）图像处理C/C++算法开发与测试验证；（2）图像处理FPGA算法开发与定点化分析；（3）图像处理GPU算法开发与测试验证；（4）三维图像重建、识别算法设计与仿真。 高新兴 http://gosuncn.zhiye.com/zpdetail/150166443 12345678910111213141516171819 算法工程师（研发平台） (未申请)招聘类别： 校园招聘 工作性质： 全职 薪资范围： 面议 招聘人数： 12发布时间： 2018-08-24 截止时间： 工作地点: 广东省-广州市工作职责:1、负责车牌识别算法、场景文本及特征搜索等核心算法研发；2、负责模型训练与调优，识别模型导出与部署；3、负责与软件工程师配合进行算法的跨平台开发和性能优化；4、负责针对特定任务进行深度神经网络的结构调优与参数调优技术。任职资格：1、硕士及以上学历，模式识别、计算机、图像处理、信号处理、电子、自动化相关专业； 2、掌握图像处理、模式识别及计算机视觉技术等基本理论；3、熟练掌握C/C++开发语言，熟悉OpenCV、Matlab、或者类似图形库； 4、良好的沟通能力与团队合作精神。 闻泰http://campus.wingtech.com/#/job/a3c72363-5fef-4214-afee-76b200e9425a?_k=4tjbpt 12345678910111213141516171819202122232425262728 影像效果/算法工程师岗位要求：1）数字信号处理、模式识别专业、应用数学、计算机、光学、图像处理、电子相关专业，统招全日制研究生及以上学历；2）熟悉C/C++语言编程；3）了解/熟悉图像分析方法，理解常用图像特征提取算法的原理；4）了解常见开源库Open CV/openGL等，熟练使用c和c++；5）对色彩，色温，色调，光线等视觉因素具有强敏感的同学优先（不能有色盲、色弱）；6）能进行计算机图像处理和识别方面的软件编程者优先；7）熟悉人脸识别、目标检测、跟踪和识别、图像处理等技术，有彩色图像处理的经验（包括3A、色彩校正、降噪、插值等）者优先；8）精通图像增强与提取、处理与识别、图像特征建模等算法开发者优先。职位描述：1）负责图形图像定位、分割、识别算法的研究，根据业务特点优化算法；2）研究图像特征检测的识别，包括算法实现、试验、优化等；3）收集行业内新的技术、算法，提高现有系统对图形图像识别的效率与准确率；4）对已有成熟图形图像处理算法的集成和应用。]]></content>
      <tags>
        <tag>Resume</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装mysql，和遇到的一些错误及解决方案]]></title>
    <url>%2F2018%2F03%2F28%2Fdatabase_install%2F</url>
    <content type="text"><![CDATA[安装mysql 1、下载mysql-5.7.20是解压版免安装的，mysql-5.7.20下载地址：http://dev.mysql.com/downloads/mysql/ 2、安装 解压在你喜欢的位置 3、配置 新建一个ini文件，并命名为my.ini，放置到mysql根目录下，文件内容如下 12345678910111213141516[mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 [mysqld] #设置3306端口 port = 3306 # 设置mysql的安装目录 basedir=E:\program2\javaTool\mysql-5.7.20-winx64# 设置mysql数据库的数据的存放目录 datadir=E:\program2\javaTool\mysql-5.7.20-winx64\data# 允许最大连接数 max_connections=200 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB 注：设置mysql的安装目录 basedir=设置mysql数据库的数据的存放目录 datadir=这两个参数改为你所解压后的文件夹的位置 4、安装mysql服务&lt;/h3&gt;4.1、管理员身份打开cmd.exe&lt;/h3&gt;文件位置C:\Windows\System32\cmd.exe,找到右击选择管理员身份打开（重点），如果没有一管理员身份打开运行cmd.exe，会报错 1Install/Remove of the Service Denied! mysql 将目录切换到你mysql安装目录的bin目录后，在cmd窗口输入 1mysqld install 回车运行即可。 4.2、创建data文件将目录切换到你mysql安装目录的bin目录后，再输入 1mysqld --initialize -insecure --user=mysql 在软件目录下生成data文件夹。mysql登录的用户名为root，密码为空 之前的my.ini中两个参数要改为自己的：设置mysql的安装目录 basedir=软件安装目录设置mysql数据库的数据的存放目录 datadir=软件安装目录\data这两个参数改为你所解压后的文件夹的位置，否则会报错“无法初始化库文件等”如下图 1mysqld: Can&apos;t create/write to file 4.3 测试启动启动mysql服务： 将目录切换到你mysql安装目录的bin目录，输入 net start mysql 启动服务，OK成功。 4.3.1 报错 12Found option without preceding group in config file:XXX;Fatal error in defaults handling. 原因：用记事本配置my.ini编码格式有问题，一般情况下是UTF-8编码格式，但是这里需要ANSI编码格式用记事本打开my.ini文件，然后点击：文件—&gt;另存为—&gt;将编码修改为：ANSI—&gt;保存！ 然后cmd窗口输入命令行启动mysql 4.3.2 报错 解决：以管理员身份来运行cmd程序来启动mysql。 4.3.3运行 net start mysql 报错：1服务正在启动或停止中，请稍候片刻后再试一次。 解决方法：打开任务管理器，把mysql进程关闭，再次启动mysql服务器 启动成功]]></content>
      <tags>
        <tag>Mysql</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matlab的gui图像处理操作界面，实现重置和退出按钮功能]]></title>
    <url>%2F2018%2F03%2F09%2Fmatlab_gui_exit%2F</url>
    <content type="text"><![CDATA[axes控件实现了展示图片，动态txt控件实现了展示或者输入参数。 在gui界面右键点击“重置”pushbotton回到代码块callback，编写代码 以下代码是实现图片和参数数字重置，是重置按钮（puttern）的功能实现12345678910111213141516function pushbutton1_Callback(hObject, eventdata, handles)% hObject handle to pushbutton1 (see GCBO)% eventdata reserved - to be defined in a future version of MATLAB% handles structure with handles and user data (see GUIDATA)% 重置清空图片 美滋滋cla(handles.axes1,&apos;reset&apos;);cla(handles.axes2,&apos;reset&apos;);cla(handles.axes3,&apos;reset&apos;);cla(handles.axes4,&apos;reset&apos;);cla(handles.axes5,&apos;reset&apos;);% 重置清空动态txt的文字 美滋滋set(handles.edit1,&apos;string&apos;,&apos;&apos;)set(handles.edit2,&apos;string&apos;,&apos;&apos;)set(handles.edit3,&apos;string&apos;,&apos;&apos;)set(handles.edit4,&apos;string&apos;,&apos;&apos;) 退出按钮：在gui界面右键点击“退出”pushbotton回到代码块callback，编写代码即可1close]]></content>
      <tags>
        <tag>Matlab</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客添加背景音乐和音乐歌单(举例网易云音乐)]]></title>
    <url>%2F2018%2F03%2F08%2Fhexo_music%20list%2F</url>
    <content type="text"><![CDATA[添加背景音乐 1、 打开网易云音乐首页，然后搜索你要添加的背景音乐 http://music.163.com/ 2、 搜索到歌曲点击生成外链播放器，进去下一个界面 3、 复制外链播放器的代码打开yilia主题下的_partial文件夹下的left-col.ejs文件 复制文件内容到最下端 红线内的iframe框为复制的外链播放器代码，如图红线内，把代码放在div框 例如： &lt;div style=&quot;position:absolute; bottom:120px left:auto; width:85%&quot;&gt; &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=260 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=422428548&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; 这样就可以了 注：调节播放器大小，改变外链播放器的代码块，长度宽度即可 width=260 height=86]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>yilia</tag>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客cnzz网站访问量统计]]></title>
    <url>%2F2018%2F03%2F08%2Fhexo_cnzz%2F</url>
    <content type="text"><![CDATA[cnzz网站访问量统计 使用友盟第三方的统计插件，网址：http://www.umeng.com/进入网站先注册账号然后根据下列图片进入添加站点。 添加站点，自己搭建的博客，需要统计访问量的网站(这里加入我的博客网站)，然后点击统计代码进入代码页 代码页有很多样式，我的是红框的演示，纯文字统计，简洁大方，选择其他样式也可以 选择样式，复制样式代码到..\themes\yilia\layout\_partial下的footer.ejs中加入如下代码块&lt;div&gt;和&lt;/div&gt;即可 123&lt;div&gt; 里面是从CNZZ复制的代码 &lt;/div&gt; 代码块&lt;div&gt;和&lt;/div&gt;一定要在&lt;footer&gt;和&lt;/fotter&gt;之间]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>yilia</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab2014a vs2015编译器解决方法]]></title>
    <url>%2F2018%2F03%2F07%2Fmatlab_vs2015%2F</url>
    <content type="text"><![CDATA[准备工作 前提：电脑已经安装1、Matlab版本2014a2、VS版本2015 目标：结合Matlab和VS2015，实现Matlab的GUI文件和.m文件转化为.exe文件，然后可以单独运行.exe文件 首先在Matlab命令行输入1mbuild -setup 报错红色，显示没有选择项，此处没有截图不直观我猜测可能是matlab2014a的破解不完全 解决方案下载资源链接：https://pan.b链aidu.com/s/1hoDxMKFU2l-3ZhTObFetCw 密码：vdlq 然后替换文件 附件下面的将mexopts/下的msvc2015.xml和msvcpp2015.xml复制到Matlab目录下的bin/win64/mexopts下就可以了 首先在Matlab命令行输入mbuild -setup 然后输入mex -setup 选项都选择C++的就哦了]]></content>
      <tags>
        <tag>Matlab</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决方案matlab2014a破解不完全，报错Test checkout of feature 'Compiler' failed]]></title>
    <url>%2F2018%2F03%2F07%2Fmatlab_exe%2F</url>
    <content type="text"><![CDATA[解决方案 报错情况： 目标是把.m文件转化为exe文件，先运行mcc -m你的文件+.m后缀如果报错Test checkout of feature &#39;Compiler&#39; failed 是因为你的matlab2014a破解不完全。前提是你的电脑已经安装好了VS编译器 2014a的解决办法：下载资源：ht链tps://pan.baidu.com/s/1KNZqVqxMx6f接IaxQULAIq_g 密码：cti0 下载后解压，把install.jar以及相应位数的三个文件（compiler.dll，mcc.exe，libmwservices.dll）复制到对应位置替换即可。在matlab安装目录下搜索到文件然后替换，保险起见先把要替换的文件剪切出来，实际上我的操作是成功的，万一万一万一不成功还能复原回去 另外把license.lic改为与MATLAB\licenses文件夹下的那个lic文件同名，复制并替换之。如图所示，我把需要替换的文件都拿了出来，其中license文件是绑定了你的电脑名称，所以需要把新文件改名]]></content>
      <tags>
        <tag>Matlab</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库Mysql_3_4]]></title>
    <url>%2F2018%2F03%2F04%2Fdatabase_2%2F</url>
    <content type="text"><![CDATA[一、数据库约束 1.1 默认值约束(default)1.2 非空约束( not null )1.3 唯一约束(unique)CREATE TABLE test( id INT UNIQUE ,-- 唯一 NAME VARCHAR(20) NOT NULL, -- 非空 gender VARCHAR(2) DEFAULT &#39;男&#39; -- 默认值约束 ); 1.4 主键约束(primary key 作用:非空+唯一约束)1.5 自增长约束(auto_increment)CREATE TABLE test2( id INT PRIMARY KEY AUTO_INCREMENT,-- 非空+唯一约束+自增长约束 NAME VARCHAR(20) , gender VARCHAR(2) , ); 1.6 外键约束(属于数据库中表的设计)1.6.1 外键约束:约束两个或者两个以上的表的数据，一般情况有两种表(主表,副表)DROP TABLE employee2 DELETE FROM employee2 SELECT * FROM employee2 SELECT * FROM dept 1.6.2 员工表CREATE TABLE employee2( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20), deptId INT, -- 添加外键约束 CONSTRAINT employee_dept_fk FOREIGN KEY (deptId) REFERENCES dept(id) -- 声明 外键名称 外键 被约束的字段 关联 部门表中id的字段 ); INSERT INTO employee2 (NAME,deptId) VALUES(&#39;张三&#39;,1) ; INSERT INTO employee2 (NAME,deptId) VALUES(&#39;李四&#39;,2) ; INSERT INTO employee2 (NAME,deptId) VALUES(&#39;王五&#39;,1) ; INSERT INTO employee2 (NAME,deptId) VALUES(&#39;陈六&#39;,1) ; 可以设计一个独立的表-部门表 专门用来存储部门名称,来解决数据冗余的问题 1.6.3 部门表(主表,约束别人的表)CREATE TABLE dept( id INT PRIMARY KEY AUTO_INCREMENT , NAME VARCHAR(20) -- 部门名称 ); 插入几个部门名称INSERT INTO dept (NAME) VALUES (&#39;软件开发部&#39;) ; INSERT INTO dept (NAME) VALUES (&#39;软件维护部&#39;) ; 给员工表中插入数据INSERT INTO employee2 (NAME,deptId) VALUES(&#39;王五&#39;,1) ; INSERT INTO employee2 (NAME,deptId) VALUES(&#39;陈六&#39;,1) ; INSERT INTO employee2 (NAME,deptId) VALUES(&#39;李四&#39;,2) ; 给部门表添加数据INSERT INTO dept (id,NAME) VALUES(3,&#39;硬件开发部&#39;); 修改数据UPDATE employee2 SET deptId = 3 WHERE id = 3; 删除数据DELETE FROM employee2 WHERE id =2; 1.7 补充 —常遇到字段类型: 1)char(20) vs varchar(20) char(20):是一个固定长度的字符串,存储字符串内容,一定是20个字符串。varchar(20):可变的字符串长度,实际存储的时候是根据当前实际的字符串长度 DROP TABLE test ; 2) int 和int(4) int:默认的长度11位,再存储数值类型的时候,存储实际长度int(4):固定长度]]></content>
      <tags>
        <tag>Mysql</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库Mysql_3_4]]></title>
    <url>%2F2018%2F03%2F04%2Fdatabase_1%2F</url>
    <content type="text"><![CDATA[一、 mysql常用命令 1.1 管理CREATE DATABASE Aoman_OS -- 创建数据库 USE Aoman_OS -- 使用数据库 DROP DATABASE Aoman_OS -- 删除数据库 1.2 数据库内容CREATE TABLE employee( -- 创建数据库表格 id INT,NAME VARCHAR(20),gender VARCHAR(2),title VARCHAR(10),email VARCHAR(20) ); SELECT * FROM employee -- 查看数据库表格 2.1 增加数据库内容INSERT INTO employee VALUES(1,&#39;依依&#39;,&#39;女&#39;,&#39;程序员鼓励师&#39;,&#39;123@163.com&#39;); INSERT INTO employee VALUES(2,&#39;尔尔&#39;,&#39;男&#39;,&#39;程序开发工程师&#39;,&#39;124@163.com&#39;); INSERT INTO employee VALUES(3,&#39;散散&#39;,&#39;男&#39;,&#39;程序维护工程师&#39;,&#39;125@163.com&#39;); 2.2 插入部分数据 INSERT INTO employee (id,NAME) VALUES (4,&#39;思思&#39;); 2.3 修改数据UPDATE employee SET gender=&#39;女&#39;,title=&#39;文秘&#39; WHERE id =4; 2.4 删除表中所有数据DELETE * FROM employee 2.5 删除数据表DROP FROM employee 3.1 查询SELECT id AS &#39;1&#39; FROM employee SELECT id AS &#39;1&#39; ，NAME AS &#39;尔尔&#39; FROM employee 3.2 不重复的查询SELECT DISTINCT email FROM employee 3.3 条件查询SELECT * FROM employee WHERE id=1 OR NAME = &#39;思思&#39; ; -- or 并集 SELECT * FROM employee WHERE id=1 AND NAME = &#39;思思&#39; ; -- and 交集 3.4 判断查询大于 &gt; ,小于 &lt; ,等于 = 不等于 ！= 或者 &lt;&gt;， 在什么之间 between 1 and 2， 非空 isnot null 或者 不等于 &#39;&#39; 3.5 模糊查询SELECT * FROM studet WHERE NAME LIKE &#39;思%&#39; %代替任何字符，任何长度的字符 -仅仅代替一个字符 3.6 asc 升序 desc 降序默认情况下:是按照插入顺序进行排序 SELECT * FROM student ORDER BY id ASC ; 需求:servlet成绩是一个降序排序 SELECT * FROM student ORDER BY servlet DESC ; 二、小练习CREATE TABLE student2( id INT, NAME VARCHAR(20), chinese FLOAT, english FLOAT, math FLOAT ); INSERT INTO student2(id,NAME,chinese,english,math) VALUES(1,&#39;张小明&#39;,89,78,90); INSERT INTO student2(id,NAME,chinese,english,math) VALUES(2,&#39;李进&#39;,67,53,95); INSERT INTO student2(id,NAME,chinese,english,math) VALUES(3,&#39;王五&#39;,87,78,77); INSERT INTO student2(id,NAME,chinese,english,math) VALUES(4,&#39;李一&#39;,88,98,92); INSERT INTO student2(id,NAME,chinese,english,math) VALUES(5,&#39;李来财&#39;,82,84,67); INSERT INTO student2(id,NAME,chinese,english,math) VALUES(6,&#39;张进宝&#39;,55,85,45); INSERT INTO student2(id,NAME,chinese,english,math) VALUES(7,&#39;黄蓉&#39;,75,65,30) 查询操作练习(在学生表数据基础上：student.sql)— 查询表中所有学生的信息。 SELECT * FROM student2 ; — 查询表中所有学生的姓名和对应的英语成绩。 SELECT NAME ,english FROM student2 — 使用别名表示学生分数。 SELECT id AS &#39;编号&#39;,NAME AS &#39;姓名&#39;,chinese AS &#39;语文&#39;,english AS &#39;英语&#39;,math AS &#39;数学&#39; FROM student2 ; — 查询姓名为李一的学生成绩 SELECT * FROM student2 WHERE NAME = &#39;李一&#39;; — 查询英语成绩大于等于90分的同学 SELECT * FROM student2 WHERE english &gt;=90 — 查询总分大于200分的所有同学 SELECT * FROM student2 WHERE (chinese+english+math)&gt;200; — 查询所有姓李的学生英语成绩。 SELECT NAME,english FROM student2 WHERE NAME LIKE &#39;李%&#39; — 查询英语&gt;80或者总分&gt;200的同学 SELECT * FROM student2 WHERE english &gt;80 OR (chinese+english+math)&gt;200;]]></content>
      <tags>
        <tag>Mysql</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客yilia主题_缺失模块_解决方案]]></title>
    <url>%2F2018%2F02%2F08%2Fhexo_3%2F</url>
    <content type="text"><![CDATA[hexo博客yilia主题左侧栏目有一个全部文章的按钮，刚开始开始报错缺失模块，如下图： 我解决了这个问题着实不容易饶了弯路，但是跟着提示步骤，其实很简单，走起： 1、查看node版本打开命令控制台，输入代码 ```node -v``` 查看node版本，如下图：123456789![这里写图片描述](http://upload-images.jianshu.io/upload_images/6280966-e798155edf9d3c60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)只要node的版本高于6.2就行## 2、运行命令行博客根目录下运行命令行 ```npm i hexo-generator-json-content --save 如果这个包已经存在，会报错，图忘了截了。 但是你需要在theme文件夹的yilia主题文件夹下，找到node—modules文件夹。如果hexo-generator-json-content 这个包是存在的就OK，可以进行第三步了，见下图： 3、配置文件博客根目录下，找到_config.yml，打开找一个空白地方复制一下配置信息： 1234567891011121314151617181920212223242526272829303132333435jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 注（重点）：细节处—复制的信息格式要调好1、配置文件内找空白处粘贴文件 2、第一行jsonContent: - 即下图46行前没有空格 下图47、48、49行前有一个空格 剩下的有两个空格 具体格式如下图所示： 保存后同步文件在看你的博客，点全部文章按钮 应该是修复了缺失模块这个报错]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
        <tag>yilia</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客yilia主题_more截断文章_多标签添加]]></title>
    <url>%2F2018%2F02%2F08%2Fhexo_2%2F</url>
    <content type="text"><![CDATA[以下均为自己遇到的问题并加以修改或者纠正. 在文章下方可以使用more语句进行截断，这样博客首页只会出现文章的前面一小部分，看起来很清爽简约 或者 anguage: zh-CN ```//在需要阶段的地方插入该代码语句12345678910111213141516171819202122&gt;&gt; aa在这里，yilia主题会判断含有`&lt;!--more--&gt;`的位置，然后文章截断两部分，第一部分展示在博客首页，第二部分即上方的aa只能点开展开全文，才能继续阅读文章。截断效果如下图：![效果](http://upload-images.jianshu.io/upload_images/6280966-dff71bcc18df7583.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)在这里我对yilia主题做了修改原始效果为：![原始效果](http://upload-images.jianshu.io/upload_images/6280966-2bc7446857bc04e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)修改后为：去掉了more按钮，打开文章可以点击文章或者点击展开全文![修改效果](http://upload-images.jianshu.io/upload_images/6280966-51ea736ffd940d2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)做法很简单，进入theme目录，打开yilia目录下的_config.yml文件，修改excerpt_link参数： excerpt_link：之后的more单词换成空格注：‘excerpt_link： ’。其中：后有一个空格键``` 修改图如下图 如何给文章加多个标签： 修改如下图，格式为 [tag1, tag2] 注：逗号之后要有一个空格。[tag1, tag2]= [tag1+逗号+空格+tag2] 修改如下图所示：]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
        <tag>yilia</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-github博客首页菜单中文乱码两种解决方案]]></title>
    <url>%2F2018%2F02%2F06%2Fhexo_1%2F</url>
    <content type="text"><![CDATA[方案一： 菜单设置成中文显示，编辑博客根目录下的_config.yml文件 设置language字段如下: zh-Hans```1234或者```language: zh-CN 取决于你的主题theme目录下的language目录下有zh-Hans.yml还是zh-CN.yml 方案二：根目录下的配置文件是_config.yml文件 我们需要打开此文件，然后编辑文字。 但是保存之后的格式可能跟文件本身的格式编码不一样，所以会出现乱码问题。 推荐用sublime，VScode，atom等文本编辑器打开，这三款开源软件写代码也很便利。此处用atom文本编辑器打开编辑，保存后不会出现乱码问题了]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[米pad记事本 0828刷好lineage系统]]></title>
    <url>%2F2018%2F01%2F10%2F%E8%AE%B0%E4%BA%8B18_08_28%2F</url>
    <content type="text"><![CDATA[记事本 18-11-2087还是不够简约，入手凯酷84，心情大好 18-10-09红轴 贼鸥 87 舒服 18-10-09贼鸥87键 机械键盘改装，改樱桃红轴，键帽换为PBT键帽，磨砂手感，很不错 18-08-280828平板刷好lineage系统，奈斯，大夫 魔趣系统bug有点多，无故重启，故刷入lineage系统0811版，运行完美 18-07-29 入了一款小米平板，自带系统安卓4.4.4，系统太丑，找了第三方安装包魔趣7.1，升级到安卓7，比miui流畅多了，魔趣大法好 18-07-20纪念自己做的电容笔（右），虽然丑，用着还行，但是精确度比较差，还是买了一个10块的用用。 通过香烟盒里的锡纸连接手与屏幕导电，屏幕上的电极感应，然后确定操作点击屏幕。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
