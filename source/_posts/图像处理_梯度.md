---
title: 图像融合简介
date: 2019-12-31 21:44:45
tags: [图像处理, 图像融合]
---

图像融合
<!--more-->

### 图像梯度
图像梯度是有方向性的改变图像的亮度或颜色。亮度梯度或颜色梯度也被用于逐步融合的颜色，也可以被看作是一个层次从低到高的。

### 平均梯度
平均梯度就是一幅图像的梯度图上所有点的均值。它反映了图像中的纹理变化特征，同时能一定程度反映出图像的清晰度。一般来说平均梯度越大，图像层次也就越丰富，变化就越多，图像也就越清晰。

可以把平均梯度当做一系列模糊程度的评价标准。


灰度图像和彩色图像都可以用于计算梯度图，对于彩色图像，先对三通道颜色值分别计算梯度，然后取梯度值最大的那个作为该像素的梯度。


梯度图像是从原始图像中创建出来的（通常通过卷积过滤器，比如最简单的Sobel过滤器)。每个梯度图像中的像素被用来计算在一个给定的方向，在原始图像中同一个像素的强度变化。为了得到该方向的全范围，梯度图像在x 和y 方向上都会被计算。

图像梯度最常见的用途之一是边缘检测。在计算梯度图像后，拥有大梯度值的像素很可能是边缘像素。在梯度的方向，拥有最大梯度值的响度则很有可能成为边缘像素，而且跟踪边缘的方向很可能是垂直于梯度的方向的。一个使用梯度的边缘检测算法的例子是Canny 边缘检测器。

几种梯度算子如下：
```


clear
close all
clc
%% %%%%%%%%%%%%%%%图像%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
I=imread('3096.jpg');

if size(I,3) == 3
   I=rgb2gray(I);
else
end
I=im2double(I);
figure;imshow(I);title('(a)原始图像')
[m,n]=size(I);

% I=I;%不加噪声
%I=imnoise(I,'speckle',deta_2);
% I=imnoise(I,'salt & pepper',0.05); %加椒盐噪声
% I=imnoise(I,'gaussian',0,0.01); % 加高斯噪声
figure;imshow(I);title('(b)加噪图像');

%%  梯度法
T=20;%阈值
I_gradient=zeros(m,n);
for i=2:m-1
    for j=2:n-1
        I_gradient(i,j)=abs(I(i+1,j)-I(i,j))+abs(I(i,j+1)-I(i,j));
        if I_gradient(i,j)<T
            I_gradient(i,j)=0;
        else
            I_gradient(i,j)=255;
        end
    end
end
figure(1);subplot(2,3,1);imshow(uint8(I_gradient));title('梯度法');
 
%% roberts算子
I_r=zeros(m,n);
for i=2:m-1
    for j=2:n-1
        I_r(i,j)=abs(I(i+1,j+1)-I(i,j))+abs(I(i,j+1)-I(i+1,j));
        if I_r(i,j)<T
            I_r(i,j)=0;
        else
            I_r(i,j)=255;
        end
    end
end
I_r=imbinarize(imfilter(I,r),T);
subplot(2,3,2);imshow(uint8(I_r));title('Roberts算子');
 
%% prewitt算子
I_prewitt=zeros(m,n);
for i=2:m-1
    for j=2:n-1
        I_prewitt(i,j)=abs(I(i-1,j-1)+I(i,j-1)+I(i+1,j-1)-I(i-1,j+1)-I(i,j+1)-I(i+1,j+1))+abs(I(i+1,j-1)+I(i+1,j)+I(i+1,j+1)-I(i-1,j-1)-I(i-1,j)-I(i-1,j+1));
        if I_prewitt(i,j)<15
            I_prewitt(i,j)=0;
        else
            I_prewitt(i,j)=255;
        end
    end
end
subplot(2,3,3);imshow(uint8(I_prewitt));title('Prewitt算子');
 
%% sobel算子
I_sobel=zeros(m,n);
for i=2:m-1
    for j=2:n-1
        I_sobel(i,j)=abs(I(i-1,j-1)+2*I(i,j-1)+I(i+1,j-1)-I(i-1,j+1)-2*I(i,j+1)-I(i+1,j+1))+abs(I(i+1,j-1)+2*I(i+1,j)+I(i+1,j+1)-I(i-1,j-1)-2*I(i-1,j)-I(i-1,j+1));
        if I_sobel(i,j)<T
            I_sobel(i,j)=0;
        else
            I_sobel(i,j)=255;
        end
    end
end
subplot(2,3,4);imshow(uint8(I_sobel));title('Sobel算子');
 
 
%% LoG算子
log1=[0 0 -1 0 0;
    0 -1 -2 -1 0;
    -1 -2 16 -2 -1;
    0 -1 -2 -1 0;
    0 0 -1 0 0];
 
I_l=conv2(I,log1,'same');
I_log=imbinarize(abs(I_l),300);
subplot(2,3,6);imshow(I_log);title('LoG算子');

%% 平均梯度
I=double(I);
% [M,N,K]=size(I);
sum=0;
for i=1:m-1
    for j=1:n-1
        diffX(i,j)=I(i,j)-I(i+1,j);
        diffY(i,j)=I(i,j)-I(i,j+1);
        w(i,j)=sqrt(((diffX(i,j))^2+(diffY(i,j))^2)/2);
        sum=sum+w(i,j);
    end
end

diffX_a = mapminmax(diffX);
figure;imshow(diffX_a);
diffY_a = mapminmax(diffY);
figure;imshow(diffY_a);
W_a = mapminmax(w);
figure;imshow(W_a);

AVEGRAD=sum/((m-1)*(n-1))


```


---

### [我的个人博客主页，欢迎访问](http://www.aomanhao.top/)
### [我的CSDN主页，欢迎访问](https://blog.csdn.net/Aoman_Hao)
### [我的GitHub主页，欢迎访问](https://github.com/AomanHao)


